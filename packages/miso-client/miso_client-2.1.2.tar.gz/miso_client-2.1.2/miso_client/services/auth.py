"""
Authentication service for token validation and user management.

This module handles authentication operations including client token management,
token validation, user information retrieval, and logout functionality.
"""

import logging
from typing import Any, Dict, Optional

from ..models.config import AuthResult, AuthStrategy, UserInfo
from ..services.redis import RedisService
from ..utils.http_client import HttpClient

logger = logging.getLogger(__name__)


class AuthService:
    """Authentication service for token validation and user management."""

    def __init__(self, http_client: HttpClient, redis: RedisService):
        """
        Initialize authentication service.

        Args:
            http_client: HTTP client instance
            redis: Redis service instance
        """
        self.config = http_client.config
        self.http_client = http_client
        self.redis = redis

    async def get_environment_token(self) -> str:
        """
        Get environment token using client credentials.

        This is called automatically by HttpClient, but can be called manually if needed.

        Returns:
            Client token string

        Raises:
            AuthenticationError: If token fetch fails
        """
        return await self.http_client.get_environment_token()

    async def _validate_token_request(
        self, token: str, auth_strategy: Optional[AuthStrategy] = None
    ) -> Dict[str, Any]:
        """
        Helper method to call /api/v1/auth/validate endpoint with proper request body.

        Args:
            token: JWT token to validate
            auth_strategy: Optional authentication strategy

        Returns:
            Validation result dictionary
        """
        if auth_strategy is not None:
            return await self.http_client.authenticated_request(
                "POST",
                "/api/v1/auth/validate",
                token,
                {"token": token},
                auth_strategy=auth_strategy,
            )
        else:
            return await self.http_client.authenticated_request(
                "POST", "/api/v1/auth/validate", token, {"token": token}
            )

    async def login(self, redirect: str, state: Optional[str] = None) -> Dict[str, Any]:
        """
        Initiate login flow by calling the controller login endpoint.

        This method calls GET /api/v1/auth/login with redirect and optional state parameters.
        The controller returns a login URL that should be used to redirect the user to Keycloak.

        Args:
            redirect: Callback URL where Keycloak redirects after authentication (required)
            state: Optional CSRF protection token (auto-generated by backend if omitted)

        Returns:
            Dictionary containing:
                - success: True if successful
                - data: Dictionary with loginUrl and state
                - timestamp: Response timestamp

        Example:
            >>> response = await auth_service.login(
            ...     redirect="http://localhost:3000/auth/callback",
            ...     state="abc123"
            ... )
            >>> login_url = response["data"]["loginUrl"]
            >>> state = response["data"]["state"]
        """
        try:
            params = {"redirect": redirect}
            if state:
                params["state"] = state

            response = await self.http_client.get("/api/v1/auth/login", params=params)
            return response
        except Exception as error:
            logger.error("Login failed", exc_info=error)
            # Return empty dict on error per service method pattern
            return {}

    async def validate_token(
        self, token: str, auth_strategy: Optional[AuthStrategy] = None
    ) -> bool:
        """
        Validate token with controller.

        If API_KEY is configured and token matches it, bypasses OAuth2 validation.

        Args:
            token: JWT token to validate (or API_KEY for testing)
            auth_strategy: Optional authentication strategy

        Returns:
            True if token is valid, False otherwise
        """
        # Check API_KEY first (for testing)
        if self.config.api_key and token == self.config.api_key:
            return True

        # Fall back to OAuth2 validation
        try:
            result = await self._validate_token_request(token, auth_strategy)
            auth_result = AuthResult(**result)
            return auth_result.authenticated

        except Exception as error:
            logger.error("Token validation failed", exc_info=error)
            return False

    async def get_user(
        self, token: str, auth_strategy: Optional[AuthStrategy] = None
    ) -> Optional[UserInfo]:
        """
        Get user information from token.

        If API_KEY is configured and token matches it, returns None (no user info for API key auth).

        Args:
            token: JWT token (or API_KEY for testing)
            auth_strategy: Optional authentication strategy

        Returns:
            UserInfo if token is valid, None otherwise
        """
        # Check API_KEY first (for testing)
        if self.config.api_key and token == self.config.api_key:
            # API key authentication doesn't provide user info
            return None

        # Fall back to OAuth2 validation
        try:
            result = await self._validate_token_request(token, auth_strategy)
            auth_result = AuthResult(**result)

            if auth_result.authenticated and auth_result.user:
                return auth_result.user

            return None

        except Exception as error:
            logger.error("Failed to get user info", exc_info=error)
            return None

    async def get_user_info(
        self, token: str, auth_strategy: Optional[AuthStrategy] = None
    ) -> Optional[UserInfo]:
        """
        Get user information from GET /api/v1/auth/user endpoint.

        If API_KEY is configured and token matches it, returns None (no user info for API key auth).

        Args:
            token: JWT token (or API_KEY for testing)
            auth_strategy: Optional authentication strategy

        Returns:
            UserInfo if token is valid, None otherwise
        """
        # Check API_KEY first (for testing)
        if self.config.api_key and token == self.config.api_key:
            # API key authentication doesn't provide user info
            return None

        # Fall back to OAuth2 validation
        try:
            if auth_strategy is not None:
                user_data = await self.http_client.authenticated_request(
                    "GET", "/api/v1/auth/user", token, auth_strategy=auth_strategy
                )
            else:
                user_data = await self.http_client.authenticated_request(
                    "GET", "/api/v1/auth/user", token
                )

            return UserInfo(**user_data)

        except Exception as error:
            logger.error("Failed to get user info", exc_info=error)
            return None

    async def logout(self, token: str) -> Dict[str, Any]:
        """
        Logout user by invalidating the access token.

        This method calls POST /api/v1/auth/logout with the user's access token in the request body.
        The token will be invalidated on the server side.

        Args:
            token: Access token to invalidate (required)

        Returns:
            Dictionary containing:
                - success: True if successful
                - message: Success message
                - timestamp: Response timestamp

        Example:
            >>> response = await auth_service.logout(token="jwt-token-here")
            >>> if response.get("success"):
            ...     print("Logout successful")
        """
        try:
            response = await self.http_client.authenticated_request(
                "POST", "/api/v1/auth/logout", token, {"token": token}
            )
            return response
        except Exception as error:
            logger.error("Logout failed", exc_info=error)
            # Return empty dict on error per service method pattern
            return {}

    async def is_authenticated(
        self, token: str, auth_strategy: Optional[AuthStrategy] = None
    ) -> bool:
        """
        Check if user is authenticated (has valid token).

        Args:
            token: JWT token
            auth_strategy: Optional authentication strategy

        Returns:
            True if user is authenticated, False otherwise
        """
        if auth_strategy is not None:
            return await self.validate_token(token, auth_strategy=auth_strategy)
        else:
            return await self.validate_token(token)
