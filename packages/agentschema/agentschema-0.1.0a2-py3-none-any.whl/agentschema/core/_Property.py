##########################################
# WARNING: This is an auto-generated file.
# DO NOT EDIT THIS FILE DIRECTLY
# ANY EDITS WILL BE LOST
##########################################
from dataclasses import dataclass, field
from typing import Any, Callable, Optional


@dataclass
class Property:
    """Represents a single property* This model defines the structure of properties that can be used in prompts,including their type, description, whether they are required, and other attributes.* It allows for the definition of dynamic inputs that can be filled with dataand processed to generate prompts for AI models.
    Attributes
    ----------
    name : str
        Name of the property
    kind : str
        The data type of the input property
    description : Optional[str]
        A short description of the input property
    required : Optional[bool]
        Whether the property is required
    default : Optional[Any]
        The default value of the property - this represents the default value if none is provided
    example : Optional[Any]
        Example value used for either initialization or tooling
    enumValues : Optional[list[Any]]
        Allowed enumeration values for the property
    """

    name: str = field(default="")
    kind: str = field(default="")
    description: Optional[str] = None
    required: Optional[bool] = None
    default: Optional[Any] = None
    example: Optional[Any] = None
    enumValues: Optional[list[Any]] = field(default_factory=list)

    @staticmethod
    def load(
        data: Any, pre_process: Optional[Callable[[Any], Any]] = None
    ) -> "Property":
        """Load a Property instance.
        Args:
            data (Any): The data to load the instance from.
            pre_process (Optional[Callable[[Any], Any]]): Optional pre-processing function to apply to the data before loading.
        Returns:
            Property: The loaded Property instance.

        """

        if pre_process is not None:
            data = pre_process(data)
        # handle alternate representations
        if isinstance(data, bool):
            data = {"kind": "boolean", "example": data}
        if isinstance(data, float):
            data = {"kind": "float", "example": data}
        if isinstance(data, int):
            data = {"kind": "integer", "example": data}
        if isinstance(data, str):
            data = {"kind": "string", "example": data}

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for Property: {data}")

        # load polymorphic Property instance
        instance = Property.load_kind(data, pre_process)
        if data is not None and "name" in data:
            instance.name = data["name"]
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "description" in data:
            instance.description = data["description"]
        if data is not None and "required" in data:
            instance.required = data["required"]
        if data is not None and "default" in data:
            instance.default = data["default"]
        if data is not None and "example" in data:
            instance.example = data["example"]
        if data is not None and "enumValues" in data:
            instance.enumValues = data["enumValues"]
        return instance

    @staticmethod
    def load_kind(
        data: dict, pre_process: Optional[Callable[[Any], Any]]
    ) -> "Property":
        # load polymorphic Property instance
        if data is not None and "kind" in data:
            discriminator_value = str(data["kind"]).lower()
            if discriminator_value == "array":
                return ArrayProperty.load(data, pre_process)
            elif discriminator_value == "object":
                return ObjectProperty.load(data, pre_process)
            else:
                # create new instance (stop recursion)
                return Property()
        else:
            # create new instance
            return Property()


@dataclass
class ArrayProperty(Property):
    """Represents an array property.This extends the base Property model to represent an array of items.
    Attributes
    ----------
    kind : str

    items : Property
        The type of items contained in the array
    """

    kind: str = field(default="array")
    items: Property = field(default_factory=Property)

    @staticmethod
    def load(
        data: Any, pre_process: Optional[Callable[[Any], Any]] = None
    ) -> "ArrayProperty":
        """Load a ArrayProperty instance.
        Args:
            data (Any): The data to load the instance from.
            pre_process (Optional[Callable[[Any], Any]]): Optional pre-processing function to apply to the data before loading.
        Returns:
            ArrayProperty: The loaded ArrayProperty instance.

        """

        if pre_process is not None:
            data = pre_process(data)

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for ArrayProperty: {data}")

        # create new instance
        instance = ArrayProperty()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "items" in data:
            instance.items = Property.load(data["items"], pre_process)
        return instance


@dataclass
class ObjectProperty(Property):
    """Represents an object property.This extends the base Property model to represent a structured object.
    Attributes
    ----------
    kind : str

    properties : list[Property]
        The properties contained in the object
    """

    kind: str = field(default="object")
    properties: list[Property] = field(default_factory=list)

    @staticmethod
    def load(
        data: Any, pre_process: Optional[Callable[[Any], Any]] = None
    ) -> "ObjectProperty":
        """Load a ObjectProperty instance.
        Args:
            data (Any): The data to load the instance from.
            pre_process (Optional[Callable[[Any], Any]]): Optional pre-processing function to apply to the data before loading.
        Returns:
            ObjectProperty: The loaded ObjectProperty instance.

        """

        if pre_process is not None:
            data = pre_process(data)

        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for ObjectProperty: {data}")

        # create new instance
        instance = ObjectProperty()
        if data is not None and "kind" in data:
            instance.kind = data["kind"]
        if data is not None and "properties" in data:
            instance.properties = ObjectProperty.load_properties(
                data["properties"], pre_process
            )
        return instance

    @staticmethod
    def load_properties(
        data: dict | list, pre_process: Optional[Callable[[Any], Any]]
    ) -> list[Property]:
        if isinstance(data, dict):
            # convert simple named properties to list of Property
            if len(data.keys()) == 1:
                data = [{"name": k, "": v} for k, v in data.items()]
            else:
                data = [{"name": k, **v} for k, v in data.items()]
        return [Property.load(item, pre_process) for item in data]
