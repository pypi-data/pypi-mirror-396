# coding: utf-8

"""
    Paystack

    The OpenAPI specification of the Paystack API that merchants and developers can harness to build financial solutions in Africa.

    The version of the OpenAPI document: 1.0.0
    Contact: techsupport@paystack.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import datetime

from pydantic import Field, StrictBool, StrictInt, StrictStr

from typing import Optional

from alexasomba_paystack.models.customer_authorization_initialize_request import CustomerAuthorizationInitializeRequest
from alexasomba_paystack.models.customer_authorization_initialize_response import CustomerAuthorizationInitializeResponse
from alexasomba_paystack.models.customer_authorization_verify_response import CustomerAuthorizationVerifyResponse
from alexasomba_paystack.models.customer_create import CustomerCreate
from alexasomba_paystack.models.customer_create_response import CustomerCreateResponse
from alexasomba_paystack.models.customer_deactivate_authorization import CustomerDeactivateAuthorization
from alexasomba_paystack.models.customer_deactivate_authorization_response import CustomerDeactivateAuthorizationResponse
from alexasomba_paystack.models.customer_direct_debit_activation_charge_request import CustomerDirectDebitActivationChargeRequest
from alexasomba_paystack.models.customer_direct_debit_activation_charge_response import CustomerDirectDebitActivationChargeResponse
from alexasomba_paystack.models.customer_fetch_mandate_authorizations_response import CustomerFetchMandateAuthorizationsResponse
from alexasomba_paystack.models.customer_fetch_response import CustomerFetchResponse
from alexasomba_paystack.models.customer_initialize_direct_debit_request import CustomerInitializeDirectDebitRequest
from alexasomba_paystack.models.customer_initialize_direct_debit_response import CustomerInitializeDirectDebitResponse
from alexasomba_paystack.models.customer_list_response import CustomerListResponse
from alexasomba_paystack.models.customer_risk_action import CustomerRiskAction
from alexasomba_paystack.models.customer_update import CustomerUpdate
from alexasomba_paystack.models.customer_update_response import CustomerUpdateResponse
from alexasomba_paystack.models.customer_validate import CustomerValidate
from alexasomba_paystack.models.customer_validate_response import CustomerValidateResponse
from alexasomba_paystack.models.customer_whitelist_blacklist_response import CustomerWhitelistBlacklistResponse

from alexasomba_paystack.api_client import ApiClient
from alexasomba_paystack.api_response import ApiResponse
from alexasomba_paystack.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class CustomerApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def customer_create(self, customer_create : Optional[CustomerCreate] = None, **kwargs) -> CustomerCreateResponse:  # noqa: E501
        """Create Customer  # noqa: E501

        Create a customer on your integration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_create(customer_create, async_req=True)
        >>> result = thread.get()

        :param customer_create:
        :type customer_create: CustomerCreate
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerCreateResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_create_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_create_with_http_info(customer_create, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_create_with_http_info(self, customer_create : Optional[CustomerCreate] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create Customer  # noqa: E501

        Create a customer on your integration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_create_with_http_info(customer_create, async_req=True)
        >>> result = thread.get()

        :param customer_create:
        :type customer_create: CustomerCreate
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerCreateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'customer_create'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_create" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['customer_create'] is not None:
            _body_params = _params['customer_create']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerCreateResponse",
            '401': "Error",
        }

        return self.api_client.call_api(
            '/customer', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_deactivate_authorization(self, customer_deactivate_authorization : Optional[CustomerDeactivateAuthorization] = None, **kwargs) -> CustomerDeactivateAuthorizationResponse:  # noqa: E501
        """Deactivate Authorization  # noqa: E501

        Deactivate an authorization for any payment channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_deactivate_authorization(customer_deactivate_authorization, async_req=True)
        >>> result = thread.get()

        :param customer_deactivate_authorization:
        :type customer_deactivate_authorization: CustomerDeactivateAuthorization
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerDeactivateAuthorizationResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_deactivate_authorization_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_deactivate_authorization_with_http_info(customer_deactivate_authorization, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_deactivate_authorization_with_http_info(self, customer_deactivate_authorization : Optional[CustomerDeactivateAuthorization] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Deactivate Authorization  # noqa: E501

        Deactivate an authorization for any payment channel.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_deactivate_authorization_with_http_info(customer_deactivate_authorization, async_req=True)
        >>> result = thread.get()

        :param customer_deactivate_authorization:
        :type customer_deactivate_authorization: CustomerDeactivateAuthorization
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerDeactivateAuthorizationResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'customer_deactivate_authorization'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_deactivate_authorization" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['customer_deactivate_authorization'] is not None:
            _body_params = _params['customer_deactivate_authorization']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerDeactivateAuthorizationResponse",
            '401': "Error",
        }

        return self.api_client.call_api(
            '/customer/authorization/deactivate', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_direct_debit_activation_charge(self, id : Annotated[StrictInt, Field(..., description="The customer ID attached to the authorization")], customer_direct_debit_activation_charge_request : Optional[CustomerDirectDebitActivationChargeRequest] = None, **kwargs) -> CustomerDirectDebitActivationChargeResponse:  # noqa: E501
        """Direct Debit Activation Charge  # noqa: E501

        Trigger an activation charge on an inactive mandate on behalf of your customer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_direct_debit_activation_charge(id, customer_direct_debit_activation_charge_request, async_req=True)
        >>> result = thread.get()

        :param id: The customer ID attached to the authorization (required)
        :type id: int
        :param customer_direct_debit_activation_charge_request:
        :type customer_direct_debit_activation_charge_request: CustomerDirectDebitActivationChargeRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerDirectDebitActivationChargeResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_direct_debit_activation_charge_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_direct_debit_activation_charge_with_http_info(id, customer_direct_debit_activation_charge_request, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_direct_debit_activation_charge_with_http_info(self, id : Annotated[StrictInt, Field(..., description="The customer ID attached to the authorization")], customer_direct_debit_activation_charge_request : Optional[CustomerDirectDebitActivationChargeRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Direct Debit Activation Charge  # noqa: E501

        Trigger an activation charge on an inactive mandate on behalf of your customer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_direct_debit_activation_charge_with_http_info(id, customer_direct_debit_activation_charge_request, async_req=True)
        >>> result = thread.get()

        :param id: The customer ID attached to the authorization (required)
        :type id: int
        :param customer_direct_debit_activation_charge_request:
        :type customer_direct_debit_activation_charge_request: CustomerDirectDebitActivationChargeRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerDirectDebitActivationChargeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'customer_direct_debit_activation_charge_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_direct_debit_activation_charge" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['customer_direct_debit_activation_charge_request'] is not None:
            _body_params = _params['customer_direct_debit_activation_charge_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerDirectDebitActivationChargeResponse",
            '401': "Error",
        }

        return self.api_client.call_api(
            '/customer/{id}/directdebit-activation-charge', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_fetch(self, code : Annotated[StrictStr, Field(..., description="The code for the customer gotten from the response of the customer creation")], **kwargs) -> CustomerFetchResponse:  # noqa: E501
        """Fetch Customer  # noqa: E501

        Get details of a customer on your integration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_fetch(code, async_req=True)
        >>> result = thread.get()

        :param code: The code for the customer gotten from the response of the customer creation (required)
        :type code: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerFetchResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_fetch_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_fetch_with_http_info(code, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_fetch_with_http_info(self, code : Annotated[StrictStr, Field(..., description="The code for the customer gotten from the response of the customer creation")], **kwargs) -> ApiResponse:  # noqa: E501
        """Fetch Customer  # noqa: E501

        Get details of a customer on your integration.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_fetch_with_http_info(code, async_req=True)
        >>> result = thread.get()

        :param code: The code for the customer gotten from the response of the customer creation (required)
        :type code: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerFetchResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'code'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_fetch" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['code']:
            _path_params['code'] = _params['code']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerFetchResponse",
            '401': "Error",
            '404': "Error",
        }

        return self.api_client.call_api(
            '/customer/{code}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_fetch_mandate_authorizations(self, id : Annotated[StrictInt, Field(..., description="The customer ID for the authorizations to fetch")], **kwargs) -> CustomerFetchMandateAuthorizationsResponse:  # noqa: E501
        """Fetch Mandate Authorizations  # noqa: E501

        Get the list of direct debit mandates associated with a customer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_fetch_mandate_authorizations(id, async_req=True)
        >>> result = thread.get()

        :param id: The customer ID for the authorizations to fetch (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerFetchMandateAuthorizationsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_fetch_mandate_authorizations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_fetch_mandate_authorizations_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_fetch_mandate_authorizations_with_http_info(self, id : Annotated[StrictInt, Field(..., description="The customer ID for the authorizations to fetch")], **kwargs) -> ApiResponse:  # noqa: E501
        """Fetch Mandate Authorizations  # noqa: E501

        Get the list of direct debit mandates associated with a customer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_fetch_mandate_authorizations_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The customer ID for the authorizations to fetch (required)
        :type id: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerFetchMandateAuthorizationsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_fetch_mandate_authorizations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerFetchMandateAuthorizationsResponse",
            '401': "Error",
        }

        return self.api_client.call_api(
            '/customer/{id}/directdebit-mandate-authorizations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_initialize_authorization(self, customer_authorization_initialize_request : CustomerAuthorizationInitializeRequest, **kwargs) -> CustomerAuthorizationInitializeResponse:  # noqa: E501
        """Initialize Authorization  # noqa: E501

        Initiate a request to create a reusable authorization code for recurring transactions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_initialize_authorization(customer_authorization_initialize_request, async_req=True)
        >>> result = thread.get()

        :param customer_authorization_initialize_request: (required)
        :type customer_authorization_initialize_request: CustomerAuthorizationInitializeRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerAuthorizationInitializeResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_initialize_authorization_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_initialize_authorization_with_http_info(customer_authorization_initialize_request, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_initialize_authorization_with_http_info(self, customer_authorization_initialize_request : CustomerAuthorizationInitializeRequest, **kwargs) -> ApiResponse:  # noqa: E501
        """Initialize Authorization  # noqa: E501

        Initiate a request to create a reusable authorization code for recurring transactions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_initialize_authorization_with_http_info(customer_authorization_initialize_request, async_req=True)
        >>> result = thread.get()

        :param customer_authorization_initialize_request: (required)
        :type customer_authorization_initialize_request: CustomerAuthorizationInitializeRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerAuthorizationInitializeResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'customer_authorization_initialize_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_initialize_authorization" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['customer_authorization_initialize_request'] is not None:
            _body_params = _params['customer_authorization_initialize_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerAuthorizationInitializeResponse",
            '401': "Error",
        }

        return self.api_client.call_api(
            '/customer/authorization/initialize', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_initialize_direct_debit(self, id : Annotated[StrictInt, Field(..., description="The ID of the customer to initialize the direct debit for")], customer_initialize_direct_debit_request : Optional[CustomerInitializeDirectDebitRequest] = None, **kwargs) -> CustomerInitializeDirectDebitResponse:  # noqa: E501
        """Initialize Direct Debit  # noqa: E501

        Initialize the process of linking an account to a customer for Direct Debit transactions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_initialize_direct_debit(id, customer_initialize_direct_debit_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the customer to initialize the direct debit for (required)
        :type id: int
        :param customer_initialize_direct_debit_request:
        :type customer_initialize_direct_debit_request: CustomerInitializeDirectDebitRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerInitializeDirectDebitResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_initialize_direct_debit_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_initialize_direct_debit_with_http_info(id, customer_initialize_direct_debit_request, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_initialize_direct_debit_with_http_info(self, id : Annotated[StrictInt, Field(..., description="The ID of the customer to initialize the direct debit for")], customer_initialize_direct_debit_request : Optional[CustomerInitializeDirectDebitRequest] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Initialize Direct Debit  # noqa: E501

        Initialize the process of linking an account to a customer for Direct Debit transactions  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_initialize_direct_debit_with_http_info(id, customer_initialize_direct_debit_request, async_req=True)
        >>> result = thread.get()

        :param id: The ID of the customer to initialize the direct debit for (required)
        :type id: int
        :param customer_initialize_direct_debit_request:
        :type customer_initialize_direct_debit_request: CustomerInitializeDirectDebitRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerInitializeDirectDebitResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id',
            'customer_initialize_direct_debit_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_initialize_direct_debit" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['customer_initialize_direct_debit_request'] is not None:
            _body_params = _params['customer_initialize_direct_debit_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerInitializeDirectDebitResponse",
            '401': "Error",
        }

        return self.api_client.call_api(
            '/customer/{id}/initialize-direct-debit', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_list(self, use_cursor : Annotated[Optional[StrictBool], Field(description="A flag to indicate if cursor based pagination should be used")] = None, next : Annotated[Optional[StrictStr], Field(description="An alphanumeric value returned for every cursor based retrieval, used to retrieve the next set of data ")] = None, previous : Annotated[Optional[StrictStr], Field(description="An alphanumeric value returned for every cursor based retrieval, used to retrieve the previous set of data ")] = None, var_from : Annotated[Optional[datetime], Field(description="The start date")] = None, to : Annotated[Optional[datetime], Field(description="The end date")] = None, per_page : Annotated[Optional[StrictStr], Field(description="The number of records to fetch per request")] = None, page : Annotated[Optional[StrictStr], Field(description="The offset to retrieve data from")] = None, **kwargs) -> CustomerListResponse:  # noqa: E501
        """List Customers  # noqa: E501

        List customers on your integration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_list(use_cursor, next, previous, var_from, to, per_page, page, async_req=True)
        >>> result = thread.get()

        :param use_cursor: A flag to indicate if cursor based pagination should be used
        :type use_cursor: bool
        :param next: An alphanumeric value returned for every cursor based retrieval, used to retrieve the next set of data 
        :type next: str
        :param previous: An alphanumeric value returned for every cursor based retrieval, used to retrieve the previous set of data 
        :type previous: str
        :param var_from: The start date
        :type var_from: datetime
        :param to: The end date
        :type to: datetime
        :param per_page: The number of records to fetch per request
        :type per_page: str
        :param page: The offset to retrieve data from
        :type page: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerListResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_list_with_http_info(use_cursor, next, previous, var_from, to, per_page, page, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_list_with_http_info(self, use_cursor : Annotated[Optional[StrictBool], Field(description="A flag to indicate if cursor based pagination should be used")] = None, next : Annotated[Optional[StrictStr], Field(description="An alphanumeric value returned for every cursor based retrieval, used to retrieve the next set of data ")] = None, previous : Annotated[Optional[StrictStr], Field(description="An alphanumeric value returned for every cursor based retrieval, used to retrieve the previous set of data ")] = None, var_from : Annotated[Optional[datetime], Field(description="The start date")] = None, to : Annotated[Optional[datetime], Field(description="The end date")] = None, per_page : Annotated[Optional[StrictStr], Field(description="The number of records to fetch per request")] = None, page : Annotated[Optional[StrictStr], Field(description="The offset to retrieve data from")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List Customers  # noqa: E501

        List customers on your integration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_list_with_http_info(use_cursor, next, previous, var_from, to, per_page, page, async_req=True)
        >>> result = thread.get()

        :param use_cursor: A flag to indicate if cursor based pagination should be used
        :type use_cursor: bool
        :param next: An alphanumeric value returned for every cursor based retrieval, used to retrieve the next set of data 
        :type next: str
        :param previous: An alphanumeric value returned for every cursor based retrieval, used to retrieve the previous set of data 
        :type previous: str
        :param var_from: The start date
        :type var_from: datetime
        :param to: The end date
        :type to: datetime
        :param per_page: The number of records to fetch per request
        :type per_page: str
        :param page: The offset to retrieve data from
        :type page: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerListResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'use_cursor',
            'next',
            'previous',
            'var_from',
            'to',
            'per_page',
            'page'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_list" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('use_cursor') is not None:  # noqa: E501
            _query_params.append(('use_cursor', _params['use_cursor']))

        if _params.get('next') is not None:  # noqa: E501
            _query_params.append(('next', _params['next']))

        if _params.get('previous') is not None:  # noqa: E501
            _query_params.append(('previous', _params['previous']))

        if _params.get('var_from') is not None:  # noqa: E501
            if isinstance(_params['var_from'], datetime):
                _query_params.append(('from', _params['var_from'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            if isinstance(_params['to'], datetime):
                _query_params.append(('to', _params['to'].strftime(self.api_client.configuration.datetime_format)))
            else:
                _query_params.append(('to', _params['to']))

        if _params.get('per_page') is not None:  # noqa: E501
            _query_params.append(('perPage', _params['per_page']))

        if _params.get('page') is not None:  # noqa: E501
            _query_params.append(('page', _params['page']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerListResponse",
            '401': "Error",
            '404': "Error",
        }

        return self.api_client.call_api(
            '/customer', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_risk_action(self, customer_risk_action : Optional[CustomerRiskAction] = None, **kwargs) -> CustomerWhitelistBlacklistResponse:  # noqa: E501
        """Set Risk Action  # noqa: E501

        Set customer's risk action by whitelisting or blacklisting the customer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_risk_action(customer_risk_action, async_req=True)
        >>> result = thread.get()

        :param customer_risk_action:
        :type customer_risk_action: CustomerRiskAction
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerWhitelistBlacklistResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_risk_action_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_risk_action_with_http_info(customer_risk_action, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_risk_action_with_http_info(self, customer_risk_action : Optional[CustomerRiskAction] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Set Risk Action  # noqa: E501

        Set customer's risk action by whitelisting or blacklisting the customer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_risk_action_with_http_info(customer_risk_action, async_req=True)
        >>> result = thread.get()

        :param customer_risk_action:
        :type customer_risk_action: CustomerRiskAction
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerWhitelistBlacklistResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'customer_risk_action'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_risk_action" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['customer_risk_action'] is not None:
            _body_params = _params['customer_risk_action']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerWhitelistBlacklistResponse",
            '401': "Error",
        }

        return self.api_client.call_api(
            '/customer/set_risk_action', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_update(self, code : Annotated[StrictStr, Field(..., description="The code for the customer gotten from the response of the customer creation")], customer_update : Optional[CustomerUpdate] = None, **kwargs) -> CustomerUpdateResponse:  # noqa: E501
        """Update Customer  # noqa: E501

        Update a customer's details on your integration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_update(code, customer_update, async_req=True)
        >>> result = thread.get()

        :param code: The code for the customer gotten from the response of the customer creation (required)
        :type code: str
        :param customer_update:
        :type customer_update: CustomerUpdate
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerUpdateResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_update_with_http_info(code, customer_update, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_update_with_http_info(self, code : Annotated[StrictStr, Field(..., description="The code for the customer gotten from the response of the customer creation")], customer_update : Optional[CustomerUpdate] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Update Customer  # noqa: E501

        Update a customer's details on your integration  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_update_with_http_info(code, customer_update, async_req=True)
        >>> result = thread.get()

        :param code: The code for the customer gotten from the response of the customer creation (required)
        :type code: str
        :param customer_update:
        :type customer_update: CustomerUpdate
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerUpdateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'code',
            'customer_update'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_update" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['code']:
            _path_params['code'] = _params['code']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['customer_update'] is not None:
            _body_params = _params['customer_update']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerUpdateResponse",
            '401': "Error",
            '404': "Error",
        }

        return self.api_client.call_api(
            '/customer/{code}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_validate(self, code : Annotated[StrictStr, Field(..., description="The code for the customer gotten from the response of the customer creation")], customer_validate : Optional[CustomerValidate] = None, **kwargs) -> CustomerValidateResponse:  # noqa: E501
        """Validate Customer  # noqa: E501

        Validate a customer's identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_validate(code, customer_validate, async_req=True)
        >>> result = thread.get()

        :param code: The code for the customer gotten from the response of the customer creation (required)
        :type code: str
        :param customer_validate:
        :type customer_validate: CustomerValidate
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerValidateResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_validate_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_validate_with_http_info(code, customer_validate, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_validate_with_http_info(self, code : Annotated[StrictStr, Field(..., description="The code for the customer gotten from the response of the customer creation")], customer_validate : Optional[CustomerValidate] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Validate Customer  # noqa: E501

        Validate a customer's identity  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_validate_with_http_info(code, customer_validate, async_req=True)
        >>> result = thread.get()

        :param code: The code for the customer gotten from the response of the customer creation (required)
        :type code: str
        :param customer_validate:
        :type customer_validate: CustomerValidate
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerValidateResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'code',
            'customer_validate'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_validate" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['code']:
            _path_params['code'] = _params['code']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['customer_validate'] is not None:
            _body_params = _params['customer_validate']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json', 'application/x-www-form-urlencoded']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '202': "CustomerValidateResponse",
            '401': "Error",
        }

        return self.api_client.call_api(
            '/customer/{code}/identification', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def customer_verify_authorization(self, reference : Annotated[StrictStr, Field(..., description="The reference returned in the initialization response")], **kwargs) -> CustomerAuthorizationVerifyResponse:  # noqa: E501
        """Verify Authorization  # noqa: E501

        Check the status of an authorization request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_verify_authorization(reference, async_req=True)
        >>> result = thread.get()

        :param reference: The reference returned in the initialization response (required)
        :type reference: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CustomerAuthorizationVerifyResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the customer_verify_authorization_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.customer_verify_authorization_with_http_info(reference, **kwargs)  # noqa: E501

    @validate_arguments
    def customer_verify_authorization_with_http_info(self, reference : Annotated[StrictStr, Field(..., description="The reference returned in the initialization response")], **kwargs) -> ApiResponse:  # noqa: E501
        """Verify Authorization  # noqa: E501

        Check the status of an authorization request  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.customer_verify_authorization_with_http_info(reference, async_req=True)
        >>> result = thread.get()

        :param reference: The reference returned in the initialization response (required)
        :type reference: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CustomerAuthorizationVerifyResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'reference'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method customer_verify_authorization" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['reference']:
            _path_params['reference'] = _params['reference']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['bearerAuth']  # noqa: E501

        _response_types_map = {
            '200': "CustomerAuthorizationVerifyResponse",
            '401': "Error",
            '404': "Error",
        }

        return self.api_client.call_api(
            '/customer/authorization/verify/{reference}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
