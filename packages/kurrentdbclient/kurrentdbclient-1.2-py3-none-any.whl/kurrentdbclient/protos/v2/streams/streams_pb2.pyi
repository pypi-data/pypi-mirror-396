"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
******************************************************************************************
This protocol is UNSTABLE in the sense of being subject to change.
******************************************************************************************
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _SchemaFormat:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SchemaFormatEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SchemaFormat.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SCHEMA_FORMAT_UNSPECIFIED: _SchemaFormat.ValueType  # 0
    """Default value, should not be used."""
    SCHEMA_FORMAT_JSON: _SchemaFormat.ValueType  # 1
    SCHEMA_FORMAT_PROTOBUF: _SchemaFormat.ValueType  # 2
    SCHEMA_FORMAT_AVRO: _SchemaFormat.ValueType  # 3
    SCHEMA_FORMAT_BYTES: _SchemaFormat.ValueType  # 4

class SchemaFormat(_SchemaFormat, metaclass=_SchemaFormatEnumTypeWrapper):
    """Represents the data format of the schema."""

SCHEMA_FORMAT_UNSPECIFIED: SchemaFormat.ValueType  # 0
"""Default value, should not be used."""
SCHEMA_FORMAT_JSON: SchemaFormat.ValueType  # 1
SCHEMA_FORMAT_PROTOBUF: SchemaFormat.ValueType  # 2
SCHEMA_FORMAT_AVRO: SchemaFormat.ValueType  # 3
SCHEMA_FORMAT_BYTES: SchemaFormat.ValueType  # 4
global___SchemaFormat = SchemaFormat

class _ExpectedRevisionConstants:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ExpectedRevisionConstantsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ExpectedRevisionConstants.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    EXPECTED_REVISION_CONSTANTS_SINGLE_EVENT: _ExpectedRevisionConstants.ValueType  # 0
    """The stream must have exactly one event at revision 0.
    Used for scenarios requiring strict single-event semantics.
    """
    EXPECTED_REVISION_CONSTANTS_NO_STREAM: _ExpectedRevisionConstants.ValueType  # -1
    """The stream must not exist yet (first write to the stream).
    Fails if the stream already has events.
    """
    EXPECTED_REVISION_CONSTANTS_ANY: _ExpectedRevisionConstants.ValueType  # -2
    """Accept any current state of the stream (no optimistic concurrency check).
    The write will succeed regardless of the stream's current revision.
    """
    EXPECTED_REVISION_CONSTANTS_EXISTS: _ExpectedRevisionConstants.ValueType  # -4
    """The stream must exist (have at least one record).
    Fails if the stream doesn't exist yet.
    """

class ExpectedRevisionConstants(_ExpectedRevisionConstants, metaclass=_ExpectedRevisionConstantsEnumTypeWrapper):
    """Constants for expected revision validation in optimistic concurrency control.
    These can be used in the expected_revision field, or you can specify an actual revision number.
    """

EXPECTED_REVISION_CONSTANTS_SINGLE_EVENT: ExpectedRevisionConstants.ValueType  # 0
"""The stream must have exactly one event at revision 0.
Used for scenarios requiring strict single-event semantics.
"""
EXPECTED_REVISION_CONSTANTS_NO_STREAM: ExpectedRevisionConstants.ValueType  # -1
"""The stream must not exist yet (first write to the stream).
Fails if the stream already has events.
"""
EXPECTED_REVISION_CONSTANTS_ANY: ExpectedRevisionConstants.ValueType  # -2
"""Accept any current state of the stream (no optimistic concurrency check).
The write will succeed regardless of the stream's current revision.
"""
EXPECTED_REVISION_CONSTANTS_EXISTS: ExpectedRevisionConstants.ValueType  # -4
"""The stream must exist (have at least one record).
Fails if the stream doesn't exist yet.
"""
global___ExpectedRevisionConstants = ExpectedRevisionConstants

@typing.final
class AppendRequest(google.protobuf.message.Message):
    """Represents the input for appending records to a specific stream."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STREAM_FIELD_NUMBER: builtins.int
    RECORDS_FIELD_NUMBER: builtins.int
    EXPECTED_REVISION_FIELD_NUMBER: builtins.int
    stream: builtins.str
    """The stream to append records to."""
    expected_revision: builtins.int
    """The expected revision for optimistic concurrency control.
    Can be either:
    - A specific revision number (0, 1, 2, ...) - the stream must be at exactly this revision
    - An ExpectedRevisionConstants value (-4, -2, -1) for special semantics

    If omitted, defaults to EXPECTED_REVISION_CONSTANTS_ANY (-2).
    """
    @property
    def records(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AppendRecord]:
        """The records to append to the stream."""

    def __init__(
        self,
        *,
        stream: builtins.str = ...,
        records: collections.abc.Iterable[global___AppendRecord] | None = ...,
        expected_revision: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_expected_revision", b"_expected_revision", "expected_revision", b"expected_revision"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_expected_revision", b"_expected_revision", "expected_revision", b"expected_revision", "records", b"records", "stream", b"stream"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_expected_revision", b"_expected_revision"]) -> typing.Literal["expected_revision"] | None: ...

global___AppendRequest = AppendRequest

@typing.final
class AppendResponse(google.protobuf.message.Message):
    """Represents the outcome of an append operation."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    STREAM_FIELD_NUMBER: builtins.int
    STREAM_REVISION_FIELD_NUMBER: builtins.int
    POSITION_FIELD_NUMBER: builtins.int
    stream: builtins.str
    """The stream to which records were appended."""
    stream_revision: builtins.int
    """The actual/current revision of the stream after the append.
    This is the revision number of the last record written to this stream.
    """
    position: builtins.int
    """The position of the last appended record in the global log."""
    def __init__(
        self,
        *,
        stream: builtins.str = ...,
        stream_revision: builtins.int = ...,
        position: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_position", b"_position", "position", b"position"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_position", b"_position", "position", b"position", "stream", b"stream", "stream_revision", b"stream_revision"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_position", b"_position"]) -> typing.Literal["position"] | None: ...

global___AppendResponse = AppendResponse

@typing.final
class AppendSessionResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OUTPUT_FIELD_NUMBER: builtins.int
    POSITION_FIELD_NUMBER: builtins.int
    position: builtins.int
    """The global commit position of the last appended record in the session."""
    @property
    def output(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AppendResponse]:
        """The results of each append request in the session."""

    def __init__(
        self,
        *,
        output: collections.abc.Iterable[global___AppendResponse] | None = ...,
        position: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["output", b"output", "position", b"position"]) -> None: ...

global___AppendSessionResponse = AppendSessionResponse

@typing.final
class SchemaInfo(google.protobuf.message.Message):
    """Schema information for record validation and interpretation."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    FORMAT_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    ID_FIELD_NUMBER: builtins.int
    format: global___SchemaFormat.ValueType
    """The format of the data payload.
    Determines how the bytes in AppendRecord.data should be interpreted.
    """
    name: builtins.str
    """The schema name (replaces the legacy "event type" concept).
    Identifies what kind of data this record contains.

    Common naming formats:
      - Kebab-case: "order-placed", "customer-registered"
      - URN format: "urn:kurrentdb:events:order-placed:v1"
      - Dotted namespace: "Teams.Player.V1", "Orders.OrderPlaced.V2"
      - Reverse domain: "com.acme.orders.placed"
    """
    id: builtins.str
    """The identifier of the specific version of the schema that the record payload
    conforms to. This should match a registered schema version in the system.
    Not necessary when not enforcing schema validation.
    """
    def __init__(
        self,
        *,
        format: global___SchemaFormat.ValueType = ...,
        name: builtins.str = ...,
        id: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_id", b"_id", "id", b"id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_id", b"_id", "format", b"format", "id", b"id", "name", b"name"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_id", b"_id"]) -> typing.Literal["id"] | None: ...

global___SchemaInfo = SchemaInfo

@typing.final
class AppendRecord(google.protobuf.message.Message):
    """Record to be appended to a stream."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class PropertiesEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> google.protobuf.struct_pb2.Value: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: google.protobuf.struct_pb2.Value | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    RECORD_ID_FIELD_NUMBER: builtins.int
    PROPERTIES_FIELD_NUMBER: builtins.int
    SCHEMA_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    record_id: builtins.str
    """Unique identifier for this record (must be a valid UUID/GUID).
    If not provided, the server will generate a new one.
    """
    data: builtins.bytes
    """The record payload as raw bytes.
    The format specified in SchemaInfo determines how to interpret these bytes.
    """
    @property
    def properties(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, google.protobuf.struct_pb2.Value]:
        """A collection of properties providing additional information about the
        record. Can contain user-defined or system propreties.
        System keys will be prefixed with "$" (e.g., "$timestamp").
        User-defined keys MUST NOT start with "$".

        Common examples:
          User metadata:
            - "user-id": "12345"
            - "tenant": "acme-corp"
            - "source": "mobile-app"

          System metadata (with $ prefix):
            - "$trace-id": "4bf92f3577b34da6a3ce929d0e0e4736"  // OpenTelemetry trace ID
            - "$span-id": "00f067aa0ba902b7"                   // OpenTelemetry span ID
            - "$timestamp": "2025-01-15T10:30:00.000Z"         // ISO 8601 timestamp
        """

    @property
    def schema(self) -> global___SchemaInfo:
        """Schema information for this record."""

    def __init__(
        self,
        *,
        record_id: builtins.str | None = ...,
        properties: collections.abc.Mapping[builtins.str, google.protobuf.struct_pb2.Value] | None = ...,
        schema: global___SchemaInfo | None = ...,
        data: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_record_id", b"_record_id", "record_id", b"record_id", "schema", b"schema"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_record_id", b"_record_id", "data", b"data", "properties", b"properties", "record_id", b"record_id", "schema", b"schema"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_record_id", b"_record_id"]) -> typing.Literal["record_id"] | None: ...

global___AppendRecord = AppendRecord
