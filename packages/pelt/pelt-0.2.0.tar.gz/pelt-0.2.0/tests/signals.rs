//! Test with different signals generated by Python `ruptures` library.

mod common;

use std::num::NonZero;

use pelt::{Kahan, Pelt, SegmentCostFunction};

/// Ensure the main algorithm is correct.
#[test]
fn pelt_small() {
    let pelt = Pelt::new()
        .with_jump(NonZero::new(5).expect("Invalid number"))
        .with_minimum_segment_length(NonZero::new(2).expect("Invalid number"))
        .with_segment_cost_function(SegmentCostFunction::L1);

    // Test prediction
    assert_eq!(
        pelt.predict::<Kahan<_>, _>(
            common::load_signals_fixture(include_str!("../tests/signals.txt")).view(),
            10.0
        )
        .expect("Error predicting"),
        vec![100, 200]
    );
}

/// Ensure the main algorithm is correct with a larger dataset.
#[test]
fn pelt_large() {
    let pelt = Pelt::new()
        .with_jump(NonZero::new(5).expect("Invalid number"))
        .with_minimum_segment_length(NonZero::new(2).expect("Invalid number"))
        .with_segment_cost_function(SegmentCostFunction::L1);

    // Test prediction
    assert_eq!(
        pelt.predict::<Kahan<_>, _>(
            common::load_signals_fixture(include_str!("../tests/signals-large.txt")).view(),
            10.0
        )
        .expect("Error predicting"),
        vec![2000, 4000]
    );
}
