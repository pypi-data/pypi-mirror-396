# generated by https://github.com/puzl-cloud/kubesdk
#   filename:  api__v1_openapi.json

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import ClassVar, Dict, List, Set

from kube_models.const import *
from kube_models.loader import *
from kube_models.loader import LazyLoadModel
from kube_models.resource import *

from ...apimachinery.pkg.api.resource import Quantity
from ...apimachinery.pkg.apis.meta.v1 import (
    Condition,
    LabelSelector,
    ListMeta,
    MicroTime,
    ObjectMeta,
    Time,
)
from ...apimachinery.pkg.util.intstr import IntOrString


@dataclass(slots=True, kw_only=True, frozen=True)
class AWSElasticBlockStoreVolumeSource(LazyLoadModel):
    volumeID: str
    fsType: str | None = None
    partition: int | None = None
    readOnly: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class AppArmorProfile(LazyLoadModel):
    type: str
    localhostProfile: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class AttachedVolume(LazyLoadModel):
    devicePath: str
    name: str


@dataclass(slots=True, kw_only=True, frozen=True)
class AzureDiskVolumeSource(LazyLoadModel):
    diskName: str
    diskURI: str
    cachingMode: str | None = 'ReadWrite'
    fsType: str | None = 'ext4'
    kind: str | None = 'Shared'
    readOnly: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class AzureFilePersistentVolumeSource(LazyLoadModel):
    secretName: str
    shareName: str
    readOnly: bool | None = None
    secretNamespace: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class AzureFileVolumeSource(LazyLoadModel):
    secretName: str
    shareName: str
    readOnly: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Capabilities(LazyLoadModel):
    add: List[str] | None = None
    drop: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ClientIPConfig(LazyLoadModel):
    timeoutSeconds: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ComponentCondition(LazyLoadModel):
    status: str
    type: str
    error: str | None = None
    message: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ConfigMapEnvSource(LazyLoadModel):
    name: str | None = None
    optional: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ConfigMapKeySelector(LazyLoadModel):
    key: str
    name: str | None = None
    optional: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ConfigMapNodeConfigSource(LazyLoadModel):
    kubeletConfigKey: str
    name: str
    namespace: str
    resourceVersion: str | None = None
    uid: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerExtendedResourceRequest(LazyLoadModel):
    containerName: str
    requestName: str
    resourceName: str


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerImage(LazyLoadModel):
    names: List[str] | None = None
    sizeBytes: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerPort(LazyLoadModel):
    containerPort: int
    hostIP: str | None = None
    hostPort: int | None = None
    name: str | None = None
    protocol: str | None = 'TCP'


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerResizePolicy(LazyLoadModel):
    resourceName: str
    restartPolicy: str


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerRestartRuleOnExitCodes(LazyLoadModel):
    operator: str
    values: List[int] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerStateWaiting(LazyLoadModel):
    message: str | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class DaemonEndpoint(LazyLoadModel):
    Port: int


@dataclass(slots=True, kw_only=True, frozen=True)
class EndpointPort(LazyLoadModel):
    port: int
    appProtocol: str | None = None
    name: str | None = None
    protocol: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class EventSource(LazyLoadModel):
    component: str | None = None
    host: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ExecAction(LazyLoadModel):
    command: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class FCVolumeSource(LazyLoadModel):
    fsType: str | None = None
    lun: int | None = None
    readOnly: bool | None = None
    targetWWNs: List[str] | None = None
    wwids: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class FileKeySelector(LazyLoadModel):
    key: str
    path: str
    volumeName: str
    optional: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class FlockerVolumeSource(LazyLoadModel):
    datasetName: str | None = None
    datasetUUID: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class GCEPersistentDiskVolumeSource(LazyLoadModel):
    pdName: str
    fsType: str | None = None
    partition: int | None = None
    readOnly: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class GRPCAction(LazyLoadModel):
    port: int
    service: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class GitRepoVolumeSource(LazyLoadModel):
    repository: str
    directory: str | None = None
    revision: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class GlusterfsPersistentVolumeSource(LazyLoadModel):
    endpoints: str
    path: str
    endpointsNamespace: str | None = None
    readOnly: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class GlusterfsVolumeSource(LazyLoadModel):
    endpoints: str
    path: str
    readOnly: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class HTTPHeader(LazyLoadModel):
    name: str
    value: str


@dataclass(slots=True, kw_only=True, frozen=True)
class HostAlias(LazyLoadModel):
    ip: str
    hostnames: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class HostIP(LazyLoadModel):
    ip: str


@dataclass(slots=True, kw_only=True, frozen=True)
class HostPathVolumeSource(LazyLoadModel):
    path: str
    type: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ImageVolumeSource(LazyLoadModel):
    pullPolicy: str | None = None
    reference: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class KeyToPath(LazyLoadModel):
    key: str
    path: str
    mode: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class LinuxContainerUser(LazyLoadModel):
    gid: int
    uid: int
    supplementalGroups: List[int] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class LocalObjectReference(LazyLoadModel):
    name: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class LocalVolumeSource(LazyLoadModel):
    path: str
    fsType: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ModifyVolumeStatus(LazyLoadModel):
    status: str
    targetVolumeAttributesClassName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NFSVolumeSource(LazyLoadModel):
    path: str
    server: str
    readOnly: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NamespaceSpec(LazyLoadModel):
    finalizers: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeAddress(LazyLoadModel):
    address: str
    type: str


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeConfigSource(LazyLoadModel):
    configMap: ConfigMapNodeConfigSource | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeConfigStatus(LazyLoadModel):
    active: NodeConfigSource | None = None
    assigned: NodeConfigSource | None = None
    error: str | None = None
    lastKnownGood: NodeConfigSource | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeDaemonEndpoints(LazyLoadModel):
    kubeletEndpoint: DaemonEndpoint | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeFeatures(LazyLoadModel):
    supplementalGroupsPolicy: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeRuntimeHandlerFeatures(LazyLoadModel):
    recursiveReadOnlyMounts: bool | None = None
    userNamespaces: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeSelectorRequirement(LazyLoadModel):
    key: str
    operator: str
    values: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeSelectorTerm(LazyLoadModel):
    matchExpressions: List[NodeSelectorRequirement] | None = None
    matchFields: List[NodeSelectorRequirement] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeSwapStatus(LazyLoadModel):
    capacity: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeSystemInfo(LazyLoadModel):
    architecture: str
    bootID: str
    containerRuntimeVersion: str
    kernelVersion: str
    kubeProxyVersion: str
    kubeletVersion: str
    machineID: str
    operatingSystem: str
    osImage: str
    systemUUID: str
    swap: NodeSwapStatus | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ObjectFieldSelector(LazyLoadModel):
    fieldPath: str
    apiVersion: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ObjectReference(LazyLoadModel):
    apiVersion: str | None = None
    fieldPath: str | None = None
    kind: str | None = None
    name: str | None = None
    namespace: str | None = None
    resourceVersion: str | None = None
    uid: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolumeClaimVolumeSource(LazyLoadModel):
    claimName: str
    readOnly: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PhotonPersistentDiskVolumeSource(LazyLoadModel):
    pdID: str
    fsType: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodCertificateProjection(LazyLoadModel):
    keyType: str
    signerName: str
    certificateChainPath: str | None = None
    credentialBundlePath: str | None = None
    keyPath: str | None = None
    maxExpirationSeconds: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodDNSConfigOption(LazyLoadModel):
    name: str | None = None
    value: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodExtendedResourceClaimStatus(LazyLoadModel):
    requestMappings: List[ContainerExtendedResourceRequest]
    resourceClaimName: str


@dataclass(slots=True, kw_only=True, frozen=True)
class PodIP(LazyLoadModel):
    ip: str


@dataclass(slots=True, kw_only=True, frozen=True)
class PodOS(LazyLoadModel):
    name: str


@dataclass(slots=True, kw_only=True, frozen=True)
class PodReadinessGate(LazyLoadModel):
    conditionType: str


@dataclass(slots=True, kw_only=True, frozen=True)
class PodResourceClaim(LazyLoadModel):
    name: str
    resourceClaimName: str | None = None
    resourceClaimTemplateName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodResourceClaimStatus(LazyLoadModel):
    name: str
    resourceClaimName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodSchedulingGate(LazyLoadModel):
    name: str


@dataclass(slots=True, kw_only=True, frozen=True)
class PortStatus(LazyLoadModel):
    port: int
    protocol: str
    error: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PortworxVolumeSource(LazyLoadModel):
    volumeID: str
    fsType: str | None = None
    readOnly: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PreferredSchedulingTerm(LazyLoadModel):
    preference: NodeSelectorTerm
    weight: int


@dataclass(slots=True, kw_only=True, frozen=True)
class QuobyteVolumeSource(LazyLoadModel):
    registry: str
    volume: str
    group: str | None = None
    readOnly: bool | None = None
    tenant: str | None = None
    user: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class RBDVolumeSource(LazyLoadModel):
    image: str
    monitors: List[str]
    fsType: str | None = None
    keyring: str | None = '/etc/ceph/keyring'
    pool: str | None = 'rbd'
    readOnly: bool | None = None
    secretRef: LocalObjectReference | None = None
    user: str | None = 'admin'


@dataclass(slots=True, kw_only=True, frozen=True)
class ResourceClaim(LazyLoadModel):
    name: str
    request: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ResourceHealth(LazyLoadModel):
    resourceID: str
    health: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ResourceStatus(LazyLoadModel):
    name: str
    resources: List[ResourceHealth] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class SELinuxOptions(LazyLoadModel):
    level: str | None = None
    role: str | None = None
    type: str | None = None
    user: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ScaleIOVolumeSource(LazyLoadModel):
    gateway: str
    secretRef: LocalObjectReference
    system: str
    fsType: str | None = 'xfs'
    protectionDomain: str | None = None
    readOnly: bool | None = None
    sslEnabled: bool | None = None
    storageMode: str | None = 'ThinProvisioned'
    storagePool: str | None = None
    volumeName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ScopedResourceSelectorRequirement(LazyLoadModel):
    operator: str
    scopeName: str
    values: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class SeccompProfile(LazyLoadModel):
    type: str
    localhostProfile: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class SecretEnvSource(LazyLoadModel):
    name: str | None = None
    optional: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class SecretKeySelector(LazyLoadModel):
    key: str
    name: str | None = None
    optional: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class SecretProjection(LazyLoadModel):
    items: List[KeyToPath] | None = None
    name: str | None = None
    optional: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class SecretReference(LazyLoadModel):
    name: str | None = None
    namespace: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class SecretVolumeSource(LazyLoadModel):
    defaultMode: int | None = None
    items: List[KeyToPath] | None = None
    optional: bool | None = None
    secretName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceAccountTokenProjection(LazyLoadModel):
    path: str
    audience: str | None = None
    expirationSeconds: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class SessionAffinityConfig(LazyLoadModel):
    clientIP: ClientIPConfig | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class SleepAction(LazyLoadModel):
    seconds: int


@dataclass(slots=True, kw_only=True, frozen=True)
class StorageOSPersistentVolumeSource(LazyLoadModel):
    fsType: str | None = None
    readOnly: bool | None = None
    secretRef: ObjectReference | None = None
    volumeName: str | None = None
    volumeNamespace: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class StorageOSVolumeSource(LazyLoadModel):
    fsType: str | None = None
    readOnly: bool | None = None
    secretRef: LocalObjectReference | None = None
    volumeName: str | None = None
    volumeNamespace: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Sysctl(LazyLoadModel):
    name: str
    value: str


@dataclass(slots=True, kw_only=True, frozen=True)
class Toleration(LazyLoadModel):
    effect: str | None = None
    key: str | None = None
    operator: str | None = None
    tolerationSeconds: int | None = None
    value: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class TypedLocalObjectReference(LazyLoadModel):
    kind: str
    name: str
    apiGroup: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class TypedObjectReference(LazyLoadModel):
    kind: str
    name: str
    apiGroup: str | None = None
    namespace: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeDevice(LazyLoadModel):
    devicePath: str
    name: str


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeMount(LazyLoadModel):
    mountPath: str
    name: str
    mountPropagation: str | None = None
    readOnly: bool | None = None
    recursiveReadOnly: str | None = None
    subPath: str | None = None
    subPathExpr: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeMountStatus(LazyLoadModel):
    mountPath: str
    name: str
    readOnly: bool | None = None
    recursiveReadOnly: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class VsphereVirtualDiskVolumeSource(LazyLoadModel):
    volumePath: str
    fsType: str | None = None
    storagePolicyID: str | None = None
    storagePolicyName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class WindowsSecurityContextOptions(LazyLoadModel):
    gmsaCredentialSpec: str | None = None
    gmsaCredentialSpecName: str | None = None
    hostProcess: bool | None = None
    runAsUserName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class CSIPersistentVolumeSource(LazyLoadModel):
    driver: str
    volumeHandle: str
    controllerExpandSecretRef: SecretReference | None = None
    controllerPublishSecretRef: SecretReference | None = None
    fsType: str | None = None
    nodeExpandSecretRef: SecretReference | None = None
    nodePublishSecretRef: SecretReference | None = None
    nodeStageSecretRef: SecretReference | None = None
    readOnly: bool | None = None
    volumeAttributes: Dict[str, str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class CSIVolumeSource(LazyLoadModel):
    driver: str
    fsType: str | None = None
    nodePublishSecretRef: LocalObjectReference | None = None
    readOnly: bool | None = None
    volumeAttributes: Dict[str, str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class CephFSPersistentVolumeSource(LazyLoadModel):
    monitors: List[str]
    path: str | None = None
    readOnly: bool | None = None
    secretFile: str | None = None
    secretRef: SecretReference | None = None
    user: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class CephFSVolumeSource(LazyLoadModel):
    monitors: List[str]
    path: str | None = None
    readOnly: bool | None = None
    secretFile: str | None = None
    secretRef: LocalObjectReference | None = None
    user: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class CinderPersistentVolumeSource(LazyLoadModel):
    volumeID: str
    fsType: str | None = None
    readOnly: bool | None = None
    secretRef: SecretReference | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class CinderVolumeSource(LazyLoadModel):
    volumeID: str
    fsType: str | None = None
    readOnly: bool | None = None
    secretRef: LocalObjectReference | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ConfigMapProjection(LazyLoadModel):
    items: List[KeyToPath] | None = None
    name: str | None = None
    optional: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ConfigMapVolumeSource(LazyLoadModel):
    defaultMode: int | None = None
    items: List[KeyToPath] | None = None
    name: str | None = None
    optional: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerRestartRule(LazyLoadModel):
    action: str
    exitCodes: ContainerRestartRuleOnExitCodes | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerStateRunning(LazyLoadModel):
    startedAt: Time | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerStateTerminated(LazyLoadModel):
    exitCode: int
    containerID: str | None = None
    finishedAt: Time | None = None
    message: str | None = None
    reason: str | None = None
    signal: int | None = None
    startedAt: Time | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerUser(LazyLoadModel):
    linux: LinuxContainerUser | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class EmptyDirVolumeSource(LazyLoadModel):
    medium: str | None = None
    sizeLimit: Quantity | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class EndpointAddress(LazyLoadModel):
    ip: str
    hostname: str | None = None
    nodeName: str | None = None
    targetRef: ObjectReference | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class EndpointSubset(LazyLoadModel):
    addresses: List[EndpointAddress] | None = None
    notReadyAddresses: List[EndpointAddress] | None = None
    ports: List[EndpointPort] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class EnvFromSource(LazyLoadModel):
    configMapRef: ConfigMapEnvSource | None = None
    prefix: str | None = None
    secretRef: SecretEnvSource | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class EventSeries(LazyLoadModel):
    count: int | None = None
    lastObservedTime: MicroTime | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class FlexPersistentVolumeSource(LazyLoadModel):
    driver: str
    fsType: str | None = None
    options: Dict[str, str] | None = None
    readOnly: bool | None = None
    secretRef: SecretReference | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class FlexVolumeSource(LazyLoadModel):
    driver: str
    fsType: str | None = None
    options: Dict[str, str] | None = None
    readOnly: bool | None = None
    secretRef: LocalObjectReference | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class HTTPGetAction(LazyLoadModel):
    port: IntOrString
    host: str | None = None
    httpHeaders: List[HTTPHeader] | None = None
    path: str | None = None
    scheme: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ISCSIPersistentVolumeSource(LazyLoadModel):
    iqn: str
    lun: int
    targetPortal: str
    chapAuthDiscovery: bool | None = None
    chapAuthSession: bool | None = None
    fsType: str | None = None
    initiatorName: str | None = None
    iscsiInterface: str | None = 'default'
    portals: List[str] | None = None
    readOnly: bool | None = None
    secretRef: SecretReference | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ISCSIVolumeSource(LazyLoadModel):
    iqn: str
    lun: int
    targetPortal: str
    chapAuthDiscovery: bool | None = None
    chapAuthSession: bool | None = None
    fsType: str | None = None
    initiatorName: str | None = None
    iscsiInterface: str | None = 'default'
    portals: List[str] | None = None
    readOnly: bool | None = None
    secretRef: LocalObjectReference | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class LimitRangeItem(LazyLoadModel):
    type: str
    default: Dict[str, Quantity] | None = None
    defaultRequest: Dict[str, Quantity] | None = None
    max: Dict[str, Quantity] | None = None
    maxLimitRequestRatio: Dict[str, Quantity] | None = None
    min: Dict[str, Quantity] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class LimitRangeSpec(LazyLoadModel):
    limits: List[LimitRangeItem]


@dataclass(slots=True, kw_only=True, frozen=True)
class LoadBalancerIngress(LazyLoadModel):
    hostname: str | None = None
    ip: str | None = None
    ipMode: str | None = None
    ports: List[PortStatus] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class LoadBalancerStatus(LazyLoadModel):
    ingress: List[LoadBalancerIngress] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NamespaceCondition(LazyLoadModel):
    status: str
    type: str
    lastTransitionTime: Time | None = None
    message: str | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NamespaceStatus(LazyLoadModel):
    conditions: List[NamespaceCondition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    phase: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeCondition(LazyLoadModel):
    status: str
    type: str
    lastHeartbeatTime: Time | None = None
    lastTransitionTime: Time | None = None
    message: str | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeRuntimeHandler(LazyLoadModel):
    features: NodeRuntimeHandlerFeatures | None = None
    name: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeSelector(LazyLoadModel):
    nodeSelectorTerms: List[NodeSelectorTerm]


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeStatus(LazyLoadModel):
    addresses: List[NodeAddress] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    allocatable: Dict[str, Quantity] | None = None
    capacity: Dict[str, Quantity] | None = None
    conditions: List[NodeCondition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    config: NodeConfigStatus | None = None
    daemonEndpoints: NodeDaemonEndpoints | None = None
    features: NodeFeatures | None = None
    images: List[ContainerImage] | None = None
    nodeInfo: NodeSystemInfo | None = None
    phase: str | None = None
    runtimeHandlers: List[NodeRuntimeHandler] | None = None
    volumesAttached: List[AttachedVolume] | None = None
    volumesInUse: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolumeClaimCondition(LazyLoadModel):
    status: str
    type: str
    lastProbeTime: Time | None = None
    lastTransitionTime: Time | None = None
    message: str | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolumeClaimStatus(LazyLoadModel):
    accessModes: List[str] | None = None
    allocatedResourceStatuses: Dict[str, str] | None = None
    allocatedResources: Dict[str, Quantity] | None = None
    capacity: Dict[str, Quantity] | None = None
    conditions: List[PersistentVolumeClaimCondition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    currentVolumeAttributesClassName: str | None = None
    modifyVolumeStatus: ModifyVolumeStatus | None = None
    phase: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolumeStatus(LazyLoadModel):
    lastPhaseTransitionTime: Time | None = None
    message: str | None = None
    phase: str | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodCondition(LazyLoadModel):
    status: str
    type: str
    lastProbeTime: Time | None = None
    lastTransitionTime: Time | None = None
    message: str | None = None
    observedGeneration: int | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodDNSConfig(LazyLoadModel):
    nameservers: List[str] | None = None
    options: List[PodDNSConfigOption] | None = None
    searches: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodSecurityContext(LazyLoadModel):
    appArmorProfile: AppArmorProfile | None = None
    fsGroup: int | None = None
    fsGroupChangePolicy: str | None = None
    runAsGroup: int | None = None
    runAsNonRoot: bool | None = None
    runAsUser: int | None = None
    seLinuxChangePolicy: str | None = None
    seLinuxOptions: SELinuxOptions | None = None
    seccompProfile: SeccompProfile | None = None
    supplementalGroups: List[int] | None = None
    supplementalGroupsPolicy: str | None = None
    sysctls: List[Sysctl] | None = None
    windowsOptions: WindowsSecurityContextOptions | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class RBDPersistentVolumeSource(LazyLoadModel):
    image: str
    monitors: List[str]
    fsType: str | None = None
    keyring: str | None = '/etc/ceph/keyring'
    pool: str | None = 'rbd'
    readOnly: bool | None = None
    secretRef: SecretReference | None = None
    user: str | None = 'admin'


@dataclass(slots=True, kw_only=True, frozen=True)
class ReplicationControllerCondition(LazyLoadModel):
    status: str
    type: str
    lastTransitionTime: Time | None = None
    message: str | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ReplicationControllerStatus(LazyLoadModel):
    replicas: int
    availableReplicas: int | None = None
    conditions: List[ReplicationControllerCondition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    fullyLabeledReplicas: int | None = None
    observedGeneration: int | None = None
    readyReplicas: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ResourceFieldSelector(LazyLoadModel):
    resource: str
    containerName: str | None = None
    divisor: Quantity | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ResourceQuotaStatus(LazyLoadModel):
    hard: Dict[str, Quantity] | None = None
    used: Dict[str, Quantity] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ResourceRequirements(LazyLoadModel):
    claims: List[ResourceClaim] | None = None
    limits: Dict[str, Quantity] | None = None
    requests: Dict[str, Quantity] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ScaleIOPersistentVolumeSource(LazyLoadModel):
    gateway: str
    secretRef: SecretReference
    system: str
    fsType: str | None = 'xfs'
    protectionDomain: str | None = None
    readOnly: bool | None = None
    sslEnabled: bool | None = None
    storageMode: str | None = 'ThinProvisioned'
    storagePool: str | None = None
    volumeName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ScopeSelector(LazyLoadModel):
    matchExpressions: List[ScopedResourceSelectorRequirement] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class SecurityContext(LazyLoadModel):
    allowPrivilegeEscalation: bool | None = None
    appArmorProfile: AppArmorProfile | None = None
    capabilities: Capabilities | None = None
    privileged: bool | None = None
    procMount: str | None = None
    readOnlyRootFilesystem: bool | None = None
    runAsGroup: int | None = None
    runAsNonRoot: bool | None = None
    runAsUser: int | None = None
    seLinuxOptions: SELinuxOptions | None = None
    seccompProfile: SeccompProfile | None = None
    windowsOptions: WindowsSecurityContextOptions | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ServicePort(LazyLoadModel):
    port: int
    appProtocol: str | None = None
    name: str | None = None
    nodePort: int | None = None
    protocol: str | None = 'TCP'
    targetPort: IntOrString | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceSpec(LazyLoadModel):
    allocateLoadBalancerNodePorts: bool | None = None
    clusterIP: str | None = None
    clusterIPs: List[str] | None = None
    externalIPs: List[str] | None = None
    externalName: str | None = None
    externalTrafficPolicy: str | None = None
    healthCheckNodePort: int | None = None
    internalTrafficPolicy: str | None = None
    ipFamilies: List[str] | None = None
    ipFamilyPolicy: str | None = None
    loadBalancerClass: str | None = None
    loadBalancerIP: str | None = None
    loadBalancerSourceRanges: List[str] | None = None
    ports: List[ServicePort] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'port',
        },
    )
    publishNotReadyAddresses: bool | None = None
    selector: Dict[str, str] | None = None
    sessionAffinity: str | None = None
    sessionAffinityConfig: SessionAffinityConfig | None = None
    trafficDistribution: str | None = None
    type: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class TCPSocketAction(LazyLoadModel):
    port: IntOrString
    host: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Taint(LazyLoadModel):
    effect: str
    key: str
    timeAdded: Time | None = None
    value: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeNodeAffinity(LazyLoadModel):
    required: NodeSelector | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeResourceRequirements(LazyLoadModel):
    limits: Dict[str, Quantity] | None = None
    requests: Dict[str, Quantity] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Binding(K8sResource):
    target: ObjectReference
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'Binding'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    plural_: ClassVar[str] = 'binding'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ClusterTrustBundleProjection(LazyLoadModel):
    path: str
    labelSelector: LabelSelector | None = None
    name: str | None = None
    optional: bool | None = None
    signerName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ComponentStatus(LazyLoadModel):
    apiVersion: str = 'v1'
    conditions: List[ComponentCondition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    kind: str = 'ComponentStatus'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class ComponentStatusList(LazyLoadModel):
    items: List[ComponentStatus]
    apiVersion: str = 'v1'
    kind: str = 'ComponentStatusList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class ConfigMap(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    binaryData: Dict[str, str] | None = None
    data: Dict[str, str] | None = None
    immutable: bool | None = None
    kind: ClassVar[str] = 'ConfigMap'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    plural_: ClassVar[str] = 'configmaps'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class ConfigMapList(LazyLoadModel):
    items: List[ConfigMap]
    apiVersion: str = 'v1'
    kind: str = 'ConfigMapList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerState(LazyLoadModel):
    running: ContainerStateRunning | None = None
    terminated: ContainerStateTerminated | None = None
    waiting: ContainerStateWaiting | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ContainerStatus(LazyLoadModel):
    image: str
    imageID: str
    name: str
    ready: bool
    restartCount: int
    allocatedResources: Dict[str, Quantity] | None = None
    allocatedResourcesStatus: List[ResourceStatus] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )
    containerID: str | None = None
    lastState: ContainerState | None = None
    resources: ResourceRequirements | None = None
    started: bool | None = None
    state: ContainerState | None = None
    stopSignal: str | None = None
    user: ContainerUser | None = None
    volumeMounts: List[VolumeMountStatus] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'mountPath',
        },
    )


@dataclass(slots=True, kw_only=True, frozen=True)
class DownwardAPIVolumeFile(LazyLoadModel):
    path: str
    fieldRef: ObjectFieldSelector | None = None
    mode: int | None = None
    resourceFieldRef: ResourceFieldSelector | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class DownwardAPIVolumeSource(LazyLoadModel):
    defaultMode: int | None = None
    items: List[DownwardAPIVolumeFile] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Endpoints(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'Endpoints'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    subsets: List[EndpointSubset] | None = None
    plural_: ClassVar[str] = 'endpoints'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class EndpointsList(LazyLoadModel):
    items: List[Endpoints]
    apiVersion: str = 'v1'
    kind: str = 'EndpointsList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class EnvVarSource(LazyLoadModel):
    configMapKeyRef: ConfigMapKeySelector | None = None
    fieldRef: ObjectFieldSelector | None = None
    fileKeyRef: FileKeySelector | None = None
    resourceFieldRef: ResourceFieldSelector | None = None
    secretKeyRef: SecretKeySelector | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Event(K8sResource):
    involvedObject: ObjectReference
    metadata: ObjectMeta
    action: str | None = None
    apiVersion: ClassVar[str] = 'v1'
    count: int | None = None
    eventTime: MicroTime | None = None
    firstTimestamp: Time | None = None
    kind: ClassVar[str] = 'Event'
    lastTimestamp: Time | None = None
    message: str | None = None
    reason: str | None = None
    related: ObjectReference | None = None
    reportingComponent: str | None = None
    reportingInstance: str | None = None
    series: EventSeries | None = None
    source: EventSource | None = None
    type: str | None = None
    plural_: ClassVar[str] = 'events'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class EventList(LazyLoadModel):
    items: List[Event]
    apiVersion: str = 'v1'
    kind: str = 'EventList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class LifecycleHandler(LazyLoadModel):
    exec: ExecAction | None = None
    httpGet: HTTPGetAction | None = None
    sleep: SleepAction | None = None
    tcpSocket: TCPSocketAction | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class LimitRange(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'LimitRange'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: LimitRangeSpec | None = None
    plural_: ClassVar[str] = 'limitranges'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class LimitRangeList(LazyLoadModel):
    items: List[LimitRange]
    apiVersion: str = 'v1'
    kind: str = 'LimitRangeList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class Namespace(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'Namespace'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: NamespaceSpec | None = None
    status: NamespaceStatus | None = None
    plural_: ClassVar[str] = 'namespaces'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class NamespaceList(LazyLoadModel):
    items: List[Namespace]
    apiVersion: str = 'v1'
    kind: str = 'NamespaceList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeAffinity(LazyLoadModel):
    preferredDuringSchedulingIgnoredDuringExecution: (
        List[PreferredSchedulingTerm] | None
    ) = None
    requiredDuringSchedulingIgnoredDuringExecution: NodeSelector | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeSpec(LazyLoadModel):
    configSource: NodeConfigSource | None = None
    externalID: str | None = None
    podCIDR: str | None = None
    podCIDRs: List[str] = field(
        default_factory=list, metadata={'x-kubernetes-patch-strategy': 'merge'}
    )
    providerID: str | None = None
    taints: List[Taint] | None = None
    unschedulable: bool | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolumeClaimSpec(LazyLoadModel):
    accessModes: List[str] | None = None
    dataSource: TypedLocalObjectReference | None = None
    dataSourceRef: TypedObjectReference | None = None
    resources: VolumeResourceRequirements | None = None
    selector: LabelSelector | None = None
    storageClassName: str | None = None
    volumeAttributesClassName: str | None = None
    volumeMode: str | None = None
    volumeName: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolumeClaimTemplate(LazyLoadModel):
    spec: PersistentVolumeClaimSpec
    metadata: ObjectMeta | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolumeSpec(LazyLoadModel):
    accessModes: List[str] | None = None
    awsElasticBlockStore: AWSElasticBlockStoreVolumeSource | None = None
    azureDisk: AzureDiskVolumeSource | None = None
    azureFile: AzureFilePersistentVolumeSource | None = None
    capacity: Dict[str, Quantity] | None = None
    cephfs: CephFSPersistentVolumeSource | None = None
    cinder: CinderPersistentVolumeSource | None = None
    claimRef: ObjectReference | None = None
    csi: CSIPersistentVolumeSource | None = None
    fc: FCVolumeSource | None = None
    flexVolume: FlexPersistentVolumeSource | None = None
    flocker: FlockerVolumeSource | None = None
    gcePersistentDisk: GCEPersistentDiskVolumeSource | None = None
    glusterfs: GlusterfsPersistentVolumeSource | None = None
    hostPath: HostPathVolumeSource | None = None
    iscsi: ISCSIPersistentVolumeSource | None = None
    local: LocalVolumeSource | None = None
    mountOptions: List[str] | None = None
    nfs: NFSVolumeSource | None = None
    nodeAffinity: VolumeNodeAffinity | None = None
    persistentVolumeReclaimPolicy: str | None = None
    photonPersistentDisk: PhotonPersistentDiskVolumeSource | None = None
    portworxVolume: PortworxVolumeSource | None = None
    quobyte: QuobyteVolumeSource | None = None
    rbd: RBDPersistentVolumeSource | None = None
    scaleIO: ScaleIOPersistentVolumeSource | None = None
    storageClassName: str | None = None
    storageos: StorageOSPersistentVolumeSource | None = None
    volumeAttributesClassName: str | None = None
    volumeMode: str | None = None
    vsphereVolume: VsphereVirtualDiskVolumeSource | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodAffinityTerm(LazyLoadModel):
    topologyKey: str
    labelSelector: LabelSelector | None = None
    matchLabelKeys: List[str] | None = None
    mismatchLabelKeys: List[str] | None = None
    namespaceSelector: LabelSelector | None = None
    namespaces: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodStatus(LazyLoadModel):
    conditions: List[PodCondition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    containerStatuses: List[ContainerStatus] | None = None
    ephemeralContainerStatuses: List[ContainerStatus] | None = None
    extendedResourceClaimStatus: PodExtendedResourceClaimStatus | None = None
    hostIP: str | None = None
    hostIPs: List[HostIP] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'ip',
        },
    )
    initContainerStatuses: List[ContainerStatus] | None = None
    message: str | None = None
    nominatedNodeName: str | None = None
    observedGeneration: int | None = None
    phase: str | None = None
    podIP: str | None = None
    podIPs: List[PodIP] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'ip',
        },
    )
    qosClass: str | None = None
    reason: str | None = None
    resize: str | None = None
    resourceClaimStatuses: List[PodResourceClaimStatus] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge,retainKeys',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )
    startTime: Time | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Probe(LazyLoadModel):
    exec: ExecAction | None = None
    failureThreshold: int | None = None
    grpc: GRPCAction | None = None
    httpGet: HTTPGetAction | None = None
    initialDelaySeconds: int | None = None
    periodSeconds: int | None = None
    successThreshold: int | None = None
    tcpSocket: TCPSocketAction | None = None
    terminationGracePeriodSeconds: int | None = None
    timeoutSeconds: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ResourceQuotaSpec(LazyLoadModel):
    hard: Dict[str, Quantity] | None = None
    scopeSelector: ScopeSelector | None = None
    scopes: List[str] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Secret(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    data: Dict[str, str] | None = None
    immutable: bool | None = None
    kind: ClassVar[str] = 'Secret'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    stringData: Dict[str, str] | None = None
    type: str | None = None
    plural_: ClassVar[str] = 'secrets'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class SecretList(LazyLoadModel):
    items: List[Secret]
    apiVersion: str = 'v1'
    kind: str = 'SecretList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceAccount(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    automountServiceAccountToken: bool | None = None
    imagePullSecrets: List[LocalObjectReference] | None = None
    kind: ClassVar[str] = 'ServiceAccount'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    secrets: List[ObjectReference] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )
    plural_: ClassVar[str] = 'serviceaccounts'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceAccountList(LazyLoadModel):
    items: List[ServiceAccount]
    apiVersion: str = 'v1'
    kind: str = 'ServiceAccountList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceStatus(LazyLoadModel):
    conditions: List[Condition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    loadBalancer: LoadBalancerStatus | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class TopologySpreadConstraint(LazyLoadModel):
    maxSkew: int
    topologyKey: str
    whenUnsatisfiable: str
    labelSelector: LabelSelector | None = None
    matchLabelKeys: List[str] | None = None
    minDomains: int | None = None
    nodeAffinityPolicy: str | None = None
    nodeTaintsPolicy: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class WeightedPodAffinityTerm(LazyLoadModel):
    podAffinityTerm: PodAffinityTerm
    weight: int


@dataclass(slots=True, kw_only=True, frozen=True)
class DownwardAPIProjection(LazyLoadModel):
    items: List[DownwardAPIVolumeFile] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class EnvVar(LazyLoadModel):
    name: str
    value: str | None = None
    valueFrom: EnvVarSource | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class EphemeralVolumeSource(LazyLoadModel):
    volumeClaimTemplate: PersistentVolumeClaimTemplate | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Lifecycle(LazyLoadModel):
    postStart: LifecycleHandler | None = None
    preStop: LifecycleHandler | None = None
    stopSignal: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Node(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'Node'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: NodeSpec | None = None
    status: NodeStatus | None = None
    plural_: ClassVar[str] = 'nodes'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class NodeList(LazyLoadModel):
    items: List[Node]
    apiVersion: str = 'v1'
    kind: str = 'NodeList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolume(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'PersistentVolume'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: PersistentVolumeSpec | None = None
    status: PersistentVolumeStatus | None = None
    plural_: ClassVar[str] = 'persistentvolumes'
    is_namespaced_: ClassVar[bool] = False
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolumeClaim(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'PersistentVolumeClaim'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: PersistentVolumeClaimSpec | None = None
    status: PersistentVolumeClaimStatus | None = None
    plural_: ClassVar[str] = 'persistentvolumeclaims'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolumeClaimList(LazyLoadModel):
    items: List[PersistentVolumeClaim]
    apiVersion: str = 'v1'
    kind: str = 'PersistentVolumeClaimList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class PersistentVolumeList(LazyLoadModel):
    items: List[PersistentVolume]
    apiVersion: str = 'v1'
    kind: str = 'PersistentVolumeList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class PodAffinity(LazyLoadModel):
    preferredDuringSchedulingIgnoredDuringExecution: (
        List[WeightedPodAffinityTerm] | None
    ) = None
    requiredDuringSchedulingIgnoredDuringExecution: List[PodAffinityTerm] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodAntiAffinity(LazyLoadModel):
    preferredDuringSchedulingIgnoredDuringExecution: (
        List[WeightedPodAffinityTerm] | None
    ) = None
    requiredDuringSchedulingIgnoredDuringExecution: List[PodAffinityTerm] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ResourceQuota(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'ResourceQuota'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: ResourceQuotaSpec | None = None
    status: ResourceQuotaStatus | None = None
    plural_: ClassVar[str] = 'resourcequotas'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class ResourceQuotaList(LazyLoadModel):
    items: List[ResourceQuota]
    apiVersion: str = 'v1'
    kind: str = 'ResourceQuotaList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class Service(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'Service'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: ServiceSpec | None = None
    status: ServiceStatus | None = None
    plural_: ClassVar[str] = 'services'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class ServiceList(LazyLoadModel):
    items: List[Service]
    apiVersion: str = 'v1'
    kind: str = 'ServiceList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class VolumeProjection(LazyLoadModel):
    clusterTrustBundle: ClusterTrustBundleProjection | None = None
    configMap: ConfigMapProjection | None = None
    downwardAPI: DownwardAPIProjection | None = None
    podCertificate: PodCertificateProjection | None = None
    secret: SecretProjection | None = None
    serviceAccountToken: ServiceAccountTokenProjection | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Affinity(LazyLoadModel):
    nodeAffinity: NodeAffinity | None = None
    podAffinity: PodAffinity | None = None
    podAntiAffinity: PodAntiAffinity | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Container(LazyLoadModel):
    name: str
    args: List[str] | None = None
    command: List[str] | None = None
    env: List[EnvVar] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )
    envFrom: List[EnvFromSource] | None = None
    image: str | None = None
    imagePullPolicy: str | None = None
    lifecycle: Lifecycle | None = None
    livenessProbe: Probe | None = None
    ports: List[ContainerPort] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'containerPort',
        },
    )
    readinessProbe: Probe | None = None
    resizePolicy: List[ContainerResizePolicy] | None = None
    resources: ResourceRequirements | None = None
    restartPolicy: str | None = None
    restartPolicyRules: List[ContainerRestartRule] | None = None
    securityContext: SecurityContext | None = None
    startupProbe: Probe | None = None
    stdin: bool | None = None
    stdinOnce: bool | None = None
    terminationMessagePath: str | None = None
    terminationMessagePolicy: str | None = None
    tty: bool | None = None
    volumeDevices: List[VolumeDevice] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'devicePath',
        },
    )
    volumeMounts: List[VolumeMount] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'mountPath',
        },
    )
    workingDir: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class EphemeralContainer(LazyLoadModel):
    name: str
    args: List[str] | None = None
    command: List[str] | None = None
    env: List[EnvVar] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )
    envFrom: List[EnvFromSource] | None = None
    image: str | None = None
    imagePullPolicy: str | None = None
    lifecycle: Lifecycle | None = None
    livenessProbe: Probe | None = None
    ports: List[ContainerPort] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'containerPort',
        },
    )
    readinessProbe: Probe | None = None
    resizePolicy: List[ContainerResizePolicy] | None = None
    resources: ResourceRequirements | None = None
    restartPolicy: str | None = None
    restartPolicyRules: List[ContainerRestartRule] | None = None
    securityContext: SecurityContext | None = None
    startupProbe: Probe | None = None
    stdin: bool | None = None
    stdinOnce: bool | None = None
    targetContainerName: str | None = None
    terminationMessagePath: str | None = None
    terminationMessagePolicy: str | None = None
    tty: bool | None = None
    volumeDevices: List[VolumeDevice] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'devicePath',
        },
    )
    volumeMounts: List[VolumeMount] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'mountPath',
        },
    )
    workingDir: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ProjectedVolumeSource(LazyLoadModel):
    defaultMode: int | None = None
    sources: List[VolumeProjection] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Volume(LazyLoadModel):
    name: str
    awsElasticBlockStore: AWSElasticBlockStoreVolumeSource | None = None
    azureDisk: AzureDiskVolumeSource | None = None
    azureFile: AzureFileVolumeSource | None = None
    cephfs: CephFSVolumeSource | None = None
    cinder: CinderVolumeSource | None = None
    configMap: ConfigMapVolumeSource | None = None
    csi: CSIVolumeSource | None = None
    downwardAPI: DownwardAPIVolumeSource | None = None
    emptyDir: EmptyDirVolumeSource | None = None
    ephemeral: EphemeralVolumeSource | None = None
    fc: FCVolumeSource | None = None
    flexVolume: FlexVolumeSource | None = None
    flocker: FlockerVolumeSource | None = None
    gcePersistentDisk: GCEPersistentDiskVolumeSource | None = None
    gitRepo: GitRepoVolumeSource | None = None
    glusterfs: GlusterfsVolumeSource | None = None
    hostPath: HostPathVolumeSource | None = None
    image: ImageVolumeSource | None = None
    iscsi: ISCSIVolumeSource | None = None
    nfs: NFSVolumeSource | None = None
    persistentVolumeClaim: PersistentVolumeClaimVolumeSource | None = None
    photonPersistentDisk: PhotonPersistentDiskVolumeSource | None = None
    portworxVolume: PortworxVolumeSource | None = None
    projected: ProjectedVolumeSource | None = None
    quobyte: QuobyteVolumeSource | None = None
    rbd: RBDVolumeSource | None = None
    scaleIO: ScaleIOVolumeSource | None = None
    secret: SecretVolumeSource | None = None
    storageos: StorageOSVolumeSource | None = None
    vsphereVolume: VsphereVirtualDiskVolumeSource | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class PodSpec(LazyLoadModel):
    activeDeadlineSeconds: int | None = None
    affinity: Affinity | None = None
    automountServiceAccountToken: bool | None = None
    containers: List[Container] = field(
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        }
    )
    dnsConfig: PodDNSConfig | None = None
    dnsPolicy: str | None = None
    enableServiceLinks: bool | None = None
    ephemeralContainers: List[EphemeralContainer] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )
    hostAliases: List[HostAlias] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'ip',
        },
    )
    hostIPC: bool | None = None
    hostNetwork: bool | None = None
    hostPID: bool | None = None
    hostUsers: bool | None = None
    hostname: str | None = None
    hostnameOverride: str | None = None
    imagePullSecrets: List[LocalObjectReference] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )
    initContainers: List[Container] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )
    nodeName: str | None = None
    nodeSelector: Dict[str, str] | None = None
    os: PodOS | None = None
    overhead: Dict[str, Quantity] | None = None
    preemptionPolicy: str | None = None
    priority: int | None = None
    priorityClassName: str | None = None
    readinessGates: List[PodReadinessGate] | None = None
    resourceClaims: List[PodResourceClaim] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge,retainKeys',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )
    resources: ResourceRequirements | None = None
    restartPolicy: str | None = None
    runtimeClassName: str | None = None
    schedulerName: str | None = None
    schedulingGates: List[PodSchedulingGate] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )
    securityContext: PodSecurityContext | None = None
    serviceAccount: str | None = None
    serviceAccountName: str | None = None
    setHostnameAsFQDN: bool | None = None
    shareProcessNamespace: bool | None = None
    subdomain: str | None = None
    terminationGracePeriodSeconds: int | None = None
    tolerations: List[Toleration] | None = None
    topologySpreadConstraints: List[TopologySpreadConstraint] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'topologyKey',
        },
    )
    volumes: List[Volume] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge,retainKeys',
            'x-kubernetes-patch-merge-key': 'name',
        },
    )


@dataclass(slots=True, kw_only=True, frozen=True)
class PodTemplateSpec(LazyLoadModel):
    metadata: ObjectMeta | None = None
    spec: PodSpec | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ReplicationControllerSpec(LazyLoadModel):
    minReadySeconds: int | None = None
    replicas: int | None = 1
    selector: Dict[str, str] | None = None
    template: PodTemplateSpec | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class Pod(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'Pod'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: PodSpec | None = None
    status: PodStatus | None = None
    plural_: ClassVar[str] = 'pods'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class PodList(LazyLoadModel):
    items: List[Pod]
    apiVersion: str = 'v1'
    kind: str = 'PodList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class PodTemplate(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'PodTemplate'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    template: PodTemplateSpec | None = None
    plural_: ClassVar[str] = 'podtemplates'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class PodTemplateList(LazyLoadModel):
    items: List[PodTemplate]
    apiVersion: str = 'v1'
    kind: str = 'PodTemplateList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class ReplicationController(K8sResource):
    apiVersion: ClassVar[str] = 'v1'
    kind: ClassVar[str] = 'ReplicationController'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: ReplicationControllerSpec | None = None
    status: ReplicationControllerStatus | None = None
    plural_: ClassVar[str] = 'replicationcontrollers'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = None
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class ReplicationControllerList(LazyLoadModel):
    items: List[ReplicationController]
    apiVersion: str = 'v1'
    kind: str = 'ReplicationControllerList'
    metadata: ListMeta = field(default_factory=ObjectMeta)
