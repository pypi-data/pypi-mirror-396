# generated by https://github.com/puzl-cloud/kubesdk
#   filename:  apis__apps__v1_openapi.json

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import ClassVar, List, Set

from kube_models.const import *
from kube_models.loader import *
from kube_models.loader import LazyLoadModel
from kube_models.resource import *

from ...apimachinery.pkg.apis.meta.v1 import LabelSelector, ListMeta, ObjectMeta, Time
from ...apimachinery.pkg.runtime import RawExtension
from ...apimachinery.pkg.util.intstr import IntOrString
from ..core.v1 import PersistentVolumeClaim, PodTemplateSpec


@dataclass(slots=True, kw_only=True, frozen=True)
class StatefulSetOrdinals(LazyLoadModel):
    start: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class StatefulSetPersistentVolumeClaimRetentionPolicy(LazyLoadModel):
    whenDeleted: str | None = None
    whenScaled: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class DaemonSetCondition(LazyLoadModel):
    status: str
    type: str
    lastTransitionTime: Time | None = None
    message: str | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class DaemonSetStatus(LazyLoadModel):
    currentNumberScheduled: int
    desiredNumberScheduled: int
    numberMisscheduled: int
    numberReady: int
    collisionCount: int | None = None
    conditions: List[DaemonSetCondition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    numberAvailable: int | None = None
    numberUnavailable: int | None = None
    observedGeneration: int | None = None
    updatedNumberScheduled: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class DeploymentCondition(LazyLoadModel):
    status: str
    type: str
    lastTransitionTime: Time | None = None
    lastUpdateTime: Time | None = None
    message: str | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class DeploymentStatus(LazyLoadModel):
    availableReplicas: int | None = None
    collisionCount: int | None = None
    conditions: List[DeploymentCondition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    observedGeneration: int | None = None
    readyReplicas: int | None = None
    replicas: int | None = None
    terminatingReplicas: int | None = None
    unavailableReplicas: int | None = None
    updatedReplicas: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ReplicaSetCondition(LazyLoadModel):
    status: str
    type: str
    lastTransitionTime: Time | None = None
    message: str | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ReplicaSetStatus(LazyLoadModel):
    replicas: int
    availableReplicas: int | None = None
    conditions: List[ReplicaSetCondition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    fullyLabeledReplicas: int | None = None
    observedGeneration: int | None = None
    readyReplicas: int | None = None
    terminatingReplicas: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class RollingUpdateDaemonSet(LazyLoadModel):
    maxSurge: IntOrString | None = None
    maxUnavailable: IntOrString | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class RollingUpdateDeployment(LazyLoadModel):
    maxSurge: IntOrString | None = None
    maxUnavailable: IntOrString | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class RollingUpdateStatefulSetStrategy(LazyLoadModel):
    maxUnavailable: IntOrString | None = None
    partition: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class StatefulSetCondition(LazyLoadModel):
    status: str
    type: str
    lastTransitionTime: Time | None = None
    message: str | None = None
    reason: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class StatefulSetStatus(LazyLoadModel):
    replicas: int
    availableReplicas: int | None = None
    collisionCount: int | None = None
    conditions: List[StatefulSetCondition] = field(
        default_factory=list,
        metadata={
            'x-kubernetes-patch-strategy': 'merge',
            'x-kubernetes-patch-merge-key': 'type',
        },
    )
    currentReplicas: int | None = None
    currentRevision: str | None = None
    observedGeneration: int | None = None
    readyReplicas: int | None = None
    updateRevision: str | None = None
    updatedReplicas: int | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class StatefulSetUpdateStrategy(LazyLoadModel):
    rollingUpdate: RollingUpdateStatefulSetStrategy | None = None
    type: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class ControllerRevision(K8sResource):
    revision: int
    apiVersion: ClassVar[str] = 'apps/v1'
    data: RawExtension | None = None
    kind: ClassVar[str] = 'ControllerRevision'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    plural_: ClassVar[str] = 'controllerrevisions'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = 'apps'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class ControllerRevisionList(LazyLoadModel):
    items: List[ControllerRevision]
    apiVersion: str = 'apps/v1'
    kind: str = 'ControllerRevisionList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class DaemonSetUpdateStrategy(LazyLoadModel):
    rollingUpdate: RollingUpdateDaemonSet | None = None
    type: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class DeploymentStrategy(LazyLoadModel):
    rollingUpdate: RollingUpdateDeployment | None = None
    type: str | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class DaemonSetSpec(LazyLoadModel):
    selector: LabelSelector
    template: PodTemplateSpec
    minReadySeconds: int | None = None
    revisionHistoryLimit: int | None = None
    updateStrategy: DaemonSetUpdateStrategy | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class DeploymentSpec(LazyLoadModel):
    selector: LabelSelector
    template: PodTemplateSpec
    minReadySeconds: int | None = None
    paused: bool | None = None
    progressDeadlineSeconds: int | None = None
    replicas: int | None = None
    revisionHistoryLimit: int | None = None
    strategy: DeploymentStrategy = field(
        default_factory=dict, metadata={'x-kubernetes-patch-strategy': 'retainKeys'}
    )


@dataclass(slots=True, kw_only=True, frozen=True)
class ReplicaSetSpec(LazyLoadModel):
    selector: LabelSelector
    minReadySeconds: int | None = None
    replicas: int | None = None
    template: PodTemplateSpec | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class StatefulSetSpec(LazyLoadModel):
    selector: LabelSelector
    template: PodTemplateSpec
    minReadySeconds: int | None = None
    ordinals: StatefulSetOrdinals | None = None
    persistentVolumeClaimRetentionPolicy: (
        StatefulSetPersistentVolumeClaimRetentionPolicy | None
    ) = None
    podManagementPolicy: str | None = None
    replicas: int | None = None
    revisionHistoryLimit: int | None = None
    serviceName: str | None = None
    updateStrategy: StatefulSetUpdateStrategy | None = None
    volumeClaimTemplates: List[PersistentVolumeClaim] | None = None


@dataclass(slots=True, kw_only=True, frozen=True)
class DaemonSet(K8sResource):
    apiVersion: ClassVar[str] = 'apps/v1'
    kind: ClassVar[str] = 'DaemonSet'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: DaemonSetSpec | None = None
    status: DaemonSetStatus | None = None
    plural_: ClassVar[str] = 'daemonsets'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = 'apps'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class DaemonSetList(LazyLoadModel):
    items: List[DaemonSet]
    apiVersion: str = 'apps/v1'
    kind: str = 'DaemonSetList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class Deployment(K8sResource):
    apiVersion: ClassVar[str] = 'apps/v1'
    kind: ClassVar[str] = 'Deployment'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: DeploymentSpec | None = None
    status: DeploymentStatus | None = None
    plural_: ClassVar[str] = 'deployments'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = 'apps'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class DeploymentList(LazyLoadModel):
    items: List[Deployment]
    apiVersion: str = 'apps/v1'
    kind: str = 'DeploymentList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class ReplicaSet(K8sResource):
    apiVersion: ClassVar[str] = 'apps/v1'
    kind: ClassVar[str] = 'ReplicaSet'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: ReplicaSetSpec | None = None
    status: ReplicaSetStatus | None = None
    plural_: ClassVar[str] = 'replicasets'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = 'apps'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class ReplicaSetList(LazyLoadModel):
    items: List[ReplicaSet]
    apiVersion: str = 'apps/v1'
    kind: str = 'ReplicaSetList'
    metadata: ListMeta = field(default_factory=ObjectMeta)


@dataclass(slots=True, kw_only=True, frozen=True)
class StatefulSet(K8sResource):
    apiVersion: ClassVar[str] = 'apps/v1'
    kind: ClassVar[str] = 'StatefulSet'
    metadata: ObjectMeta = field(default_factory=ObjectMeta)
    spec: StatefulSetSpec | None = None
    status: StatefulSetStatus | None = None
    plural_: ClassVar[str] = 'statefulsets'
    is_namespaced_: ClassVar[bool] = True
    group_: ClassVar[Optional[str]] = 'apps'
    patch_strategies_: ClassVar[set[PatchRequestType]] = {
        'application/apply-patch+cbor',
        'application/apply-patch+yaml',
        'application/json-patch+json',
        'application/merge-patch+json',
        'application/strategic-merge-patch+json',
    }


@dataclass(slots=True, kw_only=True, frozen=True)
class StatefulSetList(LazyLoadModel):
    items: List[StatefulSet]
    apiVersion: str = 'apps/v1'
    kind: str = 'StatefulSetList'
    metadata: ListMeta = field(default_factory=ObjectMeta)
