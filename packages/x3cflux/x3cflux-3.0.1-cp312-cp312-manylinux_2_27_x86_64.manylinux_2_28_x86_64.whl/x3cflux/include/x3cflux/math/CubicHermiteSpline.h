// This work is derived from the cubic hermite spline interpolator
// implemented in the boost math library (since v1.73).
//
// Copyright Nick Thompson, 2020
// Use, modification and distribution are subject to the
// Boost Software License, Version 1.0.
//
// Boost Software License - Version 1.0 - August 17th, 2003
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#ifndef X3CFLUX_CUBICHERMITESPLINE_H
#define X3CFLUX_CUBICHERMITESPLINE_H

#include "MathError.h"
#include "NumericTypes.h"
#include <util/Logging.h>
#include <vector>

namespace x3cflux {

/// \brief Hermite spline interpolator with cubic degree polynomials
/// \tparam FunctionValueType type of function value (Eigen vector or matrix)
template <typename FunctionValueType> class CubicHermiteSpline {
  public:
    using FunctionValue = FunctionValueType;
    using Scalar = typename FunctionValue::Scalar;
    using ElementValue = std::conditional_t<std::is_same<FunctionValue, Matrix<Scalar>>::value, Vector<Scalar>, Scalar>;

  private:
    std::vector<Real> places_;
    std::vector<FunctionValue> functionValues_;
    std::vector<FunctionValue> derivativeValues_;

  public:
    CubicHermiteSpline();

    /// Create cubic hermite spline interpolation.
    /// \param places function evaluation places in ascending order
    /// \param functionValues function values at evaluation places
    /// \param derivativeValues function derivatives at evaluation places
    CubicHermiteSpline(std::vector<Real> places, const std::vector<FunctionValue> &functionValues,
                       const std::vector<FunctionValue> &derivativeValues);

    /// \return function evaluation places
    const std::vector<Real> &getPlaces() const;

    /// \return function values at evaluation places
    const std::vector<FunctionValue> &getFunctionValues() const;

    /// \return function derivatives at evaluation places
    const std::vector<FunctionValue> &getDerivativeValues() const;

    /// Interpolate function in a given place.
    /// \param place evaluation place
    /// \return interpolated function value
    FunctionValue operator()(Real place) const;

    /// Interpolate element function in a given place.
    /// \param place evaluation place
    /// \param elemIndex index of element
    /// \return interpolated element function value
    ElementValue operator()(Real place, Index elemIndex) const;

    /// Interpolate function in a given place.
    /// \param place evaluation place
    /// \return interpolated function value
    FunctionValue evaluate(Real place) const;

    /// Interpolate element function in a given place.
    /// \param place evaluation place
    /// \param elemIndex index of element
    /// \return interpolated element function value
    ElementValue evaluateElement(Real place, Index elemIndex) const;

    /// Interpolate derivative of function in a given place.
    /// \param place evaluation place
    /// \return interpolated derivative value
    FunctionValue evaluateDerivative(Real place) const;

    /// \return domain of interpolation
    std::pair<Real, Real> getDomain() const;

  private:
    template <typename ValueType>
    static ValueType computeCubicSpline(const ValueType &y0, const ValueType &y1, const ValueType &dy0,
                                        const ValueType &dy1, Real place, Real x0, Real x1) {
        auto dx = x1 - x0;
        auto t = (place - x0) / dx;

        return (1 - t) * (1 - t) * (y0 * (1 + 2 * t) + dy0 * (place - x0)) +
               t * t * (y1 * (3 - 2 * t) + dx * dy1 * (t - 1));
    }

    template <typename ValueType>
    static ValueType computeCubicSplineDerivative(const ValueType &y0, const ValueType &y1, const ValueType &dy0,
                                                  const ValueType &dy1, Real place, Real x0, Real x1) {
        auto dx = x1 - x0;

        auto a0 = (y1 - y0 - dy0 * dx) / (dx * dx);
        auto a1 = (dy1 - dy0) / (2 * dx);
        auto b1 = 3 * a0 - 2 * a1;
        auto b0 = 2 * (a1 - a0) / dx;

        return dy0 + 2 * b0 * (place - x0) + 3 * b1 * (place - x0) * (place - x0);
    }

    static Real get(const RealVector &value, Index elemIndex);

    static RealVector get(const RealMatrix &value, Index elemIndex);
};

} // namespace x3cflux

#ifndef COMPILE_TEMPLATES
#include "CubicHermiteSpline.tpp"
#endif

#endif // X3CFLUX_CUBICHERMITESPLINE_H
