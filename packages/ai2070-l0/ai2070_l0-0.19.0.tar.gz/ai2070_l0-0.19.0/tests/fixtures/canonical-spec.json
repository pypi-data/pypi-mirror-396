{
  "$schema": "./canonical-spec.schema.json",
  "version": "1.0.0",
  "description": "Canonical specification for L0 runtime behavior. Used to reconcile TypeScript and Python implementations.",

  "errorHandling": {
    "L0Error": {
      "description": "Enhanced error class with recovery context",
      "properties": {
        "name": { "type": "string", "value": "L0Error" },
        "message": {
          "type": "string",
          "description": "Human-readable error message"
        },
        "code": {
          "type": "L0ErrorCode",
          "description": "Error code for programmatic handling"
        },
        "category": {
          "type": "ErrorCategory",
          "description": "Computed from code via getErrorCategory()"
        },
        "timestamp": {
          "type": "number",
          "description": "Unix timestamp when error occurred"
        },
        "context": {
          "type": "L0ErrorContext",
          "description": "Recovery context information"
        }
      },
      "computedProperties": {
        "hasCheckpoint": {
          "type": "boolean",
          "description": "True if checkpoint exists and has length > 0",
          "computation": "context.checkpoint !== undefined && context.checkpoint.length > 0"
        }
      },
      "toJSON": {
        "description": "Serialization format for logging/transport",
        "shape": {
          "name": "string",
          "code": "L0ErrorCode",
          "category": "ErrorCategory",
          "message": "string",
          "timestamp": "number",
          "hasCheckpoint": "boolean",
          "checkpoint": "string | undefined",
          "tokenCount": "number | undefined",
          "modelRetryCount": "number | undefined",
          "networkRetryCount": "number | undefined",
          "fallbackIndex": "number | undefined",
          "metadata": "Record<string, unknown> | undefined",
          "context": "Record<string, unknown> | undefined"
        },
        "notes": [
          "metadata contains internal state (retry counters, violation details, etc.)",
          "context contains user-provided context from L0Options.context"
        ]
      }
    },

    "L0ErrorCodes": {
      "description": "All possible error codes",
      "values": {
        "STREAM_ABORTED": "User/signal aborted the stream",
        "INITIAL_TOKEN_TIMEOUT": "No token received within initialToken timeout",
        "INTER_TOKEN_TIMEOUT": "Gap between tokens exceeded interToken timeout",
        "ZERO_OUTPUT": "Model returned empty/whitespace-only response",
        "GUARDRAIL_VIOLATION": "Recoverable guardrail violation (triggers retry)",
        "FATAL_GUARDRAIL_VIOLATION": "Non-recoverable guardrail violation (halts)",
        "INVALID_STREAM": "Stream result not iterable and no adapter matched",
        "ALL_STREAMS_EXHAUSTED": "Primary and all fallback streams failed",
        "NETWORK_ERROR": "Network connectivity issue",
        "DRIFT_DETECTED": "Semantic drift detected in output",
        "ADAPTER_NOT_FOUND": "No adapter found for stream type",
        "FEATURE_NOT_ENABLED": "Feature requires explicit opt-in"
      }
    },

    "ErrorCategory": {
      "description": "Error categories for routing decisions",
      "values": {
        "network": "Connection drops, DNS, SSL, fetch errors",
        "transient": "Temporary issues like timeouts",
        "content": "Content quality issues (guardrails, drift, zero output)",
        "provider": "Provider-side issues (aborted, exhausted)",
        "internal": "L0 internal errors (invalid stream, adapter not found)"
      },
      "codeToCategory": {
        "NETWORK_ERROR": "network",
        "INITIAL_TOKEN_TIMEOUT": "transient",
        "INTER_TOKEN_TIMEOUT": "transient",
        "GUARDRAIL_VIOLATION": "content",
        "FATAL_GUARDRAIL_VIOLATION": "content",
        "DRIFT_DETECTED": "content",
        "ZERO_OUTPUT": "content",
        "INVALID_STREAM": "internal",
        "ADAPTER_NOT_FOUND": "internal",
        "FEATURE_NOT_ENABLED": "internal",
        "STREAM_ABORTED": "provider",
        "ALL_STREAMS_EXHAUSTED": "provider"
      }
    },

    "L0ErrorContext": {
      "description": "Context passed to L0Error constructor",
      "shape": {
        "code": { "type": "L0ErrorCode", "required": true },
        "checkpoint": {
          "type": "string",
          "required": false,
          "description": "Current checkpoint content for recovery"
        },
        "tokenCount": {
          "type": "number",
          "required": false,
          "description": "Tokens processed before error"
        },
        "contentLength": {
          "type": "number",
          "required": false,
          "description": "Accumulated content length"
        },
        "modelRetryCount": {
          "type": "number",
          "required": false,
          "description": "Model retry attempts made"
        },
        "networkRetryCount": {
          "type": "number",
          "required": false,
          "description": "Network retries (don't count toward limit)"
        },
        "fallbackIndex": {
          "type": "number",
          "required": false,
          "description": "Current fallback index (0 = primary)"
        },
        "metadata": {
          "type": "Record<string, unknown>",
          "required": false,
          "description": "Additional internal context"
        },
        "context": {
          "type": "Record<string, unknown>",
          "required": false,
          "description": "User-provided context"
        }
      }
    }
  },

  "monitoring": {
    "observabilityEvents": {
      "description": "Events emitted via EventDispatcher for monitoring/observability",
      "baseShape": {
        "type": {
          "type": "EventType",
          "description": "Event type identifier",
          "required": true
        },
        "ts": {
          "type": "number",
          "description": "Unix timestamp",
          "required": true
        },
        "streamId": {
          "type": "string",
          "description": "UUID v7 for session correlation",
          "required": true
        },
        "context": {
          "type": "Record<string, unknown>",
          "description": "User-provided context (deeply cloned, immutable)",
          "required": false
        }
      },
      "events": {
        "SESSION_START": {
          "description": "Emitted exactly ONCE at session start (anchor event)",
          "fields": [
            {
              "name": "attempt",
              "type": "number",
              "required": true,
              "description": "Always 1 for session start"
            },
            {
              "name": "isRetry",
              "type": "boolean",
              "required": true,
              "description": "Always false for session start"
            },
            {
              "name": "isFallback",
              "type": "boolean",
              "required": true,
              "description": "Always false for session start"
            }
          ]
        },
        "STREAM_INIT": {
          "description": "Emitted when stream iteration begins",
          "fields": []
        },
        "STREAM_READY": {
          "description": "Emitted when connection is established and ready to emit",
          "fields": []
        },
        "SESSION_END": {
          "description": "Hard end-of-stream marker",
          "fields": []
        },
        "SESSION_SUMMARY": {
          "description": "Final session summary for replay",
          "fields": [
            {
              "name": "tokenCount",
              "type": "number",
              "required": true,
              "description": "Total tokens processed"
            },
            {
              "name": "startTs",
              "type": "number",
              "required": true,
              "description": "Session start timestamp"
            },
            {
              "name": "endTs",
              "type": "number",
              "required": true,
              "description": "Session end timestamp"
            },
            {
              "name": "driftDetected",
              "type": "boolean",
              "required": true,
              "description": "Whether drift was detected"
            },
            {
              "name": "guardrailViolations",
              "type": "number",
              "required": true,
              "description": "Count of guardrail violations"
            },
            {
              "name": "fallbackDepth",
              "type": "number",
              "required": true,
              "description": "Maximum fallback index used"
            },
            {
              "name": "retryCount",
              "type": "number",
              "required": true,
              "description": "Total retry attempts"
            },
            {
              "name": "checkpointsCreated",
              "type": "number",
              "required": true,
              "description": "Number of checkpoints saved"
            }
          ]
        },
        "ADAPTER_WRAP_START": {
          "description": "Emitted when adapter detection/wrapping starts",
          "fields": [
            {
              "name": "streamType",
              "type": "string",
              "required": true,
              "description": "typeof stream"
            },
            {
              "name": "adapterId",
              "type": "string",
              "required": false,
              "description": "Adapter identifier if known at start"
            }
          ]
        },
        "ADAPTER_DETECTED": {
          "description": "Emitted when an adapter is matched to the stream",
          "fields": [
            {
              "name": "adapterId",
              "type": "string",
              "required": true,
              "description": "Adapter identifier"
            }
          ]
        },
        "ADAPTER_WRAP_END": {
          "description": "Emitted when adapter wrapping completes",
          "fields": [
            {
              "name": "adapterId",
              "type": "string",
              "required": true,
              "description": "Adapter identifier"
            }
          ]
        },
        "TIMEOUT_START": {
          "description": "Emitted when a timeout timer starts",
          "fields": [
            {
              "name": "timeoutType",
              "type": "string",
              "required": true,
              "enum": ["initial", "inter"],
              "description": "Type of timeout"
            },
            {
              "name": "configuredMs",
              "type": "number",
              "required": true,
              "description": "Configured timeout in milliseconds"
            }
          ]
        },
        "TIMEOUT_RESET": {
          "description": "Emitted when inter-token timeout is reset",
          "fields": [
            {
              "name": "timeoutType",
              "type": "string",
              "required": true,
              "enum": ["initial", "inter"],
              "description": "Type of timeout being reset"
            },
            {
              "name": "configuredMs",
              "type": "number",
              "required": true,
              "description": "Configured timeout in milliseconds"
            },
            {
              "name": "tokenIndex",
              "type": "number",
              "required": true,
              "description": "Index of token that triggered reset"
            }
          ]
        },
        "TIMEOUT_TRIGGERED": {
          "description": "Emitted when timeout fires",
          "fields": [
            {
              "name": "timeoutType",
              "type": "string",
              "required": true,
              "enum": ["initial", "inter"],
              "description": "Type of timeout"
            },
            {
              "name": "elapsedMs",
              "type": "number",
              "required": true,
              "description": "Time elapsed before timeout"
            },
            {
              "name": "configuredMs",
              "type": "number",
              "required": true,
              "description": "Configured timeout in milliseconds"
            }
          ]
        },
        "NETWORK_ERROR": {
          "description": "Emitted when a network error occurs",
          "fields": [
            {
              "name": "error",
              "type": "string",
              "required": true,
              "description": "Error message"
            },
            {
              "name": "code",
              "type": "string",
              "required": false,
              "description": "Error code if available"
            },
            {
              "name": "retryable",
              "type": "boolean",
              "required": true,
              "description": "Whether the error is retryable"
            }
          ]
        },
        "NETWORK_RECOVERY": {
          "description": "Emitted when network recovers after error",
          "fields": [
            {
              "name": "attemptCount",
              "type": "number",
              "required": true,
              "description": "Number of recovery attempts"
            },
            {
              "name": "durationMs",
              "type": "number",
              "required": true,
              "description": "Time to recover in milliseconds"
            }
          ]
        },
        "CONNECTION_DROPPED": {
          "description": "Emitted when connection is dropped",
          "fields": [
            {
              "name": "reason",
              "type": "string",
              "required": true,
              "description": "Reason for connection drop"
            }
          ]
        },
        "CONNECTION_RESTORED": {
          "description": "Emitted when connection is restored",
          "fields": [
            {
              "name": "durationMs",
              "type": "number",
              "required": true,
              "description": "Time connection was down in milliseconds"
            }
          ]
        },
        "ABORT_REQUESTED": {
          "description": "Emitted when abort is requested",
          "fields": [
            {
              "name": "source",
              "type": "string",
              "required": true,
              "enum": ["user", "timeout", "error"],
              "description": "Source of abort request"
            }
          ]
        },
        "ABORT_COMPLETED": {
          "description": "Emitted when stream abort completes",
          "fields": [
            {
              "name": "tokenCount",
              "type": "number",
              "required": true,
              "description": "Tokens processed before abort"
            },
            {
              "name": "contentLength",
              "type": "number",
              "required": true,
              "description": "Content length at abort"
            }
          ]
        },
        "TOOL_REQUESTED": {
          "description": "Emitted when model requests tool execution",
          "fields": [
            {
              "name": "toolName",
              "type": "string",
              "required": true,
              "description": "Name of the tool"
            },
            {
              "name": "toolCallId",
              "type": "string",
              "required": true,
              "description": "Unique tool call identifier"
            },
            {
              "name": "arguments",
              "type": "Record<string, unknown>",
              "required": true,
              "description": "Tool arguments"
            }
          ]
        },
        "TOOL_START": {
          "description": "Emitted when tool execution starts",
          "fields": [
            {
              "name": "toolCallId",
              "type": "string",
              "required": true,
              "description": "Unique tool call identifier"
            },
            {
              "name": "toolName",
              "type": "string",
              "required": true,
              "description": "Name of the tool"
            }
          ]
        },
        "TOOL_RESULT": {
          "description": "Emitted when tool execution returns a result",
          "fields": [
            {
              "name": "toolCallId",
              "type": "string",
              "required": true,
              "description": "Unique tool call identifier"
            },
            {
              "name": "result",
              "type": "unknown",
              "required": true,
              "description": "Tool execution result"
            },
            {
              "name": "durationMs",
              "type": "number",
              "required": true,
              "description": "Execution duration in milliseconds"
            }
          ]
        },
        "TOOL_ERROR": {
          "description": "Emitted when tool execution fails",
          "fields": [
            {
              "name": "toolCallId",
              "type": "string",
              "required": true,
              "description": "Unique tool call identifier"
            },
            {
              "name": "error",
              "type": "string",
              "required": true,
              "description": "Error message"
            },
            {
              "name": "durationMs",
              "type": "number",
              "required": true,
              "description": "Execution duration in milliseconds"
            }
          ]
        },
        "TOOL_COMPLETED": {
          "description": "Emitted when tool execution completes (success or error)",
          "fields": [
            {
              "name": "toolCallId",
              "type": "string",
              "required": true,
              "description": "Unique tool call identifier"
            },
            {
              "name": "status",
              "type": "string",
              "required": true,
              "enum": ["success", "error"],
              "description": "Completion status"
            }
          ]
        },
        "GUARDRAIL_PHASE_START": {
          "description": "Emitted when guardrail phase begins",
          "fields": [
            {
              "name": "phase",
              "type": "string",
              "required": true,
              "enum": ["pre", "post"],
              "description": "Guardrail phase"
            },
            {
              "name": "ruleCount",
              "type": "number",
              "required": true,
              "description": "Number of rules to evaluate"
            }
          ]
        },
        "GUARDRAIL_RULE_START": {
          "description": "Emitted before each guardrail rule evaluation",
          "fields": [
            {
              "name": "index",
              "type": "number",
              "required": true,
              "description": "Rule index"
            },
            {
              "name": "ruleId",
              "type": "string",
              "required": true,
              "description": "Rule identifier"
            },
            {
              "name": "callbackId",
              "type": "string",
              "required": true,
              "description": "Unique callback identifier for correlation"
            }
          ]
        },
        "GUARDRAIL_RULE_RESULT": {
          "description": "Emitted after guardrail rule evaluation",
          "fields": [
            {
              "name": "index",
              "type": "number",
              "required": true,
              "description": "Rule index"
            },
            {
              "name": "ruleId",
              "type": "string",
              "required": true,
              "description": "Rule identifier"
            },
            {
              "name": "passed",
              "type": "boolean",
              "required": true,
              "description": "Whether the rule passed"
            },
            {
              "name": "violation",
              "type": "GuardrailViolation",
              "required": false,
              "description": "Violation details if failed"
            }
          ]
        },
        "GUARDRAIL_RULE_END": {
          "description": "Emitted after guardrail rule completes",
          "fields": [
            {
              "name": "index",
              "type": "number",
              "required": true,
              "description": "Rule index"
            },
            {
              "name": "ruleId",
              "type": "string",
              "required": true,
              "description": "Rule identifier"
            },
            {
              "name": "passed",
              "type": "boolean",
              "required": true,
              "description": "Whether the rule passed"
            },
            {
              "name": "callbackId",
              "type": "string",
              "required": true,
              "description": "Unique callback identifier for correlation"
            },
            {
              "name": "durationMs",
              "type": "number",
              "required": true,
              "description": "Rule evaluation duration in milliseconds"
            }
          ]
        },
        "GUARDRAIL_PHASE_END": {
          "description": "Emitted when guardrail phase completes",
          "fields": [
            {
              "name": "phase",
              "type": "string",
              "required": true,
              "enum": ["pre", "post"],
              "description": "Guardrail phase"
            },
            {
              "name": "passed",
              "type": "boolean",
              "required": true,
              "description": "Whether all rules passed"
            },
            {
              "name": "violations",
              "type": "GuardrailViolation[]",
              "required": true,
              "description": "List of violations"
            },
            {
              "name": "durationMs",
              "type": "number",
              "required": true,
              "description": "Phase evaluation duration in milliseconds"
            }
          ]
        },
        "GUARDRAIL_CALLBACK_START": {
          "description": "Emitted when async guardrail callback starts",
          "fields": [
            {
              "name": "callbackId",
              "type": "string",
              "required": true,
              "description": "Callback identifier"
            },
            {
              "name": "index",
              "type": "number",
              "required": true,
              "description": "Rule index"
            },
            {
              "name": "ruleId",
              "type": "string",
              "required": true,
              "description": "Rule identifier"
            }
          ]
        },
        "GUARDRAIL_CALLBACK_END": {
          "description": "Emitted when async guardrail callback completes",
          "fields": [
            {
              "name": "callbackId",
              "type": "string",
              "required": true,
              "description": "Callback identifier"
            },
            {
              "name": "index",
              "type": "number",
              "required": true,
              "description": "Rule index"
            },
            {
              "name": "ruleId",
              "type": "string",
              "required": true,
              "description": "Rule identifier"
            },
            {
              "name": "durationMs",
              "type": "number",
              "required": true,
              "description": "Callback duration in milliseconds"
            },
            {
              "name": "success",
              "type": "boolean",
              "required": true,
              "description": "Whether callback succeeded"
            },
            {
              "name": "error",
              "type": "string",
              "required": false,
              "description": "Error message if failed"
            }
          ]
        },
        "DRIFT_CHECK_RESULT": {
          "description": "Emitted with drift check results",
          "fields": [
            {
              "name": "detected",
              "type": "boolean",
              "required": true,
              "description": "Whether drift was detected"
            },
            {
              "name": "score",
              "type": "number",
              "required": true,
              "description": "Drift score"
            },
            {
              "name": "metrics",
              "type": "Record<string, unknown>",
              "required": true,
              "description": "Drift metrics"
            },
            {
              "name": "threshold",
              "type": "number",
              "required": true,
              "description": "Detection threshold"
            }
          ]
        },
        "DRIFT_CHECK_SKIPPED": {
          "description": "Emitted when drift check is skipped",
          "fields": [
            {
              "name": "reason",
              "type": "string",
              "required": true,
              "description": "Reason for skipping"
            }
          ]
        },
        "CHECKPOINT_SAVED": {
          "description": "Emitted when checkpoint is saved",
          "fields": [
            {
              "name": "checkpoint",
              "type": "string",
              "required": true,
              "description": "Checkpoint content"
            },
            {
              "name": "tokenCount",
              "type": "number",
              "required": true,
              "description": "Tokens at checkpoint"
            }
          ]
        },
        "RESUME_START": {
          "description": "Emitted when resuming from checkpoint",
          "fields": [
            {
              "name": "checkpoint",
              "type": "string",
              "required": true,
              "description": "Checkpoint content"
            },
            {
              "name": "tokenCount",
              "type": "number",
              "required": true,
              "description": "Tokens at checkpoint"
            }
          ]
        },

        "CONTINUATION_START": {
          "description": "Emitted when continuation from checkpoint begins",
          "fields": [
            {
              "name": "checkpoint",
              "type": "string",
              "required": true,
              "description": "Checkpoint content"
            },
            {
              "name": "tokenCount",
              "type": "number",
              "required": true,
              "description": "Tokens at checkpoint"
            }
          ]
        },
        "ATTEMPT_START": {
          "description": "Emitted for retry attempts only (not initial, not fallbacks)",
          "fields": [
            {
              "name": "attempt",
              "type": "number",
              "required": true,
              "description": "Attempt number (2+)"
            },
            {
              "name": "isRetry",
              "type": "boolean",
              "required": true,
              "description": "Always true for retry attempts"
            },
            {
              "name": "isFallback",
              "type": "boolean",
              "required": true,
              "description": "Always false for retry attempts"
            }
          ]
        },
        "RETRY_START": {
          "description": "Emitted when retry loop begins",
          "fields": [
            {
              "name": "maxAttempts",
              "type": "number",
              "required": true,
              "description": "Maximum retry attempts"
            }
          ]
        },
        "RETRY_ATTEMPT": {
          "description": "Emitted before ATTEMPT_START when retry is triggered",
          "fields": [
            {
              "name": "attempt",
              "type": "number",
              "required": true,
              "description": "Current attempt number"
            },
            {
              "name": "maxAttempts",
              "type": "number",
              "required": true,
              "description": "Maximum retry attempts"
            },
            {
              "name": "reason",
              "type": "string",
              "required": true,
              "description": "Reason for retry"
            },
            {
              "name": "delayMs",
              "type": "number",
              "required": true,
              "description": "Delay before retry in milliseconds"
            }
          ]
        },
        "RETRY_END": {
          "description": "Emitted when retry loop completes successfully",
          "fields": [
            {
              "name": "attempt",
              "type": "number",
              "required": true,
              "description": "Final attempt number"
            },
            {
              "name": "success",
              "type": "boolean",
              "required": true,
              "description": "Always true for successful completion"
            }
          ]
        },
        "RETRY_GIVE_UP": {
          "description": "Emitted when all retry attempts exhausted",
          "fields": [
            {
              "name": "attempt",
              "type": "number",
              "required": true,
              "description": "Final attempt number"
            },
            {
              "name": "maxAttempts",
              "type": "number",
              "required": true,
              "description": "Maximum retry attempts"
            },
            {
              "name": "reason",
              "type": "string",
              "required": true,
              "description": "Reason for giving up"
            }
          ]
        },
        "FALLBACK_START": {
          "description": "Emitted when switching to fallback stream",
          "fields": [
            {
              "name": "fromIndex",
              "type": "number",
              "required": true,
              "description": "Previous stream index"
            },
            {
              "name": "toIndex",
              "type": "number",
              "required": true,
              "description": "New stream index"
            }
          ]
        },
        "FALLBACK_MODEL_SELECTED": {
          "description": "Emitted when a fallback model is selected",
          "fields": [
            {
              "name": "index",
              "type": "number",
              "required": true,
              "description": "Fallback index"
            },
            {
              "name": "reason",
              "type": "string",
              "required": true,
              "description": "Reason for fallback"
            }
          ]
        },
        "FALLBACK_END": {
          "description": "Emitted when fallback sequence completes",
          "fields": [
            {
              "name": "success",
              "type": "boolean",
              "required": true,
              "description": "Whether fallback succeeded"
            },
            {
              "name": "finalIndex",
              "type": "number",
              "required": true,
              "description": "Final fallback index used"
            }
          ]
        },

        "ERROR": {
          "description": "Emitted when error occurs",
          "fields": [
            {
              "name": "error",
              "type": "string",
              "required": true,
              "description": "Error message"
            },
            {
              "name": "errorCode",
              "type": "string",
              "required": false,
              "description": "Error code if available"
            },
            {
              "name": "failureType",
              "type": "FailureType",
              "required": true,
              "description": "Classification of failure"
            },
            {
              "name": "recoveryStrategy",
              "type": "RecoveryStrategy",
              "required": true,
              "description": "How L0 will recover"
            },
            {
              "name": "policy",
              "type": "RecoveryPolicy",
              "required": true,
              "description": "Recovery policy configuration"
            }
          ]
        },
        "COMPLETE": {
          "description": "Emitted on successful completion",
          "fields": [
            {
              "name": "tokenCount",
              "type": "number",
              "required": true,
              "description": "Total tokens processed"
            },
            {
              "name": "contentLength",
              "type": "number",
              "required": true,
              "description": "Total content length"
            },
            {
              "name": "state",
              "type": "L0State",
              "required": false,
              "description": "Final L0 state"
            }
          ]
        },
        "STRUCTURED_PARSE_START": {
          "description": "Emitted when structured output parsing begins",
          "fields": [
            {
              "name": "contentLength",
              "type": "number",
              "required": true,
              "description": "Content length to parse"
            }
          ]
        },
        "STRUCTURED_PARSE_END": {
          "description": "Emitted when structured output parsing completes",
          "fields": [
            {
              "name": "success",
              "type": "boolean",
              "required": true,
              "description": "Whether parsing succeeded"
            },
            {
              "name": "durationMs",
              "type": "number",
              "required": true,
              "description": "Parse duration in milliseconds"
            }
          ]
        },
        "STRUCTURED_PARSE_ERROR": {
          "description": "Emitted when structured output parsing fails",
          "fields": [
            {
              "name": "error",
              "type": "string",
              "required": true,
              "description": "Error message"
            },
            {
              "name": "contentPreview",
              "type": "string",
              "required": false,
              "description": "Preview of content that failed to parse"
            }
          ]
        },
        "STRUCTURED_VALIDATION_START": {
          "description": "Emitted when schema validation begins",
          "fields": [
            {
              "name": "schemaName",
              "type": "string",
              "required": false,
              "description": "Schema name if available"
            }
          ]
        },
        "STRUCTURED_VALIDATION_END": {
          "description": "Emitted when schema validation completes",
          "fields": [
            {
              "name": "valid",
              "type": "boolean",
              "required": true,
              "description": "Whether validation passed"
            },
            {
              "name": "durationMs",
              "type": "number",
              "required": true,
              "description": "Validation duration in milliseconds"
            }
          ]
        },
        "STRUCTURED_VALIDATION_ERROR": {
          "description": "Emitted when schema validation fails",
          "fields": [
            {
              "name": "errors",
              "type": "string[]",
              "required": true,
              "description": "Validation errors"
            }
          ]
        },
        "STRUCTURED_AUTO_CORRECT_START": {
          "description": "Emitted when auto-correction begins",
          "fields": [
            {
              "name": "errorCount",
              "type": "number",
              "required": true,
              "description": "Number of errors to correct"
            }
          ]
        },
        "STRUCTURED_AUTO_CORRECT_END": {
          "description": "Emitted when auto-correction completes",
          "fields": [
            {
              "name": "success",
              "type": "boolean",
              "required": true,
              "description": "Whether corrections succeeded"
            },
            {
              "name": "correctionsMade",
              "type": "number",
              "required": true,
              "description": "Number of corrections made"
            },
            {
              "name": "durationMs",
              "type": "number",
              "required": true,
              "description": "Correction duration in milliseconds"
            }
          ]
        }
      }
    },

    "failureTypes": {
      "description": "Root cause classification for errors",
      "values": {
        "network": "Connection drops, DNS, SSL, fetch errors",
        "model": "Model refused, content filter, bad response",
        "tool": "Tool execution failed",
        "timeout": "Initial token or inter-token timeout",
        "abort": "User or signal abort",
        "zero_output": "Empty response from model",
        "unknown": "Unclassified error"
      }
    },

    "recoveryStrategies": {
      "description": "What L0 does after an error",
      "values": {
        "retry": "Will retry the same stream",
        "fallback": "Will try next fallback stream",
        "continue": "Will continue despite error (non-fatal)",
        "halt": "Will stop, no recovery possible"
      }
    }
  },

  "lifecycleInvariants": {
    "description": "Critical invariants that must hold in both TS and Python",
    "invariants": [
      {
        "id": "session-start-once",
        "rule": "SESSION_START is emitted exactly ONCE per session",
        "rationale": "Anchor event for entire session, regardless of retries/fallbacks"
      },
      {
        "id": "attempt-start-retries-only",
        "rule": "ATTEMPT_START is only emitted for retries (attempt >= 2)",
        "rationale": "Initial attempt gets SESSION_START, fallbacks get FALLBACK_START"
      },
      {
        "id": "fallback-not-attempt",
        "rule": "FALLBACK_START is emitted for fallbacks, not ATTEMPT_START",
        "rationale": "Fallbacks are a different flow from retries"
      },
      {
        "id": "retry-precedes-attempt",
        "rule": "RETRY_ATTEMPT always precedes ATTEMPT_START",
        "rationale": "RETRY_ATTEMPT announces intent, ATTEMPT_START triggers onStart"
      },
      {
        "id": "timestamps-monotonic",
        "rule": "Event timestamps are monotonically increasing",
        "rationale": "Enables correct ordering during replay"
      },
      {
        "id": "stream-id-consistent",
        "rule": "streamId is consistent across all events in a session",
        "rationale": "Enables correlation of all events for a single request"
      },
      {
        "id": "context-immutable",
        "rule": "User context is deeply cloned and frozen",
        "rationale": "Prevents mutation of context after session starts"
      },
      {
        "id": "context-propagated",
        "rule": "User context appears in all observability events",
        "rationale": "Enables correlation with user's request tracking"
      }
    ]
  },

  "callbacks": {
    "description": "Callback signatures and when they fire",
    "callbacks": {
      "onStart": {
        "signature": "(attempt: number, isRetry: boolean, isFallback: boolean) => void",
        "parameters": [
          {
            "name": "attempt",
            "type": "number",
            "required": true,
            "description": "1-based attempt number"
          },
          {
            "name": "isRetry",
            "type": "boolean",
            "required": true,
            "description": "True if this is a retry attempt"
          },
          {
            "name": "isFallback",
            "type": "boolean",
            "required": true,
            "description": "True if this is a fallback stream"
          }
        ],
        "triggeredBy": ["SESSION_START", "ATTEMPT_START", "FALLBACK_START"],
        "notes": [
          "Called for initial attempt (1, false, false)",
          "Called for retry attempts (N, true, false)",
          "Called for fallback streams (1, false, true)"
        ]
      },
      "onComplete": {
        "signature": "(state: L0State) => void",
        "parameters": [
          {
            "name": "state",
            "type": "L0State",
            "required": true,
            "description": "Final state of the stream",
            "shape": {
              "content": {
                "type": "string",
                "description": "Accumulated content"
              },
              "tokenCount": {
                "type": "number",
                "description": "Total tokens processed"
              },
              "checkpoint": {
                "type": "string",
                "description": "Last checkpoint content"
              },
              "modelRetryCount": {
                "type": "number",
                "description": "Model retry attempts made"
              },
              "networkRetryCount": {
                "type": "number",
                "description": "Network retry attempts made"
              },
              "fallbackIndex": {
                "type": "number",
                "description": "Current fallback stream index (0 = primary)"
              }
            }
          }
        ],
        "triggeredBy": ["COMPLETE"],
        "notes": ["Called once on successful completion"]
      },
      "onError": {
        "signature": "(error: L0Error, willRetry: boolean, willFallback: boolean) => void",
        "parameters": [
          {
            "name": "error",
            "type": "L0Error",
            "required": true,
            "description": "The error that occurred",
            "shape": {
              "message": {
                "type": "string",
                "description": "Human-readable error message"
              },
              "code": {
                "type": "L0ErrorCode",
                "description": "Error code for programmatic handling"
              },
              "category": {
                "type": "ErrorCategory",
                "description": "Error category (network, transient, content, provider, internal)"
              }
            }
          },
          {
            "name": "willRetry",
            "type": "boolean",
            "required": true,
            "description": "True if L0 will retry after this error"
          },
          {
            "name": "willFallback",
            "type": "boolean",
            "required": true,
            "description": "True if L0 will fallback after this error"
          }
        ],
        "triggeredBy": ["ERROR"],
        "notes": ["Called for each error, flags indicate recovery path"]
      },
      "onRetry": {
        "signature": "(attempt: number, reason: string) => void",
        "parameters": [
          {
            "name": "attempt",
            "type": "number",
            "required": true,
            "description": "The retry attempt number (1-based, where 1 = first retry)"
          },
          {
            "name": "reason",
            "type": "string",
            "required": true,
            "description": "Human-readable reason for the retry"
          }
        ],
        "triggeredBy": ["RETRY_ATTEMPT"],
        "notes": ["Called before each retry attempt"]
      },
      "onFallback": {
        "signature": "(index: number, reason: string) => void",
        "parameters": [
          {
            "name": "index",
            "type": "number",
            "required": true,
            "description": "0-based fallback stream index"
          },
          {
            "name": "reason",
            "type": "string",
            "required": true,
            "description": "Human-readable reason for fallback"
          }
        ],
        "triggeredBy": ["FALLBACK_START"],
        "notes": ["index is 0-based fallback stream index"]
      },
      "onCheckpoint": {
        "signature": "(checkpoint: string, tokenCount: number) => void",
        "parameters": [
          {
            "name": "checkpoint",
            "type": "string",
            "required": true,
            "description": "The checkpoint content for resumption"
          },
          {
            "name": "tokenCount",
            "type": "number",
            "required": true,
            "description": "Tokens processed at checkpoint time"
          }
        ],
        "triggeredBy": ["CHECKPOINT_SAVED"],
        "notes": ["Called at configured intervals when continuation enabled"]
      },
      "onResume": {
        "signature": "(checkpoint: string, tokenCount: number) => void",
        "parameters": [
          {
            "name": "checkpoint",
            "type": "string",
            "required": true,
            "description": "The checkpoint content being resumed from"
          },
          {
            "name": "tokenCount",
            "type": "number",
            "required": true,
            "description": "Tokens that were processed before the checkpoint"
          }
        ],
        "triggeredBy": ["RESUME_START"],
        "notes": ["Called when resuming from checkpoint after error"]
      },
      "onAbort": {
        "signature": "(tokenCount: number, contentLength: number) => void",
        "parameters": [
          {
            "name": "tokenCount",
            "type": "number",
            "required": true,
            "description": "Tokens processed before abort"
          },
          {
            "name": "contentLength",
            "type": "number",
            "required": true,
            "description": "Content length at abort time"
          }
        ],
        "triggeredBy": ["ABORT_COMPLETED"],
        "notes": ["Called when stream is aborted"]
      },
      "onTimeout": {
        "signature": "(type: 'initial' | 'inter', elapsedMs: number) => void",
        "parameters": [
          {
            "name": "type",
            "type": "string",
            "enum": ["initial", "inter"],
            "required": true,
            "description": "Timeout type: 'initial' for first token, 'inter' for between tokens"
          },
          {
            "name": "elapsedMs",
            "type": "number",
            "required": true,
            "description": "Milliseconds elapsed before timeout"
          }
        ],
        "triggeredBy": ["TIMEOUT_TRIGGERED"],
        "notes": ["Called when timeout occurs"]
      },
      "onViolation": {
        "signature": "(violation: GuardrailViolation) => void",
        "parameters": [
          {
            "name": "violation",
            "type": "GuardrailViolation",
            "required": true,
            "description": "Details of the guardrail violation",
            "shape": {
              "ruleId": {
                "type": "string",
                "description": "Identifier of the violated rule"
              },
              "message": {
                "type": "string",
                "description": "Human-readable violation message"
              },
              "severity": {
                "type": "string",
                "enum": ["warning", "error", "fatal"],
                "description": "Violation severity"
              },
              "metadata": {
                "type": "Record<string, unknown>",
                "required": false,
                "description": "Additional violation context"
              }
            }
          }
        ],
        "triggeredBy": ["GUARDRAIL_RULE_RESULT (when passed=false)"],
        "notes": ["Called for each guardrail violation"]
      },
      "onDrift": {
        "signature": "(types: string[], confidence?: number) => void",
        "parameters": [
          {
            "name": "types",
            "type": "string[]",
            "required": true,
            "description": "Array of detected drift type identifiers"
          },
          {
            "name": "confidence",
            "type": "number",
            "required": false,
            "description": "Confidence score of the drift detection (0-1)"
          }
        ],
        "triggeredBy": ["DRIFT_CHECK_RESULT"],
        "notes": [
          "Called when semantic drift is detected in output (when detected=true)"
        ]
      },
      "onToolCall": {
        "signature": "(toolName: string, toolCallId: string, args: Record<string, unknown>) => void",
        "parameters": [
          {
            "name": "toolName",
            "type": "string",
            "required": true,
            "description": "Name of the tool being called"
          },
          {
            "name": "toolCallId",
            "type": "string",
            "required": true,
            "description": "Unique identifier for the tool call"
          },
          {
            "name": "args",
            "type": "Record<string, unknown>",
            "required": true,
            "description": "Arguments passed to the tool"
          }
        ],
        "triggeredBy": ["TOOL_REQUESTED"],
        "notes": ["Called when a tool call is detected in the stream"]
      }
    }
  },

  "toolCallSchemaValidation": {
    "description": "Schema validation for tool calls in L0 runtime",
    "toolCallShape": {
      "description": "Required shape for a valid tool call",
      "properties": {
        "name": {
          "type": "string",
          "required": true,
          "description": "Tool name identifier"
        },
        "arguments": {
          "type": "Record<string, unknown>",
          "required": true,
          "description": "Tool arguments as key-value pairs"
        },
        "id": {
          "type": "string",
          "required": false,
          "description": "Optional unique identifier for the tool call"
        }
      }
    },
    "argumentValidation": {
      "description": "Rules for validating tool arguments against schema",
      "rules": [
        {
          "id": "required-fields",
          "rule": "All required fields in the tool schema must be present",
          "errorCode": "MISSING_REQUIRED_ARGUMENT"
        },
        {
          "id": "type-checking",
          "rule": "Argument values must match their declared types",
          "errorCode": "INVALID_ARGUMENT_TYPE"
        },
        {
          "id": "enum-validation",
          "rule": "Enum values must be one of the allowed options",
          "errorCode": "INVALID_ENUM_VALUE"
        },
        {
          "id": "pattern-matching",
          "rule": "String arguments with patterns must match the regex",
          "errorCode": "PATTERN_MISMATCH"
        },
        {
          "id": "range-validation",
          "rule": "Numeric arguments must be within min/max bounds",
          "errorCode": "VALUE_OUT_OF_RANGE"
        },
        {
          "id": "array-validation",
          "rule": "Array arguments must satisfy minItems/maxItems constraints",
          "errorCode": "ARRAY_LENGTH_INVALID"
        },
        {
          "id": "no-extra-properties",
          "rule": "When additionalProperties is false, extra fields are rejected",
          "errorCode": "UNEXPECTED_ARGUMENT"
        }
      ]
    },
    "validationErrorShape": {
      "description": "Shape of validation error returned when tool call is invalid",
      "properties": {
        "code": {
          "type": "ToolCallValidationErrorCode",
          "required": true,
          "description": "Error code from argumentValidation rules"
        },
        "message": {
          "type": "string",
          "required": true,
          "description": "Human-readable error message"
        },
        "path": {
          "type": "string[]",
          "required": true,
          "description": "JSON path to the invalid field (e.g., ['arguments', 'count'])"
        },
        "expected": {
          "type": "string",
          "required": false,
          "description": "Expected type or value"
        },
        "received": {
          "type": "string",
          "required": false,
          "description": "Actual type or value received"
        }
      }
    },
    "schemaFormats": {
      "description": "Supported schema formats for tool definitions",
      "formats": {
        "jsonSchema": {
          "description": "JSON Schema draft-07 compatible schemas",
          "supportedKeywords": [
            "type",
            "properties",
            "required",
            "additionalProperties",
            "enum",
            "const",
            "pattern",
            "format",
            "minimum",
            "maximum",
            "exclusiveMinimum",
            "exclusiveMaximum",
            "minLength",
            "maxLength",
            "minItems",
            "maxItems",
            "items",
            "oneOf",
            "anyOf",
            "allOf",
            "$ref"
          ]
        }
      }
    }
  },

  "networkErrorTypes": {
    "description": "Network error classification for retry decisions",
    "types": {
      "connection_dropped": {
        "detection": [
          "connection dropped",
          "connection closed",
          "connection lost",
          "econnreset",
          "broken pipe"
        ],
        "retryable": true,
        "countsTowardLimit": false
      },
      "fetch_error": {
        "detection": [
          "TypeError with 'fetch'",
          "failed to fetch",
          "network request failed"
        ],
        "retryable": true,
        "countsTowardLimit": false
      },
      "econnreset": {
        "detection": [
          "econnreset",
          "connection reset by peer",
          "code: ECONNRESET"
        ],
        "retryable": true,
        "countsTowardLimit": false
      },
      "econnrefused": {
        "detection": [
          "econnrefused",
          "connection refused",
          "code: ECONNREFUSED"
        ],
        "retryable": true,
        "countsTowardLimit": false
      },
      "dns_error": {
        "detection": ["dns", "enotfound", "host not found", "getaddrinfo"],
        "retryable": true,
        "countsTowardLimit": false
      },
      "ssl_error": {
        "detection": ["ssl", "tls", "certificate", "handshake", "self signed"],
        "retryable": false,
        "countsTowardLimit": false
      },
      "timeout": {
        "detection": ["timeout", "timed out", "deadline exceeded", "etimedout"],
        "retryable": true,
        "countsTowardLimit": false
      }
    },
    "notes": [
      "Network errors don't count toward retry limit by default",
      "SSL errors are not retryable (configuration issue)",
      "Detection is case-insensitive substring matching"
    ]
  }
}
