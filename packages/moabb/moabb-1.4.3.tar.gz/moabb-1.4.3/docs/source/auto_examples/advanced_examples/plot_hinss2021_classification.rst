
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/advanced_examples/plot_hinss2021_classification.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_advanced_examples_plot_hinss2021_classification.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_advanced_examples_plot_hinss2021_classification.py:


================================
Hinss2021 classification example
================================

This example shows how to use the Hinss2021 dataset
with the resting state paradigm.

In this example, we aim to determine the most effective channel selection strategy
for the :class:`moabb.datasets.Hinss2021` dataset.
The pipelines under consideration are:

- `Xdawn`
- Electrode selection based on time epochs data
- Electrode selection based on covariance matrices

.. GENERATED FROM PYTHON SOURCE LINES 18-47

.. code-block:: Python


    # License: BSD (3-clause)

    import warnings

    import numpy as np
    import seaborn as sns
    from matplotlib import pyplot as plt
    from pyriemann.channelselection import ElectrodeSelection
    from pyriemann.estimation import Covariances
    from pyriemann.spatialfilters import Xdawn
    from pyriemann.tangentspace import TangentSpace
    from sklearn.base import TransformerMixin
    from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA
    from sklearn.pipeline import make_pipeline

    from moabb import set_log_level
    from moabb.datasets import Hinss2021
    from moabb.evaluations import CrossSessionEvaluation
    from moabb.paradigms import RestingStateToP300Adapter


    # Suppressing future and runtime warnings for cleaner output
    warnings.simplefilter(action="ignore", category=FutureWarning)
    warnings.simplefilter(action="ignore", category=RuntimeWarning)

    set_log_level("info")



.. GENERATED FROM PYTHON SOURCE LINES 48-53

Create util transformer
-----------------------

Let's create a scikit transformer mixin, that will
select electrodes based on the covariance information

.. GENERATED FROM PYTHON SOURCE LINES 53-80

.. code-block:: Python



    class EpochSelectChannel(TransformerMixin):
        """Select channels based on covariance information."""

        def __init__(self, n_chan, cov_est):
            self._chs_idx = None
            self.n_chan = n_chan
            self.cov_est = cov_est

        def fit(self, X, _y=None):
            # Get the covariances of the channels for each epoch.
            covs = Covariances(estimator=self.cov_est).fit_transform(X)
            # Get the average covariance between the channels
            m = np.mean(covs, axis=0)
            # Select the `n_chan` channels having the maximum covariances.
            indices = np.unravel_index(
                np.argpartition(m, -self.n_chan, axis=None)[-self.n_chan :], m.shape
            )
            # We will keep only these channels for the transform step.
            self._chs_idx = np.unique(indices)
            return self

        def transform(self, X):
            return X[:, self._chs_idx, :]



.. GENERATED FROM PYTHON SOURCE LINES 81-87

Initialization Process
----------------------

1) Define the experimental paradigm object (RestingState)
2) Load the datasets
3) Select a subset of subjects and specific events for analysis

.. GENERATED FROM PYTHON SOURCE LINES 87-103

.. code-block:: Python


    # Here we define the mne events for the RestingState paradigm.
    events = dict(easy=2, diff=3)
    # The paradigm is adapted to the P300 paradigm.
    paradigm = RestingStateToP300Adapter(events=events, tmin=0, tmax=0.5)
    # We define a list with the dataset to use
    datasets = [Hinss2021()]

    # To reduce the computation time in the example, we will only use the
    # first two subjects.
    n__subjects = 2
    title = "Datasets: "
    for dataset in datasets:
        title = title + " " + dataset.code
        dataset.subject_list = dataset.subject_list[:n__subjects]


.. GENERATED FROM PYTHON SOURCE LINES 104-108

Create Pipelines
----------------

Pipelines must be a dict of scikit-learning pipeline transformer.

.. GENERATED FROM PYTHON SOURCE LINES 108-128

.. code-block:: Python


    pipelines = {}

    pipelines["Xdawn+Cov+TS+LDA"] = make_pipeline(
        Xdawn(nfilter=4), Covariances(estimator="lwf"), TangentSpace(), LDA()
    )

    pipelines["Cov+ElSel+TS+LDA"] = make_pipeline(
        Covariances(estimator="lwf"), ElectrodeSelection(nelec=8), TangentSpace(), LDA()
    )

    # Pay attention here that the channel selection took place before computing the covariances:
    # It is done on time epochs.
    pipelines["ElSel+Cov+TS+LDA"] = make_pipeline(
        EpochSelectChannel(n_chan=8, cov_est="lwf"),
        Covariances(estimator="lwf"),
        TangentSpace(),
        LDA(),
    )


.. GENERATED FROM PYTHON SOURCE LINES 129-133

Run evaluation
----------------

Compare the pipeline using a cross session evaluation.

.. GENERATED FROM PYTHON SOURCE LINES 133-143

.. code-block:: Python


    # Here should be cross-session
    evaluation = CrossSessionEvaluation(
        paradigm=paradigm,
        datasets=datasets,
        overwrite=False,
    )

    results = evaluation.process(pipelines)


.. GENERATED FROM PYTHON SOURCE LINES 144-146

Here, with the ElSel+Cov+TS+LDA pipeline, we reduce the computation time
in approximately 8 times to the Cov+ElSel+TS+LDA pipeline.

.. GENERATED FROM PYTHON SOURCE LINES 146-150

.. code-block:: Python


    print("Averaging the session performance:")
    print(results.groupby("pipeline").mean("score")[["score", "time"]])


.. GENERATED FROM PYTHON SOURCE LINES 151-155

Plot Results
-------------

Here, we plot the results to compare two pipelines

.. GENERATED FROM PYTHON SOURCE LINES 155-178

.. code-block:: Python



    fig, ax = plt.subplots(facecolor="white", figsize=[8, 4])

    sns.stripplot(
        data=results,
        y="score",
        x="pipeline",
        ax=ax,
        jitter=True,
        alpha=0.5,
        zorder=1,
        palette="Set1",
    )
    sns.pointplot(data=results, y="score", x="pipeline", ax=ax, palette="Set1").set(
        title=title
    )

    ax.set_ylabel("ROC AUC")
    ax.set_ylim(0.3, 1)

    plt.show()


.. GENERATED FROM PYTHON SOURCE LINES 179-184

Key Observations:
-----------------
- `Xdawn` is not ideal for the resting state paradigm. This is due to its specific design for Event-Related Potential (ERP).
- Electrode selection strategy based on covariance matrices demonstrates less variability and typically yields better performance.
- However, this strategy is more time-consuming compared to the simpler electrode selection based on time epoch data.

**Estimated memory usage:**  0 MB


.. _sphx_glr_download_auto_examples_advanced_examples_plot_hinss2021_classification.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_hinss2021_classification.ipynb <plot_hinss2021_classification.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_hinss2021_classification.py <plot_hinss2021_classification.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_hinss2021_classification.zip <plot_hinss2021_classification.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
