"""These functions are used by the plot backend to cut pieces out
 of triangulated and gridded meshes given a `bbox`. This keeps 
 irrelavent data from effecting the colormap generated by countor plots."""

from __future__ import annotations
import numpy as np

#[ ] Make a parent function for tri functions with kwarg mode={"cpu","gpu","auto"} that passes to proper function.
def tri_bbox_prep(mesh: np.ndarray,
                   bbox: tuple[float,float,float,float],
                   vals: np.ndarray=None
                   ) -> np.ndarray | tuple[np.ndarray,np.ndarray]:
    """Frontend for `trigridtrim()` that widens `bbox` used to trim the mesh to prevent whitespace in the plotted `bbox`.

    Parameters
    ----------
    
    mesh : matplotlib.tri.Triangulation
        The triangulated mesh that will be plotted.
    
    bbox : tuple
        typing.Iterable containing x0,y0,x1,y1 where point 0 is the bottem left and point 1 is the top right of the bounding box.
    
    vals : np.ndarray, optional
        Values that will be plotted.

    Returns
    -------
    np.ndarray | tuple[np.ndarray,np.ndarray]
        The `mesh`, and `vals` if passed, with the adjustedbbox.
    
    """
    xnodes=mesh.x
    ynodes=mesh.y
    xwide=(np.max(xnodes)-np.min(xnodes))*.01
    ywide=(np.max(ynodes)-np.min(ynodes))*.01
    adjust=np.minimum(xwide,ywide)
    adjustedbbox=(bbox[0]-adjust,bbox[1]-adjust,bbox[2]+adjust,bbox[3]+adjust)
    trimmed=trigridtrim(mesh.triangles,np.vstack((xnodes,ynodes)).transpose(),adjustedbbox,vals=vals)
    if np.any(vals):
        mesh.triangles=trimmed[0]
        return mesh,trimmed[1]
    else: 
        mesh.triangles=trimmed
        return mesh
    

def trigridtrim(elemcomps: np.ndarray,nodes: np.ndarray,bbox: list,vals: np.ndarray=None,returnindex: bool=False) -> np.ndarray | list[np.ndarray]:
    """Funtion to cut out a portion of the elements from a unstructured triangular mesh.
    
    Parameters
    ----------
    elemcomps : np.ndarray
        (m,3) array with indexes to the nodes in the element.

    nodes : np.ndarray
        x and y coordinates of mesh with shape (n,2).

    bbox : Iterable
       Iterable containing x0,y0,x1,y1 where point 0 is the bottem left and point 1 is the top right of the bounding box.

    vals : np.ndarray, optional
        Z values of `nodes`.

    returnindex : bool
        Return the indexs used to cut the original element array.

    Returns
    -------
    np.ndarray | list
        Returns the trimmed array of `elements` or list of arrays based on kwargs.

    Note
    ----
    This differs from `trigridcut()` since the `nodes` are not removed. 

    """ 
    
    barycenters=np.array([(nodes[elemcomps[:,0],0]+nodes[elemcomps[:,1],0]+nodes[elemcomps[:,2],0])/3,(nodes[elemcomps[:,0],1]+nodes[elemcomps[:,1],1]+nodes[elemcomps[:,2],1])/3])
    bbox_x=np.where(np.logical_and(barycenters[0]>=bbox[0],barycenters[0]<=bbox[2]))
    bbox_y=np.where(np.logical_and(barycenters[1]>=bbox[1],barycenters[1]<=bbox[3]))
    bboxindex=np.intersect1d(bbox_x,bbox_y)
    
    if not np.any(vals)  and not returnindex: return elemcomps[bboxindex]
    bboxelem=elemcomps[bboxindex]
    returnlist=[bboxelem]

    if np.any(vals): 
        nodeindex=np.unique(bboxelem)
        returnlist.append(vals[nodeindex])
    if returnindex: returnlist.append(bboxindex)
    return returnlist


#Creates a smaller grid from a larger grid.
def trigridcut(nodes: np.ndarray,bbox: list,elemcomps: np.ndarray=None,vals: np.ndarray=None,returnindex: bool=False) -> np.ndarray | list[np.ndarray]:
    """Funtion to cut out a portion of the x and y coordinates from a unstructured triangular.
    
    Parameters
    ----------
    nodes : np.ndarray
        x and y coordinates of mesh with shape (n,2).
    
    bbox : Iterable
       Iterable containing x0,y0,x1,y1 where point 0 is the bottem left and point 1 is the top right of the bounding box.

    vals : np.ndarray, optional
        Z values of `nodes`.

    elemcomps : np.ndarray, optional
        (m,3) array with indexes to the `nodes` in the element. If present, `elemcomps` will be trimmed and and renumbered to match new node indexes.

    returnindex : bool
        Return the indexs used to cut the original element array.

    Returns
    -------
    np.ndarray | list
        Returns the trimmed array of `nodes` or list of arrays based on kwargs.

    Note
    ----
    This differs from `trigridtrim()` since the `nodes` themselves are removed. 

    """  

    #Finds the index of the nodes that are between the desired x and y individually then finds the intersection of the two sets.
    #The np.logical_and() is limited to three inputs.
    bbox_x=np.where(np.logical_and(nodes[:,0]>=bbox[0],nodes[:,0]<=bbox[2]))
    bbox_y=np.where(np.logical_and(nodes[:,1]>=bbox[1],nodes[:,1]<=bbox[3]))
    bboxindex=np.intersect1d(bbox_x,bbox_y)

    if not np.any(vals) and not np.any(elemcomps) and not returnindex: return nodes[bboxindex,0:3]

    returnlist=[nodes[bboxindex,0:3]]
    
    if np.any(elemcomps):
        #Creates a booleen matrix for elemcomps and then creates a new elementcomp matrix where all three elements are  of elemcomps true.
        elemcompbool=np.isin(elemcomps,bboxindex)
        bboxelemcomp=elemcomps[elemcompbool[:,0]&elemcompbool[:,1]&elemcompbool[:,2]]
        
        #Because bboxelemcomp is cut out from elemcomps, its indexes are not the same as bboxindex. 
        #np.nditer is used to iterate through bboxelcomp and sets them to the index of bboxindex to reference them properly. 
        #This does not work if the bbox has no nodes. I do not care.
        indexdict={ str(orgindex): i for i,orgindex in enumerate(bboxindex) }
        with np.nditer(bboxelemcomp,op_flags=["readwrite"]) as tec:
            for node in tec:
                node[...]=indexdict[str(node)] 
    
        returnlist.append(bboxelemcomp)

    if np.any(vals): returnlist.append(vals[bboxindex])
    if returnindex: returnlist.append(bboxindex)
    return returnlist

def meshgridcut(mesh: np.ndarray ,bbox: list,vals:np.ndarray=None) -> np.ndarray | tuple[np.ndarray,np.ndarray]:
    """Cuts out the x and y from a np.meshgrid. Used for stwave data.
    
    Parameters
    ----------
    mesh : np.ndarray
        Mesh generated from `np.meshgrid` where `mesh[0]` is the x coordinates and `mesh[1]` is the y coordinates.
    
    bbox : Iterable
       Iterable containing x0,y0,x1,y1 where point 0 is the bottem left and point 1 is the top right of the bounding box.

    vals : np.ndarray, optional
        Z values of nodes.

    Returns
    -------
    np.ndarray | tuple
        Returns the trimmed array of nodes or list of arrays based on kwargs.

    """
    
    bbox_x=np.logical_and(mesh[0]>=bbox[0],mesh[0]<=bbox[2])
    bbox_y=np.logical_and(mesh[1]>=bbox[1],mesh[1]<=bbox[3])
    bboxindex=np.logical_and(bbox_x,bbox_y)

    #Traverses through the x direction and then deletes all non needed columns from the array.
    dele=np.empty(0).astype(int)
    for i in range(len(bboxindex)):
        if np.any(bboxindex[i])!=True:
            dele=np.append(dele,i)

    bboxindex=np.delete(bboxindex,dele,axis=0)
    bboxmesh_x=np.delete(mesh[0],dele,axis=0)
    bboxmesh_y=np.delete(mesh[1],dele,axis=0)
    if np.any(vals): bboxvals=np.delete(vals,dele,axis=0)

    dele=np.empty(0).astype(int)

    #Traverses through the y direction and then deletes all non needed rows from the array.
    for i in range(np.shape(bboxindex)[1]):
        if np.any(bboxindex[:,i])!=True:
            dele=np.append(dele,i)
    
    bboxmesh_x=np.delete(bboxmesh_x,dele,axis=1)
    bboxmesh_y=np.delete(bboxmesh_y,dele,axis=1)
    if np.any(vals): bboxvals=np.delete(bboxvals,dele,axis=1)
    bboxmesh=np.array([bboxmesh_x,bboxmesh_y])

    return (bboxmesh,bboxvals) if np.any(vals) else bboxmesh