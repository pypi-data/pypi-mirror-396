import logging
from typing import Any, Dict

from baicai_base.agents.graphs.nodes import BaseNode
from baicai_base.utils.data import extract_code, get_saved_pickle_path, preview_data
from langchain_core.runnables import RunnableConfig

from baicai_dev.agents.graphs.action_builder.state import ActionState
from baicai_dev.agents.roles.ml import action_coder


class ActionCoderNode(BaseNode):
    """
    Node for coding actions using code generated by an LLM.
    """

    def __init__(self, llm: Any, logger: logging.Logger = None) -> None:
        """
        Initialize the ActionCoderNode with a language model and an optional logger.

        Args:
            llm: The language model to be used for action coding.
            logger: Optional logger for logging information.
        """
        super().__init__(llm=llm, logger=logger)
        self.runnable = action_coder(self.llm)

    def __call__(self, state: ActionState, config: RunnableConfig) -> Dict[str, Any]:
        """
        Execute the node logic.

        Args:
            state (ActionState): The current state of the action process.
            config (RunnableConfig): Configuration details for the node.

        Returns:
            dict: Updated state after execution.
        """
        # Extract and initialize state components with defaults for potential None values
        messages = state.get("messages", [])
        actions = state.get("actions", [])

        selected_metric = config["configurable"]["selected_metric"]
        columns = config["configurable"]["cols"]
        target = config["configurable"]["target"]
        name = config["configurable"]["name"]
        avg_param = config["configurable"]["avg_param"]
        clean_data_path = get_saved_pickle_path(folder=None, name=name, file_prefix="baseline")

        try:
            cleaned_data_info = preview_data(clean_data_path, target=target)["data_info"]
        except (KeyError, FileNotFoundError) as e:
            cleaned_data_info = config["configurable"]["brief_data_info"]
            self.logger.warning(f"### Warning: No cleaned data info found. Using brief data info instead. {e}")

        self.logger.info("## Action Coder")

        self.solution = self.runnable.invoke(
            {
                "clean_data_path": clean_data_path,
                "selected_metric": selected_metric,
                "actions": actions,
                "columns": columns,
                "target": target,
                "cleaned_data_info": cleaned_data_info,
                "messages": messages,
                "name": name,
                "avg_param": avg_param,
            }
        )

        code_block = extract_code(self.solution.content)
        self.logger.info(f"### Code generated: \n{self.solution.content}")

        codes = code_block.split("# New action starts")
        if len(codes[1:]) != len(actions):
            self.logger.info(
                f"The length of generated codes is {len(codes[1:])} and the length of actions is {len(actions)}"
            )
            self.logger.info(f"The generated codes are: \n{codes}")
            self.logger.info(f"The actions are: \n{actions}")
            raise ValueError("The number of actions and codes does not match.")

        for action, code in zip(actions, codes[1:], strict=False):
            action.update({"code": code})

        self.logger.debug(f"### Codes generated: \n{codes}")

        return {
            "actions": actions,
            "load_data_code": {"code": codes[0]},
        }
