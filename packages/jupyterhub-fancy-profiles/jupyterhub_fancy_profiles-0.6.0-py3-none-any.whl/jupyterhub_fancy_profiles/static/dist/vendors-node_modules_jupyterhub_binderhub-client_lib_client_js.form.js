"use strict";
(self["webpackChunkjupyterhub_fancy_profiles"] = self["webpackChunkjupyterhub_fancy_profiles"] || []).push([["vendors-node_modules_jupyterhub_binderhub-client_lib_client_js"],{

/***/ "./node_modules/@jupyterhub/binderhub-client/lib/client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@jupyterhub/binderhub-client/lib/client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BinderRepository: () => (/* binding */ BinderRepository)
/* harmony export */ });
/* harmony import */ var _microsoft_fetch_event_source__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @microsoft/fetch-event-source */ "./node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js");
/* harmony import */ var event_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! event-iterator */ "./node_modules/event-iterator/lib/dom.js");



function _getXSRFToken() {
  // from @jupyterlab/services
  // https://github.com/jupyterlab/jupyterlab/blob/69223102d717f3d3e9f976d32e657a4e2456e85d/packages/services/src/contents/index.ts#L1178-L1184
  let cookie = "";
  try {
    cookie = document.cookie;
  } catch (e) {
    // e.g. SecurityError in case of CSP Sandbox
    return null;
  }
  // extracts the value of the cookie named `_xsrf`
  // by picking up everything between `_xsrf=` and the next semicolon or end-of-line
  // `\b` ensures word boundaries, so it doesn't pick up `something_xsrf=`...
  const xsrfTokenMatch = cookie.match("\\b_xsrf=([^;]*)\\b");
  if (xsrfTokenMatch) {
    return xsrfTokenMatch[1];
  }
  return null;
}

/* throw this to close the event stream */
class EventStreamClose extends Error {}
/* throw this to close the event stream */
class EventStreamRetry extends Error {}

/**
 * Build (and optionally launch) a repository by talking to a BinderHub API endpoint
 */
class BinderRepository {
  /**
   *
   * @param {string} providerSpec Spec of the form <provider>/<repo>/<ref> to pass to the binderhub API.
   * @param {URL} buildEndpointUrl API URL of the build endpoint to talk to
   * @param {Object} [options] - optional arguments
   * @param {string} [options.buildToken] Optional JWT based build token if this binderhub installation requires using build tokens
   * @param {boolean} [options.buildOnly] Opt out of launching built image by default by passing `build_only` param
   * @param {string} [options.apiToken] Optional Bearer token for authenticating requests
   */
  constructor(providerSpec, buildEndpointUrl, options) {
    const { apiToken, buildToken, buildOnly } = options || {};

    this.providerSpec = providerSpec;
    // Make sure that buildEndpointUrl is a real URL - this ensures hostname is properly set
    if (!(buildEndpointUrl instanceof URL)) {
      throw new TypeError(
        `buildEndpointUrl must be a URL object, got ${buildEndpointUrl} instead`,
      );
    }
    // We make a copy here so we don't modify the passed in URL object
    this.buildEndpointUrl = new URL(buildEndpointUrl);
    // The binderHub API is path based, so the buildEndpointUrl must have a trailing slash. We add
    // it if it is not passed in here to us.
    if (!this.buildEndpointUrl.pathname.endsWith("/")) {
      this.buildEndpointUrl.pathname += "/";
    }

    // The actual URL we'll make a request to build this particular providerSpec
    this.buildUrl = new URL(this.providerSpec, this.buildEndpointUrl);
    if (buildToken) {
      this.buildUrl.searchParams.append("build_token", buildToken);
    }

    if (buildOnly) {
      this.buildUrl.searchParams.append("build_only", "true");
    }
    this.apiToken = apiToken;

    this.eventIteratorQueue = null;
    this.abortSignal = null;
  }

  /**
   * Call the binderhub API and yield responses as they come in
   *
   * Returns an Async iterator yielding each item returned by the
   * server API.
   *
   * @typedef Line
   * @prop {string} [phase] The phase the build is currently in. One of: building, built, fetching, launching, ready, unknown, waiting
   * @prop {string} [message] Human readable message to display to the user. Extra newlines must *not* be added
   * @prop {string} [imageName] (only with built) Full name of the image that has been built
   * @prop {string} [binder_launch_host] (only with phase=ready) The host this binderhub API request was serviced by.
   *                                     Could be different than the host the request was made to in federated cases
   * @prop {string} [binder_request] (only with phase=ready) Request used to construct this image, of form v2/<provider>/<repo>/<ref>
   * @prop {string} [binder_persistent_request] (only with phase=ready) Same as binder_request, but <ref> is fully resolved
   * @prop {string} [binder_ref_url] (only with phase=ready) A URL to the repo provider where the repo can be browsed
   * @prop {string} [image] (only with phase=ready) Full name of the image that has been built
   * @prop {string} [token] (only with phase=ready) Token to use to authenticate with jupyter server at url
   * @prop {string} [url] (only with phase=ready) URL where a jupyter server has been started
   * @prop {string} [repo_url] (only with phase=ready) URL of the repository that is ready to be launched
   *
   * @returns {AsyncIterable<Line>} An async iterator yielding responses from the API as they come in
   */
  fetch() {
    const headers = {};
    this.abortController = new AbortController();

    if (this.apiToken && this.apiToken.length > 0) {
      headers["Authorization"] = `Bearer ${this.apiToken}`;
    } else {
      const xsrf = _getXSRFToken();
      if (xsrf) {
        headers["X-Xsrftoken"] = xsrf;
      }
    }
    // setTimeout(() => this.close(), 1000);
    return new event_iterator__WEBPACK_IMPORTED_MODULE_0__.EventIterator((queue) => {
      this.eventIteratorQueue = queue;
      (0,_microsoft_fetch_event_source__WEBPACK_IMPORTED_MODULE_1__.fetchEventSource)(this.buildUrl, {
        headers,
        // signal used for closing
        signal: this.abortController.signal,
        // openWhenHidden leaves connection open (matches default)
        // otherwise fetch-event closes connections,
        // which would be nice if our javascript handled restarting messages better
        openWhenHidden: true,
        onopen: (response) => {
          if (response.ok) {
            return; // everything's good
          } else if (
            response.status >= 400 &&
            response.status < 500 &&
            response.status !== 429
          ) {
            queue.push({
              phase: "failed",
              message: `Failed to connect to event stream: ${response.status} - ${response.text}\n`,
            });
            throw new EventStreamClose();
          } else {
            queue.push({
              phase: "unknown",
              message: `Error connecting to event stream, retrying: ${response.status} - ${response.text}\n`,
            });
            throw new EventStreamRetry();
          }
        },

        onclose: () => {
          if (!queue.isStopped) {
            // close called before queue finished
            queue.push({
              phase: "failed",
              message: `Event stream closed unexpectedly\n`,
            });
            queue.stop();
            // throw new EventStreamClose();
          }
        },
        onerror: (error) => {
          console.log("Event stream error", error);
          if (error.name === "EventStreamRetry") {
            // if we don't re-raise, connection will be retried;
            queue.push({
              phase: "unknown",
              message: `Error in event stream: ${error}\n`,
            });
            return;
          }
          if (
            !(error.name === "EventStreamClose" || error.name === "AbortError")
          ) {
            // errors _other_ than EventStreamClose get displayed
            queue.push({
              phase: "failed",
              message: `Error in event stream: ${error}\n`,
            });
          }
          queue.stop();
          // need to rethrow to prevent reconnection
          throw error;
        },

        onmessage: (event) => {
          if (!event.data || event.data === "") {
            // onmessage is called for the empty lines
            return;
          }
          const data = JSON.parse(event.data);
          // FIXME: fix case of phase/state upstream
          if (data.phase) {
            data.phase = data.phase.toLowerCase();
          }
          queue.push(data);
          if (data.phase === "failed") {
            throw new EventStreamClose();
          }
        },
      });
    });
  }

  /**
   * Close the EventSource connection to the BinderHub API if it is open
   */
  close() {
    if (this.eventIteratorQueue) {
      // Stop any currently running fetch() iterations
      this.eventIteratorQueue.stop();
      this.eventIteratorQueue = null;
    }
    if (this.abortController) {
      // close event source
      this.abortController.abort();
      this.abortController = null;
    }
  }
}


/***/ }),

/***/ "./node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventStreamContentType: () => (/* binding */ EventStreamContentType),
/* harmony export */   fetchEventSource: () => (/* binding */ fetchEventSource)
/* harmony export */ });
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse */ "./node_modules/@microsoft/fetch-event-source/lib/esm/parse.js");
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};

const EventStreamContentType = 'text/event-stream';
const DefaultRetryInterval = 1000;
const LastEventId = 'last-event-id';
function fetchEventSource(input, _a) {
    var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
    return new Promise((resolve, reject) => {
        const headers = Object.assign({}, inputHeaders);
        if (!headers.accept) {
            headers.accept = EventStreamContentType;
        }
        let curRequestController;
        function onVisibilityChange() {
            curRequestController.abort();
            if (!document.hidden) {
                create();
            }
        }
        if (!openWhenHidden) {
            document.addEventListener('visibilitychange', onVisibilityChange);
        }
        let retryInterval = DefaultRetryInterval;
        let retryTimer = 0;
        function dispose() {
            document.removeEventListener('visibilitychange', onVisibilityChange);
            window.clearTimeout(retryTimer);
            curRequestController.abort();
        }
        inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', () => {
            dispose();
            resolve();
        });
        const fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;
        const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;
        async function create() {
            var _a;
            curRequestController = new AbortController();
            try {
                const response = await fetch(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));
                await onopen(response);
                await (0,_parse__WEBPACK_IMPORTED_MODULE_0__.getBytes)(response.body, (0,_parse__WEBPACK_IMPORTED_MODULE_0__.getLines)((0,_parse__WEBPACK_IMPORTED_MODULE_0__.getMessages)(id => {
                    if (id) {
                        headers[LastEventId] = id;
                    }
                    else {
                        delete headers[LastEventId];
                    }
                }, retry => {
                    retryInterval = retry;
                }, onmessage)));
                onclose === null || onclose === void 0 ? void 0 : onclose();
                dispose();
                resolve();
            }
            catch (err) {
                if (!curRequestController.signal.aborted) {
                    try {
                        const interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a !== void 0 ? _a : retryInterval;
                        window.clearTimeout(retryTimer);
                        retryTimer = window.setTimeout(create, interval);
                    }
                    catch (innerErr) {
                        dispose();
                        reject(innerErr);
                    }
                }
            }
        }
        create();
    });
}
function defaultOnOpen(response) {
    const contentType = response.headers.get('content-type');
    if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {
        throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);
    }
}
//# sourceMappingURL=fetch.js.map

/***/ }),

/***/ "./node_modules/@microsoft/fetch-event-source/lib/esm/parse.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@microsoft/fetch-event-source/lib/esm/parse.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getBytes: () => (/* binding */ getBytes),
/* harmony export */   getLines: () => (/* binding */ getLines),
/* harmony export */   getMessages: () => (/* binding */ getMessages)
/* harmony export */ });
async function getBytes(stream, onChunk) {
    const reader = stream.getReader();
    let result;
    while (!(result = await reader.read()).done) {
        onChunk(result.value);
    }
}
function getLines(onLine) {
    let buffer;
    let position;
    let fieldLength;
    let discardTrailingNewline = false;
    return function onChunk(arr) {
        if (buffer === undefined) {
            buffer = arr;
            position = 0;
            fieldLength = -1;
        }
        else {
            buffer = concat(buffer, arr);
        }
        const bufLength = buffer.length;
        let lineStart = 0;
        while (position < bufLength) {
            if (discardTrailingNewline) {
                if (buffer[position] === 10) {
                    lineStart = ++position;
                }
                discardTrailingNewline = false;
            }
            let lineEnd = -1;
            for (; position < bufLength && lineEnd === -1; ++position) {
                switch (buffer[position]) {
                    case 58:
                        if (fieldLength === -1) {
                            fieldLength = position - lineStart;
                        }
                        break;
                    case 13:
                        discardTrailingNewline = true;
                    case 10:
                        lineEnd = position;
                        break;
                }
            }
            if (lineEnd === -1) {
                break;
            }
            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
            lineStart = position;
            fieldLength = -1;
        }
        if (lineStart === bufLength) {
            buffer = undefined;
        }
        else if (lineStart !== 0) {
            buffer = buffer.subarray(lineStart);
            position -= lineStart;
        }
    };
}
function getMessages(onId, onRetry, onMessage) {
    let message = newMessage();
    const decoder = new TextDecoder();
    return function onLine(line, fieldLength) {
        if (line.length === 0) {
            onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);
            message = newMessage();
        }
        else if (fieldLength > 0) {
            const field = decoder.decode(line.subarray(0, fieldLength));
            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);
            const value = decoder.decode(line.subarray(valueOffset));
            switch (field) {
                case 'data':
                    message.data = message.data
                        ? message.data + '\n' + value
                        : value;
                    break;
                case 'event':
                    message.event = value;
                    break;
                case 'id':
                    onId(message.id = value);
                    break;
                case 'retry':
                    const retry = parseInt(value, 10);
                    if (!isNaN(retry)) {
                        onRetry(message.retry = retry);
                    }
                    break;
            }
        }
    };
}
function concat(a, b) {
    const res = new Uint8Array(a.length + b.length);
    res.set(a);
    res.set(b, a.length);
    return res;
}
function newMessage() {
    return {
        data: '',
        event: '',
        id: '',
        retry: undefined,
    };
}
//# sourceMappingURL=parse.js.map

/***/ }),

/***/ "./node_modules/event-iterator/lib/dom.js":
/*!************************************************!*\
  !*** ./node_modules/event-iterator/lib/dom.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const event_iterator_1 = __webpack_require__(/*! ./event-iterator */ "./node_modules/event-iterator/lib/event-iterator.js");
exports.EventIterator = event_iterator_1.EventIterator;
function subscribe(event, options, evOptions) {
    return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
    }, evOptions);
}
exports.subscribe = subscribe;
exports["default"] = event_iterator_1.EventIterator;


/***/ }),

/***/ "./node_modules/event-iterator/lib/event-iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/event-iterator/lib/event-iterator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
class EventQueue {
    constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
    }
    push(value) {
        if (this.isStopped)
            return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
            const placeholder = this.pullQueue.shift();
            if (placeholder)
                placeholder.resolve(resolution);
        }
        else {
            this.pushQueue.push(Promise.resolve(resolution));
            if (this.highWaterMark !== undefined &&
                this.pushQueue.length >= this.highWaterMark &&
                !this.isPaused) {
                this.isPaused = true;
                if (this.eventHandlers.highWater) {
                    this.eventHandlers.highWater();
                }
                else if (console) {
                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
                }
            }
        }
    }
    stop() {
        if (this.isStopped)
            return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
            placeholder.resolve({ value: undefined, done: true });
        }
        this.pullQueue.length = 0;
    }
    fail(error) {
        if (this.isStopped)
            return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
            for (const placeholder of this.pullQueue) {
                placeholder.reject(error);
            }
            this.pullQueue.length = 0;
        }
        else {
            const rejection = Promise.reject(error);
            /* Attach error handler to avoid leaking an unhandled promise rejection. */
            rejection.catch(() => { });
            this.pushQueue.push(rejection);
        }
    }
    remove() {
        Promise.resolve().then(() => {
            if (this.removeCallback)
                this.removeCallback();
        });
    }
    [Symbol.asyncIterator]() {
        return {
            next: (value) => {
                const result = this.pushQueue.shift();
                if (result) {
                    if (this.lowWaterMark !== undefined &&
                        this.pushQueue.length <= this.lowWaterMark &&
                        this.isPaused) {
                        this.isPaused = false;
                        if (this.eventHandlers.lowWater) {
                            this.eventHandlers.lowWater();
                        }
                    }
                    return result;
                }
                else if (this.isStopped) {
                    return Promise.resolve({ value: undefined, done: true });
                }
                else {
                    return new Promise((resolve, reject) => {
                        this.pullQueue.push({ resolve, reject });
                    });
                }
            },
            return: () => {
                this.isStopped = true;
                this.pushQueue.length = 0;
                this.remove();
                return Promise.resolve({ value: undefined, done: true });
            },
        };
    }
}
class EventIterator {
    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback =
            listen({
                push: value => queue.push(value),
                stop: () => queue.stop(),
                fail: error => queue.fail(error),
                on: (event, fn) => {
                    queue.eventHandlers[event] = fn;
                },
            }) || (() => { });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
    }
}
exports.EventIterator = EventIterator;
exports["default"] = EventIterator;


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_jupyterhub_binderhub-client_lib_client_js.form.js.map