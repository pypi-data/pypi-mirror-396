{"version":3,"file":"vendors-node_modules_jupyterhub_binderhub-client_lib_client_js.form.js","mappings":";;;;;;;;;;;;;;;AAAiE;AAClB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA,YAAY,kCAAkC;;AAE9C;AACA;AACA;AACA;AACA,sDAAsD,kBAAkB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,cAAc;AACzD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAa;AAC5B;AACA,MAAM,+EAAgB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB,IAAI,cAAc;AAChG,aAAa;AACb;AACA,YAAY;AACZ;AACA;AACA,sEAAsE,iBAAiB,IAAI,cAAc;AACzG,aAAa;AACb;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM;AACvD,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AClNA,cAAc,SAAI,IAAI,SAAI;AAC1B;AACA;AACA;AACA;AACA,6DAA6D,cAAc;AAC3E;AACA;AACA;AACA;AACA;AAC0D;AACnD;AACP;AACA;AACO;AACP,UAAU,kIAAkI;AAC5I;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,WAAW,8CAA8C;AAC3I;AACA,sBAAsB,gDAAQ,gBAAgB,gDAAQ,CAAC,mDAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uDAAuD,uBAAuB,YAAY,YAAY;AACtG;AACA;AACA;;;;;;;;;;;;;;;;ACxFO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wCAAwC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC7Ga;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,yBAAyB,mBAAO,CAAC,6EAAkB;AACnD,qBAAqB;AACrB;AACA,iDAAiD,MAAM;AACvD;AACA;AACA,KAAK;AACL;AACA,iBAAiB;AACjB,kBAAe;;;;;;;;;;;ACXF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uBAAuB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8BAA8B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8BAA8B;AAC3E;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yCAAyC,8BAA8B;AACvE,aAAa;AACb;AACA;AACA;AACA;AACA,0BAA0B,wCAAwC,IAAI;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAe","sources":["webpack://jupyterhub-fancy-profiles/./node_modules/@jupyterhub/binderhub-client/lib/client.js","webpack://jupyterhub-fancy-profiles/./node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js","webpack://jupyterhub-fancy-profiles/./node_modules/@microsoft/fetch-event-source/lib/esm/parse.js","webpack://jupyterhub-fancy-profiles/./node_modules/event-iterator/lib/dom.js","webpack://jupyterhub-fancy-profiles/./node_modules/event-iterator/lib/event-iterator.js"],"sourcesContent":["import { fetchEventSource } from \"@microsoft/fetch-event-source\";\nimport { EventIterator } from \"event-iterator\";\n\nfunction _getXSRFToken() {\n  // from @jupyterlab/services\n  // https://github.com/jupyterlab/jupyterlab/blob/69223102d717f3d3e9f976d32e657a4e2456e85d/packages/services/src/contents/index.ts#L1178-L1184\n  let cookie = \"\";\n  try {\n    cookie = document.cookie;\n  } catch (e) {\n    // e.g. SecurityError in case of CSP Sandbox\n    return null;\n  }\n  // extracts the value of the cookie named `_xsrf`\n  // by picking up everything between `_xsrf=` and the next semicolon or end-of-line\n  // `\\b` ensures word boundaries, so it doesn't pick up `something_xsrf=`...\n  const xsrfTokenMatch = cookie.match(\"\\\\b_xsrf=([^;]*)\\\\b\");\n  if (xsrfTokenMatch) {\n    return xsrfTokenMatch[1];\n  }\n  return null;\n}\n\n/* throw this to close the event stream */\nclass EventStreamClose extends Error {}\n/* throw this to close the event stream */\nclass EventStreamRetry extends Error {}\n\n/**\n * Build (and optionally launch) a repository by talking to a BinderHub API endpoint\n */\nexport class BinderRepository {\n  /**\n   *\n   * @param {string} providerSpec Spec of the form <provider>/<repo>/<ref> to pass to the binderhub API.\n   * @param {URL} buildEndpointUrl API URL of the build endpoint to talk to\n   * @param {Object} [options] - optional arguments\n   * @param {string} [options.buildToken] Optional JWT based build token if this binderhub installation requires using build tokens\n   * @param {boolean} [options.buildOnly] Opt out of launching built image by default by passing `build_only` param\n   * @param {string} [options.apiToken] Optional Bearer token for authenticating requests\n   */\n  constructor(providerSpec, buildEndpointUrl, options) {\n    const { apiToken, buildToken, buildOnly } = options || {};\n\n    this.providerSpec = providerSpec;\n    // Make sure that buildEndpointUrl is a real URL - this ensures hostname is properly set\n    if (!(buildEndpointUrl instanceof URL)) {\n      throw new TypeError(\n        `buildEndpointUrl must be a URL object, got ${buildEndpointUrl} instead`,\n      );\n    }\n    // We make a copy here so we don't modify the passed in URL object\n    this.buildEndpointUrl = new URL(buildEndpointUrl);\n    // The binderHub API is path based, so the buildEndpointUrl must have a trailing slash. We add\n    // it if it is not passed in here to us.\n    if (!this.buildEndpointUrl.pathname.endsWith(\"/\")) {\n      this.buildEndpointUrl.pathname += \"/\";\n    }\n\n    // The actual URL we'll make a request to build this particular providerSpec\n    this.buildUrl = new URL(this.providerSpec, this.buildEndpointUrl);\n    if (buildToken) {\n      this.buildUrl.searchParams.append(\"build_token\", buildToken);\n    }\n\n    if (buildOnly) {\n      this.buildUrl.searchParams.append(\"build_only\", \"true\");\n    }\n    this.apiToken = apiToken;\n\n    this.eventIteratorQueue = null;\n    this.abortSignal = null;\n  }\n\n  /**\n   * Call the binderhub API and yield responses as they come in\n   *\n   * Returns an Async iterator yielding each item returned by the\n   * server API.\n   *\n   * @typedef Line\n   * @prop {string} [phase] The phase the build is currently in. One of: building, built, fetching, launching, ready, unknown, waiting\n   * @prop {string} [message] Human readable message to display to the user. Extra newlines must *not* be added\n   * @prop {string} [imageName] (only with built) Full name of the image that has been built\n   * @prop {string} [binder_launch_host] (only with phase=ready) The host this binderhub API request was serviced by.\n   *                                     Could be different than the host the request was made to in federated cases\n   * @prop {string} [binder_request] (only with phase=ready) Request used to construct this image, of form v2/<provider>/<repo>/<ref>\n   * @prop {string} [binder_persistent_request] (only with phase=ready) Same as binder_request, but <ref> is fully resolved\n   * @prop {string} [binder_ref_url] (only with phase=ready) A URL to the repo provider where the repo can be browsed\n   * @prop {string} [image] (only with phase=ready) Full name of the image that has been built\n   * @prop {string} [token] (only with phase=ready) Token to use to authenticate with jupyter server at url\n   * @prop {string} [url] (only with phase=ready) URL where a jupyter server has been started\n   * @prop {string} [repo_url] (only with phase=ready) URL of the repository that is ready to be launched\n   *\n   * @returns {AsyncIterable<Line>} An async iterator yielding responses from the API as they come in\n   */\n  fetch() {\n    const headers = {};\n    this.abortController = new AbortController();\n\n    if (this.apiToken && this.apiToken.length > 0) {\n      headers[\"Authorization\"] = `Bearer ${this.apiToken}`;\n    } else {\n      const xsrf = _getXSRFToken();\n      if (xsrf) {\n        headers[\"X-Xsrftoken\"] = xsrf;\n      }\n    }\n    // setTimeout(() => this.close(), 1000);\n    return new EventIterator((queue) => {\n      this.eventIteratorQueue = queue;\n      fetchEventSource(this.buildUrl, {\n        headers,\n        // signal used for closing\n        signal: this.abortController.signal,\n        // openWhenHidden leaves connection open (matches default)\n        // otherwise fetch-event closes connections,\n        // which would be nice if our javascript handled restarting messages better\n        openWhenHidden: true,\n        onopen: (response) => {\n          if (response.ok) {\n            return; // everything's good\n          } else if (\n            response.status >= 400 &&\n            response.status < 500 &&\n            response.status !== 429\n          ) {\n            queue.push({\n              phase: \"failed\",\n              message: `Failed to connect to event stream: ${response.status} - ${response.text}\\n`,\n            });\n            throw new EventStreamClose();\n          } else {\n            queue.push({\n              phase: \"unknown\",\n              message: `Error connecting to event stream, retrying: ${response.status} - ${response.text}\\n`,\n            });\n            throw new EventStreamRetry();\n          }\n        },\n\n        onclose: () => {\n          if (!queue.isStopped) {\n            // close called before queue finished\n            queue.push({\n              phase: \"failed\",\n              message: `Event stream closed unexpectedly\\n`,\n            });\n            queue.stop();\n            // throw new EventStreamClose();\n          }\n        },\n        onerror: (error) => {\n          console.log(\"Event stream error\", error);\n          if (error.name === \"EventStreamRetry\") {\n            // if we don't re-raise, connection will be retried;\n            queue.push({\n              phase: \"unknown\",\n              message: `Error in event stream: ${error}\\n`,\n            });\n            return;\n          }\n          if (\n            !(error.name === \"EventStreamClose\" || error.name === \"AbortError\")\n          ) {\n            // errors _other_ than EventStreamClose get displayed\n            queue.push({\n              phase: \"failed\",\n              message: `Error in event stream: ${error}\\n`,\n            });\n          }\n          queue.stop();\n          // need to rethrow to prevent reconnection\n          throw error;\n        },\n\n        onmessage: (event) => {\n          if (!event.data || event.data === \"\") {\n            // onmessage is called for the empty lines\n            return;\n          }\n          const data = JSON.parse(event.data);\n          // FIXME: fix case of phase/state upstream\n          if (data.phase) {\n            data.phase = data.phase.toLowerCase();\n          }\n          queue.push(data);\n          if (data.phase === \"failed\") {\n            throw new EventStreamClose();\n          }\n        },\n      });\n    });\n  }\n\n  /**\n   * Close the EventSource connection to the BinderHub API if it is open\n   */\n  close() {\n    if (this.eventIteratorQueue) {\n      // Stop any currently running fetch() iterations\n      this.eventIteratorQueue.stop();\n      this.eventIteratorQueue = null;\n    }\n    if (this.abortController) {\n      // close event source\n      this.abortController.abort();\n      this.abortController = null;\n    }\n  }\n}\n","var __rest = (this && this.__rest) || function (s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n};\r\nimport { getBytes, getLines, getMessages } from './parse';\r\nexport const EventStreamContentType = 'text/event-stream';\r\nconst DefaultRetryInterval = 1000;\r\nconst LastEventId = 'last-event-id';\r\nexport function fetchEventSource(input, _a) {\r\n    var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, [\"signal\", \"headers\", \"onopen\", \"onmessage\", \"onclose\", \"onerror\", \"openWhenHidden\", \"fetch\"]);\r\n    return new Promise((resolve, reject) => {\r\n        const headers = Object.assign({}, inputHeaders);\r\n        if (!headers.accept) {\r\n            headers.accept = EventStreamContentType;\r\n        }\r\n        let curRequestController;\r\n        function onVisibilityChange() {\r\n            curRequestController.abort();\r\n            if (!document.hidden) {\r\n                create();\r\n            }\r\n        }\r\n        if (!openWhenHidden) {\r\n            document.addEventListener('visibilitychange', onVisibilityChange);\r\n        }\r\n        let retryInterval = DefaultRetryInterval;\r\n        let retryTimer = 0;\r\n        function dispose() {\r\n            document.removeEventListener('visibilitychange', onVisibilityChange);\r\n            window.clearTimeout(retryTimer);\r\n            curRequestController.abort();\r\n        }\r\n        inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', () => {\r\n            dispose();\r\n            resolve();\r\n        });\r\n        const fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;\r\n        const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;\r\n        async function create() {\r\n            var _a;\r\n            curRequestController = new AbortController();\r\n            try {\r\n                const response = await fetch(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));\r\n                await onopen(response);\r\n                await getBytes(response.body, getLines(getMessages(id => {\r\n                    if (id) {\r\n                        headers[LastEventId] = id;\r\n                    }\r\n                    else {\r\n                        delete headers[LastEventId];\r\n                    }\r\n                }, retry => {\r\n                    retryInterval = retry;\r\n                }, onmessage)));\r\n                onclose === null || onclose === void 0 ? void 0 : onclose();\r\n                dispose();\r\n                resolve();\r\n            }\r\n            catch (err) {\r\n                if (!curRequestController.signal.aborted) {\r\n                    try {\r\n                        const interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a !== void 0 ? _a : retryInterval;\r\n                        window.clearTimeout(retryTimer);\r\n                        retryTimer = window.setTimeout(create, interval);\r\n                    }\r\n                    catch (innerErr) {\r\n                        dispose();\r\n                        reject(innerErr);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        create();\r\n    });\r\n}\r\nfunction defaultOnOpen(response) {\r\n    const contentType = response.headers.get('content-type');\r\n    if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {\r\n        throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);\r\n    }\r\n}\r\n//# sourceMappingURL=fetch.js.map","export async function getBytes(stream, onChunk) {\r\n    const reader = stream.getReader();\r\n    let result;\r\n    while (!(result = await reader.read()).done) {\r\n        onChunk(result.value);\r\n    }\r\n}\r\nexport function getLines(onLine) {\r\n    let buffer;\r\n    let position;\r\n    let fieldLength;\r\n    let discardTrailingNewline = false;\r\n    return function onChunk(arr) {\r\n        if (buffer === undefined) {\r\n            buffer = arr;\r\n            position = 0;\r\n            fieldLength = -1;\r\n        }\r\n        else {\r\n            buffer = concat(buffer, arr);\r\n        }\r\n        const bufLength = buffer.length;\r\n        let lineStart = 0;\r\n        while (position < bufLength) {\r\n            if (discardTrailingNewline) {\r\n                if (buffer[position] === 10) {\r\n                    lineStart = ++position;\r\n                }\r\n                discardTrailingNewline = false;\r\n            }\r\n            let lineEnd = -1;\r\n            for (; position < bufLength && lineEnd === -1; ++position) {\r\n                switch (buffer[position]) {\r\n                    case 58:\r\n                        if (fieldLength === -1) {\r\n                            fieldLength = position - lineStart;\r\n                        }\r\n                        break;\r\n                    case 13:\r\n                        discardTrailingNewline = true;\r\n                    case 10:\r\n                        lineEnd = position;\r\n                        break;\r\n                }\r\n            }\r\n            if (lineEnd === -1) {\r\n                break;\r\n            }\r\n            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);\r\n            lineStart = position;\r\n            fieldLength = -1;\r\n        }\r\n        if (lineStart === bufLength) {\r\n            buffer = undefined;\r\n        }\r\n        else if (lineStart !== 0) {\r\n            buffer = buffer.subarray(lineStart);\r\n            position -= lineStart;\r\n        }\r\n    };\r\n}\r\nexport function getMessages(onId, onRetry, onMessage) {\r\n    let message = newMessage();\r\n    const decoder = new TextDecoder();\r\n    return function onLine(line, fieldLength) {\r\n        if (line.length === 0) {\r\n            onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);\r\n            message = newMessage();\r\n        }\r\n        else if (fieldLength > 0) {\r\n            const field = decoder.decode(line.subarray(0, fieldLength));\r\n            const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);\r\n            const value = decoder.decode(line.subarray(valueOffset));\r\n            switch (field) {\r\n                case 'data':\r\n                    message.data = message.data\r\n                        ? message.data + '\\n' + value\r\n                        : value;\r\n                    break;\r\n                case 'event':\r\n                    message.event = value;\r\n                    break;\r\n                case 'id':\r\n                    onId(message.id = value);\r\n                    break;\r\n                case 'retry':\r\n                    const retry = parseInt(value, 10);\r\n                    if (!isNaN(retry)) {\r\n                        onRetry(message.retry = retry);\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction concat(a, b) {\r\n    const res = new Uint8Array(a.length + b.length);\r\n    res.set(a);\r\n    res.set(b, a.length);\r\n    return res;\r\n}\r\nfunction newMessage() {\r\n    return {\r\n        data: '',\r\n        event: '',\r\n        id: '',\r\n        retry: undefined,\r\n    };\r\n}\r\n//# sourceMappingURL=parse.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst event_iterator_1 = require(\"./event-iterator\");\nexports.EventIterator = event_iterator_1.EventIterator;\nfunction subscribe(event, options, evOptions) {\n    return new event_iterator_1.EventIterator(({ push }) => {\n        this.addEventListener(event, push, options);\n        return () => this.removeEventListener(event, push, options);\n    }, evOptions);\n}\nexports.subscribe = subscribe;\nexports.default = event_iterator_1.EventIterator;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EventQueue {\n    constructor() {\n        this.pullQueue = [];\n        this.pushQueue = [];\n        this.eventHandlers = {};\n        this.isPaused = false;\n        this.isStopped = false;\n    }\n    push(value) {\n        if (this.isStopped)\n            return;\n        const resolution = { value, done: false };\n        if (this.pullQueue.length) {\n            const placeholder = this.pullQueue.shift();\n            if (placeholder)\n                placeholder.resolve(resolution);\n        }\n        else {\n            this.pushQueue.push(Promise.resolve(resolution));\n            if (this.highWaterMark !== undefined &&\n                this.pushQueue.length >= this.highWaterMark &&\n                !this.isPaused) {\n                this.isPaused = true;\n                if (this.eventHandlers.highWater) {\n                    this.eventHandlers.highWater();\n                }\n                else if (console) {\n                    console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);\n                }\n            }\n        }\n    }\n    stop() {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        for (const placeholder of this.pullQueue) {\n            placeholder.resolve({ value: undefined, done: true });\n        }\n        this.pullQueue.length = 0;\n    }\n    fail(error) {\n        if (this.isStopped)\n            return;\n        this.isStopped = true;\n        this.remove();\n        if (this.pullQueue.length) {\n            for (const placeholder of this.pullQueue) {\n                placeholder.reject(error);\n            }\n            this.pullQueue.length = 0;\n        }\n        else {\n            const rejection = Promise.reject(error);\n            /* Attach error handler to avoid leaking an unhandled promise rejection. */\n            rejection.catch(() => { });\n            this.pushQueue.push(rejection);\n        }\n    }\n    remove() {\n        Promise.resolve().then(() => {\n            if (this.removeCallback)\n                this.removeCallback();\n        });\n    }\n    [Symbol.asyncIterator]() {\n        return {\n            next: (value) => {\n                const result = this.pushQueue.shift();\n                if (result) {\n                    if (this.lowWaterMark !== undefined &&\n                        this.pushQueue.length <= this.lowWaterMark &&\n                        this.isPaused) {\n                        this.isPaused = false;\n                        if (this.eventHandlers.lowWater) {\n                            this.eventHandlers.lowWater();\n                        }\n                    }\n                    return result;\n                }\n                else if (this.isStopped) {\n                    return Promise.resolve({ value: undefined, done: true });\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        this.pullQueue.push({ resolve, reject });\n                    });\n                }\n            },\n            return: () => {\n                this.isStopped = true;\n                this.pushQueue.length = 0;\n                this.remove();\n                return Promise.resolve({ value: undefined, done: true });\n            },\n        };\n    }\n}\nclass EventIterator {\n    constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {\n        const queue = new EventQueue();\n        queue.highWaterMark = highWaterMark;\n        queue.lowWaterMark = lowWaterMark;\n        queue.removeCallback =\n            listen({\n                push: value => queue.push(value),\n                stop: () => queue.stop(),\n                fail: error => queue.fail(error),\n                on: (event, fn) => {\n                    queue.eventHandlers[event] = fn;\n                },\n            }) || (() => { });\n        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();\n        Object.freeze(this);\n    }\n}\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;\n"],"names":[],"sourceRoot":""}