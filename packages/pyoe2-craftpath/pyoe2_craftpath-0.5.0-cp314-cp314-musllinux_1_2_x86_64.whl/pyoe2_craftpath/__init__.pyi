# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import enum
import typing

@typing.final
class AffixDefinition:
    @property
    def exlusive_groups(self) -> builtins.set[builtins.str]:
        r"""
        2 Affixes with intersecting exlusive groups
        cannot be applied on same item
        """
    @property
    def tags(self) -> builtins.set[builtins.int]:
        r"""
        Tags like "Physical" etc. for Homogen Omen
        """
    @property
    def description_template(self) -> builtins.str: ...
    @property
    def affix_class(self) -> AffixClassEnum:
        r"""
        Normal, Desecrated, Essence
        """
    @property
    def affix_location(self) -> AffixLocationEnum:
        r"""
        Prefix, Suffix, Socket
        """
    def __str__(self) -> builtins.str: ...

@typing.final
class AffixId:
    @property
    def raw_value(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.int) -> AffixId: ...

@typing.final
class AffixSpecifier:
    @property
    def affix(self) -> AffixId: ...
    @property
    def fractured(self) -> builtins.bool: ...
    @property
    def tier(self) -> AffixTierConstraints: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class AffixTierConstraints:
    @property
    def tier(self) -> AffixTierLevel: ...
    @property
    def bounds(self) -> AffixTierLevelBoundsEnum: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class AffixTierLevel:
    @property
    def raw_value(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.int) -> AffixTierLevel: ...

@typing.final
class AffixTierLevelMeta:
    @property
    def weight(self) -> Weight: ...
    @property
    def min_item_level(self) -> ItemLevel: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class BaseGroupDefinition:
    @property
    def name_base_group(self) -> builtins.str: ...
    @property
    def max_affix(self) -> builtins.int: ...
    @property
    def max_sockets(self) -> builtins.int: ...
    @property
    def is_rare(self) -> builtins.bool: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class BaseGroupId:
    @property
    def raw_value(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.int) -> BaseGroupId: ...

@typing.final
class BaseItemId:
    @property
    def raw_value(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.int) -> BaseItemId: ...

@typing.final
class Calculator:
    @property
    def matrix(self) -> builtins.dict[builtins.int, ItemMatrixNode]: ...
    @property
    def starting_item(self) -> ItemSnapshot: ...
    @property
    def target_item(self) -> ItemSnapshot: ...
    @property
    def statistics(self) -> builtins.dict[builtins.str, StatisticResult]: ...
    @property
    def statistics_grouped(self) -> builtins.dict[builtins.str, builtins.list[GroupRoute]]: ...
    def __str__(self) -> builtins.str: ...
    @staticmethod
    def generate_item_matrix(starting_item: ItemSnapshot, target: ItemSnapshot, item_provider: ItemInfoProvider, market_info: MarketPriceProvider, matrix_builder: DynMatrixBuilder) -> Calculator: ...
    def calculate_statistics(self, item_provider: ItemInfoProvider, market_provider: MarketPriceProvider, max_routes: builtins.int, max_ram_in_bytes: builtins.int, statistic_analyzer: DynStatisticAnalyzerPaths) -> builtins.list[ItemRoute]: ...
    def calculate_statistics_currency_group(self, item_provider: ItemInfoProvider, market_provider: MarketPriceProvider, max_ram_in_bytes: builtins.int, statistic_analyzer: DynStatisticAnalyzerCurrencyGroups) -> builtins.list[GroupRoute]: ...
    @staticmethod
    def calculate_target_proximity(start: ItemSnapshot, target: ItemSnapshot, provider: ItemInfoProvider) -> builtins.int: ...
    @staticmethod
    def sanity_check_item(start: ItemSnapshot, provider: ItemInfoProvider) -> builtins.bool: ...

class CraftCurrencyEnum:
    def get_item_name(self, item_info: ItemInfoProvider) -> builtins.str: ...
    @typing.final
    class OrbOfTransmutationNormal(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.OrbOfTransmutationNormal: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class OrbOfTransmutationGreater(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.OrbOfTransmutationGreater: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class OrbOfTransmutationPerfect(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.OrbOfTransmutationPerfect: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class OrbOfAugmentationNormal(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.OrbOfAugmentationNormal: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class OrbOfAugmentationGreater(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.OrbOfAugmentationGreater: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class OrbOfAugmentationPerfect(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.OrbOfAugmentationPerfect: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class RegalOrbNormal(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.RegalOrbNormal: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class RegalOrbGreater(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.RegalOrbGreater: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class RegalOrbPerfect(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.RegalOrbPerfect: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class ExaltedOrbNormal(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.ExaltedOrbNormal: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class ExaltedOrbGreater(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.ExaltedOrbGreater: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class ExaltedOrbPerfect(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.ExaltedOrbPerfect: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class OrbOfAnnulment(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.OrbOfAnnulment: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class ChaosOrbNormal(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.ChaosOrbNormal: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class ChaosOrbGreater(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.ChaosOrbGreater: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class ChaosOrbPerfect(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.ChaosOrbPerfect: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class ArtificersOrb(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.ArtificersOrb: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class VaalOrb(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.VaalOrb: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class OmenOfCorruption(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.OmenOfCorruption: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class FracturingOrb(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.FracturingOrb: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class Desecrator(CraftCurrencyEnum):
        __match_args__ = ("_0", "_1",)
        @property
        def _0(self) -> BaseItemId: ...
        @property
        def _1(self) -> BaseGroupId: ...
        def __new__(cls, _0: BaseItemId, _1: BaseGroupId) -> CraftCurrencyEnum.Desecrator: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class AbyssalEchoes(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.AbyssalEchoes: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class TheBlackblooded(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.TheBlackblooded: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class TheSovereign(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.TheSovereign: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class TheLiege(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.TheLiege: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class DextralNecromancy(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.DextralNecromancy: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class SinistralNecromancy(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.SinistralNecromancy: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class HomogenisingCoronation(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.HomogenisingCoronation: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class HomogenisingExaltation(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.HomogenisingExaltation: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class DextralExaltation(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.DextralExaltation: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class SinistralExaltation(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.SinistralExaltation: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class DextralAnnulment(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.DextralAnnulment: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class SinistralAnnulment(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.SinistralAnnulment: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class DextralErasure(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.DextralErasure: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class SinistralErasure(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.SinistralErasure: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class Whittling(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.Whittling: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class Essence(CraftCurrencyEnum):
        __match_args__ = ("_0",)
        @property
        def _0(self) -> EssenceId: ...
        def __new__(cls, _0: EssenceId) -> CraftCurrencyEnum.Essence: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class DextralCrystallisation(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.DextralCrystallisation: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    
    @typing.final
    class SinistralCrystallisation(CraftCurrencyEnum):
        __match_args__ = ()
        def __new__(cls) -> CraftCurrencyEnum.SinistralCrystallisation: ...
        def __len__(self) -> builtins.int: ...
        def __getitem__(self, key: builtins.int) -> typing.Any: ...
    

@typing.final
class CraftCurrencyList:
    @property
    def list(self) -> builtins.set[CraftCurrencyEnum]: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class CraftOfExileEmulatorItemImport:
    @staticmethod
    def parse_itemsnapshot_from_string(item_json: builtins.str, provider: ItemInfoProvider) -> ItemSnapshot: ...

@typing.final
class CraftOfExileItemInfoProvider:
    @staticmethod
    def parse_from_json(text: builtins.str) -> ItemInfoProvider: ...

@typing.final
class DynMatrixBuilder:
    def __str__(self) -> builtins.str: ...

@typing.final
class DynStatisticAnalyzerCurrencyGroups:
    def __str__(self) -> builtins.str: ...
    def get_name(self) -> builtins.str: ...
    def get_description(self) -> builtins.str: ...
    def get_unit_type(self) -> builtins.str: ...
    def lower_is_better(self) -> builtins.bool: ...
    def get_statistic(self, calculator: Calculator, item_provider: ItemInfoProvider, market_provider: MarketPriceProvider, max_ram_in_bytes: builtins.int) -> builtins.list[GroupRoute]: ...
    def calculate_weight_for_group_step_index(self, group_routes: typing.Sequence[typing.Sequence[RouteChance]], subpath_amount: SubpathAmount, index: builtins.int) -> RouteChance: ...
    def format_display_more_info(self, group_route: GroupRoute, item_provider: ItemInfoProvider, market_provider: MarketPriceProvider) -> typing.Optional[builtins.str]: ...
    def calculate_cost_per_craft(self, currency: typing.Sequence[CraftCurrencyList], item_info: ItemInfoProvider, market_provider: MarketPriceProvider) -> PriceInDivines: ...
    def calculate_tries_needed_for_60_percent(self, group_route: GroupRoute) -> builtins.int: ...

@typing.final
class DynStatisticAnalyzerPaths:
    def __str__(self) -> builtins.str: ...
    def get_name(self) -> builtins.str: ...
    def get_description(self) -> builtins.str: ...
    def get_unit_type(self) -> builtins.str: ...
    def lower_is_better(self) -> builtins.bool: ...
    def get_statistic(self, calculator: Calculator, item_provider: ItemInfoProvider, market_provider: MarketPriceProvider, max_routes: builtins.int, max_ram_in_bytes: builtins.int) -> builtins.list[ItemRoute]: ...
    def calculate_cost_per_craft(self, currency: typing.Sequence[CraftCurrencyList], item_info: ItemInfoProvider, market_provider: MarketPriceProvider) -> PriceInDivines: ...
    def calculate_tries_needed_for_60_percent(self, route: ItemRoute) -> builtins.int: ...
    def format_display_more_info(self, route: ItemRoute, item_provider: ItemInfoProvider, market_provider: MarketPriceProvider) -> typing.Optional[builtins.str]: ...

@typing.final
class EssenceDefinition:
    @property
    def name_essence(self) -> builtins.str: ...
    @property
    def base_tier_table(self) -> builtins.dict[BaseItemId, builtins.dict[AffixId, EssenceTierLevelMeta]]: ...
    @property
    def corrupt(self) -> builtins.bool: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class EssenceId:
    @property
    def raw_value(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.int) -> EssenceId: ...

@typing.final
class EssenceTierLevelMeta:
    @property
    def id(self) -> builtins.str: ...
    @property
    def min_item_level(self) -> ItemLevel: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class Fraction:
    @property
    def num(self) -> builtins.int: ...
    @property
    def den(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, num: builtins.int, den: builtins.int) -> Fraction: ...
    @staticmethod
    def zero() -> Fraction: ...
    @staticmethod
    def one() -> Fraction: ...
    @staticmethod
    def from_int(value: builtins.int) -> Fraction: ...
    @staticmethod
    def gcd(a: builtins.int, b: builtins.int) -> builtins.int: ...
    def simplify(self) -> None: ...
    def to_f64(self) -> builtins.float: ...

@typing.final
class GroupRoute:
    @property
    def group(self) -> builtins.list[CraftCurrencyList]: ...
    @property
    def weight(self) -> RouteCustomWeight: ...
    @property
    def unique_route_weights(self) -> builtins.list[builtins.list[RouteChance]]: ...
    @property
    def chance(self) -> RouteChance: ...
    @property
    def amount_subpaths(self) -> SubpathAmount: ...
    def __str__(self) -> builtins.str: ...
    def to_pretty_string(self, item_provider: ItemInfoProvider, market_provider: MarketPriceProvider, statistic_analyzer: DynStatisticAnalyzerCurrencyGroups) -> builtins.str: ...

@typing.final
class Item:
    @property
    def snapshot(self) -> ItemSnapshot: ...
    @property
    def helper(self) -> ItemSnapshotHelper: ...
    @property
    def meta(self) -> ItemTechnicalMeta: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class ItemId:
    @property
    def raw_value(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.int) -> ItemId: ...

@typing.final
class ItemInfoProvider:
    @property
    def cache_affix_def(self) -> builtins.dict[AffixId, AffixDefinition]: ...
    @property
    def cache_item_affix_table(self) -> builtins.dict[BaseItemId, builtins.dict[AffixId, builtins.dict[AffixTierLevel, AffixTierLevelMeta]]]: ...
    @property
    def cache_affix_essence_table(self) -> builtins.dict[tuple[AffixId, BaseItemId], builtins.set[EssenceId]]: ...
    @property
    def cache_essence_def(self) -> builtins.dict[EssenceId, EssenceDefinition]: ...
    @property
    def cache_base_group_table(self) -> builtins.dict[BaseItemId, BaseGroupId]: ...
    @property
    def base_group_definition(self) -> builtins.dict[BaseGroupId, BaseGroupDefinition]: ...
    def __str__(self) -> builtins.str: ...
    def lookup_base_item_mods(self, base_item_id: BaseItemId) -> builtins.dict[AffixId, builtins.dict[AffixTierLevel, AffixTierLevelMeta]]: ...
    def lookup_affix_definition(self, affix_id: AffixId) -> AffixDefinition: ...
    def lookup_base_group(self, base_item_id: BaseItemId) -> BaseGroupId: ...
    def lookup_essence_definition(self, essence_id: EssenceId) -> EssenceDefinition: ...
    def lookup_base_group_definition(self, base_group_id: BaseGroupId) -> BaseGroupDefinition: ...
    def lookup_affix_essences(self, affix_id: AffixId, base_item_id: BaseItemId) -> builtins.set[EssenceId]: ...
    def is_abyssal_mark(self, id: AffixId) -> builtins.bool: ...
    def collect_essence_info_for_affix(self, essence_id: EssenceId, base_item_id: BaseItemId, affix_id: AffixId) -> tuple[EssenceDefinition, ItemLevel, tuple[AffixTierLevel, AffixTierLevelMeta]]: ...

@typing.final
class ItemLevel:
    @property
    def raw_value(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.int) -> ItemLevel: ...

@typing.final
class ItemMatrixNode:
    @property
    def item(self) -> Item: ...
    @property
    def propagate(self) -> builtins.dict[CraftCurrencyList, builtins.list[PropagationTarget]]: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class ItemName:
    @property
    def raw_value(self) -> builtins.str: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.str) -> ItemName: ...

@typing.final
class ItemRoute:
    @property
    def route(self) -> builtins.list[ItemRouteNode]: ...
    @property
    def weight(self) -> RouteCustomWeight: ...
    @property
    def chance(self) -> RouteChance: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def to_pretty_string(self, item_provider: ItemInfoProvider, market_provider: MarketPriceProvider, statistic_analyzer: DynStatisticAnalyzerPaths, calculator: Calculator, groups: typing.Optional[typing.Sequence[GroupRoute]]) -> builtins.str: ...
    def locate_group(self, calculated_groups: typing.Sequence[GroupRoute]) -> typing.Optional[GroupRoute]: ...

@typing.final
class ItemRouteNode:
    @property
    def item_matrix_id(self) -> builtins.int: ...
    @property
    def chance(self) -> Fraction: ...
    @property
    def currency_list(self) -> CraftCurrencyList: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class ItemSnapshot:
    @property
    def item_level(self) -> ItemLevel: ...
    @property
    def rarity(self) -> ItemRarityEnum: ...
    @property
    def base_id(self) -> BaseItemId: ...
    @property
    def affixes(self) -> builtins.set[AffixSpecifier]: ...
    @property
    def corrupted(self) -> builtins.bool: ...
    @property
    def allowed_sockets(self) -> builtins.int: ...
    @property
    def sockets(self) -> builtins.set[AffixSpecifier]: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def to_pretty_string(self, item_provider: ItemInfoProvider, print_affixes: builtins.bool) -> builtins.str: ...

@typing.final
class ItemSnapshotHelper:
    @property
    def target_proximity(self) -> builtins.int: ...
    @property
    def prefix_count(self) -> builtins.int: ...
    @property
    def suffix_count(self) -> builtins.int: ...
    @property
    def blocked_modgroups(self) -> builtins.set[builtins.str]: ...
    @property
    def homogenized_mods(self) -> builtins.set[builtins.int]: ...
    @property
    def unwanted_affixes(self) -> builtins.set[AffixSpecifier]: ...
    @property
    def is_desecrated(self) -> builtins.bool: ...
    @property
    def has_desecrated_target(self) -> typing.Optional[AffixSpecifier]: ...
    @property
    def marked_by_abyssal_lord(self) -> typing.Optional[AffixSpecifier]: ...
    @property
    def has_essences_target(self) -> builtins.set[AffixSpecifier]: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class ItemTechnicalMeta:
    @property
    def mark_for_essence_only(self) -> builtins.bool: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class MarketPriceProvider:
    @property
    def cache_market_prices(self) -> builtins.dict[ItemName, PriceInDivines]: ...
    @property
    def cache_exchange_rate_div_to_exalted(self) -> builtins.float: ...
    @property
    def cache_exchange_rate_div_to_chaos(self) -> builtins.float: ...
    def __str__(self) -> builtins.str: ...
    def try_lookup_currency_in_divines_default_if_fail(self, currency: CraftCurrencyEnum, item_provider: ItemInfoProvider) -> PriceInDivines: ...
    def currency_convert(self, from_divs: PriceInDivines, to_kind: PriceKind) -> builtins.float: ...
    def currency_convert_raw(self, from_divs: builtins.float, to_kind: PriceKind) -> builtins.float: ...
    def currency_convert_from_exalted(self, from_ex: builtins.float, to_kind: PriceKind) -> builtins.float: ...

@typing.final
class PoeNinjaMarketPriceProvider:
    @staticmethod
    def parse_from_json_list(texts: typing.Sequence[builtins.str]) -> MarketPriceProvider: ...

@typing.final
class PriceInDivines:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __lt__(self, other: builtins.object) -> builtins.bool: ...
    def __le__(self, other: builtins.object) -> builtins.bool: ...
    def __gt__(self, other: builtins.object) -> builtins.bool: ...
    def __ge__(self, other: builtins.object) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.float) -> PriceInDivines: ...
    def get_divine_value(self) -> builtins.float: ...

@typing.final
class PropagationTarget:
    @property
    def next(self) -> ItemSnapshot: ...
    @property
    def chance(self) -> Fraction: ...
    @property
    def meta(self) -> ItemTechnicalMeta: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class RouteChance:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.float) -> RouteChance: ...
    def get_raw_value(self) -> builtins.float: ...

@typing.final
class RouteCustomWeight:
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.float) -> RouteCustomWeight: ...
    def get_raw_value(self) -> builtins.float: ...

@typing.final
class StatisticResult:
    @property
    def sorted_routes(self) -> builtins.list[ItemRoute]: ...
    @property
    def lower_is_better(self) -> builtins.bool: ...
    def __str__(self) -> builtins.str: ...

@typing.final
class SubpathAmount:
    @property
    def raw_value(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.int) -> SubpathAmount: ...

@typing.final
class Weight:
    @property
    def raw_value(self) -> builtins.int: ...
    def __eq__(self, other: builtins.object) -> builtins.bool: ...
    def __hash__(self) -> builtins.int: ...
    def __str__(self) -> builtins.str: ...
    def __new__(cls, value: builtins.int) -> Weight: ...

@typing.final
class AffixClassEnum(enum.Enum):
    Base = ...
    Desecrated = ...
    Essence = ...

@typing.final
class AffixLocationEnum(enum.Enum):
    Socket = ...
    Prefix = ...
    Suffix = ...

@typing.final
class AffixTierLevelBoundsEnum(enum.Enum):
    Exact = ...
    Minimum = ...

@typing.final
class ItemRarityEnum(enum.Enum):
    Normal = ...
    Magic = ...
    Rare = ...
    Unique = ...

@typing.final
class MatrixBuilderPreset(enum.Enum):
    r"""
    Collection of presets provided from CraftPath by default
    """
    HappyPathMatrixBuilder = ...
    r"""
    Builds a tree-like structure for item propagation,
    while trying to stay on the 'Happy Path'
    """

    def get_instance(self) -> DynMatrixBuilder: ...

@typing.final
class PriceKind(enum.Enum):
    Divine = ...
    Exalted = ...
    Chaos = ...

@typing.final
class StatisticAnalyzerCurrencyGroupPreset(enum.Enum):
    r"""
    Collection of presets provided from CraftPath by default
    """
    CurrencyGroupChance = ...
    r"""
    Collect ALL currency sequences that lead to the target item, sorted by chance
    Additionally, SUMS of all unique subpaths and returns ONE averaged out subpath
    """
    CurrencyGroupChanceMemoryHeavy = ...
    r"""
    Collect ALL currency sequences that lead to the target item, sorted by chance
    Additionally, collects and returns ALL unique subpaths
    """

    def get_instance(self) -> DynStatisticAnalyzerCurrencyGroups: ...

@typing.final
class StatisticAnalyzerPathPreset(enum.Enum):
    r"""
    Collection of presets provided from CraftPath by default
    """
    UniquePathChance = ...
    r"""
    Returns N (= amount_routes) paths sorted by chance,
    applying statistics DURING collection
    """
    UniquePathEfficiency = ...
    r"""
    Returns N (= amount_routes) paths sorted by cost * tries needed for 60 percent,
    applying statistics DURING collection
    """
    UniquePathCost = ...
    r"""
    Returns N (= amount_routes) paths sorted by cost,
    applying statistics DURING collection
    """
    UniquePathChanceMemoryHeavy = ...
    r"""
    Collects and returns ALL unique subpaths,
    applying statistics AFTER collection
    (amount_routes is ignored)
    """

    def get_instance(self) -> DynStatisticAnalyzerPaths: ...

def check_for_updates_and_print() -> builtins.bool: ...

def retrieve_contents_from_urls_with_cache_unstable_order(cache_url_map: typing.Mapping[builtins.str, builtins.str], max_cache_duration_in_sec: builtins.int) -> builtins.list[builtins.str]:
    r"""
    * Order-preservation of `cache_url_map` is not guaranteed.
    * If order is required, split requests into single function calls.
    * E. g. Group 1. item info, Group 2. economy.
    """

