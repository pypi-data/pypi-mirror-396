# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# src/pdftl/cli/help.py

"""Help for CLI interface"""

import importlib.metadata
import itertools
import logging
import sys
import textwrap
from datetime import date

logger = logging.getLogger(__name__)

import pikepdf
from rich import box

logger = logging.getLogger(__name__)
from rich.console import Console, ConsoleOptions, RenderResult
from rich.markdown import Heading, Markdown
from rich.markup import escape
from rich.panel import Panel
from rich.text import Text

from pdftl.cli.console import console
from pdftl.cli.help_data import (
    SPECIAL_HELP_TOPICS_MAP,
    SYNOPSIS_TEMPLATE,
    VERSION_TEMPLATE,
)
from pdftl.cli.whoami import HOMEPAGE, PACKAGE, WHOAMI
from pdftl.core.cli_data import CLI_DATA
from pdftl.core.registry import registry
from pdftl.utils.string import before_space


class LeftJustifiedHeading(Heading):
    def __rich_console__(
        self, console: Console, options: ConsoleOptions
    ) -> RenderResult:
        text = self.text
        text.justify = "left"
        if self.tag == "h1":
            # Draw a border around h1s
            yield Panel(
                text,
                box=box.HEAVY,
                style="markdown.h1.border",
            )
        else:
            # Styled text for h2 and beyond
            if self.tag == "h2":
                yield Text("")
            yield text


class HelpMarkdown(Markdown):
    elements = {
        **Markdown.elements,
        "heading_open": LeftJustifiedHeading,
    }

    def __init__(self, markup, *args, **kwargs):
        self.source = markup
        super().__init__(markup, *args, **kwargs)

    def __str__(self):
        return self.source


def get_synopsis():
    """Returns the main synopsis text for the application."""
    # Note: Using Markdown syntax here provides better output when rendered by rich
    special_help_topics = " | ".join(
        [f"{x[0]}" for x in SPECIAL_HELP_TOPICS_MAP.keys()]
    )
    ret = SYNOPSIS_TEMPLATE.strip().format(
        whoami=WHOAMI, special_help_topics=special_help_topics
    )
    return ret


def get_project_version():
    """
    Gets the project version from installed package metadata or the
    setuptools_scm generated _version.py file.
    """
    # 1. Try standard package metadata (Best for pip-installed users)
    try:
        return importlib.metadata.version("pdftl")
    except importlib.metadata.PackageNotFoundError:
        pass

    # 2. Fallback: Read the file generated by setuptools_scm
    # This works for local dev/editable installs where metadata might fail
    try:
        # Since help.py is in pdftl.cli, we import from the package root
        # pylint: disable=import-outside-toplevel
        from pdftl._version import version

        return version
    except ImportError:
        # _version.py might not exist if setuptools_scm hasn't run yet
        return "unknown-dev-version"


def print_version(dest=None):
    """Prints detailed version information for the package and its core dependencies."""

    dependencies = "\n".join(
        [
            f"  - {name} {version}"
            for name, version in [
                ("python", sys.version.split()[0]),
                ("pikepdf", pikepdf.__version__),
                ("libqpdf", pikepdf.__libqpdf_version__),
            ]
        ]
    )

    start_year = 2025
    current_year = date.today().year
    output = VERSION_TEMPLATE.strip().format(
        whoami=WHOAMI,
        package=PACKAGE,
        project_version=get_project_version(),
        years=(
            str(start_year)
            if current_year <= start_year
            else f"{start_year}-{current_year}"
        ),
        homepage=HOMEPAGE,
        dependencies=dependencies,
    )

    if dest is None or dest is sys.stdout or dest is sys.stderr:
        console.print(output)
    else:
        print(output, file=dest)


def _format_examples_block(examples, show_topics=False):
    """
    Formats the examples into a rich-ready Markdown block.
    We convert the structured data into a Markdown code/list structure.
    """
    output = "## Examples\n\n"
    per_example_topic_count = 1
    topic = None

    for ex in examples:
        # Add topic heading if necessary
        if show_topics and ex.get("topic"):
            if ex["topic"] == topic:
                per_example_topic_count += 1
            else:
                per_example_topic_count = 1
            topic = ex["topic"]

            # Use Markdown heading or strong text for topics
            heading_text = f"Example{f' {per_example_topic_count}' if per_example_topic_count > 1 else ''} for '`{topic}`'"
            output += f"### {heading_text}\n"

        assert "desc" in ex and "cmd" in ex

        # Use a quote block for description and a fenced code block for command
        output += f"> {ex['desc']}\n"
        output += f"```\n{WHOAMI} {ex['cmd'].strip()}\n```\n\n"

    return output.rstrip()


def _usage_as_markdown(x: str) -> str:
    return " ".join(map(lambda y: f"`{y}`", x.strip().split()))


def _print_topic_help(hprint, topic_data, topic_name):
    """Prints the detailed help for a specific command or topic."""
    safe_topic_name = (
        topic_name
        if any(topic_name in x for x in SPECIAL_HELP_TOPICS_MAP)
        else f"`{topic_name}`"
    )

    hprint(HelpMarkdown(f"# {WHOAMI}: help for {safe_topic_name}"))

    if desc := topic_data.get("desc", None):
        hprint(HelpMarkdown(f"\n{desc.strip()}"))

    if usage := topic_data.get("usage", None):
        usage_string = f"## Usage\n> {WHOAMI} {_usage_as_markdown(usage)}"
        hprint(HelpMarkdown(usage_string))

    if long_desc := topic_data.get("long_desc", None):
        cleaned_desc = long_desc.strip()
        hprint(HelpMarkdown("\n## Details\n" + cleaned_desc))

    if examples := topic_data.get("examples", None):
        example_markdown = _format_examples_block(examples)
        hprint(HelpMarkdown(example_markdown))

    if tags := topic_data.get("tags", None):
        hprint(HelpMarkdown(f"\n**Tags**: {', '.join(tags)}"))

    if caller := topic_data.get("caller", None):
        hprint(HelpMarkdown(f"\n*Source: {caller}*"))


def print_main_help(hprint):
    """Prints the main, default help screen."""

    hprint(HelpMarkdown(f"# **{WHOAMI}** - PDF Tackle {get_project_version()}"))
    hprint(HelpMarkdown("_A wannabe CLI compatible clone/extension of pdftk_"))

    hprint(HelpMarkdown("## Usage"))
    hprint(HelpMarkdown("\n```\n" + get_synopsis().strip() + "\n```"))

    # hprint(HelpMarkdown("## Operations\n\n\n"))
    all_ops_and_opts = list(registry.operations) + list(registry.options)

    # # Define a fixed column width based on the longest command name
    # col_width = max(len(x) for x in all_ops_and_opts) + 4

    _print_desc_table(hprint, "Operations", registry.operations)
    _print_desc_table(hprint, "Options", registry.options)


def _print_desc_table(hprint, title, container):
    table = f"|{title}||\n|-|-|\n"
    for operation, info in sorted(list(container.items())):
        table += f"|`{escape(operation)}`|{info['desc']}|\n"
    hprint(HelpMarkdown(table))


def _print_output_options_help(hprint):
    """Prints detailed help for all output options."""
    hprint(HelpMarkdown("# Options for PDF output\n"))
    for opt, info in sorted(registry.options.items()):
        safe_opt = escape(opt)
        hprint(HelpMarkdown(f"\n## `{safe_opt}`"))
        hprint(HelpMarkdown(f"\n> {info['desc']}\n"))
        if "long_desc" in info:
            cleaned_desc = info["long_desc"].strip()
            hprint(HelpMarkdown("\n## Details\n"))
            hprint(HelpMarkdown(cleaned_desc))
        if examples := info.get("examples", None):
            example_markdown = _format_examples_block(examples)
            hprint(HelpMarkdown(example_markdown))


def _print_examples_help(hprint):
    """Prints all examples and not much else (uses HelpMarkdown output)."""
    hprint(HelpMarkdown(_format_examples_block(_discover_examples(), show_topics=True)))


def _discover_examples():
    """Find all known CLI examples."""
    all_examples = []
    for topic, topic_data in itertools.chain(
        registry.operations.items(),
        CLI_DATA["extra help topics"].items(),
        registry.options.items(),
    ):
        new_examples = topic_data.get("examples", [])
        for example in new_examples:
            example["topic"] = topic
        all_examples.extend(new_examples)
    return all_examples


def _print_help_dispatch_table():
    """Return a dispatch table for print_help"""
    dispatch_table = {
        before_space(op): (
            lambda hprint, op_info=info, op_name=op: _print_topic_help(
                hprint, op_info, op_name
            )
        )
        for op, info in itertools.chain(
            registry.operations.items(), registry.options.items()
        )
    }
    dispatch_table.update(
        {
            topic: (
                lambda hprint, t_data=data: _print_topic_help(
                    hprint, t_data, t_data["title"]
                )
            )
            for topic, data in CLI_DATA["extra help topics"].items()
        }
    )
    dispatch_table["output_options"] = _print_output_options_help
    dispatch_table["examples"] = _print_examples_help
    return dispatch_table


def print_help(command=None, dest=None, raw=False):
    """
    Displays help information for the tool, a specific command, or a topic.

    Args:
        command (str, optional): The command or topic to get help for.
                                 If None, the main help screen is shown.
        dest (file object, optional): The destination to write help text to.
                                      Defaults to sys.stdout.
        raw (bool, optional): If True, output raw markdown/text instead of rendered Rich output.
    """

    def hprint(*args):
        # 1. Process all arguments into rich-compatible objects or raw strings.
        processed_args = []
        for arg in args:
            if isinstance(arg, HelpMarkdown):
                processed_args.append(arg)
            elif isinstance(arg, str):
                if raw:
                    processed_args.append(arg)
                else:
                    processed_args.append(Text.from_markup(arg))
            else:
                processed_args.append(arg)

        # 2. Output handling.
        use_rich_console = not raw and (
            dest is None or dest is sys.stdout or dest is sys.stderr
        )

        if use_rich_console:
            console.print(*processed_args)
        elif not raw:
            # Rendered output for files/pipes (fixes missing table format in files)
            width = console.width if console.width else 80
            file_console = Console(file=dest, width=width, force_terminal=False)
            file_console.print(*processed_args)
        else:
            # Raw output (Markdown source)
            output_parts = []
            for arg in processed_args:
                if isinstance(arg, HelpMarkdown):
                    output_parts.append(str(arg))
                elif isinstance(arg, Text):
                    output_parts.append(arg.plain)
                else:
                    output_parts.append(str(arg))

            output_string = " ".join(output_parts)
            target = dest if dest is not None else sys.stdout
            print(output_string, file=target)

    safe_command = command.lower() if command else None

    if safe_command is None:
        print_main_help(hprint)
    elif safe_command in (dispatch_table := _print_help_dispatch_table()):
        dispatch_table[safe_command](hprint)
    elif safe_command == "all":
        # Iterates through all topics
        all_topics = [
            None,
            "input",
            *sorted(registry.operations),
            "filter_mode",
            "output_options",
            "pipeline",
            "page_specs",
            "help",
        ]
        for i, topic in enumerate(all_topics):
            if i > 0:
                # Use a separator line
                hprint(HelpMarkdown("\n---\n"))
            print_help(topic, dest=dest, raw=raw)
    else:
        logger.warning(
            "Unknown help topic '%s' requested, showing default help\n", command
        )
        print_main_help(hprint)


def find_special_topic_command(topic):
    """Searches for a command within a predefined set of special topics."""
    if topic is None:
        return None
    for keywords, command in SPECIAL_HELP_TOPICS_MAP.items():
        if topic in keywords:
            return command
    return None


def find_operator_topic_command(help_topics):
    """Searches for a command that matches a known operator."""
    return next(
        (topic for topic in help_topics if topic.lower() in registry.operations), None
    )


def find_option_topic_command(help_topics):
    """Searches for a command that matches a known option."""
    known_options = [before_space(opt) for opt in registry.options]
    return next((topic for topic in help_topics if topic in known_options), None)
