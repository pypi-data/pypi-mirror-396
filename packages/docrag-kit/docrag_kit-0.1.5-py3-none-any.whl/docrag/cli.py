"""Command-line interface for DocRAG Kit."""

import click
from pathlib import Path
from docrag import __version__


def create_mcp_server_wrapper(docrag_dir: Path) -> bool:
    """
    Create mcp_server.py wrapper in .docrag directory.
    
    Args:
        docrag_dir: Path to .docrag directory
        
    Returns:
        True if successful, False otherwise
    """
    mcp_server_content = '''#!/usr/bin/env python3
"""
MCP Server wrapper for this project.

This file is auto-generated by DocRAG Kit.

IMPORTANT: This wrapper should be run via the installed docrag package:
    python -m docrag.mcp_server
    
NOT directly as a script (relative imports won't work):
    python .docrag/mcp_server.py  # ‚ùå Don't do this

For MCP configuration, use:
    docrag mcp-config
"""

import sys
from pathlib import Path

print("‚ö†Ô∏è  WARNING: This wrapper is deprecated!", file=sys.stderr)
print("   Use 'python -m docrag.mcp_server' instead", file=sys.stderr)
print("   Or run 'docrag mcp-config' to update your MCP configuration", file=sys.stderr)
sys.exit(1)
'''
    
    try:
        mcp_server_path = docrag_dir / "mcp_server.py"
        mcp_server_path.write_text(mcp_server_content)
        mcp_server_path.chmod(0o755)  # Make executable
        return True
    except Exception:
        return False


@click.group()
@click.version_option(version=__version__, prog_name="docrag")
def cli():
    """DocRAG Kit - Universal RAG system for project documentation.
    
    Quick start:
    1. Run 'docrag init' to initialize RAG system in your project
    2. Run 'docrag index' to index your documentation
    3. Run 'docrag mcp-config' to get MCP server configuration
    """
    pass


@cli.command()
@click.option("--non-interactive", is_flag=True, help="Use default values without prompts")
@click.option("--template", type=click.Choice(['general', 'symfony', 'ios']), default='general', help="Project template to use")
def init(non_interactive, template):
    """Initialize DocRAG in current project."""
    from pathlib import Path
    from .config_manager import ConfigManager
    
    # Check if .docrag/ already exists
    docrag_dir = Path.cwd() / ".docrag"
    if docrag_dir.exists():
        click.echo("‚ùå Error: .docrag/ directory already exists")
        click.echo("   DocRAG is already initialized in this project")
        click.echo("   Use 'docrag config --edit' to modify configuration")
        return
    
    try:
        # Run setup wizard (interactive or non-interactive)
        config_manager = ConfigManager()
        if non_interactive:
            # Use default configuration based on template
            from .config_manager import DocRAGConfig
            config = DocRAGConfig.from_template(template)
            click.echo(f"‚úÖ Using {template} template with default values")
        else:
            config = config_manager.interactive_setup()
        
        # Create .docrag/ directory
        docrag_dir.mkdir(parents=True, exist_ok=True)
        
        # Save configuration to config.yaml
        config_manager.save_config(config)
        click.echo(f"\n‚úÖ Configuration saved to {config_manager.config_path}")
        
        # Create .docrag/.gitignore
        from .security import (
            create_docrag_gitignore, 
            display_gitignore_warning,
            create_env_example,
            display_security_reminder
        )
        
        if create_docrag_gitignore(docrag_dir):
            click.echo(f"‚úÖ Created {docrag_dir / '.gitignore'}")
        else:
            click.echo(f"‚ö†Ô∏è  Failed to create {docrag_dir / '.gitignore'}")
        
        # Create .env.example template
        if create_env_example(Path.cwd()):
            click.echo(f"‚úÖ Created .env.example template")
        else:
            click.echo(f"‚ö†Ô∏è  Failed to create .env.example")
        
        # Create mcp_server.py wrapper
        if create_mcp_server_wrapper(docrag_dir):
            click.echo(f"‚úÖ Created {docrag_dir / 'mcp_server.py'}")
        else:
            click.echo(f"‚ö†Ô∏è  Failed to create {docrag_dir / 'mcp_server.py'}")
        
        # Check root .gitignore and warn if .env is not excluded
        display_gitignore_warning(Path.cwd(), offer_fix=True)
        
        # Display security reminder
        display_security_reminder()
        
        # Display next steps
        click.echo("\nüìù Next steps:")
        click.echo("   1. Run: docrag index")
        click.echo("   2. Run: docrag mcp-config")
        click.echo("\n   Documentation: https://github.com/docrag-kit/docrag-kit")
        
    except KeyboardInterrupt:
        click.echo("\n\n‚ùå Setup cancelled")
        return
    except Exception as e:
        click.echo(f"\n‚ùå Error during initialization: {e}")
        return


@cli.command()
def fix_prompt():
    """Fix prompt template to include required placeholders."""
    from pathlib import Path
    from .config_manager import ConfigManager
    import yaml
    
    config_manager = ConfigManager()
    
    # Check if configuration exists
    if not config_manager.config_path.exists():
        click.echo("‚ùå Error: DocRAG not initialized in this project")
        click.echo("   Run 'docrag init' first")
        return
    
    try:
        # Load configuration
        config = config_manager.load_config()
        if not config:
            click.echo("‚ùå Error: Failed to load configuration")
            return
        
        # Check if template has required placeholders
        template = config.prompt.template
        if '{context}' in template and '{question}' in template:
            click.echo("‚úÖ Prompt template already has required placeholders")
            return
        
        click.echo("üîß Fixing prompt template...")
        click.echo(f"\nüìã Current template (first 200 chars):")
        click.echo(f"{'=' * 80}")
        click.echo(template[:200] + "..." if len(template) > 200 else template)
        click.echo(f"{'=' * 80}\n")
        
        # Get project type and name
        project_type = config.project.type
        project_name = config.project.name
        
        # Create fixed template based on project type
        if project_type == 'symfony':
            base_instruction = f"You are an expert assistant for the {project_name} project - a Symfony-based application."
        elif project_type == 'ios':
            base_instruction = f"You are an iOS development expert for the {project_name} project."
        else:
            base_instruction = f"You are a developer assistant for the {project_name} project."
        
        fixed_template = f"""{base_instruction}
Answer questions based on the provided documentation context.
Be concise and accurate. Respond in Russian if the question is in Russian.
If you don't know the answer based on the context, say so.

Context:
{{context}}

Question: {{question}}

Answer:"""
        
        # Update configuration
        config.prompt.template = fixed_template
        config_manager.save_config(config)
        
        click.echo(f"‚úÖ Fixed prompt template")
        click.echo(f"\nüìù New template:")
        click.echo(f"{'=' * 80}")
        click.echo(fixed_template)
        click.echo(f"{'=' * 80}\n")
        click.echo(f"‚úÖ Configuration saved to {config_manager.config_path}")
        click.echo("\nüìù Next steps:")
        click.echo("   1. Restart Kiro IDE to reload MCP server")
        click.echo("   2. Try asking a question with answer_question tool")
        
    except Exception as e:
        click.echo(f"‚ùå Error fixing prompt template: {e}")
        import traceback
        traceback.print_exc()


@cli.command()
@click.option("--force", is_flag=True, help="Overwrite existing database without confirmation")
def index(force):
    """Index project documents."""
    from pathlib import Path
    from .config_manager import ConfigManager
    from .document_processor import DocumentProcessor
    from .vector_db import VectorDBManager
    
    project_root = Path.cwd()
    
    # Load configuration
    config_manager = ConfigManager(project_root)
    config = config_manager.load_config()
    
    if config is None:
        click.echo("‚ùå Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    # Convert config to dictionary for processors
    config_dict = config.to_dict()
    
    try:
        # Check for API key
        vector_db = VectorDBManager(config_dict, project_root)
        
        # Check if database already exists
        db_path = project_root / ".docrag" / "vectordb"
        if db_path.exists() and not force:
            click.echo("‚ö†Ô∏è  Vector database already exists - overwriting...")
            # Automatically overwrite without confirmation
        
        # Scan and load documents
        click.echo("\nüìÅ Scanning documents...")
        doc_processor = DocumentProcessor(config_dict)
        chunks, stats = doc_processor.process(project_root)
        
        if stats['files_found'] == 0:
            click.echo("‚ùå No files found to index")
            click.echo("   Check your configuration:")
            click.echo(f"   - Directories: {config.indexing.directories}")
            click.echo(f"   - Extensions: {config.indexing.extensions}")
            return
        
        # Display file count
        click.echo(f"‚úÖ Found {stats['files_found']} files to index")
        
        if stats['files_processed'] < stats['files_found']:
            click.echo(f"‚ö†Ô∏è  {stats['files_found'] - stats['files_processed']} files failed to load")
        
        # Create vector database
        click.echo(f"\nüìä Creating vector database...")
        click.echo(f"   Processing {stats['chunks_created']} chunks...")
        
        vector_db.create_database(chunks, show_progress=True)
        
        # Display statistics
        click.echo("\n‚úÖ Indexing complete!")
        click.echo(f"   Files processed: {stats['files_processed']}")
        click.echo(f"   Chunks created: {stats['chunks_created']}")
        click.echo(f"   Total characters: {stats['total_characters']:,}")
        
        # Display next steps
        click.echo("\nüìù Next steps:")
        click.echo("   Run: docrag mcp-config")
        
    except ValueError as e:
        click.echo(f"\n{e}")
        return
    except Exception as e:
        click.echo(f"\n‚ùå Error during indexing: {e}")
        import traceback
        traceback.print_exc()
        return


@cli.command()
@click.option("--force", is_flag=True, help="Skip confirmation prompt")
def reindex(force):
    """Rebuild vector database from scratch."""
    from pathlib import Path
    from .config_manager import ConfigManager
    from .document_processor import DocumentProcessor
    from .vector_db import VectorDBManager
    
    project_root = Path.cwd()
    
    # Load configuration
    config_manager = ConfigManager(project_root)
    config = config_manager.load_config()
    
    if config is None:
        click.echo("‚ùå Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    # Convert config to dictionary for processors
    config_dict = config.to_dict()
    
    # Display info message
    click.echo("‚ö†Ô∏è  Rebuilding vector database from scratch...")
    click.echo("   All indexed data will be removed and rebuilt")
    
    try:
        # Initialize vector database manager
        vector_db = VectorDBManager(config_dict, project_root)
        
        # Delete old database
        click.echo("\nüóëÔ∏è  Deleting old database...")
        vector_db.delete_database()
        click.echo("‚úÖ Old database deleted")
        
        # Scan and load documents
        click.echo("\nüìÅ Scanning documents...")
        doc_processor = DocumentProcessor(config_dict)
        chunks, stats = doc_processor.process(project_root)
        
        if stats['files_found'] == 0:
            click.echo("‚ùå No files found to index")
            click.echo("   Check your configuration:")
            click.echo(f"   - Directories: {config.indexing.directories}")
            click.echo(f"   - Extensions: {config.indexing.extensions}")
            return
        
        # Display file count
        click.echo(f"‚úÖ Found {stats['files_found']} files to index")
        
        if stats['files_processed'] < stats['files_found']:
            click.echo(f"‚ö†Ô∏è  {stats['files_found'] - stats['files_processed']} files failed to load")
        
        # Create vector database
        click.echo(f"\nüìä Creating vector database...")
        click.echo(f"   Processing {stats['chunks_created']} chunks...")
        
        vector_db.create_database(chunks, show_progress=True)
        
        # Display updated statistics
        click.echo("\n‚úÖ Reindexing complete!")
        click.echo(f"   Files processed: {stats['files_processed']}")
        click.echo(f"   Chunks created: {stats['chunks_created']}")
        click.echo(f"   Total characters: {stats['total_characters']:,}")
        
    except ValueError as e:
        click.echo(f"\n{e}")
        return
    except Exception as e:
        click.echo(f"\n‚ùå Error during reindexing: {e}")
        import traceback
        traceback.print_exc()
        return


@cli.command()
@click.option("--edit", is_flag=True, help="Open configuration in editor")
def config(edit):
    """Display or edit current configuration."""
    from pathlib import Path
    import subprocess
    import os
    import yaml
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    config_manager = ConfigManager(project_root)
    
    # Check if configuration exists
    if not config_manager.config_path.exists():
        click.echo("‚ùå Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    if edit:
        # Open configuration in editor
        click.echo("‚úèÔ∏è  Opening configuration in editor...")
        
        # Determine editor (use EDITOR env var or default to system editor)
        editor = os.environ.get('EDITOR')
        
        if not editor:
            # Try common editors
            if os.system('which code > /dev/null 2>&1') == 0:
                editor = 'code'
            elif os.system('which nano > /dev/null 2>&1') == 0:
                editor = 'nano'
            elif os.system('which vim > /dev/null 2>&1') == 0:
                editor = 'vim'
            elif os.system('which vi > /dev/null 2>&1') == 0:
                editor = 'vi'
            else:
                # Fallback to open (macOS) or xdg-open (Linux)
                import platform
                if platform.system() == 'Darwin':
                    editor = 'open'
                else:
                    editor = 'xdg-open'
        
        try:
            subprocess.run([editor, str(config_manager.config_path)])
            click.echo("‚úÖ Configuration file opened")
        except Exception as e:
            click.echo(f"‚ùå Error opening editor: {e}")
            click.echo(f"   Try manually editing: {config_manager.config_path}")
    
    else:
        # Display current configuration
        click.echo("‚öôÔ∏è  Current configuration:\n")
        
        try:
            # Load and display YAML
            with open(config_manager.config_path, 'r', encoding='utf-8') as f:
                config_data = yaml.safe_load(f)
            
            # Pretty print the configuration
            click.echo(yaml.dump(config_data, default_flow_style=False, sort_keys=False))
            
            click.echo(f"\nüìÅ Configuration file: {config_manager.config_path}")
            click.echo("   Use 'docrag config --edit' to modify")
        
        except Exception as e:
            click.echo(f"‚ùå Error reading configuration: {e}")


@cli.command("mcp-config")
def mcp_config():
    """Display MCP server configuration for Kiro."""
    from pathlib import Path
    import json
    import platform
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    config_manager = ConfigManager(project_root)
    
    # Check if configuration exists
    if not config_manager.config_path.exists():
        click.echo("‚ùå Error: Configuration not found")
        click.echo("   Run 'docrag init' to initialize DocRAG first")
        return
    
    # Load configuration to get project name
    config = config_manager.load_config()
    if config is None:
        click.echo("‚ùå Error: Failed to load configuration")
        return
    
    project_name = config.project.name
    
    # Get absolute path to mcp_server.py
    mcp_server_path = project_root / ".docrag" / "mcp_server.py"
    
    # Check if mcp_server.py exists
    if not mcp_server_path.exists():
        click.echo("‚ö†Ô∏è  Warning: mcp_server.py not found")
        click.echo(f"   Expected at: {mcp_server_path}")
        click.echo("   This file should be created during 'docrag init'")
        return
    
    # Generate MCP server configuration
    # Use simple name like other MCP servers (context7, perplexity, etc.)
    server_name = "docrag"
    
    # Detect Python executable with MCP library installed
    import sys
    import subprocess
    
    def find_python_with_mcp():
        """Find Python executable that has mcp library installed."""
        # Try current Python first
        candidates = [sys.executable]
        
        # Add common pyenv Python 3.10+ locations
        pyenv_root = Path.home() / ".pyenv" / "versions"
        if pyenv_root.exists():
            for version_dir in sorted(pyenv_root.iterdir(), reverse=True):
                if version_dir.is_dir() and version_dir.name.startswith("3.1"):
                    python_bin = version_dir / "bin" / "python"
                    if python_bin.exists():
                        candidates.append(str(python_bin))
        
        # Test each candidate
        for python_path in candidates:
            try:
                result = subprocess.run(
                    [python_path, "-c", "import mcp; import docrag"],
                    capture_output=True,
                    timeout=5
                )
                if result.returncode == 0:
                    return python_path
            except:
                continue
        
        # Fallback to current Python
        return sys.executable
    
    python_executable = find_python_with_mcp()
    
    # Use module execution instead of script path to avoid import issues
    mcp_config = {
        "mcpServers": {
            server_name: {
                "command": python_executable,
                "args": ["-m", "docrag.mcp_server"],
                "cwd": str(project_root),
                "env": {},
                "disabled": False,
                "autoApprove": []
            }
        }
    }
    
    # Display configuration
    click.echo("üîå MCP Server Configuration for Kiro\n")
    click.echo("Add this to your Kiro MCP configuration file:")
    click.echo(".kiro/settings/mcp.json (workspace config)\n")
    
    click.echo("```json")
    click.echo(json.dumps(mcp_config, indent=2))
    click.echo("```\n")
    
    # Display manual instructions
    click.echo("üìù Manual Setup Instructions:")
    click.echo("1. Open or create: .kiro/settings/mcp.json")
    click.echo("2. Add the above configuration to the 'mcpServers' section")
    click.echo("3. Restart Kiro or reload MCP servers")
    click.echo("4. The server will appear as: " + server_name)
    
    # Try to add to workspace config automatically
    workspace_config_path = project_root / ".kiro" / "settings" / "mcp.json"
    
    click.echo("\nüéØ Adding to workspace configuration...")
    
    if click.confirm("   Would you like to automatically add this configuration?", default=True):
        try:
            # Read existing config or create new one
            if workspace_config_path.exists():
                # Backup existing config
                backup_path = workspace_config_path.with_suffix('.json.backup')
                import shutil
                shutil.copy2(workspace_config_path, backup_path)
                click.echo(f"   ‚úÖ Backed up existing config to {backup_path}")
                
                # Load existing config
                with open(workspace_config_path, 'r', encoding='utf-8') as f:
                    existing_config = json.load(f)
            else:
                existing_config = {"mcpServers": {}}
            
            # Ensure mcpServers exists
            if "mcpServers" not in existing_config:
                existing_config["mcpServers"] = {}
            
            # Add new server entry
            existing_config["mcpServers"][server_name] = mcp_config["mcpServers"][server_name]
            
            # Ensure directory exists
            workspace_config_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write updated config
            with open(workspace_config_path, 'w', encoding='utf-8') as f:
                json.dump(existing_config, f, indent=2)
            
            click.echo(f"   ‚úÖ Configuration added to {workspace_config_path}")
            click.echo("   üîÑ Restart Kiro or reload MCP servers to activate")
            
            # Add note about user config option
            click.echo("\nüí° Note: Configuration added to workspace config (.kiro/settings/mcp.json)")
            click.echo("   This makes the MCP server available only in this workspace")
            click.echo("   To make it available globally, add to: ~/.kiro/settings/mcp.json")
        
        except Exception as e:
            click.echo(f"   ‚ùå Error adding configuration: {e}")
            click.echo("   Please add the configuration manually")
    else:
        click.echo("\nüí° Tip: You can manually add the configuration to:")
        click.echo("   - Workspace: .kiro/settings/mcp.json (recommended)")
        click.echo("   - User: ~/.kiro/settings/mcp.json (global)")


@cli.command()
def doctor():
    """Diagnose DocRAG installation and configuration issues."""
    from pathlib import Path
    import os
    import sys
    from .config_manager import ConfigManager
    
    project_root = Path.cwd()
    issues_found = []
    warnings_found = []
    
    click.echo("üîç DocRAG Health Check\n")
    click.echo("=" * 70)
    
    # Check 1: DocRAG initialization
    click.echo("\nüì¶ Checking DocRAG initialization...")
    docrag_dir = project_root / ".docrag"
    if not docrag_dir.exists():
        issues_found.append("DocRAG not initialized (.docrag/ directory missing)")
        click.echo("   ‚ùå .docrag/ directory not found")
        click.echo("      Run: docrag init")
    else:
        click.echo("   ‚úÖ .docrag/ directory exists")
    
    # Check 2: Configuration file
    click.echo("\n‚öôÔ∏è  Checking configuration...")
    config_path = docrag_dir / "config.yaml"
    if not config_path.exists():
        issues_found.append("Configuration file missing (.docrag/config.yaml)")
        click.echo("   ‚ùå config.yaml not found")
        click.echo("      Run: docrag init")
    else:
        click.echo("   ‚úÖ config.yaml exists")
        try:
            config_manager = ConfigManager(project_root)
            config = config_manager.load_config()
            if config:
                click.echo(f"      Project: {config.project.name}")
                click.echo(f"      Type: {config.project.type}")
                click.echo(f"      LLM Provider: {config.llm.provider}")
        except Exception as e:
            issues_found.append(f"Configuration file is invalid: {e}")
            click.echo(f"   ‚ùå Failed to load config: {e}")
    
    # Check 3: API Keys
    click.echo("\nüîë Checking API keys...")
    env_path = project_root / ".env"
    if not env_path.exists():
        warnings_found.append(".env file not found")
        click.echo("   ‚ö†Ô∏è  .env file not found")
        click.echo("      Create .env and add your API key")
    else:
        click.echo("   ‚úÖ .env file exists")
        # Check if API key is set (without exposing it)
        from dotenv import load_dotenv
        load_dotenv(env_path)
        
        openai_key = os.getenv('OPENAI_API_KEY')
        google_key = os.getenv('GOOGLE_API_KEY')
        
        if openai_key and len(openai_key) > 10:
            click.echo("      ‚úÖ OPENAI_API_KEY is set")
        else:
            warnings_found.append("OPENAI_API_KEY not set or empty")
            click.echo("      ‚ö†Ô∏è  OPENAI_API_KEY not set")
        
        if google_key and len(google_key) > 10:
            click.echo("      ‚úÖ GOOGLE_API_KEY is set")
    
    # Check 4: Vector database
    click.echo("\nüìä Checking vector database...")
    vectordb_path = docrag_dir / "vectordb"
    if not vectordb_path.exists():
        warnings_found.append("Vector database not created yet")
        click.echo("   ‚ö†Ô∏è  Vector database not found")
        click.echo("      Run: docrag index")
    else:
        click.echo("   ‚úÖ Vector database exists")
        # Check size
        total_size = sum(f.stat().st_size for f in vectordb_path.rglob('*') if f.is_file())
        size_mb = total_size / (1024 * 1024)
        click.echo(f"      Size: {size_mb:.1f} MB")
        
        if size_mb < 0.1:
            warnings_found.append("Vector database is very small (might be empty)")
            click.echo("      ‚ö†Ô∏è  Database seems empty, consider reindexing")
    
    # Check 5: Python environment
    click.echo("\nüêç Checking Python environment...")
    click.echo(f"   Python version: {sys.version.split()[0]}")
    
    if sys.version_info < (3, 10):
        issues_found.append(f"Python {sys.version_info.major}.{sys.version_info.minor} is too old (need 3.10+)")
        click.echo("   ‚ùå Python 3.10+ required")
    else:
        click.echo("   ‚úÖ Python version OK")
    
    # Check 6: Required packages
    click.echo("\nüìö Checking required packages...")
    required_packages = ['langchain', 'chromadb', 'openai', 'mcp']
    for package in required_packages:
        try:
            __import__(package)
            click.echo(f"   ‚úÖ {package} installed")
        except ImportError:
            issues_found.append(f"Required package '{package}' not installed")
            click.echo(f"   ‚ùå {package} not installed")
    
    # Check 7: MCP configuration
    click.echo("\nüîå Checking MCP configuration...")
    workspace_mcp = project_root / ".kiro" / "settings" / "mcp.json"
    user_mcp = Path.home() / ".kiro" / "settings" / "mcp.json"
    
    mcp_configured = False
    if workspace_mcp.exists():
        click.echo("   ‚úÖ Workspace MCP config exists")
        mcp_configured = True
        try:
            import json
            with open(workspace_mcp) as f:
                mcp_data = json.load(f)
                if "mcpServers" in mcp_data and "docrag" in mcp_data["mcpServers"]:
                    click.echo("      ‚úÖ docrag server configured")
                else:
                    warnings_found.append("docrag server not found in MCP config")
                    click.echo("      ‚ö†Ô∏è  docrag server not configured")
        except Exception as e:
            warnings_found.append(f"Failed to read MCP config: {e}")
            click.echo(f"      ‚ö†Ô∏è  Failed to read config: {e}")
    
    if user_mcp.exists():
        click.echo("   ‚ÑπÔ∏è  User MCP config exists")
        mcp_configured = True
    
    if not mcp_configured:
        warnings_found.append("MCP not configured")
        click.echo("   ‚ö†Ô∏è  MCP not configured")
        click.echo("      Run: docrag mcp-config")
    
    # Summary
    click.echo("\n" + "=" * 70)
    click.echo("\nüìã Summary:\n")
    
    if not issues_found and not warnings_found:
        click.echo("‚úÖ Everything looks good! DocRAG is properly configured.")
    else:
        if issues_found:
            click.echo(f"‚ùå Found {len(issues_found)} issue(s):")
            for issue in issues_found:
                click.echo(f"   ‚Ä¢ {issue}")
        
        if warnings_found:
            click.echo(f"\n‚ö†Ô∏è  Found {len(warnings_found)} warning(s):")
            for warning in warnings_found:
                click.echo(f"   ‚Ä¢ {warning}")
        
        click.echo("\nüí° Quick fixes:")
        if "DocRAG not initialized" in str(issues_found):
            click.echo("   1. Run: docrag init")
        if "Vector database not created" in str(warnings_found):
            click.echo("   2. Run: docrag index")
        if "MCP not configured" in str(warnings_found):
            click.echo("   3. Run: docrag mcp-config")


if __name__ == "__main__":
    cli()
