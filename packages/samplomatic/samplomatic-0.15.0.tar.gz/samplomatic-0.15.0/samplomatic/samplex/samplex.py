# This code is a Qiskit project.
#
# (C) Copyright IBM 2025.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""Samplex"""

from collections.abc import Iterable, Mapping, Sequence
from concurrent.futures import Future, ThreadPoolExecutor, as_completed, wait
from typing import TYPE_CHECKING, Any

import numpy as np
from numpy.random import Generator, SeedSequence, default_rng
from rustworkx import is_isomorphic
from rustworkx.rustworkx import PyDiGraph, topological_generations

from ..aliases import (
    EdgeIndex,
    InterfaceName,
    LayoutMethod,
    LayoutPresets,
    NodeIndex,
    NumSubsystems,
    Parameter,
    ParameterExpression,
    ParamIndex,
    ParamSpec,
    RegisterName,
    Self,
)
from ..annotations import VirtualType
from ..exceptions import SamplexConstructionError, SamplexRuntimeError
from ..tensor_interface import Specification, TensorInterface, TensorSpecification
from ..virtual_registers import VirtualRegister
from ..visualization import plot_graph
from .interfaces import SamplexOutput
from .nodes import CollectionNode, EvaluationNode, Node, SamplingNode
from .parameter_expression_table import ParameterExpressionTable

if TYPE_CHECKING:
    from plotly.graph_objects import Figure

RNG: Generator = default_rng()
"""The default randomness generator."""


class Samplex:
    r"""Represents a probability distribution over circuit parameters and other fields.

    :class:`~.Samplex` is the core type of the samplomatic library. It is a portmanteau of "sampling
    complex".

    In abstract terms, a samplex represents a parametric probability distribution over the
    parameters of some template circuit, as well as other array-valued fields to use in
    post-processing data collected from executing the bound template circuit. In practical terms, it
    implements a :meth:`~.Samplex.sample` method that draws from this distribution to produce a
    collection of arrays that include at least an array of (random) angles valid for the template
    circuit. For example, a samplex instance might implement Pauli twirling on all the layers of
    some base circuit including final measurements, so that the angles returned by sampling from it
    correspond to Pauli gates composed with whatever single-qubit gates exist in the base circuit,
    along with bool arrays that describe how to invert those measurement results flipped by
    measurement twirling. However, its semantics are not limited to this, and its structure is
    highly extensible: new group types, new distributions, new virtual gate propagation techniques
    can be added to the library.

    Internally, a samplex uses a directed acyclic graph (DAG) representation that describes the
    sampling process procedurally. Each node of the graph interacts with a collection of
    :class:`~.VirtualRegister`\s, and connections between nodes denote register dependency: if
    :math:`A \rightarrow B`, then :math:`B` requires :math:`A` to have acted on the registers before
    it is allowed to act. This implies that the flow of the graph is not temporal with respect to
    execution like the DAG of a quantum circuit, but instead flows from nodes responsible for
    generating randomizations to nodes responsible for rendering the processed randomizations as
    outputs. There are three types of nodes:

    * :class:`~.SamplingNode`\s are responsible for instantiating new registers from inputs,
    * :class:`~.EvaluationNode`\s are responsible for transforming, combining, and removing
      registers,
    * :class:`~.CollectionNode`\s are responsible reading registers and writing to output values
      of :meth:`~.Samplex.sample`.

    Samplexes are typically generated by passing a base circuit with annotated box instructions to
    the :func:`~.build` function. Generating one manually is possible, though tedious, and the user
    is then also responsible for constructing a compatible parametric quantum circuit to use as the
    template circuit. The following example shows a simple circuit built into a samplex and template
    pair using the :func:`~.build` function, and plots the resulting DAG of the samplex. The three
    different types of nodes described above are denoted by different shapes.

    .. plotly::
        :include-source:
        :context:

        >>> from samplomatic import build, Twirl
        >>> from qiskit import QuantumCircuit
        >>>
        >>> circuit = QuantumCircuit(2)
        >>> with circuit.box([Twirl()]):
        ...    circuit.cz(0, 1)
        >>> with circuit.box([Twirl()]):
        ...     circuit.measure_all()
        >>>
        >>> template, samplex = build(circuit)
        >>> samplex.draw() # doctest: +SKIP

    Although the DAG is the main component of the data model this object, other information is also
    stored:

    * Samplexes themselves can be parametric (see :attr:`~.add:attr:`~parameters`) and evaluate
      parameter expressions, all of which is stored by the samplex. For example, when constructed
      via :func:`~.build`, a samplex will accept values for all of the parameters accepted by the
      base circuit.
    * Input and output specifications that describe exactly what values are expected as input at
      :meth:`~.sample` time, and what values will be returned, see :meth:`~.inputs` and
      :meth:`~.outputs`.
    * Noise model requirements that specify what types of noise models are compatible with the
      sampling needs of a samplex.
    """

    _RESERVED_INPUTS: frozenset[InterfaceName] = frozenset()
    _RESERVED_OUTPUTS: frozenset[InterfaceName] = frozenset()

    def __init__(self):
        self.graph = PyDiGraph[Node, None]()
        self._finalized = False
        self._param_table = ParameterExpressionTable()
        self._passthrough_params = None
        self._evaluation_streams: list[list[EvaluationNode]] = []
        self._sampling_nodes: list[SamplingNode] = []
        self._collection_nodes: list[CollectionNode] = []
        self._input_specifications: dict[InterfaceName, Specification] = {}
        self._output_specifications: dict[InterfaceName, Specification] = {}

    def __str__(self):
        inputs = self.inputs().describe(
            bound_prefix="  * ", prefix="  - ", width=100, include_free_dimensions=True
        )
        outputs = self.outputs().describe(prefix="    * ", width=100)
        return f"Samplex(<{len(self.graph)} nodes>)\n  Inputs:\n{inputs}\n  Outputs:\n{outputs}"

    @property
    def parameters(self) -> list[Parameter]:
        """The sorted parameters expecting values at sampling time."""
        return self._param_table.parameters

    @property
    def num_parameters(self) -> int:
        """The number of parameters expected at sampling time."""
        return self._param_table.num_parameters

    def append_parameter_expression(self, expression: ParameterExpression) -> ParamIndex:
        """Add a parameter expression to the samplex.

        An expression needs to be added to a samplex before a node can be added that references it.
        An entry will be inserted into :attr:`~.parameters` in sorted order for every new parameter
        appearing in the given parameter expression.

        Args:
            expression: A parameter or parameter expression.

        Returns:
            An index that parametric nodes can use to referenced the evaluated expression.
        """
        return self._param_table.append(expression)

    def set_passthrough_params(self, passthrough_params: ParamSpec) -> int:
        """Set the mapping for passthrough parameters.

        Some parameters are not influenced by virtual gate propagation and are not set
        by collection nodes. These parameters are only mapped from the original circuit
        parameters, to the template circuit parameters. This function sets the mapping
        for these parameters.

        Args:
            passthrough_params: `ParamSpec` for the passthrough parameters.

        Returns: The maximum template parameter index in `passthrough_params`.
        """
        param_idxs = []
        param_exp_idxs = []
        for idx, exp in passthrough_params:
            param_idxs.append(idx)
            param_exp_idxs.append(self.append_parameter_expression(exp))
        self._passthrough_params = (param_idxs, param_exp_idxs)
        return max(param_idxs)

    def add_input(self, specification: Specification):
        """Add a sampling input to this samplex.

        Args:
            specification: A specification of the input name and type.
        """
        if specification.name in self._RESERVED_INPUTS:
            raise SamplexConstructionError(
                f"Input name '{specification.name}' is reserved and cannot be used."
            )
        if (name := specification.name) in self._input_specifications:
            raise SamplexConstructionError(f"An input with name '{name}' already exists.")
        self._input_specifications[name] = specification

    def add_output(self, specification: Specification):
        """Add a sampling output to this samplex.

        Args:
            specification: A specification of the ouput name and type.
        """
        if specification.name in self._RESERVED_OUTPUTS:
            raise SamplexConstructionError(
                f"Output name '{specification.name}' is reserved and cannot be used."
            )
        if (name := specification.name) in self._output_specifications:
            raise SamplexConstructionError(f"An output with name '{name}' already exists.")
        self._output_specifications[name] = specification

    def add_node(self, node: Node) -> NodeIndex:
        """Add a node to the samplex graph.

        Args:
            node: The node to add.

        Returns:
            The integer index of the added node.
        """
        if node.num_parameters and max(node.parameter_idxs) >= self._param_table.num_expressions:
            raise SamplexConstructionError(
                f"{node} expects to use parameter index {max(node.parameter_idxs)} but "
                f"this samplex only has {self._param_table.num_expressions} parameter "
                "expressions so far."
            )
        self._finalized = False
        return self.graph.add_node(node)

    def add_edge(self, a: NodeIndex, b: NodeIndex) -> EdgeIndex:
        """Add an edge to the samplex graph.

        Args:
            a: The node index of the source node.
            b: The node index of the destination node.

        Returns:
            The integer index of the added edge.
        """
        self._finalized = False
        return self.graph.add_edge(a, b, None)

    def _validate_evaluation_strategy(self):
        register_descriptions: dict[RegisterName, tuple[NumSubsystems, VirtualType]] = {}
        for sampling_node in self._sampling_nodes:
            sampling_node.validate_and_update(register_descriptions)

        for evaluation_stream in self._evaluation_streams:
            for evaluation_node in evaluation_stream:
                evaluation_node.validate_and_update(register_descriptions)

        for collection_node in self._collection_nodes:
            collection_node.validate_and_update(register_descriptions)

    def finalize(self) -> Self:
        """Signal that all nodes and edges have been added, and determine node traversal order.

        Raises:
            SamplexError: If node dependency conflicts are discovered.

        Returns:
            The same instance, for chaining.
        """
        cut_graph = self.graph.copy()

        sampling_nodes: list[SamplingNode] = []
        collection_nodes: list[CollectionNode] = []
        for node_idx in cut_graph.node_indices():
            if isinstance(node := cut_graph[node_idx], SamplingNode):
                sampling_nodes.append(node)
                cut_graph.remove_node(node_idx)
            elif isinstance(node := cut_graph[node_idx], CollectionNode):
                collection_nodes.append(node)
                cut_graph.remove_node(node_idx)

        evaluation_streams: list[list[EvaluationNode]] = []
        for node_idxs in topological_generations(cut_graph):
            evaluation_streams.append([cut_graph[node_idx] for node_idx in node_idxs])

        self._sampling_nodes = sampling_nodes
        self._evaluation_streams = evaluation_streams
        self._collection_nodes = collection_nodes

        self._validate_evaluation_strategy()

        self._finalized = True

        return self

    def inputs(self) -> TensorInterface:
        """Return an object that specifies and helps build the required inputs of :meth:`~sample`.

        Returns:
            The input interface for this samplex.
        """
        return TensorInterface(self._input_specifications.values())

    def outputs(self) -> TensorInterface:
        """Return an object that specifies the promised outputs of :meth:`~sample`.

        Returns:
            The output interface for this samplex.
        """
        return SamplexOutput(self._output_specifications.values())

    def sample(
        self,
        samplex_input: Mapping[str, Any] | None = None,
        num_randomizations: int = 1,
        rng: int | SeedSequence | Generator | None = None,
        keep_registers: bool = False,
        max_workers: int | None = None,
    ) -> SamplexOutput:
        """Sample.

        The following example builds a simple circuit with two parameters into a samplex to
        demonstrate calling this method. In particular, note that required inputs to the samplex
        nodes, which includes both type and array shape information, are listed by :meth:`inputs`,
        and need to be bound with values.

        .. plot::
            :include-source:
            :context:
            :nofigs:

            >>> from samplomatic import build, Twirl
            >>> from qiskit.circuit import QuantumCircuit, Parameter
            >>>
            >>> # quickly make a circuit and build it to construct an example simplex
            >>> circuit = QuantumCircuit(2)
            >>> with circuit.box([Twirl()]):
            ...     circuit.rx(Parameter("a"), 0)
            ...     circuit.rx(Parameter("b"), 0)
            ...     circuit.cz(0, 1)
            >>> with circuit.box([Twirl()]):
            ...     circuit.measure_all()
            >>>
            >>> template, samplex = build(circuit)
            >>>
            >>> # query the samplex for the expected inputs at sample time, and note that we
            >>> # are required to pass a length-2 vector of floats for 'a' and 'b' (alphabetical)
            >>> print(inputs := samplex.inputs())
            TensorInterface(<
                - 'parameter_values' <float64[2]>: Input parameter values to use during sampling.
            >)

            >>> # after binding required values, we can sample 123 randomizations
            >>> samplex.sample(
            ...     inputs.bind(parameter_values=[0.1, 0.2]),
            ...     num_randomizations=123,
            ... ) # doctest: +ELLIPSIS
            SamplexOutput({'measurement_flips.meas': ..., 'parameter_values': ...})

            >>> # alternatively, we can provide any mapping object directly to specify inputs
            >>> samplex.sample(
            ...     {"parameter_values": [0.1, 0.2]},
            ...     num_randomizations=123,
            ... ) # doctest: +ELLIPSIS
            SamplexOutput({'measurement_flips.meas': ..., 'parameter_values': ...})


        Args:
            samplex_input: A mapping from input names to input values, as described by
                :meth:`~.inputs` (see also the :ref:`samplex-io` guide), or ``None`` if
                no input is required. Names that contain a period can use nested dictionary
                expansion. Note that :class:`~.TensorInterface` is a mapping object and is therefore
                a valid input argument when fully bound.
            num_randomizations: The number of randomizations to sample.
            keep_registers: Whether to keep the virtual registers used during sampling and include
                them in the output under the metadata key ``"registers"``.
            rng: An integer for seeding a randomness generator, a generator itself, or ``None``
                to use the default generator owned by the module.
            max_workers: The maximum number of threads that can be used to execute the
                parallel execution of sampling, evaluation, and collection nodes.
        """
        if not self._finalized:
            # this raises instead of calling finalize() to make it impossible
            # to accidentally affect timing benchmarks of sample()
            raise SamplexRuntimeError("The samplex has not been finalized yet, call `finalize()`.")

        if not isinstance(samplex_input, TensorInterface):
            samplex_input = self.inputs().bind(**(samplex_input or {}))

        if not samplex_input.fully_bound:
            raise SamplexRuntimeError(
                "The samplex input is missing values for the following:\n"
                f"{samplex_input.describe(prefix='  * ', include_bound=False)}"
            )

        outputs = self.outputs()
        if keep_registers:
            outputs.metadata["registers"] = {}
        for spec in self._output_specifications.values():
            if isinstance(spec, TensorSpecification):
                shape = tuple(
                    num_randomizations if dim == "num_randomizations" else dim for dim in spec.shape
                )
                outputs[spec.name] = np.empty(shape, dtype=spec.dtype)

        parameter_values = samplex_input.get("parameter_values", [])
        evaluated_values = self._param_table.evaluate(parameter_values)
        if self._passthrough_params:
            outputs["parameter_values"][:, self._passthrough_params[0]] = evaluated_values[
                self._passthrough_params[1]
            ]

        for key in outputs:
            if key.startswith("measurement_flips"):
                outputs[key][:] = 0

        rng = default_rng(rng) if isinstance(rng, int | SeedSequence) else (rng or RNG)

        registers: dict[RegisterName, VirtualRegister] = outputs.metadata.get("registers", {})

        with ThreadPoolExecutor(max_workers) as pool:
            # use rng.spawn() to ensure determinism of PRNG even when there is a thread pool
            wait_with_raise(
                pool.submit(
                    node.sample,
                    registers,
                    child_rng,
                    samplex_input,
                    num_randomizations,
                )
                for child_rng, node in zip(
                    rng.spawn(len(self._sampling_nodes)), self._sampling_nodes
                )
            )

            for stream in self._evaluation_streams:
                wait_with_raise(
                    pool.submit(node.evaluate, registers, evaluated_values[node.parameter_idxs])
                    for node in stream
                )

            wait_with_raise(
                pool.submit(node.collect, registers, outputs, child_rng)
                for child_rng, node in zip(
                    rng.spawn(len(self._collection_nodes)), self._collection_nodes
                )
            )

        return outputs

    def draw(
        self,
        cols: int = 2,
        subgraph_idxs: None | int | Sequence[int] = None,
        layout_method: LayoutPresets | LayoutMethod = "auto",
    ) -> "Figure":
        """Draw the graph in this samplex using the :meth:`~plot_graph` method.

        Args:
            cols: The number of columns in the returned figure.
            subgraph_idxs: The indices of the subgraphs to include in the plot, or ``None``
                to include all of the subgraphs.
            layout_method: A predefined layout method by name, or a callable implementing a layout.

        Returns:
            A Plotly graph.
        """

        def _node_ranker(node: Node) -> int:
            if isinstance(node, SamplingNode):
                return 0
            if isinstance(node, CollectionNode):
                return 1
            return None

        return plot_graph(
            graph=self.graph,
            cols=cols,
            subgraph_idxs=subgraph_idxs,
            layout_method=layout_method,
            ranker=_node_ranker,
        )

    def __eq__(self, other) -> bool:
        """Compare against ``other`` and return ``True`` if the two are equal.

        Samplexes must have isomorphic graphs to be equal. This means that
        two :class:`~.Samplex` objects are equal if they describe the same
        distribution, regardless of graph indexing.
        """
        # We don't compare some internal attributes set by the finalization, as they
        # are drawn directly from the graph.
        return (
            isinstance(other, Samplex)
            and is_isomorphic(self.graph, other.graph, lambda x, y: x == y)
            and self._finalized == other._finalized
            and self._input_specifications == other._input_specifications
            and self._output_specifications == other._output_specifications
            and self._param_table == other._param_table
            and self._passthrough_params == other._passthrough_params
        )


def wait_with_raise(futures: Iterable[Future]):
    """Wait for futures to complete, raising the first exception encountered.

    If there is an exception, cancel all remaining futures.

    Args:
        futures: An iterable of futures to wait on.

    Raises:
        Exception: The first exception encountered among the futures.
    """
    futures = list(futures)
    try:
        for completed_task in as_completed(futures):
            exception = completed_task.exception()
            if exception is not None:
                # Let's cancel the remaining tasks
                for task in futures:
                    # cancel() is a best-effort attempt, and does not guarantee that
                    # the task will be cancelled if already running.
                    task.cancel()
                raise exception
    finally:
        # ensure remaining futures complete or are cancelled
        wait(futures)
