# This code is a Qiskit project.
#
# (C) Copyright IBM 2025.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""GroupMeasIntoBoxes"""

import itertools
from collections import defaultdict
from typing import Literal

from qiskit.circuit import Annotation, Bit
from qiskit.dagcircuit import DAGCircuit
from qiskit.transpiler.basepasses import TransformationPass
from qiskit.transpiler.exceptions import TranspilerError

from ...aliases import DAGOpNode
from ...annotations import ChangeBasis, Twirl
from ...utils import validate_literals
from .utils import make_and_insert_box, validate_op_is_supported


class GroupMeasIntoBoxes(TransformationPass):
    """Collect the measurements in a circuit inside boxes.

    This pass collects all of the measurements in the input circuit in boxes. To assign the
    measurements to these boxes, it uses a greedy collection strategy that tries to collect
    measurements in the earliest possible box that they can fit.

    Args:
        annotations: The annotations placed on the measurement boxes. The supported values are:

            * ``'twirl'`` for a :class:`~.Twirl` annotation.
            * ``'change_basis'`` for a :class:`~.ChangeBasis` annotation with mode
              ``'measure'``.
            * ``'all'`` for both :class:`~.Twirl` and :class:`~.ChangeBasis` annotations.

        prefix_ref: A prefix to all the :class:`.ChangeBasis.ref` generated by this class. Every
            ``ref`` is generated by appending a counter to ``prefix_ref``. In order to avoid
            collisions, the counter is shared across all the instances of this class and it is
            incremented every time that a new ``ref`` is created.
    """

    _REF_COUNTER = itertools.count()

    @validate_literals("annotations")
    def __init__(
        self,
        annotations: Literal["twirl", "change_basis", "all"] = "twirl",
        prefix_ref: str = "basis",
    ):
        super().__init__()

        self.annotations = annotations
        self.prefix_ref = prefix_ref

    def _make_annotations(self) -> list[Annotation]:
        """Make annotations for the boxes created by this pass."""
        if self.annotations == "twirl":
            return [Twirl()]
        if self.annotations == "change_basis":
            return [ChangeBasis(ref=f"{self.prefix_ref}{next(self._REF_COUNTER)}")]
        if self.annotations == "all":
            return [Twirl(), ChangeBasis(ref=f"{self.prefix_ref}{next(self._REF_COUNTER)}")]

        # should be unreachable given validate_literals() call in constructor
        raise

    def run(self, dag: DAGCircuit) -> DAGCircuit:
        """Collect the operations in the dag inside left-dressed boxes.

        The collection strategy undertakes the following steps:
            *   Loop through the DAG's op nodes in topological order.
            *   Group together measurement nodes to be  placed in the same  box.
            *   Whenever a node can be placed in more than one group, place it in the earliest
                possible group--where "earliest" is with reference to opological ordering.
            *   When looping is complete, replace each group with a box.
        """
        # A list of groups that need to be placed in the same box, expressed as a dict for fast
        # access. Every node in each group either contains a single-qubit gate or a measurement
        # --when constructing this dictionary, we explicitly leave out nodes that contain different
        # ops.
        groups: dict[int, list[DAGOpNode]] = defaultdict(list)

        # A map from bits (qubits and clbits) to the index of the earliest group that is able to
        # collect operations on those bits
        group_indices: dict[Bit, int] = defaultdict(int)

        for node in dag.topological_op_nodes():
            validate_op_is_supported(node)

            # The index of the earliest group able to collect ops on all the bits in this node
            group_idx: int = max(group_indices[bit] for bit in node.qargs + node.cargs)

            if (name := node.op.name) in ["barrier", "box"] or (
                node.is_standard_gate() and node.op.num_qubits == 2
            ):
                # Update the trackers
                for bit in node.qargs + node.cargs:
                    group_indices[bit] = group_idx
            elif name == "measure":
                # Add this measurement to the group
                groups[group_idx].append(node)

                # Update trackers
                for qubit in node.qargs:
                    group_indices[qubit] = group_idx + 1
            elif node.is_standard_gate() and node.op.num_qubits == 1:
                # Leave single-qubit gates alone
                continue
            else:
                raise TranspilerError(f"'{name}' operation is not supported.")

        for nodes in groups.values():
            cargs = [carg for node in nodes for carg in node.cargs]
            if len(cargs) != len(set(cargs)):
                raise TranspilerError(
                    "Cannot twirl more than one measurement on the same classical bit."
                )

            make_and_insert_box(dag, nodes, self._make_annotations())

        return dag
