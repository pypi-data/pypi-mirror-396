# This code is a Qiskit project.
#
# (C) Copyright IBM 2025.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""AddInjectNoise"""

import itertools
from collections import defaultdict
from collections.abc import Callable
from typing import Literal

from qiskit.circuit import CircuitInstruction
from qiskit.dagcircuit import DAGCircuit, DAGOpNode
from qiskit.transpiler.basepasses import TransformationPass
from qiskit.transpiler.exceptions import TranspilerError

from ...annotations import InjectNoise, Twirl
from ...utils import BoxKey, get_annotation, undress_box, validate_literals


class AddInjectNoise(TransformationPass):
    """Inserts :class:`~.InjectNoise` annotations to all the unique boxes with twirling annotation.

    This pass finds boxes matching the conditions implied by ``targets``, adds inject noise
    to their annotations, and replaces them with new boxes with the updated annotations.

    Args:
        strategy: The noise injection strategy.
        overwrite: Whether to overwrite the ``ref`` of inject noise annotations that are already
            present in the circuit.
        prefix_ref: A prefix to all the ``ref`` generated by this class.
        prefix_modifier_ref: A prefix to all the ``modifier_refs`` generated by this class.
        targets: The class of annotated boxes to target. The supported values are:

                * ``'none'`` to avoid annotating boxes of any kind.
                * ``'gates'`` to target only the twirl-annotated boxes that contain entanglers.
                * ``'measures'`` to target only the twirl-annotated boxes that own classical
                    registers.
                * ``'all'`` to target all the twirl-annotated boxes that contain entanglers
                    and/or own classical registers.

    .. note::
        Every ``ref`` is generated by appending a counter to ``prefix_ref``. The counter is shared
        across all the instances of this class. In order to avoid collisions, it is incremented
        every time that a new ``ref`` is created. The same mechanism (with a different counter)
        is used to generate the ``modifier_refs``.
    """

    _REF_COUNTER = itertools.count()
    _MODIFIER_REF_COUNTER = itertools.count()

    @validate_literals("strategy", "targets")
    def __init__(
        self,
        strategy: Literal[
            "no_modification", "uniform_modification", "individual_modification"
        ] = "no_modification",
        overwrite: bool = False,
        prefix_ref: str = "r",
        prefix_modifier_ref: str = "m",
        targets: Literal["none", "gates", "measures", "all"] = "none",
    ):
        super().__init__()
        self.strategy = strategy
        self.overwrite = overwrite
        self.prefix_ref = prefix_ref
        self.prefix_modifier_ref = prefix_modifier_ref
        self.targets = targets

    def _skip_undressed_box(self) -> Callable[[DAGOpNode], bool]:
        if self.targets == "none":
            return True
        if self.targets == "all":
            # Skip boxes that do not contain entanglers or measurements
            return (
                lambda undressed_box: undressed_box.body.num_nonlocal_gates() == 0
                and not undressed_box.body.clbits
            )
        if self.targets == "gates":
            return lambda undressed_box: undressed_box.body.num_nonlocal_gates() == 0
        if self.targets == "measures":
            return lambda undressed_box: not undressed_box.body.clbits

        raise TranspilerError(
            f"Targets '{self.targets}' is invalid, choose one of 'none', 'all', 'gates',"
            " and 'measures'."
        )

    def run(self, dag: DAGCircuit) -> DAGCircuit:
        if self.targets == "none":
            return dag

        # A dictionary to map unique boxes to their ``ref``
        box_to_ref: dict[BoxKey, int] = defaultdict(
            lambda: f"{self.prefix_ref}{next(self._REF_COUNTER)}"
        )

        skip_undressed_box: Callable[[DAGOpNode], bool] = self._skip_undressed_box()

        for node in dag.op_nodes():
            if node.op.name == "box" and (twirl := get_annotation(node.op, Twirl)):
                undressed_box = undress_box(node.op)
                undressed_box.annotations = [twirl]

                if skip_undressed_box(undressed_box):
                    continue

                instr_qubits = undressed_box.body.qubits
                instr_clbits = undressed_box.body.clbits
                instr = CircuitInstruction(undressed_box, instr_qubits, instr_clbits)
                box_key = BoxKey(instr)

                if inject_noise_annotation := get_annotation(node.op, InjectNoise):
                    if box_key not in box_to_ref:
                        # The box already has a noise injection annotation, but it is the first box
                        # to be found for this hash. Its `ref` will be reused for all future boxes
                        # that produce the same hash.
                        box_to_ref[box_key] = inject_noise_annotation.ref
                    else:
                        # The box already has a noise injection annotation, and another box with the
                        # same hash has previously been found.
                        if self.overwrite is True:
                            annotation_idx = node.op.annotations.index(inject_noise_annotation)
                            node.op.annotations[annotation_idx] = InjectNoise(
                                box_to_ref[box_key],
                                inject_noise_annotation.modifier_ref,
                            )
                            # substitute back into the dag to guarantee that the
                            # change makes it back to the rust data model.
                            dag.substitute_node(node, node.op)
                else:
                    # The box does not have a noise injection annotation.
                    ref = box_to_ref[box_key]

                    if self.strategy == "no_modification":
                        modifier_ref = ""
                    elif self.strategy == "uniform_modification":
                        modifier_ref = ref
                    else:
                        # individual modification
                        modifier_ref = (
                            f"{self.prefix_modifier_ref}{next(self._MODIFIER_REF_COUNTER)}"
                        )

                    node.op.annotations += [InjectNoise(ref, modifier_ref)]
                    # substitute back into the dag to guarantee that the
                    # change makes it back to the rust data model.
                    dag.substitute_node(node, node.op)
        return dag
