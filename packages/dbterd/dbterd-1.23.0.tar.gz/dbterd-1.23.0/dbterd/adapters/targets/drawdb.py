"""DrawDB target adapter for dbterd.

This module converts parsed dbt artifacts into DrawDB JSON format
for visualization with DrawDB tools.
"""

import json
from typing import ClassVar

from dbterd.core.adapters.target import BaseTargetAdapter
from dbterd.core.builder.json_builder import JsonERDBuilder
from dbterd.core.models import Ref, Table
from dbterd.core.registry.decorators import register_target


@register_target("drawdb", description="DrawDB JSON format")
class DrawdbAdapter(BaseTargetAdapter):
    """DrawDB format target adapter.

    Generates DrawDB JSON format for the DrawDB visual database designer.
    """

    file_extension = ".ddb"
    default_filename = "output.ddb"

    RELATIONSHIP_SYMBOLS: ClassVar[dict[str, str]] = {
        "01": "One to one",
        "11": "One to one",
        "0n": "One to many",
        "1n": "One to many",
        "nn": "Many to many",
    }
    DEFAULT_SYMBOL = "Many to one"  # n1

    def build_erd(self, tables: list[Table], relationships: list[Ref], **kwargs) -> str:
        """Build DrawDB JSON content using JsonERDBuilder chainable API."""
        graphic_tables = self.get_graphic_tables(tables=tables)

        # Get generated_at from metadata if available
        generated_at = ""
        manifest = kwargs.get("manifest")
        if manifest and hasattr(manifest, "metadata") and hasattr(manifest.metadata, "generated_at"):
            generated_at = str(manifest.metadata.generated_at)

        title = kwargs.get("output_file_name") or "Generated by dbterd"

        # Build JSON with DrawDB-specific structure using chainable API
        builder = JsonERDBuilder()
        builder.add_header(
            {
                "author": "dbterd",
                "title": title,
                "date": generated_at,
                "notes": [],
                "subjectAreas": [],
                "database": "generic",
                "types": [],
            }
        )
        builder.add_tables(tables, lambda t: self.format_table_dict(t, tables.index(t), graphic_tables))
        builder.add_relationships(
            relationships, lambda r: self.format_relationship_dict(r, relationships.index(r), graphic_tables)
        )

        # DrawDB schema - defines exact output structure
        drawdb_schema = {
            "$header": None,
            "tables": "$tables",
            "relationships": "$relationships",
        }
        return builder.build(schema=drawdb_schema)

    def format_table(self, table: Table, **kwargs) -> str:
        """Format a single table as JSON string (required by base class)."""
        graphic_tables = kwargs.get("graphic_tables", {})
        idx = kwargs.get("idx", 0)
        return json.dumps(self.format_table_dict(table, idx, graphic_tables))

    def format_relationship(self, relationship: Ref, **kwargs) -> str:
        """Format a single relationship as JSON string (required by base class)."""
        graphic_tables = kwargs.get("graphic_tables", {})
        idx = kwargs.get("idx", 0)
        return json.dumps(self.format_relationship_dict(relationship, idx, graphic_tables))

    def get_y(self, tables: list[Table], idx: int, graphic_tables: dict, column_size: int = 4) -> float:
        """Get y value of a table for layout.

        y = S x (T's no of columns) + (T's y value if any)
        - T: the prev table in the same graph column
        - S: the height value of a graphic column, default = 50

        Args:
            tables: Parsed tables
            idx: Current table index
            graphic_tables: Mutable calculated graphic tables dict
            column_size: Graphic column size, default = 4

        Returns:
            y value for table positioning

        """
        if idx < column_size:
            return 0

        col_len = len(tables[idx - column_size].columns) + 1  # plus title row
        y = (50 * col_len) * (0 if idx < column_size else 1)

        if idx - column_size >= 0:
            prev_table_name = tables[idx - column_size].name
            y += graphic_tables[prev_table_name].get("y", 0)

        return y

    def get_graphic_tables(self, tables: list[Table]) -> dict:
        """Return indexed and pre-layouted tables.

        Args:
            tables: List of parsed tables

        Returns:
            Indexed and layouted tables dict

        """
        graphic_tables: dict = {}
        for idx, table in enumerate(tables):
            idx_fields: dict = {}
            graphic_tables[table.name] = {
                "id": idx,
                "x": 500 * (idx % 4),
                "y": self.get_y(tables, idx, graphic_tables),
                "fields": idx_fields,
            }
            for idc, col in enumerate(table.columns):
                idx_fields[col.name] = {"id": idc}

        return graphic_tables

    def format_table_dict(self, table: Table, idx: int, graphic_tables: dict) -> dict:
        """Format a single table as DrawDB dict."""
        return {
            "id": idx,
            "name": table.name,
            "x": graphic_tables.get(table.name, {}).get("x"),
            "y": graphic_tables.get(table.name, {}).get("y"),
            "comment": table.description,
            "indices": [],
            "color": "#175e7a",
            "fields": [
                {
                    "id": idc,
                    "name": col.name,
                    "type": col.data_type,
                    "default": "",
                    "check": "",
                    "primary": False,
                    "unique": False,
                    "notNull": False,
                    "increment": False,
                    "comment": col.description,
                }
                for idc, col in enumerate(table.columns)
            ],
        }

    def format_relationship_dict(self, relationship: Ref, idx: int, graphic_tables: dict) -> dict:
        """Format a single relationship as DrawDB dict."""
        return {
            "id": idx,
            "name": f"fk__{relationship.table_map[1]}_{relationship.table_map[0]}__{relationship.column_map[1]}",
            "cardinality": self.get_rel_symbol(relationship.type),
            "startTableId": graphic_tables.get(relationship.table_map[1], {}).get("id"),
            "endTableId": graphic_tables.get(relationship.table_map[0], {}).get("id"),
            "startFieldId": (
                graphic_tables.get(relationship.table_map[1], {})
                .get("fields", {})
                .get(relationship.column_map[1], {})
                .get("id")
            ),
            "endFieldId": (
                graphic_tables.get(relationship.table_map[0], {})
                .get("fields", {})
                .get(relationship.column_map[0], {})
                .get("id")
            ),
            "updateConstraint": "No action",
            "deleteConstraint": "No action",
        }
