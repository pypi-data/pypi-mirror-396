"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Scene(google.protobuf.message.Message):
    """Optical scene definition made of parts, optical properties, sources, sensors and simulations"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class GeoPaths(google.protobuf.message.Message):
        """Geometry path of object that will include the specific property (can be sub-scene/part/body/face). 
        geo_path in the format : "<sub-scene name>/<part name>/<body name>/<face name>" (no name by default for root scene and root part).
        "body0" -> body0 of the root part in the root scene
        "body0/face0" -> face0 in body0 of the root part in the root scene
        "part1" -> part1 of the root part in the root scene
        "part1/body1/face1" -> face1 in body1 in part1 of the root part in the root scene
        "subScene1" -> root part in the sub scene subScene1
        "subScene1/part2" -> part2 of the sub scene subScene1
        Particularities:
        If the object GeoPaths is defined and geo_paths left empty, this means "All geometry selected".
        If the object GeoPaths is NOT defined, this means "No geometry selected".
        """
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        GEO_PATHS_FIELD_NUMBER: builtins.int
        @property
        def geo_paths(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """list of geo paths"""
            pass
        def __init__(self,
            *,
            geo_paths : typing.Optional[typing.Iterable[typing.Text]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["geo_paths",b"geo_paths"]) -> None: ...

    class GeoPath(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        GEO_PATH_FIELD_NUMBER: builtins.int
        REVERSE_NORMAL_FIELD_NUMBER: builtins.int
        geo_path: typing.Text = ...
        """Geometry that will be used ("<body name>" for a whole body, or "<body name>/<face name>" for a specific face)"""

        reverse_normal: builtins.bool = ...
        """optional - if not set or false : normal is not reversed."""

        def __init__(self,
            *,
            geo_path : typing.Text = ...,
            reverse_normal : typing.Optional[builtins.bool] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["_reverse_normal",b"_reverse_normal","reverse_normal",b"reverse_normal"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["_reverse_normal",b"_reverse_normal","geo_path",b"geo_path","reverse_normal",b"reverse_normal"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["_reverse_normal",b"_reverse_normal"]) -> typing.Optional[typing_extensions.Literal["reverse_normal"]]: ...

    class MaterialInstance(google.protobuf.message.Message):
        """Instance of a material to apply on geometries of the scene"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class Texture(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class MappingOperator(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                class Planar(google.protobuf.message.Message):
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    def __init__(self,
                        ) -> None: ...

                class Cubic(google.protobuf.message.Message):
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    def __init__(self,
                        ) -> None: ...

                class Spherical(google.protobuf.message.Message):
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    SPHERE_PERIMETER_FIELD_NUMBER: builtins.int
                    sphere_perimeter: builtins.float = ...
                    def __init__(self,
                        *,
                        sphere_perimeter : builtins.float = ...,
                        ) -> None: ...
                    def ClearField(self, field_name: typing_extensions.Literal["sphere_perimeter",b"sphere_perimeter"]) -> None: ...

                class Cylindrical(google.protobuf.message.Message):
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    BASE_PERIMETER_FIELD_NUMBER: builtins.int
                    base_perimeter: builtins.float = ...
                    def __init__(self,
                        *,
                        base_perimeter : builtins.float = ...,
                        ) -> None: ...
                    def ClearField(self, field_name: typing_extensions.Literal["base_perimeter",b"base_perimeter"]) -> None: ...

                PLANAR_FIELD_NUMBER: builtins.int
                CUBIC_FIELD_NUMBER: builtins.int
                SPHERICAL_FIELD_NUMBER: builtins.int
                CYLINDRICAL_FIELD_NUMBER: builtins.int
                AXIS_SYSTEM_FIELD_NUMBER: builtins.int
                U_OFFSET_FIELD_NUMBER: builtins.int
                V_OFFSET_FIELD_NUMBER: builtins.int
                U_SCALE_FACTOR_FIELD_NUMBER: builtins.int
                V_SCALE_FACTOR_FIELD_NUMBER: builtins.int
                U_LENGTH_FIELD_NUMBER: builtins.int
                V_LENGTH_FIELD_NUMBER: builtins.int
                ROTATION_FIELD_NUMBER: builtins.int
                @property
                def planar(self) -> global___Scene.MaterialInstance.Texture.MappingOperator.Planar: ...
                @property
                def cubic(self) -> global___Scene.MaterialInstance.Texture.MappingOperator.Cubic: ...
                @property
                def spherical(self) -> global___Scene.MaterialInstance.Texture.MappingOperator.Spherical: ...
                @property
                def cylindrical(self) -> global___Scene.MaterialInstance.Texture.MappingOperator.Cylindrical: ...
                @property
                def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                    """Reference for the mapping operator (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz)"""
                    pass
                u_offset: builtins.float = ...
                """Shift on U direction (mm)"""

                v_offset: builtins.float = ...
                """Shift on V direction (mm)"""

                u_scale_factor: builtins.float = ...
                """Scale factor on U dimension"""

                v_scale_factor: builtins.float = ...
                """Scale factor on V dimension"""

                u_length: builtins.float = ...
                """Dimension on U direction (mm)"""

                v_length: builtins.float = ...
                """Optional - Dimension on V direction (mm). If not filled, then the image ratio is used to define v_length from u_length."""

                rotation: builtins.float = ...
                """Rotation of UVs (degree) ]-360, 360["""

                def __init__(self,
                    *,
                    planar : typing.Optional[global___Scene.MaterialInstance.Texture.MappingOperator.Planar] = ...,
                    cubic : typing.Optional[global___Scene.MaterialInstance.Texture.MappingOperator.Cubic] = ...,
                    spherical : typing.Optional[global___Scene.MaterialInstance.Texture.MappingOperator.Spherical] = ...,
                    cylindrical : typing.Optional[global___Scene.MaterialInstance.Texture.MappingOperator.Cylindrical] = ...,
                    axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                    u_offset : builtins.float = ...,
                    v_offset : builtins.float = ...,
                    u_scale_factor : builtins.float = ...,
                    v_scale_factor : builtins.float = ...,
                    u_length : builtins.float = ...,
                    v_length : typing.Optional[builtins.float] = ...,
                    rotation : builtins.float = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["_v_length",b"_v_length","cubic",b"cubic","cylindrical",b"cylindrical","planar",b"planar","spherical",b"spherical","type",b"type","v_length",b"v_length"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["_v_length",b"_v_length","axis_system",b"axis_system","cubic",b"cubic","cylindrical",b"cylindrical","planar",b"planar","rotation",b"rotation","spherical",b"spherical","type",b"type","u_length",b"u_length","u_offset",b"u_offset","u_scale_factor",b"u_scale_factor","v_length",b"v_length","v_offset",b"v_offset","v_scale_factor",b"v_scale_factor"]) -> None: ...
                @typing.overload
                def WhichOneof(self, oneof_group: typing_extensions.Literal["_v_length",b"_v_length"]) -> typing.Optional[typing_extensions.Literal["v_length"]]: ...
                @typing.overload
                def WhichOneof(self, oneof_group: typing_extensions.Literal["type",b"type"]) -> typing.Optional[typing_extensions.Literal["planar","cubic","spherical","cylindrical"]]: ...

            class Layer(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                class TextureMappingInfo(google.protobuf.message.Message):
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    MAPPING_OPERATOR_FIELD_NUMBER: builtins.int
                    VERTICES_DATA_INDEX_FIELD_NUMBER: builtins.int
                    @property
                    def mapping_operator(self) -> global___Scene.MaterialInstance.Texture.MappingOperator:
                        """Mapping operator to create UV mapping in corresponding face"""
                        pass
                    vertices_data_index: builtins.int = ...
                    """Index in face's vertices_data where UV mapping is stored"""

                    def __init__(self,
                        *,
                        mapping_operator : typing.Optional[global___Scene.MaterialInstance.Texture.MappingOperator] = ...,
                        vertices_data_index : builtins.int = ...,
                        ) -> None: ...
                    def HasField(self, field_name: typing_extensions.Literal["mapping_operator",b"mapping_operator","uv_map",b"uv_map","vertices_data_index",b"vertices_data_index"]) -> builtins.bool: ...
                    def ClearField(self, field_name: typing_extensions.Literal["mapping_operator",b"mapping_operator","uv_map",b"uv_map","vertices_data_index",b"vertices_data_index"]) -> None: ...
                    def WhichOneof(self, oneof_group: typing_extensions.Literal["uv_map",b"uv_map"]) -> typing.Optional[typing_extensions.Literal["mapping_operator","vertices_data_index"]]: ...

                SOP_GUID_FIELD_NUMBER: builtins.int
                IMAGE_PROPERTIES_FIELD_NUMBER: builtins.int
                NORMAL_MAP_PROPERTIES_FIELD_NUMBER: builtins.int
                ANISOTROPY_MAP_PROPERTIES_FIELD_NUMBER: builtins.int
                sop_guid: typing.Text = ...
                """Guid of the surface optical property to bind to geometry"""

                @property
                def image_properties(self) -> global___Scene.MaterialInstance.Texture.Layer.TextureMappingInfo:
                    """To be filled if the SOPTemplate/Texture contains image field"""
                    pass
                @property
                def normal_map_properties(self) -> global___Scene.MaterialInstance.Texture.Layer.TextureMappingInfo:
                    """To be filled if the SOPTemplate/Texture contains normal_map field"""
                    pass
                @property
                def anisotropy_map_properties(self) -> global___Scene.MaterialInstance.Texture.Layer.TextureMappingInfo:
                    """To be filled if the SOPTemplate is anisotropic (for example an anisotropicbsdf as Library file uri)"""
                    pass
                def __init__(self,
                    *,
                    sop_guid : typing.Text = ...,
                    image_properties : typing.Optional[global___Scene.MaterialInstance.Texture.Layer.TextureMappingInfo] = ...,
                    normal_map_properties : typing.Optional[global___Scene.MaterialInstance.Texture.Layer.TextureMappingInfo] = ...,
                    anisotropy_map_properties : typing.Optional[global___Scene.MaterialInstance.Texture.Layer.TextureMappingInfo] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["anisotropy_map_properties",b"anisotropy_map_properties","image_properties",b"image_properties","normal_map_properties",b"normal_map_properties"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["anisotropy_map_properties",b"anisotropy_map_properties","image_properties",b"image_properties","normal_map_properties",b"normal_map_properties","sop_guid",b"sop_guid"]) -> None: ...

            LAYERS_FIELD_NUMBER: builtins.int
            @property
            def layers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Scene.MaterialInstance.Texture.Layer]:
                """List of texture layers (also called multi texture in case of several layers)"""
                pass
            def __init__(self,
                *,
                layers : typing.Optional[typing.Iterable[global___Scene.MaterialInstance.Texture.Layer]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["layers",b"layers"]) -> None: ...

        class NonHomogeneousProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the non homogeneous vop (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                pass
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system"]) -> None: ...

        class MetadataEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            value: typing.Text = ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        NAME_FIELD_NUMBER: builtins.int
        DISPLAY_NAME_FIELD_NUMBER: builtins.int
        DESCRIPTION_FIELD_NUMBER: builtins.int
        METADATA_FIELD_NUMBER: builtins.int
        VOP_GUID_FIELD_NUMBER: builtins.int
        NON_HOMOGENEOUS_PROPERTIES_FIELD_NUMBER: builtins.int
        SOP_GUIDS_FIELD_NUMBER: builtins.int
        SOP_GUID_FIELD_NUMBER: builtins.int
        TEXTURE_FIELD_NUMBER: builtins.int
        GEOMETRIES_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """Unique identifier in the scene"""

        display_name: typing.Text = ...
        """User name to be displayed"""

        description: typing.Text = ...
        @property
        def metadata(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
            """User defined metadata"""
            pass
        vop_guid: typing.Text = ...
        """optional - Guid of the volume optical property to instantiate"""

        @property
        def non_homogeneous_properties(self) -> global___Scene.MaterialInstance.NonHomogeneousProperties:
            """To be filled if the vop_guid corresponds to a VOPTemplate of type NonHomogeneous"""
            pass
        @property
        def sop_guids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """Deprecated - Better use sop oneof field (either sop_guid or texture)"""
            pass
        sop_guid: typing.Text = ...
        """Guid of the surface optical property to instantiate"""

        @property
        def texture(self) -> global___Scene.MaterialInstance.Texture:
            """Surface optical property to instantiate using texture (can be composed of several layers)"""
            pass
        @property
        def geometries(self) -> global___Scene.GeoPaths:
            """Geometries that will use this material"""
            pass
        def __init__(self,
            *,
            name : typing.Text = ...,
            display_name : typing.Text = ...,
            description : typing.Text = ...,
            metadata : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
            vop_guid : typing.Optional[typing.Text] = ...,
            non_homogeneous_properties : typing.Optional[global___Scene.MaterialInstance.NonHomogeneousProperties] = ...,
            sop_guids : typing.Optional[typing.Iterable[typing.Text]] = ...,
            sop_guid : typing.Text = ...,
            texture : typing.Optional[global___Scene.MaterialInstance.Texture] = ...,
            geometries : typing.Optional[global___Scene.GeoPaths] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["_vop_guid",b"_vop_guid","geometries",b"geometries","non_homogeneous_properties",b"non_homogeneous_properties","sop",b"sop","sop_guid",b"sop_guid","texture",b"texture","vop_guid",b"vop_guid","vop_properties",b"vop_properties"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["_vop_guid",b"_vop_guid","description",b"description","display_name",b"display_name","geometries",b"geometries","metadata",b"metadata","name",b"name","non_homogeneous_properties",b"non_homogeneous_properties","sop",b"sop","sop_guid",b"sop_guid","sop_guids",b"sop_guids","texture",b"texture","vop_guid",b"vop_guid","vop_properties",b"vop_properties"]) -> None: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing_extensions.Literal["_vop_guid",b"_vop_guid"]) -> typing.Optional[typing_extensions.Literal["vop_guid"]]: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing_extensions.Literal["sop",b"sop"]) -> typing.Optional[typing_extensions.Literal["sop_guid","texture"]]: ...
        @typing.overload
        def WhichOneof(self, oneof_group: typing_extensions.Literal["vop_properties",b"vop_properties"]) -> typing.Optional[typing_extensions.Literal["non_homogeneous_properties"]]: ...

    class SourceInstance(google.protobuf.message.Message):
        """Instance of a source to add in the scene"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class IntensityProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class LibraryProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                class AxisSystem(google.protobuf.message.Message):
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    VALUES_FIELD_NUMBER: builtins.int
                    @property
                    def values(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                        """orientation (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz)"""
                        pass
                    def __init__(self,
                        *,
                        values : typing.Optional[typing.Iterable[builtins.float]] = ...,
                        ) -> None: ...
                    def ClearField(self, field_name: typing_extensions.Literal["values",b"values"]) -> None: ...

                class NormalToSurface(google.protobuf.message.Message):
                    """Define the intensity distribution as normal to the selected surface."""
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    def __init__(self,
                        ) -> None: ...

                class NormalToUVMap(google.protobuf.message.Message):
                    """Define the intensity distribution as normal to the selected emissive surface and its orientation on the emissive surface."""
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    def __init__(self,
                        ) -> None: ...

                EXIT_GEOMETRIES_FIELD_NUMBER: builtins.int
                AXIS_SYSTEM_FIELD_NUMBER: builtins.int
                NORMAL_TO_SURFACE_FIELD_NUMBER: builtins.int
                NORMAL_TO_UV_MAP_FIELD_NUMBER: builtins.int
                @property
                def exit_geometries(self) -> global___Scene.GeoPaths:
                    """Exit Geometries that will use this surface source"""
                    pass
                @property
                def axis_system(self) -> global___Scene.SourceInstance.IntensityProperties.LibraryProperties.AxisSystem:
                    """orientation (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                    pass
                @property
                def normal_to_surface(self) -> global___Scene.SourceInstance.IntensityProperties.LibraryProperties.NormalToSurface:
                    """Define the intensity distribution as normal to the selected surface."""
                    pass
                @property
                def normal_to_uv_map(self) -> global___Scene.SourceInstance.IntensityProperties.LibraryProperties.NormalToUVMap:
                    """Define the intensity distribution as normal to the selected emissive surface and its orientation on the emissive surface."""
                    pass
                def __init__(self,
                    *,
                    exit_geometries : typing.Optional[global___Scene.GeoPaths] = ...,
                    axis_system : typing.Optional[global___Scene.SourceInstance.IntensityProperties.LibraryProperties.AxisSystem] = ...,
                    normal_to_surface : typing.Optional[global___Scene.SourceInstance.IntensityProperties.LibraryProperties.NormalToSurface] = ...,
                    normal_to_uv_map : typing.Optional[global___Scene.SourceInstance.IntensityProperties.LibraryProperties.NormalToUVMap] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","exit_geometries",b"exit_geometries","normal_to_surface",b"normal_to_surface","normal_to_uv_map",b"normal_to_uv_map","orientation",b"orientation"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","exit_geometries",b"exit_geometries","normal_to_surface",b"normal_to_surface","normal_to_uv_map",b"normal_to_uv_map","orientation",b"orientation"]) -> None: ...
                def WhichOneof(self, oneof_group: typing_extensions.Literal["orientation",b"orientation"]) -> typing.Optional[typing_extensions.Literal["axis_system","normal_to_surface","normal_to_uv_map"]]: ...

            class GaussianProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                AXIS_SYSTEM_FIELD_NUMBER: builtins.int
                @property
                def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                    """optional - orientation of the intensity distribution (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz) - if not filled : normal to surface map. If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                    pass
                def __init__(self,
                    *,
                    axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system"]) -> None: ...

            LIBRARY_PROPERTIES_FIELD_NUMBER: builtins.int
            GAUSSIAN_PROPERTIES_FIELD_NUMBER: builtins.int
            @property
            def library_properties(self) -> global___Scene.SourceInstance.IntensityProperties.LibraryProperties:
                """To be filled if the intensity_guid of the source template corresponds to an IntensityTemplate of type Library"""
                pass
            @property
            def gaussian_properties(self) -> global___Scene.SourceInstance.IntensityProperties.GaussianProperties:
                """To be filled if the intensity_guid of the source template corresponds to an IntensityTemplate of type Gaussian"""
                pass
            def __init__(self,
                *,
                library_properties : typing.Optional[global___Scene.SourceInstance.IntensityProperties.LibraryProperties] = ...,
                gaussian_properties : typing.Optional[global___Scene.SourceInstance.IntensityProperties.GaussianProperties] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["gaussian_properties",b"gaussian_properties","library_properties",b"library_properties","properties",b"properties"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["gaussian_properties",b"gaussian_properties","library_properties",b"library_properties","properties",b"properties"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["properties",b"properties"]) -> typing.Optional[typing_extensions.Literal["library_properties","gaussian_properties"]]: ...

        class LuminaireProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the source (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                pass
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system"]) -> None: ...

        class SurfaceProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class ExitanceConstantProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                GEO_PATHS_FIELD_NUMBER: builtins.int
                @property
                def geo_paths(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Scene.GeoPath]: ...
                def __init__(self,
                    *,
                    geo_paths : typing.Optional[typing.Iterable[global___Scene.GeoPath]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["geo_paths",b"geo_paths"]) -> None: ...

            class ExitanceVariableProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                AXIS_PLANE_FIELD_NUMBER: builtins.int
                @property
                def axis_plane(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                    """Position of the exitance map (Ox Oy Oz Xx Xy Xz Yx Yy Yz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                    pass
                def __init__(self,
                    *,
                    axis_plane : typing.Optional[typing.Iterable[builtins.float]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["axis_plane",b"axis_plane"]) -> None: ...

            EXITANCE_CONSTANT_PROPERTIES_FIELD_NUMBER: builtins.int
            EXITANCE_VARIABLE_PROPERTIES_FIELD_NUMBER: builtins.int
            INTENSITY_PROPERTIES_FIELD_NUMBER: builtins.int
            @property
            def exitance_constant_properties(self) -> global___Scene.SourceInstance.SurfaceProperties.ExitanceConstantProperties:
                """To be filled if the Surface SourceTemplate has ExitanceConstant"""
                pass
            @property
            def exitance_variable_properties(self) -> global___Scene.SourceInstance.SurfaceProperties.ExitanceVariableProperties:
                """To be filled if the Surface SourceTemplate has ExitanceVariable"""
                pass
            @property
            def intensity_properties(self) -> global___Scene.SourceInstance.IntensityProperties: ...
            def __init__(self,
                *,
                exitance_constant_properties : typing.Optional[global___Scene.SourceInstance.SurfaceProperties.ExitanceConstantProperties] = ...,
                exitance_variable_properties : typing.Optional[global___Scene.SourceInstance.SurfaceProperties.ExitanceVariableProperties] = ...,
                intensity_properties : typing.Optional[global___Scene.SourceInstance.IntensityProperties] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["exitanceProperties",b"exitanceProperties","exitance_constant_properties",b"exitance_constant_properties","exitance_variable_properties",b"exitance_variable_properties","intensity_properties",b"intensity_properties"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["exitanceProperties",b"exitanceProperties","exitance_constant_properties",b"exitance_constant_properties","exitance_variable_properties",b"exitance_variable_properties","intensity_properties",b"intensity_properties"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["exitanceProperties",b"exitanceProperties"]) -> typing.Optional[typing_extensions.Literal["exitance_constant_properties","exitance_variable_properties"]]: ...

        class ThermicProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class EmissiveFacesProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                GEO_PATHS_FIELD_NUMBER: builtins.int
                @property
                def geo_paths(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Scene.GeoPath]:
                    """the list of emitting faces of the source"""
                    pass
                def __init__(self,
                    *,
                    geo_paths : typing.Optional[typing.Iterable[global___Scene.GeoPath]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["geo_paths",b"geo_paths"]) -> None: ...

            class TemperatureFieldProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                AXIS_PLANE_FIELD_NUMBER: builtins.int
                @property
                def axis_plane(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                    """Position of the exitance map (Ox Oy Oz Xx Xy Xz Yx Yy Yz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                    pass
                def __init__(self,
                    *,
                    axis_plane : typing.Optional[typing.Iterable[builtins.float]] = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["axis_plane",b"axis_plane"]) -> None: ...

            EMISSIVE_FACES_PROPERTIES_FIELD_NUMBER: builtins.int
            TEMPERATURE_FIELD_PROPERTIES_FIELD_NUMBER: builtins.int
            @property
            def emissive_faces_properties(self) -> global___Scene.SourceInstance.ThermicProperties.EmissiveFacesProperties:
                """source emits from faces"""
                pass
            @property
            def temperature_field_properties(self) -> global___Scene.SourceInstance.ThermicProperties.TemperatureFieldProperties:
                """a specific OPTTemperature file is required (mesh + triangle temperature in Kelvin)"""
                pass
            def __init__(self,
                *,
                emissive_faces_properties : typing.Optional[global___Scene.SourceInstance.ThermicProperties.EmissiveFacesProperties] = ...,
                temperature_field_properties : typing.Optional[global___Scene.SourceInstance.ThermicProperties.TemperatureFieldProperties] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["emissive_faces_properties",b"emissive_faces_properties","exitanceProperties",b"exitanceProperties","temperature_field_properties",b"temperature_field_properties"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["emissive_faces_properties",b"emissive_faces_properties","exitanceProperties",b"exitanceProperties","temperature_field_properties",b"temperature_field_properties"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["exitanceProperties",b"exitanceProperties"]) -> typing.Optional[typing_extensions.Literal["emissive_faces_properties","temperature_field_properties"]]: ...

        class RayFileProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            EXIT_GEOMETRIES_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the source (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz)"""
                pass
            @property
            def exit_geometries(self) -> global___Scene.GeoPaths:
                """Exit Geometries that will use this rayfile source"""
                pass
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                exit_geometries : typing.Optional[global___Scene.GeoPaths] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["exit_geometries",b"exit_geometries"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","exit_geometries",b"exit_geometries"]) -> None: ...

        class DisplayProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            INTENSITY_PROPERTIES_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the source (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                pass
            @property
            def intensity_properties(self) -> global___Scene.SourceInstance.IntensityProperties: ...
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                intensity_properties : typing.Optional[global___Scene.SourceInstance.IntensityProperties] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["intensity_properties",b"intensity_properties"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","intensity_properties",b"intensity_properties"]) -> None: ...

        class AmbientProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class ManualSun(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                SUN_DIRECTION_FIELD_NUMBER: builtins.int
                REVERSE_SUN_FIELD_NUMBER: builtins.int
                @property
                def sun_direction(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                    """(X Y Z) direction to the sun"""
                    pass
                reverse_sun: builtins.bool = ...
                """optional - if not set or false : normal is not reversed"""

                def __init__(self,
                    *,
                    sun_direction : typing.Optional[typing.Iterable[builtins.float]] = ...,
                    reverse_sun : builtins.bool = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["reverse_sun",b"reverse_sun","sun_direction",b"sun_direction"]) -> None: ...

            class SunAxisSystem(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                class AutomaticSun(google.protobuf.message.Message):
                    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                    TIME_ZONE_URI_FIELD_NUMBER: builtins.int
                    YEAR_FIELD_NUMBER: builtins.int
                    MONTH_FIELD_NUMBER: builtins.int
                    DAY_FIELD_NUMBER: builtins.int
                    HOUR_FIELD_NUMBER: builtins.int
                    MINUTE_FIELD_NUMBER: builtins.int
                    LONGITUDE_FIELD_NUMBER: builtins.int
                    LATITUDE_FIELD_NUMBER: builtins.int
                    time_zone_uri: typing.Text = ...
                    year: builtins.int = ...
                    month: builtins.int = ...
                    day: builtins.int = ...
                    hour: builtins.int = ...
                    minute: builtins.int = ...
                    longitude: builtins.float = ...
                    latitude: builtins.float = ...
                    def __init__(self,
                        *,
                        time_zone_uri : typing.Text = ...,
                        year : builtins.int = ...,
                        month : builtins.int = ...,
                        day : builtins.int = ...,
                        hour : builtins.int = ...,
                        minute : builtins.int = ...,
                        longitude : builtins.float = ...,
                        latitude : builtins.float = ...,
                        ) -> None: ...
                    def ClearField(self, field_name: typing_extensions.Literal["day",b"day","hour",b"hour","latitude",b"latitude","longitude",b"longitude","minute",b"minute","month",b"month","time_zone_uri",b"time_zone_uri","year",b"year"]) -> None: ...

                AUTOMATIC_SUN_FIELD_NUMBER: builtins.int
                MANUAL_SUN_FIELD_NUMBER: builtins.int
                @property
                def automatic_sun(self) -> global___Scene.SourceInstance.AmbientProperties.SunAxisSystem.AutomaticSun:
                    """calculates the sun position according to the north direction and time zone location set"""
                    pass
                @property
                def manual_sun(self) -> global___Scene.SourceInstance.AmbientProperties.ManualSun:
                    """sets the sun position and direction from scene"""
                    pass
                def __init__(self,
                    *,
                    automatic_sun : typing.Optional[global___Scene.SourceInstance.AmbientProperties.SunAxisSystem.AutomaticSun] = ...,
                    manual_sun : typing.Optional[global___Scene.SourceInstance.AmbientProperties.ManualSun] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["automatic_sun",b"automatic_sun","manual_sun",b"manual_sun","sun_type",b"sun_type"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["automatic_sun",b"automatic_sun","manual_sun",b"manual_sun","sun_type",b"sun_type"]) -> None: ...
                def WhichOneof(self, oneof_group: typing_extensions.Literal["sun_type",b"sun_type"]) -> typing.Optional[typing_extensions.Literal["automatic_sun","manual_sun"]]: ...

            class UniformAmbientProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                MANUAL_SUN_FIELD_NUMBER: builtins.int
                @property
                def manual_sun(self) -> global___Scene.SourceInstance.AmbientProperties.ManualSun:
                    """sets the sun position and direction from scene"""
                    pass
                def __init__(self,
                    *,
                    manual_sun : typing.Optional[global___Scene.SourceInstance.AmbientProperties.ManualSun] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["manual_sun",b"manual_sun"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["manual_sun",b"manual_sun"]) -> None: ...

            class CieOvercastProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                def __init__(self,
                    ) -> None: ...

            class CieGeneralProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                NORTH_DIRECTION_FIELD_NUMBER: builtins.int
                REVERSE_NORTH_FIELD_NUMBER: builtins.int
                SUN_AXIS_SYSTEM_FIELD_NUMBER: builtins.int
                @property
                def north_direction(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                    """(X Y Z) Direction to the North"""
                    pass
                reverse_north: builtins.bool = ...
                """optional - if not set or false : normal is not reversed"""

                @property
                def sun_axis_system(self) -> global___Scene.SourceInstance.AmbientProperties.SunAxisSystem:
                    """Set the Sun direction"""
                    pass
                def __init__(self,
                    *,
                    north_direction : typing.Optional[typing.Iterable[builtins.float]] = ...,
                    reverse_north : builtins.bool = ...,
                    sun_axis_system : typing.Optional[global___Scene.SourceInstance.AmbientProperties.SunAxisSystem] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["sun_axis_system",b"sun_axis_system"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["north_direction",b"north_direction","reverse_north",b"reverse_north","sun_axis_system",b"sun_axis_system"]) -> None: ...

            class NaturalLightProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                NORTH_DIRECTION_FIELD_NUMBER: builtins.int
                REVERSE_NORTH_FIELD_NUMBER: builtins.int
                SUN_AXIS_SYSTEM_FIELD_NUMBER: builtins.int
                @property
                def north_direction(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                    """(X Y Z) Direction to the North"""
                    pass
                reverse_north: builtins.bool = ...
                """optional - if not set or false : normal is not reversed"""

                @property
                def sun_axis_system(self) -> global___Scene.SourceInstance.AmbientProperties.SunAxisSystem:
                    """Set the Sun direction"""
                    pass
                def __init__(self,
                    *,
                    north_direction : typing.Optional[typing.Iterable[builtins.float]] = ...,
                    reverse_north : builtins.bool = ...,
                    sun_axis_system : typing.Optional[global___Scene.SourceInstance.AmbientProperties.SunAxisSystem] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["sun_axis_system",b"sun_axis_system"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["north_direction",b"north_direction","reverse_north",b"reverse_north","sun_axis_system",b"sun_axis_system"]) -> None: ...

            class UsStandardProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                NORTH_DIRECTION_FIELD_NUMBER: builtins.int
                REVERSE_NORTH_FIELD_NUMBER: builtins.int
                SUN_AXIS_SYSTEM_FIELD_NUMBER: builtins.int
                @property
                def north_direction(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                    """(X Y Z) Direction to the North"""
                    pass
                reverse_north: builtins.bool = ...
                """optional - if not set or false : normal is not reversed"""

                @property
                def sun_axis_system(self) -> global___Scene.SourceInstance.AmbientProperties.SunAxisSystem:
                    """Set the Sun direction"""
                    pass
                def __init__(self,
                    *,
                    north_direction : typing.Optional[typing.Iterable[builtins.float]] = ...,
                    reverse_north : builtins.bool = ...,
                    sun_axis_system : typing.Optional[global___Scene.SourceInstance.AmbientProperties.SunAxisSystem] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["sun_axis_system",b"sun_axis_system"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["north_direction",b"north_direction","reverse_north",b"reverse_north","sun_axis_system",b"sun_axis_system"]) -> None: ...

            class EnvironmentMapProperties(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                NORTH_DIRECTION_FIELD_NUMBER: builtins.int
                REVERSE_NORTH_FIELD_NUMBER: builtins.int
                @property
                def north_direction(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                    """(X Y Z) Direction to the North"""
                    pass
                reverse_north: builtins.bool = ...
                """optional - if not set or false : normal is not reversed"""

                def __init__(self,
                    *,
                    north_direction : typing.Optional[typing.Iterable[builtins.float]] = ...,
                    reverse_north : builtins.bool = ...,
                    ) -> None: ...
                def ClearField(self, field_name: typing_extensions.Literal["north_direction",b"north_direction","reverse_north",b"reverse_north"]) -> None: ...

            ZENITH_DIRECTION_FIELD_NUMBER: builtins.int
            REVERSE_ZENITH_FIELD_NUMBER: builtins.int
            UNIFORM_AMBIENT_PROPERTIES_FIELD_NUMBER: builtins.int
            CIE_OVERCAST_PROPERTIES_FIELD_NUMBER: builtins.int
            CIE_GENERAL_PROPERTIES_FIELD_NUMBER: builtins.int
            NATURAL_LIGHT_PROPERTIES_FIELD_NUMBER: builtins.int
            US_STANDARD_PROPERTIES_FIELD_NUMBER: builtins.int
            ENVIRONMENT_MAP_PROPERTIES_FIELD_NUMBER: builtins.int
            @property
            def zenith_direction(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """line normal to the ground or Z direction"""
                pass
            reverse_zenith: builtins.bool = ...
            """optional - if not set or false : normal is not reversed"""

            @property
            def uniform_ambient_properties(self) -> global___Scene.SourceInstance.AmbientProperties.UniformAmbientProperties: ...
            @property
            def cie_overcast_properties(self) -> global___Scene.SourceInstance.AmbientProperties.CieOvercastProperties: ...
            @property
            def cie_general_properties(self) -> global___Scene.SourceInstance.AmbientProperties.CieGeneralProperties: ...
            @property
            def natural_light_properties(self) -> global___Scene.SourceInstance.AmbientProperties.NaturalLightProperties: ...
            @property
            def us_standard_properties(self) -> global___Scene.SourceInstance.AmbientProperties.UsStandardProperties: ...
            @property
            def environment_map_properties(self) -> global___Scene.SourceInstance.AmbientProperties.EnvironmentMapProperties: ...
            def __init__(self,
                *,
                zenith_direction : typing.Optional[typing.Iterable[builtins.float]] = ...,
                reverse_zenith : builtins.bool = ...,
                uniform_ambient_properties : typing.Optional[global___Scene.SourceInstance.AmbientProperties.UniformAmbientProperties] = ...,
                cie_overcast_properties : typing.Optional[global___Scene.SourceInstance.AmbientProperties.CieOvercastProperties] = ...,
                cie_general_properties : typing.Optional[global___Scene.SourceInstance.AmbientProperties.CieGeneralProperties] = ...,
                natural_light_properties : typing.Optional[global___Scene.SourceInstance.AmbientProperties.NaturalLightProperties] = ...,
                us_standard_properties : typing.Optional[global___Scene.SourceInstance.AmbientProperties.UsStandardProperties] = ...,
                environment_map_properties : typing.Optional[global___Scene.SourceInstance.AmbientProperties.EnvironmentMapProperties] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["cie_general_properties",b"cie_general_properties","cie_overcast_properties",b"cie_overcast_properties","environment_map_properties",b"environment_map_properties","natural_light_properties",b"natural_light_properties","source_properties",b"source_properties","uniform_ambient_properties",b"uniform_ambient_properties","us_standard_properties",b"us_standard_properties"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["cie_general_properties",b"cie_general_properties","cie_overcast_properties",b"cie_overcast_properties","environment_map_properties",b"environment_map_properties","natural_light_properties",b"natural_light_properties","reverse_zenith",b"reverse_zenith","source_properties",b"source_properties","uniform_ambient_properties",b"uniform_ambient_properties","us_standard_properties",b"us_standard_properties","zenith_direction",b"zenith_direction"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["source_properties",b"source_properties"]) -> typing.Optional[typing_extensions.Literal["uniform_ambient_properties","cie_overcast_properties","cie_general_properties","natural_light_properties","us_standard_properties","environment_map_properties"]]: ...

        class MetadataEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            value: typing.Text = ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        NAME_FIELD_NUMBER: builtins.int
        DISPLAY_NAME_FIELD_NUMBER: builtins.int
        DESCRIPTION_FIELD_NUMBER: builtins.int
        METADATA_FIELD_NUMBER: builtins.int
        SOURCE_GUID_FIELD_NUMBER: builtins.int
        LUMINAIRE_PROPERTIES_FIELD_NUMBER: builtins.int
        SURFACE_PROPERTIES_FIELD_NUMBER: builtins.int
        RAYFILE_PROPERTIES_FIELD_NUMBER: builtins.int
        THERMIC_PROPERTIES_FIELD_NUMBER: builtins.int
        DISPLAY_PROPERTIES_FIELD_NUMBER: builtins.int
        AMBIENT_PROPERTIES_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """Unique identifier in the scene"""

        display_name: typing.Text = ...
        """User name to be displayed"""

        description: typing.Text = ...
        @property
        def metadata(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
            """User defined metadata"""
            pass
        source_guid: typing.Text = ...
        """Guid of the SourceTemplate in SourceTemplatesManager to instantiate"""

        @property
        def luminaire_properties(self) -> global___Scene.SourceInstance.LuminaireProperties:
            """To be filled if the source_guid corresponds to a SourceTemplate of type Luminaire"""
            pass
        @property
        def surface_properties(self) -> global___Scene.SourceInstance.SurfaceProperties:
            """To be filled if the source_guid corresponds to a SourceTemplate of type Surface"""
            pass
        @property
        def rayfile_properties(self) -> global___Scene.SourceInstance.RayFileProperties:
            """To be filled if the source_guid corresponds to a SourceTemplate of type RayFile"""
            pass
        @property
        def thermic_properties(self) -> global___Scene.SourceInstance.ThermicProperties:
            """To be filled if the source_guid corresponds to a SourceTemplate of type Thermic Source"""
            pass
        @property
        def display_properties(self) -> global___Scene.SourceInstance.DisplayProperties:
            """To be filled if the source_guid corresponds to a SourceTemplate of type Display"""
            pass
        @property
        def ambient_properties(self) -> global___Scene.SourceInstance.AmbientProperties:
            """To be filled if the source_guid corresponds to a SourceTemplate of type Ambient"""
            pass
        def __init__(self,
            *,
            name : typing.Text = ...,
            display_name : typing.Text = ...,
            description : typing.Text = ...,
            metadata : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
            source_guid : typing.Text = ...,
            luminaire_properties : typing.Optional[global___Scene.SourceInstance.LuminaireProperties] = ...,
            surface_properties : typing.Optional[global___Scene.SourceInstance.SurfaceProperties] = ...,
            rayfile_properties : typing.Optional[global___Scene.SourceInstance.RayFileProperties] = ...,
            thermic_properties : typing.Optional[global___Scene.SourceInstance.ThermicProperties] = ...,
            display_properties : typing.Optional[global___Scene.SourceInstance.DisplayProperties] = ...,
            ambient_properties : typing.Optional[global___Scene.SourceInstance.AmbientProperties] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["ambient_properties",b"ambient_properties","display_properties",b"display_properties","luminaire_properties",b"luminaire_properties","properties",b"properties","rayfile_properties",b"rayfile_properties","surface_properties",b"surface_properties","thermic_properties",b"thermic_properties"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["ambient_properties",b"ambient_properties","description",b"description","display_name",b"display_name","display_properties",b"display_properties","luminaire_properties",b"luminaire_properties","metadata",b"metadata","name",b"name","properties",b"properties","rayfile_properties",b"rayfile_properties","source_guid",b"source_guid","surface_properties",b"surface_properties","thermic_properties",b"thermic_properties"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["properties",b"properties"]) -> typing.Optional[typing_extensions.Literal["luminaire_properties","surface_properties","rayfile_properties","thermic_properties","display_properties","ambient_properties"]]: ...

    class SensorInstance(google.protobuf.message.Message):
        """Instance of a sensor to add in the scene"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class _EnumRayFileType:
            ValueType = typing.NewType('ValueType', builtins.int)
            V: typing_extensions.TypeAlias = ValueType
        class _EnumRayFileTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumRayFileType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
            RayFileNone: Scene.SensorInstance.EnumRayFileType.ValueType = ...  # 0
            """Generates no ray file."""

            RayFileClassic: Scene.SensorInstance.EnumRayFileType.ValueType = ...  # 1
            """Generates a ray file without polarization data."""

            RayFilePolarization: Scene.SensorInstance.EnumRayFileType.ValueType = ...  # 2
            """Generates a ray file with the polarization data for each ray."""

            RayFileTM25: Scene.SensorInstance.EnumRayFileType.ValueType = ...  # 3
            """Generates a .tm25ray file with polarization data for each ray."""

            RayFileTM25NoPolarization: Scene.SensorInstance.EnumRayFileType.ValueType = ...  # 4
            """Generates a .tm25ray file without polarization data."""

        class EnumRayFileType(_EnumRayFileType, metaclass=_EnumRayFileTypeEnumTypeWrapper):
            """Ray file types available"""
            pass

        RayFileNone: Scene.SensorInstance.EnumRayFileType.ValueType = ...  # 0
        """Generates no ray file."""

        RayFileClassic: Scene.SensorInstance.EnumRayFileType.ValueType = ...  # 1
        """Generates a ray file without polarization data."""

        RayFilePolarization: Scene.SensorInstance.EnumRayFileType.ValueType = ...  # 2
        """Generates a ray file with the polarization data for each ray."""

        RayFileTM25: Scene.SensorInstance.EnumRayFileType.ValueType = ...  # 3
        """Generates a .tm25ray file with polarization data for each ray."""

        RayFileTM25NoPolarization: Scene.SensorInstance.EnumRayFileType.ValueType = ...  # 4
        """Generates a .tm25ray file without polarization data."""


        class LayerTypeNone(google.protobuf.message.Message):
            """Includes the simulation's results in one layer."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            def __init__(self,
                ) -> None: ...

        class LayerTypeSource(google.protobuf.message.Message):
            """Includes one layer per active source in the result."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            def __init__(self,
                ) -> None: ...

        class LayerTypeFace(google.protobuf.message.Message):
            """Includes one layer per surface selected in the result."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class _EnumSCAFilteringType:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType
            class _EnumSCAFilteringTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumSCAFilteringType.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                LastImpact: Scene.SensorInstance.LayerTypeFace.EnumSCAFilteringType.ValueType = ...  # 0
                IntersectedOneTime: Scene.SensorInstance.LayerTypeFace.EnumSCAFilteringType.ValueType = ...  # 1
            class EnumSCAFilteringType(_EnumSCAFilteringType, metaclass=_EnumSCAFilteringTypeEnumTypeWrapper):
                pass

            LastImpact: Scene.SensorInstance.LayerTypeFace.EnumSCAFilteringType.ValueType = ...  # 0
            IntersectedOneTime: Scene.SensorInstance.LayerTypeFace.EnumSCAFilteringType.ValueType = ...  # 1

            class Layer(google.protobuf.message.Message):
                DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
                NAME_FIELD_NUMBER: builtins.int
                GEOMETRIES_FIELD_NUMBER: builtins.int
                name: typing.Text = ...
                """Name of the layer"""

                @property
                def geometries(self) -> global___Scene.GeoPaths:
                    """Surface selected."""
                    pass
                def __init__(self,
                    *,
                    name : typing.Text = ...,
                    geometries : typing.Optional[global___Scene.GeoPaths] = ...,
                    ) -> None: ...
                def HasField(self, field_name: typing_extensions.Literal["geometries",b"geometries"]) -> builtins.bool: ...
                def ClearField(self, field_name: typing_extensions.Literal["geometries",b"geometries","name",b"name"]) -> None: ...

            SCA_FILTERING_MODE_FIELD_NUMBER: builtins.int
            LAYERS_FIELD_NUMBER: builtins.int
            sca_filtering_mode: global___Scene.SensorInstance.LayerTypeFace.EnumSCAFilteringType.ValueType = ...
            @property
            def layers(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Scene.SensorInstance.LayerTypeFace.Layer]:
                """Layers that will be taken into account in the result."""
                pass
            def __init__(self,
                *,
                sca_filtering_mode : global___Scene.SensorInstance.LayerTypeFace.EnumSCAFilteringType.ValueType = ...,
                layers : typing.Optional[typing.Iterable[global___Scene.SensorInstance.LayerTypeFace.Layer]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["layers",b"layers","sca_filtering_mode",b"sca_filtering_mode"]) -> None: ...

        class LayerTypeSequence(google.protobuf.message.Message):
            """Includes one layer per sequence in the result."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            class _EnumSequenceType:
                ValueType = typing.NewType('ValueType', builtins.int)
                V: typing_extensions.TypeAlias = ValueType
            class _EnumSequenceTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnumSequenceType.ValueType], builtins.type):
                DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
                Geometries: Scene.SensorInstance.LayerTypeSequence.EnumSequenceType.ValueType = ...  # 0
                Faces: Scene.SensorInstance.LayerTypeSequence.EnumSequenceType.ValueType = ...  # 1
            class EnumSequenceType(_EnumSequenceType, metaclass=_EnumSequenceTypeEnumTypeWrapper):
                pass

            Geometries: Scene.SensorInstance.LayerTypeSequence.EnumSequenceType.ValueType = ...  # 0
            Faces: Scene.SensorInstance.LayerTypeSequence.EnumSequenceType.ValueType = ...  # 1

            MAXIMUM_NB_OF_SEQUENCE_FIELD_NUMBER: builtins.int
            DEFINE_SEQUENCE_PER_FIELD_NUMBER: builtins.int
            maximum_nb_of_sequence: builtins.int = ...
            define_sequence_per: global___Scene.SensorInstance.LayerTypeSequence.EnumSequenceType.ValueType = ...
            def __init__(self,
                *,
                maximum_nb_of_sequence : builtins.int = ...,
                define_sequence_per : global___Scene.SensorInstance.LayerTypeSequence.EnumSequenceType.ValueType = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["define_sequence_per",b"define_sequence_per","maximum_nb_of_sequence",b"maximum_nb_of_sequence"]) -> None: ...

        class LayerTypePolarization(google.protobuf.message.Message):
            """Includes one layer per Stokes parameter using the polarization parameter."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            def __init__(self,
                ) -> None: ...

        class LayerTypeIncidenceAngle(google.protobuf.message.Message):
            """Includes one layer per range of incident angles."""
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            SAMPLING_FIELD_NUMBER: builtins.int
            sampling: builtins.int = ...
            def __init__(self,
                *,
                sampling : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["sampling",b"sampling"]) -> None: ...

        class CameraProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            TRAJECTORY_FILE_URI_FIELD_NUMBER: builtins.int
            LAYER_TYPE_NONE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_SOURCE_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the sensor (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                pass
            trajectory_file_uri: typing.Text = ...
            """Trajectory file, used to define the positions and orientations of the Camera sensor in time."""

            @property
            def layer_type_none(self) -> global___Scene.SensorInstance.LayerTypeNone:
                """Layer type : None"""
                pass
            @property
            def layer_type_source(self) -> global___Scene.SensorInstance.LayerTypeSource:
                """Layer type : Source"""
                pass
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                trajectory_file_uri : typing.Text = ...,
                layer_type_none : typing.Optional[global___Scene.SensorInstance.LayerTypeNone] = ...,
                layer_type_source : typing.Optional[global___Scene.SensorInstance.LayerTypeSource] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["layer_type",b"layer_type","layer_type_none",b"layer_type_none","layer_type_source",b"layer_type_source"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","layer_type",b"layer_type","layer_type_none",b"layer_type_none","layer_type_source",b"layer_type_source","trajectory_file_uri",b"trajectory_file_uri"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["layer_type",b"layer_type"]) -> typing.Optional[typing_extensions.Literal["layer_type_none","layer_type_source"]]: ...

        class IrradianceProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            RAY_FILE_TYPE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_NONE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_SOURCE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_FACE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_SEQUENCE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_POLARIZATION_FIELD_NUMBER: builtins.int
            LAYER_TYPE_INCIDENCE_ANGLE_FIELD_NUMBER: builtins.int
            INTEGRATION_DIRECTION_FIELD_NUMBER: builtins.int
            OUTPUT_FACE_GEOMETRIES_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the sensor (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                pass
            ray_file_type: global___Scene.SensorInstance.EnumRayFileType.ValueType = ...
            """Choose type of ray file generated after the simulation."""

            @property
            def layer_type_none(self) -> global___Scene.SensorInstance.LayerTypeNone:
                """Layer type : None"""
                pass
            @property
            def layer_type_source(self) -> global___Scene.SensorInstance.LayerTypeSource:
                """Layer type : Source"""
                pass
            @property
            def layer_type_face(self) -> global___Scene.SensorInstance.LayerTypeFace:
                """Layer type : Face"""
                pass
            @property
            def layer_type_sequence(self) -> global___Scene.SensorInstance.LayerTypeSequence:
                """Layer type : Sequence"""
                pass
            @property
            def layer_type_polarization(self) -> global___Scene.SensorInstance.LayerTypePolarization:
                """Layer type : Polarization"""
                pass
            @property
            def layer_type_incidence_angle(self) -> global___Scene.SensorInstance.LayerTypeIncidenceAngle:
                """Layer type : Incidence angle"""
                pass
            @property
            def integration_direction(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Sensor global integration direction [x,y,z], optional (default direction is Z axis of axis_system). Note: Contrary to any visualization of integration directions within Speos Software or its documentation the integration direction must be set in the anti-rays direction to integrate their signal. Integration direction is only settable for sensor template with IlluminanceTypePlanar or IlluminanceTypeSemiCylindrical as illuminance_type."""
                pass
            @property
            def output_face_geometries(self) -> global___Scene.GeoPaths:
                """List of output faces for inverse simulation optimization"""
                pass
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                ray_file_type : global___Scene.SensorInstance.EnumRayFileType.ValueType = ...,
                layer_type_none : typing.Optional[global___Scene.SensorInstance.LayerTypeNone] = ...,
                layer_type_source : typing.Optional[global___Scene.SensorInstance.LayerTypeSource] = ...,
                layer_type_face : typing.Optional[global___Scene.SensorInstance.LayerTypeFace] = ...,
                layer_type_sequence : typing.Optional[global___Scene.SensorInstance.LayerTypeSequence] = ...,
                layer_type_polarization : typing.Optional[global___Scene.SensorInstance.LayerTypePolarization] = ...,
                layer_type_incidence_angle : typing.Optional[global___Scene.SensorInstance.LayerTypeIncidenceAngle] = ...,
                integration_direction : typing.Optional[typing.Iterable[builtins.float]] = ...,
                output_face_geometries : typing.Optional[global___Scene.GeoPaths] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["layer_type",b"layer_type","layer_type_face",b"layer_type_face","layer_type_incidence_angle",b"layer_type_incidence_angle","layer_type_none",b"layer_type_none","layer_type_polarization",b"layer_type_polarization","layer_type_sequence",b"layer_type_sequence","layer_type_source",b"layer_type_source","output_face_geometries",b"output_face_geometries"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","integration_direction",b"integration_direction","layer_type",b"layer_type","layer_type_face",b"layer_type_face","layer_type_incidence_angle",b"layer_type_incidence_angle","layer_type_none",b"layer_type_none","layer_type_polarization",b"layer_type_polarization","layer_type_sequence",b"layer_type_sequence","layer_type_source",b"layer_type_source","output_face_geometries",b"output_face_geometries","ray_file_type",b"ray_file_type"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["layer_type",b"layer_type"]) -> typing.Optional[typing_extensions.Literal["layer_type_none","layer_type_source","layer_type_face","layer_type_sequence","layer_type_polarization","layer_type_incidence_angle"]]: ...

        class RadianceProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            OBSERVER_POINT_FIELD_NUMBER: builtins.int
            LAYER_TYPE_NONE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_SOURCE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_FACE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_SEQUENCE_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the sensor (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                pass
            @property
            def observer_point(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the observer point (Ox Oy Oz), optional (default: focal length is used)"""
                pass
            @property
            def layer_type_none(self) -> global___Scene.SensorInstance.LayerTypeNone:
                """Layer type : None"""
                pass
            @property
            def layer_type_source(self) -> global___Scene.SensorInstance.LayerTypeSource:
                """Layer type : Source"""
                pass
            @property
            def layer_type_face(self) -> global___Scene.SensorInstance.LayerTypeFace:
                """Layer type : Face"""
                pass
            @property
            def layer_type_sequence(self) -> global___Scene.SensorInstance.LayerTypeSequence:
                """Layer type : Sequence"""
                pass
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                observer_point : typing.Optional[typing.Iterable[builtins.float]] = ...,
                layer_type_none : typing.Optional[global___Scene.SensorInstance.LayerTypeNone] = ...,
                layer_type_source : typing.Optional[global___Scene.SensorInstance.LayerTypeSource] = ...,
                layer_type_face : typing.Optional[global___Scene.SensorInstance.LayerTypeFace] = ...,
                layer_type_sequence : typing.Optional[global___Scene.SensorInstance.LayerTypeSequence] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["layer_type",b"layer_type","layer_type_face",b"layer_type_face","layer_type_none",b"layer_type_none","layer_type_sequence",b"layer_type_sequence","layer_type_source",b"layer_type_source"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","layer_type",b"layer_type","layer_type_face",b"layer_type_face","layer_type_none",b"layer_type_none","layer_type_sequence",b"layer_type_sequence","layer_type_source",b"layer_type_source","observer_point",b"observer_point"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["layer_type",b"layer_type"]) -> typing.Optional[typing_extensions.Literal["layer_type_none","layer_type_source","layer_type_face","layer_type_sequence"]]: ...

        class LXPProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            NB_MAX_PATHS_FIELD_NUMBER: builtins.int
            nb_max_paths: builtins.int = ...
            """The Maximum paths corresponds to the maximum number of rays the Light Expert file (*.lpf or *.lp3) can contain."""

            def __init__(self,
                *,
                nb_max_paths : builtins.int = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["nb_max_paths",b"nb_max_paths"]) -> None: ...

        class IntensityProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            LAYER_TYPE_NONE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_SOURCE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_FACE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_SEQUENCE_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the sensor (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                pass
            @property
            def layer_type_none(self) -> global___Scene.SensorInstance.LayerTypeNone:
                """Layer type: None"""
                pass
            @property
            def layer_type_source(self) -> global___Scene.SensorInstance.LayerTypeSource:
                """Layer type: Source"""
                pass
            @property
            def layer_type_face(self) -> global___Scene.SensorInstance.LayerTypeFace:
                """Layer type: Face"""
                pass
            @property
            def layer_type_sequence(self) -> global___Scene.SensorInstance.LayerTypeSequence:
                """Layer type: Sequence"""
                pass
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                layer_type_none : typing.Optional[global___Scene.SensorInstance.LayerTypeNone] = ...,
                layer_type_source : typing.Optional[global___Scene.SensorInstance.LayerTypeSource] = ...,
                layer_type_face : typing.Optional[global___Scene.SensorInstance.LayerTypeFace] = ...,
                layer_type_sequence : typing.Optional[global___Scene.SensorInstance.LayerTypeSequence] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["layer_type",b"layer_type","layer_type_face",b"layer_type_face","layer_type_none",b"layer_type_none","layer_type_sequence",b"layer_type_sequence","layer_type_source",b"layer_type_source"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","layer_type",b"layer_type","layer_type_face",b"layer_type_face","layer_type_none",b"layer_type_none","layer_type_sequence",b"layer_type_sequence","layer_type_source",b"layer_type_source"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["layer_type",b"layer_type"]) -> typing.Optional[typing_extensions.Literal["layer_type_none","layer_type_source","layer_type_face","layer_type_sequence"]]: ...

        class PolarIntensityProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the sensor (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
                pass
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system"]) -> None: ...

        class Irradiance3DProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            RAY_FILE_TYPE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_NONE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_SOURCE_FIELD_NUMBER: builtins.int
            GEOMETRIES_FIELD_NUMBER: builtins.int
            ray_file_type: global___Scene.SensorInstance.EnumRayFileType.ValueType = ...
            """Choose type of ray file generated after the simulation."""

            @property
            def layer_type_none(self) -> global___Scene.SensorInstance.LayerTypeNone:
                """Layer type : None"""
                pass
            @property
            def layer_type_source(self) -> global___Scene.SensorInstance.LayerTypeSource:
                """Layer type : Source"""
                pass
            @property
            def geometries(self) -> global___Scene.GeoPaths:
                """Geometries that will use this sensor"""
                pass
            def __init__(self,
                *,
                ray_file_type : global___Scene.SensorInstance.EnumRayFileType.ValueType = ...,
                layer_type_none : typing.Optional[global___Scene.SensorInstance.LayerTypeNone] = ...,
                layer_type_source : typing.Optional[global___Scene.SensorInstance.LayerTypeSource] = ...,
                geometries : typing.Optional[global___Scene.GeoPaths] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["geometries",b"geometries","layer_type",b"layer_type","layer_type_none",b"layer_type_none","layer_type_source",b"layer_type_source"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["geometries",b"geometries","layer_type",b"layer_type","layer_type_none",b"layer_type_none","layer_type_source",b"layer_type_source","ray_file_type",b"ray_file_type"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["layer_type",b"layer_type"]) -> typing.Optional[typing_extensions.Literal["layer_type_none","layer_type_source"]]: ...

        class ObserverProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            LAYER_TYPE_NONE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_SOURCE_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the observed object/scene. (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). X corresponds to Horizontal direction. Y corresponds to Vertical direction."""
                pass
            @property
            def layer_type_none(self) -> global___Scene.SensorInstance.LayerTypeNone:
                """Layer type : None."""
                pass
            @property
            def layer_type_source(self) -> global___Scene.SensorInstance.LayerTypeSource:
                """Layer type : Source."""
                pass
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                layer_type_none : typing.Optional[global___Scene.SensorInstance.LayerTypeNone] = ...,
                layer_type_source : typing.Optional[global___Scene.SensorInstance.LayerTypeSource] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["layer_type",b"layer_type","layer_type_none",b"layer_type_none","layer_type_source",b"layer_type_source"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","layer_type",b"layer_type","layer_type_none",b"layer_type_none","layer_type_source",b"layer_type_source"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["layer_type",b"layer_type"]) -> typing.Optional[typing_extensions.Literal["layer_type_none","layer_type_source"]]: ...

        class ImmersiveProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            LAYER_TYPE_NONE_FIELD_NUMBER: builtins.int
            LAYER_TYPE_SOURCE_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Position of the sensor (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). X corresponds to Front direction. Y corresponds to Top direction. Z corresponds to Right direction."""
                pass
            @property
            def layer_type_none(self) -> global___Scene.SensorInstance.LayerTypeNone:
                """Layer type : None."""
                pass
            @property
            def layer_type_source(self) -> global___Scene.SensorInstance.LayerTypeSource:
                """Layer type : Source."""
                pass
            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                layer_type_none : typing.Optional[global___Scene.SensorInstance.LayerTypeNone] = ...,
                layer_type_source : typing.Optional[global___Scene.SensorInstance.LayerTypeSource] = ...,
                ) -> None: ...
            def HasField(self, field_name: typing_extensions.Literal["layer_type",b"layer_type","layer_type_none",b"layer_type_none","layer_type_source",b"layer_type_source"]) -> builtins.bool: ...
            def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","layer_type",b"layer_type","layer_type_none",b"layer_type_none","layer_type_source",b"layer_type_source"]) -> None: ...
            def WhichOneof(self, oneof_group: typing_extensions.Literal["layer_type",b"layer_type"]) -> typing.Optional[typing_extensions.Literal["layer_type_none","layer_type_source"]]: ...

        class MetadataEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            value: typing.Text = ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        NAME_FIELD_NUMBER: builtins.int
        DISPLAY_NAME_FIELD_NUMBER: builtins.int
        DESCRIPTION_FIELD_NUMBER: builtins.int
        METADATA_FIELD_NUMBER: builtins.int
        SENSOR_GUID_FIELD_NUMBER: builtins.int
        RESULT_FILE_NAME_FIELD_NUMBER: builtins.int
        CAMERA_PROPERTIES_FIELD_NUMBER: builtins.int
        IRRADIANCE_PROPERTIES_FIELD_NUMBER: builtins.int
        RADIANCE_PROPERTIES_FIELD_NUMBER: builtins.int
        INTENSITY_PROPERTIES_FIELD_NUMBER: builtins.int
        POLAR_INTENSITY_PROPERTIES_FIELD_NUMBER: builtins.int
        IRRADIANCE_3D_PROPERTIES_FIELD_NUMBER: builtins.int
        OBSERVER_PROPERTIES_FIELD_NUMBER: builtins.int
        IMMERSIVE_PROPERTIES_FIELD_NUMBER: builtins.int
        LXP_PROPERTIES_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """Unique identifier in the scene"""

        display_name: typing.Text = ...
        """User name to be displayed"""

        description: typing.Text = ...
        @property
        def metadata(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
            """User defined metadata"""
            pass
        sensor_guid: typing.Text = ...
        """Guid of the SensorTemplate in SensorTemplatesManager to instantiate"""

        result_file_name: typing.Text = ...
        """Result file name without extention. Result files of the sensor will be based on this name."""

        @property
        def camera_properties(self) -> global___Scene.SensorInstance.CameraProperties:
            """To be filled if the sensor_guid corresponds to a SensorTemplate of type CameraSensorTemplate"""
            pass
        @property
        def irradiance_properties(self) -> global___Scene.SensorInstance.IrradianceProperties:
            """To be filled if the sensor_guid corresponds to a SensorTemplate of type IrradianceSensorTemplate"""
            pass
        @property
        def radiance_properties(self) -> global___Scene.SensorInstance.RadianceProperties:
            """To be filled if the sensor_guid corresponds to a SensorTemplate of type SensorTemplate::Radiance"""
            pass
        @property
        def intensity_properties(self) -> global___Scene.SensorInstance.IntensityProperties:
            """To be filled if the sensor_guid corresponds to a SensorTemplate of type IntensitySensorTemplate"""
            pass
        @property
        def polar_intensity_properties(self) -> global___Scene.SensorInstance.PolarIntensityProperties:
            """To be filled if the sensor_guid corresponds to a SensorTemplate of type PolarIntensitySensorTemplate"""
            pass
        @property
        def irradiance_3d_properties(self) -> global___Scene.SensorInstance.Irradiance3DProperties:
            """To be filled if the sensor_guid corresponds to a SensorTemplate of type SensorTemplate::Irradiance3D"""
            pass
        @property
        def observer_properties(self) -> global___Scene.SensorInstance.ObserverProperties:
            """To be filled if the sensor_guid corresponds to a SensorTemplate of type SensorTemplate::Observer"""
            pass
        @property
        def immersive_properties(self) -> global___Scene.SensorInstance.ImmersiveProperties:
            """To be filled if the sensor_guid corresponds to a SensorTemplate of type SensorTemplate::Immersive"""
            pass
        @property
        def lxp_properties(self) -> global___Scene.SensorInstance.LXPProperties:
            """To activate lxp feature, we must fill this field"""
            pass
        def __init__(self,
            *,
            name : typing.Text = ...,
            display_name : typing.Text = ...,
            description : typing.Text = ...,
            metadata : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
            sensor_guid : typing.Text = ...,
            result_file_name : typing.Text = ...,
            camera_properties : typing.Optional[global___Scene.SensorInstance.CameraProperties] = ...,
            irradiance_properties : typing.Optional[global___Scene.SensorInstance.IrradianceProperties] = ...,
            radiance_properties : typing.Optional[global___Scene.SensorInstance.RadianceProperties] = ...,
            intensity_properties : typing.Optional[global___Scene.SensorInstance.IntensityProperties] = ...,
            polar_intensity_properties : typing.Optional[global___Scene.SensorInstance.PolarIntensityProperties] = ...,
            irradiance_3d_properties : typing.Optional[global___Scene.SensorInstance.Irradiance3DProperties] = ...,
            observer_properties : typing.Optional[global___Scene.SensorInstance.ObserverProperties] = ...,
            immersive_properties : typing.Optional[global___Scene.SensorInstance.ImmersiveProperties] = ...,
            lxp_properties : typing.Optional[global___Scene.SensorInstance.LXPProperties] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["camera_properties",b"camera_properties","immersive_properties",b"immersive_properties","intensity_properties",b"intensity_properties","irradiance_3d_properties",b"irradiance_3d_properties","irradiance_properties",b"irradiance_properties","lxp_properties",b"lxp_properties","observer_properties",b"observer_properties","polar_intensity_properties",b"polar_intensity_properties","properties",b"properties","radiance_properties",b"radiance_properties"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["camera_properties",b"camera_properties","description",b"description","display_name",b"display_name","immersive_properties",b"immersive_properties","intensity_properties",b"intensity_properties","irradiance_3d_properties",b"irradiance_3d_properties","irradiance_properties",b"irradiance_properties","lxp_properties",b"lxp_properties","metadata",b"metadata","name",b"name","observer_properties",b"observer_properties","polar_intensity_properties",b"polar_intensity_properties","properties",b"properties","radiance_properties",b"radiance_properties","result_file_name",b"result_file_name","sensor_guid",b"sensor_guid"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["properties",b"properties"]) -> typing.Optional[typing_extensions.Literal["camera_properties","irradiance_properties","radiance_properties","intensity_properties","polar_intensity_properties","irradiance_3d_properties","observer_properties","immersive_properties"]]: ...

    class SimulationInstance(google.protobuf.message.Message):
        """Instance of a simulation to add in the scene"""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class MetadataEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            value: typing.Text = ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        class VirtualBSDFBenchProperties(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            AXIS_SYSTEM_FIELD_NUMBER: builtins.int
            ANALYSIS_X_RATIO_FIELD_NUMBER: builtins.int
            ANALYSIS_Y_RATIO_FIELD_NUMBER: builtins.int
            @property
            def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
                """Axis system of measurement (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz), O will be the measurement position, Z will be the normal axis (theta angle reference) and X the orientation on the surface (phi angle reference)"""
                pass
            analysis_x_ratio: builtins.float = ...
            """Ratio to reduce the analysis area following x, must be in range ]0., 100.]"""

            analysis_y_ratio: builtins.float = ...
            """Ratio to reduce the analysis area following y, must be in range ]0., 100.]"""

            def __init__(self,
                *,
                axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
                analysis_x_ratio : builtins.float = ...,
                analysis_y_ratio : builtins.float = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["analysis_x_ratio",b"analysis_x_ratio","analysis_y_ratio",b"analysis_y_ratio","axis_system",b"axis_system"]) -> None: ...

        NAME_FIELD_NUMBER: builtins.int
        DISPLAY_NAME_FIELD_NUMBER: builtins.int
        DESCRIPTION_FIELD_NUMBER: builtins.int
        METADATA_FIELD_NUMBER: builtins.int
        SIMULATION_GUID_FIELD_NUMBER: builtins.int
        SENSOR_PATHS_FIELD_NUMBER: builtins.int
        SOURCE_PATHS_FIELD_NUMBER: builtins.int
        GEOMETRIES_FIELD_NUMBER: builtins.int
        VBB_PROPERTIES_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """Unique identifier in the scene"""

        display_name: typing.Text = ...
        """User name to be displayed"""

        description: typing.Text = ...
        @property
        def metadata(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
            """User defined metadata"""
            pass
        simulation_guid: typing.Text = ...
        """Guid of the element to instantiate"""

        @property
        def sensor_paths(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """Sensors that this simulation will include (empty for no sensor, [""] for all sensors, "<sensor name>" for a specific sensor in the current scene, or "<scene name>/<sensor name>" for a specific sensor in a specific sub scene)"""
            pass
        @property
        def source_paths(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
            """Sources that this simulation will include (empty for no source, [""] for all sources, "<source name>" for a specific source in the current scene, or "<scene name>/<source name>" for a specific source in a specific sub scene)"""
            pass
        @property
        def geometries(self) -> global___Scene.GeoPaths:
            """Geometries that this simulation will include - Not yet functional (All geometries are included by default in each simulation)"""
            pass
        @property
        def vbb_properties(self) -> global___Scene.SimulationInstance.VirtualBSDFBenchProperties:
            """To be filled if the simulation_guid corresponds to a SimulationTemplate of type VirtualBSDFBench"""
            pass
        def __init__(self,
            *,
            name : typing.Text = ...,
            display_name : typing.Text = ...,
            description : typing.Text = ...,
            metadata : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
            simulation_guid : typing.Text = ...,
            sensor_paths : typing.Optional[typing.Iterable[typing.Text]] = ...,
            source_paths : typing.Optional[typing.Iterable[typing.Text]] = ...,
            geometries : typing.Optional[global___Scene.GeoPaths] = ...,
            vbb_properties : typing.Optional[global___Scene.SimulationInstance.VirtualBSDFBenchProperties] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["geometries",b"geometries","properties",b"properties","vbb_properties",b"vbb_properties"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["description",b"description","display_name",b"display_name","geometries",b"geometries","metadata",b"metadata","name",b"name","properties",b"properties","sensor_paths",b"sensor_paths","simulation_guid",b"simulation_guid","source_paths",b"source_paths","vbb_properties",b"vbb_properties"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["properties",b"properties"]) -> typing.Optional[typing_extensions.Literal["vbb_properties"]]: ...

    class SceneInstance(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        class MetadataEntry(google.protobuf.message.Message):
            DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
            KEY_FIELD_NUMBER: builtins.int
            VALUE_FIELD_NUMBER: builtins.int
            key: typing.Text = ...
            value: typing.Text = ...
            def __init__(self,
                *,
                key : typing.Text = ...,
                value : typing.Text = ...,
                ) -> None: ...
            def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

        NAME_FIELD_NUMBER: builtins.int
        DISPLAY_NAME_FIELD_NUMBER: builtins.int
        DESCRIPTION_FIELD_NUMBER: builtins.int
        METADATA_FIELD_NUMBER: builtins.int
        SCENE_GUID_FIELD_NUMBER: builtins.int
        AXIS_SYSTEM_FIELD_NUMBER: builtins.int
        name: typing.Text = ...
        """Unique identifier in the scene"""

        display_name: typing.Text = ...
        """User name to be displayed"""

        description: typing.Text = ...
        @property
        def metadata(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
            """User defined metadata"""
            pass
        scene_guid: typing.Text = ...
        """Guid of the element to instantiate"""

        @property
        def axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
            """Scene position relative to parent PartTemplate reference (Ox Oy Oz Xx Xy Xz Yx Yy Yz Zx Zy Zz). If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
            pass
        def __init__(self,
            *,
            name : typing.Text = ...,
            display_name : typing.Text = ...,
            description : typing.Text = ...,
            metadata : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
            scene_guid : typing.Text = ...,
            axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["axis_system",b"axis_system","description",b"description","display_name",b"display_name","metadata",b"metadata","name",b"name","scene_guid",b"scene_guid"]) -> None: ...

    class GroundPlane(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        GROUND_ORIGIN_FIELD_NUMBER: builtins.int
        ZENITH_DIRECTION_FIELD_NUMBER: builtins.int
        GROUND_HEIGHT_FIELD_NUMBER: builtins.int
        @property
        def ground_origin(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
            """3D point in the geometry. HDR image is displayed on the ground plane"""
            pass
        @property
        def zenith_direction(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
            """line normal to the ground or Z direction"""
            pass
        ground_height: builtins.float = ...
        """height of the environment shooting (unit mm)"""

        def __init__(self,
            *,
            ground_origin : typing.Optional[typing.Iterable[builtins.float]] = ...,
            zenith_direction : typing.Optional[typing.Iterable[builtins.float]] = ...,
            ground_height : builtins.float = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["ground_height",b"ground_height","ground_origin",b"ground_origin","zenith_direction",b"zenith_direction"]) -> None: ...

    class MetadataEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["key",b"key","value",b"value"]) -> None: ...

    NAME_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    PART_GUID_FIELD_NUMBER: builtins.int
    SUB_SCENE_ANCHOR_AXIS_SYSTEM_FIELD_NUMBER: builtins.int
    SOURCES_FIELD_NUMBER: builtins.int
    SENSORS_FIELD_NUMBER: builtins.int
    SIMULATIONS_FIELD_NUMBER: builtins.int
    MATERIALS_FIELD_NUMBER: builtins.int
    SCENES_FIELD_NUMBER: builtins.int
    GROUND_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    description: typing.Text = ...
    @property
    def metadata(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """User defined metadata"""
        pass
    part_guid: typing.Text = ...
    """Guid from PartsManager of the geometrical part included inside the scene"""

    @property
    def sub_scene_anchor_axis_system(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """Only used for sub-scene - Represents the axis system to be attached to the one describing the scene instance. If the coordinate system is not orthonormal, it will be automatically orthonormalized"""
        pass
    @property
    def sources(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Scene.SourceInstance]:
        """The sources added in the scene"""
        pass
    @property
    def sensors(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Scene.SensorInstance]:
        """The sensors added in the scene"""
        pass
    @property
    def simulations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Scene.SimulationInstance]:
        """The simulations added in the scene"""
        pass
    @property
    def materials(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Scene.MaterialInstance]:
        """The materials (volume + surface) applied on geometries"""
        pass
    @property
    def scenes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Scene.SceneInstance]:
        """Sub scenes"""
        pass
    @property
    def ground(self) -> global___Scene.GroundPlane:
        """Optional - Only usable when there is at least one Ambient Environment Source Template that has selected a HDR image file."""
        pass
    def __init__(self,
        *,
        name : typing.Text = ...,
        description : typing.Text = ...,
        metadata : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        part_guid : typing.Text = ...,
        sub_scene_anchor_axis_system : typing.Optional[typing.Iterable[builtins.float]] = ...,
        sources : typing.Optional[typing.Iterable[global___Scene.SourceInstance]] = ...,
        sensors : typing.Optional[typing.Iterable[global___Scene.SensorInstance]] = ...,
        simulations : typing.Optional[typing.Iterable[global___Scene.SimulationInstance]] = ...,
        materials : typing.Optional[typing.Iterable[global___Scene.MaterialInstance]] = ...,
        scenes : typing.Optional[typing.Iterable[global___Scene.SceneInstance]] = ...,
        ground : typing.Optional[global___Scene.GroundPlane] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["ground",b"ground"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["description",b"description","ground",b"ground","materials",b"materials","metadata",b"metadata","name",b"name","part_guid",b"part_guid","scenes",b"scenes","sensors",b"sensors","simulations",b"simulations","sources",b"sources","sub_scene_anchor_axis_system",b"sub_scene_anchor_axis_system"]) -> None: ...
global___Scene = Scene

class Create_Request(google.protobuf.message.Message):
    """Request to create a Scene in ScenesManager"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SCENE_FIELD_NUMBER: builtins.int
    GUID_FIELD_NUMBER: builtins.int
    @property
    def scene(self) -> global___Scene: ...
    guid: typing.Text = ...
    """Optional field to specify the guid used in the database. If not set, a unique guid will be generated for that entry and sent back in the Create_Response."""

    def __init__(self,
        *,
        scene : typing.Optional[global___Scene] = ...,
        guid : typing.Optional[typing.Text] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_guid",b"_guid","guid",b"guid","scene",b"scene"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_guid",b"_guid","guid",b"guid","scene",b"scene"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_guid",b"_guid"]) -> typing.Optional[typing_extensions.Literal["guid"]]: ...
global___Create_Request = Create_Request

class Create_Response(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GUID_FIELD_NUMBER: builtins.int
    guid: typing.Text = ...
    """Guid of the Scene created in ScenesManager"""

    def __init__(self,
        *,
        guid : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["guid",b"guid"]) -> None: ...
global___Create_Response = Create_Response

class Read_Request(google.protobuf.message.Message):
    """Request to read a Scene in ScenesManager"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GUID_FIELD_NUMBER: builtins.int
    guid: typing.Text = ...
    """Guid of the Scene to be read"""

    def __init__(self,
        *,
        guid : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["guid",b"guid"]) -> None: ...
global___Read_Request = Read_Request

class Read_Response(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    SCENE_FIELD_NUMBER: builtins.int
    @property
    def scene(self) -> global___Scene:
        """Scene corresponding to the guid given in Read_Request"""
        pass
    def __init__(self,
        *,
        scene : typing.Optional[global___Scene] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["scene",b"scene"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["scene",b"scene"]) -> None: ...
global___Read_Response = Read_Response

class Update_Request(google.protobuf.message.Message):
    """Request to update a Scene in ScenesManager"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GUID_FIELD_NUMBER: builtins.int
    SCENE_FIELD_NUMBER: builtins.int
    guid: typing.Text = ...
    """Guid of the Scene to be updated"""

    @property
    def scene(self) -> global___Scene:
        """Scene that will be used for the update"""
        pass
    def __init__(self,
        *,
        guid : typing.Text = ...,
        scene : typing.Optional[global___Scene] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["scene",b"scene"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["guid",b"guid","scene",b"scene"]) -> None: ...
global___Update_Request = Update_Request

class Update_Response(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___Update_Response = Update_Response

class Delete_Request(google.protobuf.message.Message):
    """Request to delete a Scene in ScenesManager"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GUID_FIELD_NUMBER: builtins.int
    guid: typing.Text = ...
    """Guid of the Scene to be deleted"""

    def __init__(self,
        *,
        guid : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["guid",b"guid"]) -> None: ...
global___Delete_Request = Delete_Request

class Delete_Response(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___Delete_Response = Delete_Response

class List_Request(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___List_Request = List_Request

class List_Response(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GUIDS_FIELD_NUMBER: builtins.int
    @property
    def guids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Guids of the Scenes in ScenesManager"""
        pass
    def __init__(self,
        *,
        guids : typing.Optional[typing.Iterable[typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["guids",b"guids"]) -> None: ...
global___List_Response = List_Response

class LoadFile_Request(google.protobuf.message.Message):
    """Request to LoadFile service"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GUID_FIELD_NUMBER: builtins.int
    FILE_URI_FIELD_NUMBER: builtins.int
    PASSWORD_FIELD_NUMBER: builtins.int
    guid: typing.Text = ...
    """Guid of a ScenesManager element to update"""

    file_uri: typing.Text = ...
    """File uri (path or guid from FileTransferService)"""

    password: typing.Text = ...
    """Password needed to open the speos lightbox file (only necessary if user protects the speos light box with a password)"""

    def __init__(self,
        *,
        guid : typing.Text = ...,
        file_uri : typing.Text = ...,
        password : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["file_uri",b"file_uri","guid",b"guid","password",b"password"]) -> None: ...
global___LoadFile_Request = LoadFile_Request

class LoadFile_Response(google.protobuf.message.Message):
    """Response to LoadFile service"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___LoadFile_Response = LoadFile_Response

class SaveFile_Request(google.protobuf.message.Message):
    """Request to SaveFile service. Warning: SaveFile is not supported."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GUID_FIELD_NUMBER: builtins.int
    FILE_URI_FIELD_NUMBER: builtins.int
    guid: typing.Text = ...
    """Guid of a ScenesManager element to save"""

    file_uri: typing.Text = ...
    """File uri (path or guid from FileTransferService)"""

    def __init__(self,
        *,
        guid : typing.Text = ...,
        file_uri : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["file_uri",b"file_uri","guid",b"guid"]) -> None: ...
global___SaveFile_Request = SaveFile_Request

class SaveFile_Response(google.protobuf.message.Message):
    """Response to SaveFile service. Warning: SaveFile is not supported."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___SaveFile_Response = SaveFile_Response

class GetSourceRayPaths_Request(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    GUID_FIELD_NUMBER: builtins.int
    SOURCE_PATH_FIELD_NUMBER: builtins.int
    RAYS_NB_FIELD_NUMBER: builtins.int
    RAW_DATA_FIELD_NUMBER: builtins.int
    DISPLAY_DATA_FIELD_NUMBER: builtins.int
    guid: typing.Text = ...
    """Guid of a ScenesManager element"""

    source_path: typing.Text = ...
    """path to the source in the Scene : "<source name>" for a specific source in the current scene, or "<scene name>/<source name>" for a specific source in a specific sub scene"""

    rays_nb: builtins.int = ...
    """Number of rays sent by the source. Default 100"""

    raw_data: builtins.bool = ...
    """Boolean to get the wavelengths in response stream"""

    display_data: builtins.bool = ...
    """Boolean to get the colors (RGB24 format) in response stream"""

    def __init__(self,
        *,
        guid : typing.Text = ...,
        source_path : typing.Text = ...,
        rays_nb : typing.Optional[builtins.int] = ...,
        raw_data : typing.Optional[builtins.bool] = ...,
        display_data : typing.Optional[builtins.bool] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_display_data",b"_display_data","_raw_data",b"_raw_data","_rays_nb",b"_rays_nb","display_data",b"display_data","raw_data",b"raw_data","rays_nb",b"rays_nb"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_display_data",b"_display_data","_raw_data",b"_raw_data","_rays_nb",b"_rays_nb","display_data",b"display_data","guid",b"guid","raw_data",b"raw_data","rays_nb",b"rays_nb","source_path",b"source_path"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_display_data",b"_display_data"]) -> typing.Optional[typing_extensions.Literal["display_data"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_raw_data",b"_raw_data"]) -> typing.Optional[typing_extensions.Literal["raw_data"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_rays_nb",b"_rays_nb"]) -> typing.Optional[typing_extensions.Literal["rays_nb"]]: ...
global___GetSourceRayPaths_Request = GetSourceRayPaths_Request
