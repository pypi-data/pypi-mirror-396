# WARNING: This file is autogenerated by FHIR Schema Codegen.
# https://github.com/fhir-schema/fhir-schema-codegen
# Any manual changes made to this file may be overwritten.

from __future__ import annotations
from pydantic import ConfigDict, Field
from typing import List as PyList, Literal

from fhirschemapy.R4B.base import (
    BackboneElement,
    CodeableConcept,
    ContactDetail,
    Identifier,
    UsageContext,
)
from fhirschemapy.R4B.domain_resource import DomainResource


class ConceptMapGroup(BackboneElement):
    model_config = ConfigDict(serialize_by_alias=True, extra="forbid")

    element: PyList[ConceptMapGroupElement] = Field(
        alias="element", serialization_alias="element"
    )
    source: str | None = Field(None, alias="source", serialization_alias="source")
    source_version: str | None = Field(
        None, alias="sourceVersion", serialization_alias="sourceVersion"
    )
    target: str | None = Field(None, alias="target", serialization_alias="target")
    target_version: str | None = Field(
        None, alias="targetVersion", serialization_alias="targetVersion"
    )
    unmapped: ConceptMapGroupUnmapped | None = Field(
        None, alias="unmapped", serialization_alias="unmapped"
    )


class ConceptMapGroupElement(BackboneElement):
    model_config = ConfigDict(serialize_by_alias=True, extra="forbid")

    code: str | None = Field(None, alias="code", serialization_alias="code")
    display: str | None = Field(None, alias="display", serialization_alias="display")
    target: PyList[ConceptMapGroupElementTarget] | None = Field(
        None, alias="target", serialization_alias="target"
    )


class ConceptMapGroupElementTarget(BackboneElement):
    model_config = ConfigDict(serialize_by_alias=True, extra="forbid")

    code: str | None = Field(None, alias="code", serialization_alias="code")
    comment: str | None = Field(None, alias="comment", serialization_alias="comment")
    depends_on: PyList[ConceptMapGroupElementTargetDependsOn] | None = Field(
        None, alias="dependsOn", serialization_alias="dependsOn"
    )
    display: str | None = Field(None, alias="display", serialization_alias="display")
    equivalence: Literal[
        "relatedto",
        "unmatched",
        "equivalent",
        "wider",
        "subsumes",
        "narrower",
        "specializes",
        "inexact",
        "equal",
        "disjoint",
    ] = Field(alias="equivalence", serialization_alias="equivalence")
    product: PyList[ConceptMapGroupElementTargetDependsOn] | None = Field(
        None, alias="product", serialization_alias="product"
    )


class ConceptMapGroupElementTargetDependsOn(BackboneElement):
    model_config = ConfigDict(serialize_by_alias=True, extra="forbid")

    display: str | None = Field(None, alias="display", serialization_alias="display")
    property: str = Field(alias="property", serialization_alias="property")
    system: str | None = Field(None, alias="system", serialization_alias="system")
    value: str = Field(alias="value", serialization_alias="value")


class ConceptMapGroupUnmapped(BackboneElement):
    model_config = ConfigDict(serialize_by_alias=True, extra="forbid")

    code: str | None = Field(None, alias="code", serialization_alias="code")
    display: str | None = Field(None, alias="display", serialization_alias="display")
    mode: Literal["provided", "fixed", "other-map"] = Field(
        alias="mode", serialization_alias="mode"
    )
    url: str | None = Field(None, alias="url", serialization_alias="url")


class ConceptMap(DomainResource):
    model_config = ConfigDict(serialize_by_alias=True, extra="forbid")

    resource_type: str = Field(
        default="ConceptMap",
        alias="resourceType",
        serialization_alias="resourceType",
        frozen=True,
        pattern="ConceptMap",
    )

    contact: PyList[ContactDetail] | None = Field(
        None, alias="contact", serialization_alias="contact"
    )
    copyright: str | None = Field(
        None, alias="copyright", serialization_alias="copyright"
    )
    date: str | None = Field(None, alias="date", serialization_alias="date")
    description: str | None = Field(
        None, alias="description", serialization_alias="description"
    )
    experimental: bool | None = Field(
        None, alias="experimental", serialization_alias="experimental"
    )
    group: PyList[ConceptMapGroup] | None = Field(
        None, alias="group", serialization_alias="group"
    )
    identifier: Identifier | None = Field(
        None, alias="identifier", serialization_alias="identifier"
    )
    jurisdiction: PyList[CodeableConcept] | None = Field(
        None, alias="jurisdiction", serialization_alias="jurisdiction"
    )
    name: str | None = Field(None, alias="name", serialization_alias="name")
    publisher: str | None = Field(
        None, alias="publisher", serialization_alias="publisher"
    )
    purpose: str | None = Field(None, alias="purpose", serialization_alias="purpose")
    source_canonical: str | None = Field(
        None, alias="sourceCanonical", serialization_alias="sourceCanonical"
    )
    source_uri: str | None = Field(
        None, alias="sourceUri", serialization_alias="sourceUri"
    )
    status: Literal["draft", "active", "retired", "unknown"] = Field(
        alias="status", serialization_alias="status"
    )
    target_canonical: str | None = Field(
        None, alias="targetCanonical", serialization_alias="targetCanonical"
    )
    target_uri: str | None = Field(
        None, alias="targetUri", serialization_alias="targetUri"
    )
    title: str | None = Field(None, alias="title", serialization_alias="title")
    url: str | None = Field(None, alias="url", serialization_alias="url")
    use_context: PyList[UsageContext] | None = Field(
        None, alias="useContext", serialization_alias="useContext"
    )
    version: str | None = Field(None, alias="version", serialization_alias="version")

    def to_json(self, indent: int | None = None) -> str:
        return self.model_dump_json(
            exclude_unset=True, exclude_none=True, indent=indent
        )

    @classmethod
    def from_json(cls, json: str) -> ConceptMap:
        return cls.model_validate_json(json)
