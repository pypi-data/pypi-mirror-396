"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_control_plane import models, utils
from cribl_control_plane.types import BaseModel
from cribl_control_plane.utils import validate_open_enum
from enum import Enum
import pydantic
from pydantic import field_serializer
from pydantic.functional_validators import PlainValidator
from typing import Any, List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class CollectorSplunkType(str, Enum):
    r"""Collector type: splunk"""

    SPLUNK = "splunk"


class CollectorSplunkOutputMode(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Format of the returned output"""

    CSV = "csv"
    JSON = "json"


class CollectRequestParamTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectRequestParam(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the parameter's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeaderTypedDict(TypedDict):
    name: str
    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkCollectRequestHeader(BaseModel):
    name: str

    value: str
    r"""JavaScript expression to compute the header's value, normally enclosed in backticks (`${earliest}`). If a constant, use single quotes ('earliest'). Values without delimiters (earliest) are evaluated as strings."""


class CollectorSplunkAuthentication(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Authentication method for Discover and Collect REST calls"""

    # None
    NONE = "none"
    # Basic
    BASIC = "basic"
    # Basic (credentials secret)
    BASIC_SECRET = "basicSecret"
    # Bearer Token
    TOKEN = "token"
    # Bearer Token (text secret)
    TOKEN_SECRET = "tokenSecret"


class CollectorSplunkRetryType(str, Enum, metaclass=utils.OpenEnumMeta):
    r"""Algorithm to use when performing HTTP retries"""

    # Disabled
    NONE = "none"
    # Backoff
    BACKOFF = "backoff"
    # Static
    STATIC = "static"


class CollectorSplunkRetryRulesTypedDict(TypedDict):
    type: NotRequired[CollectorSplunkRetryType]
    r"""Algorithm to use when performing HTTP retries"""
    interval: NotRequired[Any]
    limit: NotRequired[Any]
    multiplier: NotRequired[Any]
    codes: NotRequired[Any]
    enable_header: NotRequired[Any]
    retry_connect_timeout: NotRequired[Any]
    retry_connect_reset: NotRequired[Any]


class CollectorSplunkRetryRules(BaseModel):
    type: Annotated[
        Optional[CollectorSplunkRetryType], PlainValidator(validate_open_enum(False))
    ] = CollectorSplunkRetryType.BACKOFF
    r"""Algorithm to use when performing HTTP retries"""

    interval: Optional[Any] = None

    limit: Optional[Any] = None

    multiplier: Optional[Any] = None

    codes: Optional[Any] = None

    enable_header: Annotated[Optional[Any], pydantic.Field(alias="enableHeader")] = None

    retry_connect_timeout: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectTimeout")
    ] = None

    retry_connect_reset: Annotated[
        Optional[Any], pydantic.Field(alias="retryConnectReset")
    ] = None

    @field_serializer("type")
    def serialize_type(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkRetryType(value)
            except ValueError:
                return value
        return value


class CollectorSplunkTypedDict(TypedDict):
    type: CollectorSplunkType
    r"""Collector type: splunk"""
    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""
    search_head: NotRequired[str]
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""
    earliest: NotRequired[str]
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""
    latest: NotRequired[str]
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""
    endpoint: NotRequired[str]
    r"""REST API used to create a search"""
    output_mode: NotRequired[CollectorSplunkOutputMode]
    r"""Format of the returned output"""
    collect_request_params: NotRequired[List[CollectRequestParamTypedDict]]
    r"""Optional collect request parameters"""
    collect_request_headers: NotRequired[
        List[CollectorSplunkCollectRequestHeaderTypedDict]
    ]
    r"""Optional collect request headers"""
    authentication: NotRequired[CollectorSplunkAuthentication]
    r"""Authentication method for Discover and Collect REST calls"""
    timeout: NotRequired[float]
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""
    use_round_robin_dns: NotRequired[bool]
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""
    disable_time_filter: NotRequired[bool]
    r"""Disable collector event time filtering when a date range is specified"""
    reject_unauthorized: NotRequired[bool]
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""
    handle_escaped_chars: NotRequired[bool]
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""
    retry_rules: NotRequired[CollectorSplunkRetryRulesTypedDict]


class CollectorSplunk(BaseModel):
    type: CollectorSplunkType
    r"""Collector type: splunk"""

    search: str
    r"""Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'"""

    search_head: Annotated[Optional[str], pydantic.Field(alias="searchHead")] = (
        "https://localhost:8089"
    )
    r"""Search head base URL. Can be an expression. Default is https://localhost:8089."""

    earliest: Optional[str] = None
    r"""The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'"""

    latest: Optional[str] = None
    r"""The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'"""

    endpoint: Optional[str] = "/services/search/v2/jobs/export"
    r"""REST API used to create a search"""

    output_mode: Annotated[
        Annotated[
            Optional[CollectorSplunkOutputMode],
            PlainValidator(validate_open_enum(False)),
        ],
        pydantic.Field(alias="outputMode"),
    ] = CollectorSplunkOutputMode.JSON
    r"""Format of the returned output"""

    collect_request_params: Annotated[
        Optional[List[CollectRequestParam]],
        pydantic.Field(alias="collectRequestParams"),
    ] = None
    r"""Optional collect request parameters"""

    collect_request_headers: Annotated[
        Optional[List[CollectorSplunkCollectRequestHeader]],
        pydantic.Field(alias="collectRequestHeaders"),
    ] = None
    r"""Optional collect request headers"""

    authentication: Annotated[
        Optional[CollectorSplunkAuthentication],
        PlainValidator(validate_open_enum(False)),
    ] = CollectorSplunkAuthentication.BASIC
    r"""Authentication method for Discover and Collect REST calls"""

    timeout: Optional[float] = 0
    r"""HTTP request inactivity timeout. Use 0 for no timeout."""

    use_round_robin_dns: Annotated[
        Optional[bool], pydantic.Field(alias="useRoundRobinDns")
    ] = False
    r"""Use round-robin DNS lookup. Suitable when DNS server returns multiple addresses in sort order."""

    disable_time_filter: Annotated[
        Optional[bool], pydantic.Field(alias="disableTimeFilter")
    ] = True
    r"""Disable collector event time filtering when a date range is specified"""

    reject_unauthorized: Annotated[
        Optional[bool], pydantic.Field(alias="rejectUnauthorized")
    ] = False
    r"""Reject certificates that cannot be verified against a valid CA (such as self-signed certificates)"""

    handle_escaped_chars: Annotated[
        Optional[bool], pydantic.Field(alias="handleEscapedChars")
    ] = False
    r"""Escape characters (\\") in search queries will be passed directly to Splunk"""

    retry_rules: Annotated[
        Optional[CollectorSplunkRetryRules], pydantic.Field(alias="retryRules")
    ] = None

    @field_serializer("output_mode")
    def serialize_output_mode(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkOutputMode(value)
            except ValueError:
                return value
        return value

    @field_serializer("authentication")
    def serialize_authentication(self, value):
        if isinstance(value, str):
            try:
                return models.CollectorSplunkAuthentication(value)
            except ValueError:
                return value
        return value
