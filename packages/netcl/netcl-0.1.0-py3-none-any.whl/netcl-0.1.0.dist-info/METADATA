Metadata-Version: 2.4
Name: netcl
Version: 0.1.0
Summary: PyOpenCL-based deep learning playground with autograd, kernels, and high-level APIs.
Author: netcl contributors
License: MIT
Project-URL: Repository, https://bbwebservice.online/lukas/netcl
Keywords: opencl,deep-learning,autograd,gpu
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: numpy>=1.22
Requires-Dist: pyopencl>=2022.3
Dynamic: license-file

# netcl – PyOpenCL Deep Learning Playground

`netcl` ist ein experimentelles Deep-Learning-Framework auf Basis von PyOpenCL. Es kombiniert low-level Kernel (Conv/Matmul/Elementwise) mit einer einfachen Autograd-Engine und einer High-Level API (Module, Trainer, Serializer), ohne Abhängigkeiten zu anderen DL-Frameworks.

## Installation
```bash
pip install .
```
Voraussetzungen: Python ≥ 3.10, NumPy, PyOpenCL und ein verfügbares OpenCL-Gerät.

## Schnelles Beispiel (MNIST-Mini-MLP)
```python
import numpy as np
from netcl.core.device import manager
from netcl.nn.layers import Sequential, Flatten, Linear, ReLU
from netcl import autograd as ag
from netcl.optim import Adam
from netcl.core.tensor import Tensor

dev = manager.default()
q = dev.queue

model = Sequential(
    Flatten(),
    Linear(q, in_features=28*28, out_features=128),
    ReLU(),
    Linear(q, in_features=128, out_features=10),
)
opt = Adam(model.parameters(), lr=5e-3)

def one_hot(y, n=10):
    oh = np.zeros((y.shape[0], n), dtype=np.float32)
    oh[np.arange(y.shape[0]), y] = 1
    return oh

xb = np.random.randn(32, 1, 28, 28).astype(np.float32)
yb = one_hot(np.random.randint(0, 10, size=(32,)))

tape = ag.Tape()
ag.set_current_tape(tape)
x = ag.tensor(Tensor.from_host(q, xb))
y = ag.tensor(Tensor.from_host(q, yb))
logits = model(x)
loss = ag.cross_entropy(logits, y)
tape.backward(loss)
opt.step(); opt.zero_grad()
ag.set_current_tape(None)
```

## Kernfeatures
- **Autograd**: Tape-basiert, elementare Ops (Matmul, Conv2d, Pooling, Elementwise) mit Backward.
- **Module/High-Level API**: `Linear`, `Conv2d`, `BatchNorm2d`, `Sequential`, `@model`-Dekorator, Trainer.
- **Optimierungen**: Conv-Algo-Heuristik/Autotuning, optional Mixed Precision, Buffer-Pool.
- **Serialization**: Speichert `Sequential`-Modelle als JSON (Architektur) + NPZ (Gewichte) via `netcl.io.serialization`.

## Speichern & Laden eines Modells
```python
from netcl.io.serialization import save_model, load_model
save_model(model, "checkpoints/mnist_mlp")
model2 = load_model("checkpoints/mnist_mlp")  # queue auto="default"
```

## Hinweise
- Tests werden nicht mitinstalliert. Für lokale Entwicklung: `python -m pytest`.
- Für Performance: Batch-Größe erhöhen, Augment minimieren, optional Mixed Precision (`Trainer(..., mixed_precision=True)`).
- Conv-Algorithmen wählen automatisch optimierte Pfade; env-Flags wie `NETCL_CONV_AUTOTUNE=1` aktivieren Tuning.
