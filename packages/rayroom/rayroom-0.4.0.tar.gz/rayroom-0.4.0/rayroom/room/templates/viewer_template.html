<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mesh Viewer</title>
    <style>
        body { margin: 0; font-family: sans-serif; }
        canvas { display: block; }
        #sidebar {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            background: rgba(255, 255, 255, 0.85);
            border-radius: 5px;
            padding: 10px;
            max-height: 90vh;
            overflow-y: auto;
        }
        #sidebar h2 {
            margin-top: 0;
            font-size: 1.1em;
        }
        .control {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        .control label {
            margin-right: 10px;
        }
        #objectList {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        #objectList li {
            padding: 4px 0;
            display: flex;
            align-items: center;
        }
        #objectList input {
            margin-right: 8px;
        }
        .object-label .name {
            font-weight: bold;
        }
        .object-label .description {
            font-size: 0.9em;
            color: #555;
            margin-left: 5px;
        }
        #camera-info {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #ccc;
        }
        #camera-info h3 {
            margin-top: 0;
            font-size: 1em;
            color: #333;
        }
        #camera-info p {
            font-size: 0.9em;
            margin: 5px 0 0;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>Room Objects</h2>
        <div class="control">
            <input type="checkbox" id="transparencyToggle" checked>
            <label for="transparencyToggle">Ghost View</label>
        </div>
        <div class="control">
            <input type="checkbox" id="edgesToggle" checked>
            <label for="edgesToggle">Show Edges</label>
        </div>
        <div class="control">
            <input type="checkbox" id="verticesToggle">
            <label for="verticesToggle">Show Vertices</label>
        </div>
        <div class="control">
            <input type="checkbox" id="furnitureToggle" checked>
            <label for="furnitureToggle">Show Furniture</label>
        </div>
        <ul id="objectList"></ul>

        <div id="camera-info">
            <h3>Camera Info</h3>
            <p id="camera-position">Position: (0.00, 0.00, 0.00)</p>
            <p id="camera-rotation">Rotation: (0.00, 0.00, 0.00)</p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xdddddd);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.up.set(0, 0, 1); // Z is up

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        
        const objContent = `{{ obj_content_js }}`;
        const loader = new OBJLoader();
        const object = loader.parse(objContent);
        
        const box = new THREE.Box3().setFromObject(object);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        object.position.sub(center);
        scene.add(object);
        
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * (Math.PI / 180);
        const cameraDistance = maxDim / (2 * Math.tan(fov / 2));
        
        camera.position.y = -cameraDistance * 1.5;
        camera.lookAt(0, 0, 0);

        controls.target.set(0, 0, 0);
        controls.update();

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, -1, 1);
        scene.add(directionalLight);

        // --- Interactivity ---
        const objectMap = {};
        const allEdges = [];
        const allVertices = [];

        object.children.forEach(child => {
            objectMap[child.name] = child;
            child.traverse(node => {
                if (node.isMesh) {
                    node.userData.originalMaterial = node.material;

                    // Edges
                    const edges = new THREE.EdgesGeometry(node.geometry);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                    node.add(line);
                    allEdges.push(line);

                    // Vertices
                    const pointsMaterial = new THREE.PointsMaterial({ color: 0x0000ff, size: 0.05 });
                    const points = new THREE.Points(node.geometry, pointsMaterial);
                    node.add(points);
                    allVertices.push(points);
                }
            });
        });

        // --- Add Receivers ---
        const receiversData = JSON.parse(`{{ receivers_json }}`);
        receiversData.forEach(receiver => {
            const receiverGroup = new THREE.Group();
            receiverGroup.name = receiver.name;

            if (receiver.type === 'ambisonic') {
                const bodyRadius = receiver.radius;
                const capsuleRadius = 0.02;
                const capsuleDist = bodyRadius + 0.01;

                // Main body
                const bodyGeom = new THREE.SphereGeometry(bodyRadius, 16, 16);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xadd8e6, roughness: 0.1, metalness: 0.1 });
                const bodySphere = new THREE.Mesh(bodyGeom, bodyMat);
                receiverGroup.add(bodySphere);

                // Capsules
                const capsuleGeom = new THREE.SphereGeometry(capsuleRadius, 8, 8);
                const matX = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red for X
                const matY = new THREE.MeshStandardMaterial({ color: 0x00ff00 }); // Green for Y
                const matZ = new THREE.MeshStandardMaterial({ color: 0x0000ff }); // Blue for Z

                const x_axis = new THREE.Vector3().fromArray(receiver.x_axis);
                const y_axis = new THREE.Vector3().fromArray(receiver.y_axis);
                const z_axis = new THREE.Vector3().fromArray(receiver.z_axis);

                const axes = [{ axis: x_axis, mat: matX }, { axis: y_axis, mat: matY }, { axis: z_axis, mat: matZ }];
                axes.forEach(item => {
                    const pos_cap = new THREE.Mesh(capsuleGeom, item.mat);
                    pos_cap.position.copy(item.axis).multiplyScalar(capsuleDist);
                    receiverGroup.add(pos_cap);
                    
                    const neg_cap = new THREE.Mesh(capsuleGeom, item.mat);
                    neg_cap.position.copy(item.axis).multiplyScalar(-capsuleDist);
                    receiverGroup.add(neg_cap);
                });

            } else { // Mono
                const monoRadius = 0.05; // Use a smaller, fixed radius for mono mics
                const geometry = new THREE.SphereGeometry(monoRadius, 16, 16);
                const material = new THREE.MeshStandardMaterial({ color: 0xadd8e6, roughness: 0.1, metalness: 0.1 });
                const sphere = new THREE.Mesh(geometry, material);
                receiverGroup.add(sphere);
            }
            
            receiverGroup.position.set(receiver.position[0], receiver.position[1], receiver.position[2]);
            receiverGroup.position.sub(center); // Adjust position relative to centered room
            
            receiverGroup.traverse(node => {
                if (node.isMesh) {
                    node.userData.originalMaterial = node.material;
                }
            });
            
            scene.add(receiverGroup);
            objectMap[receiver.name] = receiverGroup;
        });

        // --- Add Sources ---
        const sourcesData = JSON.parse(`{{ sources_json }}`);
        sourcesData.forEach(source => {
            const sourceGroup = new THREE.Group();
            sourceGroup.name = source.name;

            const sourceRadius = 0.06;
            const geometry = new THREE.SphereGeometry(sourceRadius, 16, 16);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.1, metalness: 0.1 });
            const sphere = new THREE.Mesh(geometry, material);
            sourceGroup.add(sphere);

            if (source.directivity !== 'omnidirectional') {
                const dir = new THREE.Vector3().fromArray(source.orientation);
                const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(0, 0, 0), 0.3, 0xff0000, 0.1, 0.05);
                sourceGroup.add(arrow);
            }

            sourceGroup.position.set(source.position[0], source.position[1], source.position[2]);
            sourceGroup.position.sub(center); // Adjust position relative to centered room
            
            sourceGroup.traverse(node => {
                if (node.isMesh) {
                    node.userData.originalMaterial = node.material;
                }
            });
            
            scene.add(sourceGroup);
            objectMap[source.name] = sourceGroup;
        });

        const objectsData = JSON.parse(`{{ objects_data_json }}`);
        const objectList = document.getElementById('objectList');

        objectsData.forEach(objData => {
            const name = objData.name;
            const description = objData.description;

            const li = document.createElement('li');
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = true;
            checkbox.id = `check-${name}`;
            checkbox.dataset.name = name;
            
            const label = document.createElement('label');
            label.htmlFor = `check-${name}`;
            label.className = 'object-label';
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'name';
            nameSpan.textContent = name;
            
            const descSpan = document.createElement('span');
            descSpan.className = 'description';
            descSpan.textContent = ` - ${description}`;
            
            label.appendChild(nameSpan);
            label.appendChild(descSpan);
            
            li.appendChild(checkbox);
            li.appendChild(label);
            objectList.appendChild(li);

            checkbox.addEventListener('change', (event) => {
                const objectToShowOrHide = objectMap[event.target.dataset.name];
                if (objectToShowOrHide) {
                    objectToShowOrHide.visible = event.target.checked;
                }
            });
        });

        const transparencyToggle = document.getElementById('transparencyToggle');
        const edgesToggle = document.getElementById('edgesToggle');
        const verticesToggle = document.getElementById('verticesToggle');
        const furnitureToggle = document.getElementById('furnitureToggle');
        
        function setTransparency(isTransparent) {
            for (const name in objectMap) {
                const obj = objectMap[name];
                obj.traverse(node => {
                    if (node.isMesh) {
                        if (isTransparent) {
                            if (!node.userData.transparentMaterial) {
                                const newMaterial = node.material.clone();
                                newMaterial.transparent = true;
                                const lowerName = name.toLowerCase();
                                if (lowerName.includes('mic')) {
                                    newMaterial.opacity = 0.6;
                                } else if (lowerName.includes('wall') || lowerName.includes('ceiling') || lowerName.includes('floor') || lowerName.includes('window')) {
                                    newMaterial.opacity = 0.2;
                                } else if (lowerName.includes('source') || lowerName.includes('speaker')) {
                                    newMaterial.opacity = 0.6;
                                } else {
                                    newMaterial.opacity = 0.5;
                                }
                                node.userData.transparentMaterial = newMaterial;
                            }
                            node.material = node.userData.transparentMaterial;
                        } else {
                            node.material = node.userData.originalMaterial;
                        }
                    }
                });
            }
        }

        function setEdgesVisibility(visible) {
            allEdges.forEach(edge => {
                edge.visible = visible;
            });
        }

        function setVerticesVisibility(visible) {
            allVertices.forEach(vertex => {
                vertex.visible = visible;
            });
        }

        function setFurnitureVisibility(visible) {
            objectsData.forEach(objData => {
                if (objData.type === 'furniture') {
                    const objectToToggle = objectMap[objData.name];
                    if (objectToToggle) {
                        objectToToggle.visible = visible;
                        // Also update the individual checkbox for this item
                        const checkbox = document.getElementById(`check-${objData.name}`);
                        if (checkbox) {
                            checkbox.checked = visible;
                        }
                    }
                }
            });
        }

        transparencyToggle.addEventListener('change', (event) => {
            setTransparency(event.target.checked);
        });

        edgesToggle.addEventListener('change', (event) => {
            setEdgesVisibility(event.target.checked);
        });

        verticesToggle.addEventListener('change', (event) => {
            setVerticesVisibility(event.target.checked);
        });

        furnitureToggle.addEventListener('change', (event) => {
            setFurnitureVisibility(event.target.checked);
        });
        
        // Set initial state from checkbox
        setTransparency(transparencyToggle.checked);
        setEdgesVisibility(edgesToggle.checked);
        setVerticesVisibility(verticesToggle.checked);
        setFurnitureVisibility(furnitureToggle.checked);
        
        const cameraPositionEl = document.getElementById('camera-position');
        const cameraRotationEl = document.getElementById('camera-rotation');
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);

            // Update camera info
            cameraPositionEl.textContent = `Position: (${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)})`;
            cameraRotationEl.textContent = `Rotation: (${(camera.rotation.x * 180 / Math.PI).toFixed(2)}, ${(camera.rotation.y * 180 / Math.PI).toFixed(2)}, ${(camera.rotation.z * 180 / Math.PI).toFixed(2)})`;
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
    </script>
</body>
</html>
