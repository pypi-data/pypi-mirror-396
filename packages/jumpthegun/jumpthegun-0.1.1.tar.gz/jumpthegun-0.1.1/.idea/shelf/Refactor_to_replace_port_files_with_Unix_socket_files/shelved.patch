Index: src/jumpthegun/jumpthegunctl.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import io\nimport os\nimport shlex\nimport signal\nimport socket\nimport sys\nimport time\nimport traceback\nfrom pathlib import Path\nfrom typing import BinaryIO, Dict, Tuple, cast\n\nfrom .__version__ import __version__\nfrom .config import read_config\nfrom .env_vars import apply_env_with_diff, calc_env_diff\nfrom .io_redirect import SocketOutputRedirector, StdinWrapper\nfrom .runtime_dir import get_isolated_service_runtime_dir_for_tool\nfrom .tools import ToolExceptionBase, get_tool_entrypoint\nfrom .utils import daemonize as daemonize_func\nfrom .utils import pid_exists\n\n\nclass InvalidCommand(Exception):\n    def __init__(self, command: str):\n        super().__init__(command)\n        self.command = command\n\n\nclass DaemonAlreadyExistsError(ToolExceptionBase):\n    def __str__(self):\n        return (\n            f'Jump the Gun daemon process for tool \"{self.tool_name}\" already exists.'\n        )\n\n\nclass DaemonDoesNotExistError(ToolExceptionBase):\n    def __str__(self):\n        return (\n            f'Jump the Gun daemon process for tool \"{self.tool_name}\" does not exist.'\n        )\n\n\ndef get_pid_and_port_file_paths(tool_name: str) -> Tuple[Path, Path]:\n    service_runtime_dir_path = get_isolated_service_runtime_dir_for_tool(tool_name)\n    pid_file_path = service_runtime_dir_path / f\"{tool_name}.pid\"\n    port_file_path = service_runtime_dir_path / f\"{tool_name}.port\"\n    return pid_file_path, port_file_path\n\n\ndef remove_pid_and_port_files(tool_name: str) -> None:\n    for file_path in get_pid_and_port_file_paths(tool_name):\n        if file_path.exists():\n            try:\n                file_path.unlink()\n            except Exception:\n                pass\n\n\ndef daemon_teardown(\n    sock: socket.socket, pid: int, pid_file_path: Path, port_file_path: Path\n) -> None:\n    \"\"\"Close socket and remove pid and port files upon daemon shutdown.\"\"\"\n    sock.close()\n    if pid_file_path.exists():\n        file_pid = int(pid_file_path.read_text())\n        if file_pid == pid:\n            pid_file_path.unlink(missing_ok=True)\n            port_file_path.unlink(missing_ok=True)\n\n\ndef start(tool_name: str, daemonize: bool = True) -> None:\n    config = read_config()\n\n    # Import the tool and get its entrypoint function.\n    #\n    # Override sys.stdout and sys.stderr while loading the tool runner,\n    # so that any references to them kept during module imports (e.g for\n    # setting up logging) already reference the overrides.\n    output_redirector = SocketOutputRedirector()\n    with output_redirector.override_outputs_for_imports():\n        tool_entrypoint = get_tool_entrypoint(tool_name)\n        env_before = dict(os.environ)\n        tool_runner = tool_entrypoint.load()\n        env_after = dict(os.environ)\n        env_diff = calc_env_diff(env_before, env_after)\n\n    pid_file_path, port_file_path = get_pid_and_port_file_paths(tool_name)\n\n    if pid_file_path.exists():\n        file_pid = int(pid_file_path.read_text())\n        if pid_exists(file_pid):\n            raise DaemonAlreadyExistsError(tool_name=tool_name)\n\n    if daemonize:\n        print(f'\"jumpthegun {tool_name}\" daemon process starting...')\n        daemonize_func()\n\n    # Write pid file.\n    pid = os.getpid()\n    pid_file_path.write_bytes(b\"%d\\n\" % pid)\n\n    # Open socket.\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.bind((\"127.0.0.1\", 0))\n\n    # Write port file.\n    host, port = sock.getsockname()\n    port_file_path.write_bytes(b\"%d\\n\" % port)\n\n    # Listen for connections.\n    sock.listen()\n    print(f\"Listening on {host}:{port} (pid={pid}) ...\")\n    sock.settimeout(config.idle_timeout_seconds)\n    subproc_pids: set[int] = set()\n    try:\n        while True:\n            conn, address = sock.accept()\n            print(f\"Got connection from: {address}\")\n            newpid = os.fork()\n            if newpid == 0:\n                break\n\n            # Avoid \"zombie\" processes: Reap completed sub-processes.\n            done_subproc_pids = {\n                x for x in subproc_pids if os.waitpid(x, os.WNOHANG)[0] != 0\n            }\n            subproc_pids -= done_subproc_pids\n            subproc_pids.add(newpid)\n    except BaseException as exc:\n        # Server is exiting: Clean up as needed.\n        sock.close()\n        if pid_file_path.exists():\n            file_pid = int(pid_file_path.read_text())\n            if file_pid == pid:\n                pid_file_path.unlink(missing_ok=True)\n                port_file_path.unlink(missing_ok=True)\n        if isinstance(exc, socket.timeout):\n            print(\n                f\"Exiting after receiving no connections for {config.idle_timeout_seconds} seconds.\"\n            )\n            return\n        raise\n\n    # Send pid.\n    conn.sendall(b\"%d\\n\" % os.getpid())\n\n    rfile = conn.makefile(\"rb\", 0)\n\n    # Read and set argv\n    argv_bytes = rfile.read(int(rfile.readline()))\n    sys.argv[1:] = shlex.split(argv_bytes.decode()) if argv_bytes else []\n    sys.argv[0] = tool_name\n\n    # Read and set cwd\n    pwd = rfile.read(int(rfile.readline()))\n    if not pwd:\n        raise Exception(\"Did not receive pwd from client.\")\n    os.chdir(pwd)\n\n    # Read and set env vars\n    env_vars_str: str = (rfile.read(int(rfile.readline())) or b\"\").decode()\n    split_lines = (line.split(\"=\", 1) for line in env_vars_str.split(\"\\0\"))\n    env: Dict[str, str] = dict(line for line in split_lines if len(line) == 2)\n    env.pop(\"_\", None)\n    apply_env_with_diff(env, env_diff)\n\n    sys.stdin.close()\n    sys.stdin = io.TextIOWrapper(cast(BinaryIO, StdinWrapper(conn)))\n    output_redirector.set_socket(conn)\n\n    # start_time = time.monotonic()\n    exit_code: int\n    try:\n        retval = tool_runner()\n    except BaseException as exc:\n        # end_time = time.monotonic()\n        # print(f\"Time: {end_time - start_time}\", file=sys.__stdout__)\n        # print(\"EXCEPTION\", str(exc), file=sys.__stderr__)\n        if isinstance(exc, SystemExit):\n            exit_code = exc.code if isinstance(exc.code, int) else 1\n        else:\n            traceback.print_exc()\n            exit_code = 1\n        # print(f\"{exit_code=}\", file=sys.__stdout__)\n        if isinstance(exit_code, bool):\n            exit_code = int(exit_code)\n        elif not isinstance(exit_code, int):\n            exit_code = 1\n    else:\n        if isinstance(retval, int):\n            exit_code = retval\n        else:\n            exit_code = 0\n    finally:\n        conn.sendall(b\"rc=%d\\n\" % exit_code)\n        # print(f\"Goodbye! rc={exit_code}\", file=sys.__stdout__)\n\n        sys.stdin.close()\n        sys.stdout.close()\n        sys.stderr.close()\n        conn.shutdown(socket.SHUT_WR)\n        sys.exit(0)\n\n\ndef stop(tool_name: str) -> None:\n    try:\n        get_tool_entrypoint(tool_name)\n    except ToolExceptionBase:\n        raise DaemonDoesNotExistError(tool_name)\n\n    try:\n        pid_file_path, _port_file_path = get_pid_and_port_file_paths(tool_name)\n        if not pid_file_path.exists():\n            raise DaemonDoesNotExistError(tool_name)\n\n        file_pid = int(pid_file_path.read_text())\n        if not pid_exists(file_pid):\n            raise DaemonDoesNotExistError(tool_name)\n\n        os.kill(file_pid, signal.SIGTERM)\n        for _i in range(20):\n            time.sleep(0.05)\n            if not pid_exists(file_pid):\n                break\n        else:\n            os.kill(file_pid, signal.SIGKILL)\n\n        print(f'\"jumpthegun {tool_name}\" daemon process stopped.')\n\n    finally:\n        remove_pid_and_port_files(tool_name)\n\n\ndef print_usage() -> None:\n    \"\"\"Print a message about how to run jumpthegunctl.\"\"\"\n    print(f\"Usage: {sys.argv[0]} start|stop tool_name\")\n\n\ndef do_action(tool_name: str, action: str) -> None:\n    \"\"\"Apply an action (e.g. start or stop) for a given tool.\"\"\"\n    if action == \"start\":\n        start(tool_name)\n    elif action == \"stop\":\n        stop(tool_name)\n    elif action == \"restart\":\n        try:\n            stop(tool_name)\n        except DaemonDoesNotExistError:\n            pass\n        start(tool_name)\n    else:\n        raise InvalidCommand(action)\n\n\ndef main() -> None:\n    args = sys.argv[1:]\n\n    if any(arg == \"-h\" or arg == \"--help\" for arg in args):\n        print_usage()\n        sys.exit(0)\n\n    if len(args) == 1:\n        (cmd,) = args\n        if cmd == \"version\" or cmd == \"--version\":\n            print(f\"jumpthegun v{__version__}\")\n            sys.exit(0)\n    elif len(args) == 2:\n        (cmd, tool_name) = args\n        tool_name = tool_name.strip().lower()\n\n        try:\n            do_action(tool_name=tool_name, action=cmd)\n        except ToolExceptionBase as exc:\n            print(str(exc))\n            sys.exit(1)\n        except InvalidCommand as exc:\n            print(str(exc))\n        else:\n            sys.exit(0)\n\n    print_usage()\n    sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jumpthegun/jumpthegunctl.py b/src/jumpthegun/jumpthegunctl.py
--- a/src/jumpthegun/jumpthegunctl.py	(revision af6d0f9aa00f5c0b87cc84b428ca9467393a06b9)
+++ b/src/jumpthegun/jumpthegunctl.py	(date 1748459596737)
@@ -39,15 +39,15 @@
         )
 
 
-def get_pid_and_port_file_paths(tool_name: str) -> Tuple[Path, Path]:
+def get_pid_and_socket_file_paths(tool_name: str) -> Tuple[Path, Path]:
     service_runtime_dir_path = get_isolated_service_runtime_dir_for_tool(tool_name)
     pid_file_path = service_runtime_dir_path / f"{tool_name}.pid"
-    port_file_path = service_runtime_dir_path / f"{tool_name}.port"
-    return pid_file_path, port_file_path
+    socket_file_path = service_runtime_dir_path / f"{tool_name}.sock"
+    return pid_file_path, socket_file_path
 
 
-def remove_pid_and_port_files(tool_name: str) -> None:
-    for file_path in get_pid_and_port_file_paths(tool_name):
+def remove_pid_and_socket_files(tool_name: str) -> None:
+    for file_path in get_pid_and_socket_file_paths(tool_name):
         if file_path.exists():
             try:
                 file_path.unlink()
@@ -56,15 +56,15 @@
 
 
 def daemon_teardown(
-    sock: socket.socket, pid: int, pid_file_path: Path, port_file_path: Path
+    sock: socket.socket, pid: int, pid_file_path: Path, socket_file_path: Path
 ) -> None:
-    """Close socket and remove pid and port files upon daemon shutdown."""
+    """Close socket and remove pid and socket files upon daemon shutdown."""
     sock.close()
     if pid_file_path.exists():
         file_pid = int(pid_file_path.read_text())
         if file_pid == pid:
             pid_file_path.unlink(missing_ok=True)
-            port_file_path.unlink(missing_ok=True)
+            socket_file_path.unlink(missing_ok=True)
 
 
 def start(tool_name: str, daemonize: bool = True) -> None:
@@ -83,7 +83,7 @@
         env_after = dict(os.environ)
         env_diff = calc_env_diff(env_before, env_after)
 
-    pid_file_path, port_file_path = get_pid_and_port_file_paths(tool_name)
+    pid_file_path, socket_file_path = get_pid_and_socket_file_paths(tool_name)
 
     if pid_file_path.exists():
         file_pid = int(pid_file_path.read_text())
@@ -98,23 +98,21 @@
     pid = os.getpid()
     pid_file_path.write_bytes(b"%d\n" % pid)
 
-    # Open socket.
-    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-    sock.bind(("127.0.0.1", 0))
-
-    # Write port file.
-    host, port = sock.getsockname()
-    port_file_path.write_bytes(b"%d\n" % port)
+    # Create and bind a Unix domain socket.
+    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
+    sock.bind(str(socket_file_path))
+    # Set socket permissions to be accessible only by the owner.
+    os.chmod(socket_file_path, 0o600)
 
     # Listen for connections.
     sock.listen()
-    print(f"Listening on {host}:{port} (pid={pid}) ...")
+    print(f"Listening on {socket_file_path} (pid={pid}) ...")
     sock.settimeout(config.idle_timeout_seconds)
     subproc_pids: set[int] = set()
     try:
         while True:
             conn, address = sock.accept()
-            print(f"Got connection from: {address}")
+            print("Got connection")
             newpid = os.fork()
             if newpid == 0:
                 break
@@ -127,12 +125,7 @@
             subproc_pids.add(newpid)
     except BaseException as exc:
         # Server is exiting: Clean up as needed.
-        sock.close()
-        if pid_file_path.exists():
-            file_pid = int(pid_file_path.read_text())
-            if file_pid == pid:
-                pid_file_path.unlink(missing_ok=True)
-                port_file_path.unlink(missing_ok=True)
+        daemon_teardown(sock, pid, pid_file_path, socket_file_path)
         if isinstance(exc, socket.timeout):
             print(
                 f"Exiting after receiving no connections for {config.idle_timeout_seconds} seconds."
@@ -208,7 +201,7 @@
         raise DaemonDoesNotExistError(tool_name)
 
     try:
-        pid_file_path, _port_file_path = get_pid_and_port_file_paths(tool_name)
+        pid_file_path, _ = get_pid_and_socket_file_paths(tool_name)
         if not pid_file_path.exists():
             raise DaemonDoesNotExistError(tool_name)
 
@@ -227,7 +220,7 @@
         print(f'"jumpthegun {tool_name}" daemon process stopped.')
 
     finally:
-        remove_pid_and_port_files(tool_name)
+        remove_pid_and_socket_files(tool_name)
 
 
 def print_usage() -> None:
Index: src/jumpthegun.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#!/bin/bash\nset -eEu -o pipefail\n\nfunction usage() {\n  echo \"Usage: $0 command tool_name ...\"\n  echo\n  echo \"Available commands:\"\n  echo\n  echo \"run tool_name [OPTIONS] [arg ...]    Run a CLI tool.\"\n  echo \"start tool_name                      Start a daemon for a CLI tool.\"\n  echo \"stop tool_name                       Stop a daemon for a CLI tool.\"\n  echo \"restart tool_name                    Restart a daemon for a CLI tool.\"\n  echo\n}\n\nfunction err_exit() {\n  err_msg=\"$1\"\n  echo \"$err_msg\" >&2\n  exit 1\n}\n\nfunction get_service_runtime_dir() {\n  runtime_dir=\"${XDG_RUNTIME_DIR:-}\"\n  if [ -n \"$runtime_dir\" ]; then\n    echo -n \"$runtime_dir/jumpthegun\"\n  else\n    temp_dir=\"${TMPDIR:-/tmp}\"\n    shopt -s nullglob\n    service_runtime_dirs=(\"$temp_dir/jumpthegun-$USER\"-??????)\n    shopt -u nullglob\n    if [[ ${#service_runtime_dirs[@]} -eq 1 ]]; then\n      echo -n \"${service_runtime_dirs[0]}\"\n    elif [[ ${#service_runtime_dirs[@]} -gt 1 ]]; then\n      err_exit \"Error: Multiple service runtime dirs found.\"\n    fi\n  fi\n}\n\nfunction hash_str() {\n  if [[ $OSTYPE == \"darwin\"* ]]; then\n    echo -n \"$1\" | shasum -a 256 - | head -c 8\n  else\n    echo -n \"$1\" | sha256sum - | head -c 8\n  fi\n}\n\nautorun=1\ncase \"${1:-}\" in\n-h|--help)\n  usage && exit 0 ;;\nstart|stop|restart|version|--version)\n  [[ \"$2\" =~ -h|--help ]] && usage && exit 0\n  tool_name=\"$2\"\n\n  # Find the tool's Python executable and check if it has JumpTheGun installed.\n  tool_path=\"$(command -v -- \"$tool_name\" 2>/dev/null)\" || err_exit \"Command not found: $tool_name\"\n  shebang=\"$(head -n 1 -- \"$tool_path\" 2>/dev/null)\"\n  [[ \"${shebang:0:2}\" == \"#!\" ]] || err_exit \"No shebang (#!) found in script: $tool_path\"\n  if ! python_executable=\"$(${shebang#\\#!} -c 'import sys; print(sys.executable); import jumpthegun' 2>/dev/null)\"; then\n    # Find JumpTheGun's code.\n    SCRIPT_DIR=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\n    jumpthegunctl_path=\"$SCRIPT_DIR/jumpthegunctl\"\n    jumpthegunctl_shebang=\"$(head -n 1 -- \"$jumpthegunctl_path\")\"\n    jumpthegunctl_python_executable=\"$(${jumpthegunctl_shebang#\\#!} -c 'import sys; print(sys.executable)')\"\n    jumpthegun_lib_dir=\"$(\"$jumpthegunctl_python_executable\" -c 'import jumpthegun, os; print(os.path.dirname(jumpthegun.__file__))')\"\n\n    # Make a copy of this version of JumpTheGun's code in a cache directory.\n    dir_name=\"lib-$(hash_str \"$python_executable|$(head -n 1 \"$jumpthegun_lib_dir/__version__.py\")\")\"\n    cache_home=${XDG_CACHE_HOME:-\"$HOME/.cache\"}\n    cache_dir=\"$cache_home/jumpthegun/$dir_name\"\n    if [ ! -d \"$cache_dir\" ]; then\n      mkdir -p \"$cache_dir\"\n      cp -r -- \"$jumpthegun_lib_dir\" \"$cache_dir/jumpthegun\"\n      find \"$cache_dir/jumpthegun\" -type f -not -name '*.py' -exec rm {} +\n    fi\n\n    # Add the cache directory to PYTHONPATH.\n    if [[ -n \"${PYTHONPATH:-}\" ]]; then\n      export PYTHONPATH=\"$cache_dir:$PYTHONPATH\"\n    else\n      export PYTHONPATH=\"$cache_dir\"\n    fi\n  fi\n\n  # Run JumpTheGun.\n  set -f  # Disable filename expansion (globbing).\n  exec $python_executable -c \"from jumpthegun.jumpthegunctl import main; main()\" \"$@\"\n  ;;\nrun)\n  shift\n  [[ $# -eq 0 ]] && usage && exit 1\n  if [[ \"$1\" == \"--no-autorun\" ]]; then\n    autorun=0\n    shift\n  fi\n  [[ \"$1\" =~ -h|--help ]] && usage && exit 0\n  tool_name=\"$1\"\n  shift\n  ;;\n*)\n  usage && exit 1 ;;\nesac\n\n# Find service runtime directory.\nservice_runtime_dir=\"$(get_service_runtime_dir)\"\nif [[ -z \"$service_runtime_dir\" ]]; then\n  [[ autorun -eq 1 ]] && \"${BASH_SOURCE[0]}\" start \"$tool_name\" &>/dev/null &\n  exec \"$tool_name\" \"$@\"\nfi\n\n# Calculate the isolated path for pid and port files.\nisolated_root=\"$(dirname \"$(command -v -- \"$tool_name\")\")\"\nisolated_root_hash=\"$(hash_str \"$isolated_root\")\"\nisolated_path=\"$service_runtime_dir/$isolated_root_hash\"\n\n# Check that port file exists.\nif [[ ! -f \"$isolated_path/$tool_name.port\" ]]; then\n  [[ autorun -eq 1 ]] && \"${BASH_SOURCE[0]}\" start \"$tool_name\" &>/dev/null &\n  exec \"$tool_name\" \"$@\"\nfi\n\n# Read port from port file.\nIFS= read -r port <\"$isolated_path/$tool_name.port\"\n\n# Open TCP connection.\nexec 3<>\"/dev/tcp/127.0.0.1/$port\"\n\n# Close TCP connection upon exit.\nfunction close_connection {\n  exec 3<&-\n}\ntrap close_connection EXIT\n\n\n# Read companion process PID.\nread -r -u 3 pid\n\n# Forward some signals.\nfunction forward_signal() {\n  kill -s \"$1\" \"$pid\"\n}\nfor sig in INT TERM USR1 USR2; do\n  trap \"forward_signal $sig\" \"$sig\"\ndone\n\n# Send argv and cwd.\noLang=\"${LANG-}\" oLcAll=\"${LC_ALL-}\"\nLANG=C LC_ALL=C\n# Add an x in front to avoid special-casing having zero arguments.\nargv_str=$(printf ' %q' x \"$@\")\n# Remove the leading \" x \".\nargv_str=\"${argv_str:3}\"\nprintf '%d\\n%s%d\\n%s' \"${#argv_str}\" \"$argv_str\" \"${#PWD}\" \"$PWD\" >&3\nLANG=\"$oLang\" LC_ALL=\"$oLcAll\"\n\n# Send env vars.\nx=\"$(mktemp)\"\nenv -0 > \"$x\" 2>/dev/null\nif [[ $OSTYPE == \"darwin\"* ]]; then\n  stat -f %z \"$x\" >&3\nelse\n  stat -c %s \"$x\" >&3\nfi\ncat \"$x\" >&3\nrm \"$x\"\n\n\n# Read stdout and stderr from connection, line by line, and echo them.\nIFS=\nwhile read -r -u 3 line; do\n  case \"$line\" in\n    1*)\n      # stdout\n      n_newlines=\"${line:1}\"\n      for (( i=1; i <= n_newlines; i++ )); do\n        read -r -u 3 line\n        echo \"$line\"\n      done\n      read -r -u 3 line\n      echo -n \"$line\"\n      ;;\n    2*)\n      # stderr\n      n_newlines=\"${line:1}\"\n      for (( i=1; i <= n_newlines; i++ )); do\n        read -r -u 3 line\n        echo \"$line\" >&2\n      done\n      read -r -u 3 line\n      echo -n \"$line\" >&2\n      ;;\n    3*)\n      # stdin\n      read -r line2\n      echo \"$line2\" >&3\n      ;;\n    rc=*)\n      # exit\n      rc=\"${line:3}\"\n      exit \"$rc\"\n      ;;\n    *)\n      echo \"Error: Unexpected output from jumpthegun daemon.\" >&2\n      exit 1\n      ;;\n  esac\ndone\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/jumpthegun.sh b/src/jumpthegun.sh
--- a/src/jumpthegun.sh	(revision af6d0f9aa00f5c0b87cc84b428ca9467393a06b9)
+++ b/src/jumpthegun.sh	(date 1748459080768)
@@ -108,24 +108,21 @@
   exec "$tool_name" "$@"
 fi
 
-# Calculate the isolated path for pid and port files.
+# Calculate the isolated path for pid and socket files.
 isolated_root="$(dirname "$(command -v -- "$tool_name")")"
 isolated_root_hash="$(hash_str "$isolated_root")"
 isolated_path="$service_runtime_dir/$isolated_root_hash"
 
-# Check that port file exists.
-if [[ ! -f "$isolated_path/$tool_name.port" ]]; then
+# Check that socket file exists.
+if [[ ! -f "$isolated_path/$tool_name.sock" ]]; then
   [[ autorun -eq 1 ]] && "${BASH_SOURCE[0]}" start "$tool_name" &>/dev/null &
   exec "$tool_name" "$@"
 fi
 
-# Read port from port file.
-IFS= read -r port <"$isolated_path/$tool_name.port"
+# Open Unix domain socket connection
+exec 3<>"$isolated_path/$tool_name.sock"
 
-# Open TCP connection.
-exec 3<>"/dev/tcp/127.0.0.1/$port"
-
-# Close TCP connection upon exit.
+# Close socket connection upon exit.
 function close_connection {
   exec 3<&-
 }
