import re
from datetime import datetime
from regexapp import LinePattern
from regexapp import MultilinePattern
from regexapp.exceptions import RegexBuilderError
from regexapp.exceptions import PatternReferenceError
from regexapp.exceptions import NoUserDataError
from regexapp.exceptions import NoTestDataError

from regexapp.config import version
from regexapp.collection import REF
import regexapp
from copy import copy, deepcopy
from collections import OrderedDict
from textwrap import indent
from textwrap import dedent

BASELINE_REF = deepcopy(REF)


def is_pro_edition():
    """return True if regexapp is Pro or Enterprise edition"""
    # TODO: Regex Pro Edition and Enterprise Edition will be deprecated and
    #  removed in the upcoming migration to regexapp version 1.x.
    chk = regexapp.edition == 'Pro' or regexapp.edition == 'Enterprise'
    return chk


def enclose_string(text):
    """enclose text with either double-quote or triple double-quote

    Parameters
    ----------
    text (str): a text

    Returns
    -------
    str: a new string with enclosed double-quote or triple double-quote
    """
    text = str(text)
    fmt = '"""{}"""' if len(text.splitlines()) > 1 else '"{}"'
    enclosed_txt = fmt.format(text.replace('"', r'\"'))
    return enclosed_txt


def create_custom_docstring(**kwargs):
    """Generate custom docstring for Pro Edition or Enterprise Edition

    Regex Pro Edition and Enterprise Edition will be deprecated and
    removed in the upcoming migration to regexapp version 1.x.

    Parameters
    ----------
    kwargs (dict): custom keyword arguments for
            Pro Edition or Enterprise Edition.

    Returns
    -------
    str: a custom docstring or empty string.

    """
    if kwargs:
        # TODO: Regex Pro Edition and Enterprise Edition will be deprecated
        #  and removed in the upcoming migration to regexapp version 1.x.
        if is_pro_edition():
            # fmt = ('Contact tuyen@geekstrident.com to use {!r} flags on '
            #        'Regex Pro or Enterprise Edition.')
            # print(fmt.format(kwargs))
            return ''
        else:
            # fmt = 'CANT use {!r} flags with Regex Pro Edition.'
            # print(fmt.format(kwargs))
            return ''
    else:
        return ''


def create_docstring(test_framework='unittest',
                     author='', email='', company='', **kwargs):
    """Generate module docstring for test script

    Parameters
    ----------
    test_framework (str): a test framework.  Default is unittest.
    author (str): author name.  Default is empty.
    email (str): author name.  Default is empty.
    company (str): company name.  Default is empty.
    kwargs (dict): custom keyword arguments for
            Pro Edition or Enterprise Edition.
            Regex Pro Edition and Enterprise Edition will be deprecated
            and removed in the upcoming migration to regexapp version 1.x.


    Returns
    -------
    str: a module docstring
    """

    # TODO: Regex Pro Edition and Enterprise Edition will be deprecated and
    #  removed in the upcoming migration to regexapp version 1.x.

    lang = '' if test_framework == 'robotframework' else 'Python '
    fmt = '{}{} script is generated by Regex {} Edition'
    fmt1 = 'Created by  : {}'
    fmt2 = 'Email       : {}'
    fmt3 = 'Company     : {}'
    fmt4 = 'Created date: {:%Y-%m-%d}'

    lst = list()
    author = author or company
    lst.append(fmt.format(lang, test_framework, regexapp.edition))
    lst.append('')
    author and lst.append(fmt1.format(author))
    email and lst.append(fmt2.format(email))
    company and company != author and lst.append(fmt3.format(company))
    lst.append(fmt4.format(datetime.now()))
    custom_docstr = create_custom_docstring(**kwargs)
    custom_docstr and lst.append(custom_docstr)

    if test_framework == 'robotframework':
        new_lst = [line.strip() for line in indent('\n'.join(lst), '# ').splitlines()]
        comment = '\n'.join(new_lst)
        return comment
    else:
        module_docstr = '"""{}\n"""'.format('\n'.join(lst))
        return module_docstr


def save_file(filename, content):
    """Save data to file

    Parameters
    ----------
    filename (str): a file name
    content (str): a file content
    """
    filename = str(filename).strip()
    if filename:
        with open(filename, 'w') as stream:
            stream.write(content)


class RegexBuilder:
    """Use for building regex pattern

    Attributes
    ----------
    user_data (str, list): a user data can be either string or list of string.
    test_data (str, list): a test data can be either string or list of string.

    prepended_ws (bool): prepend a whitespace at the beginning of a pattern.
            Default is False.
    appended_ws (bool): append a whitespace at the end of a pattern.
            Default is False.
    ignore_case (bool): prepend (?i) at the beginning of a pattern.
            Default is False.

    is_line (bool): a flag to use LinePattern.  Default is False.
    test_name (str): a predefined test name.  Default is empty.
            + unittest will use either predefined test name or
                generated test name from test data
            + pytest will use predefined test name.
            + robotframework test will depend on test workflow.  It might be
                either used predefined test name or generated test name.
    max_words (int): total number of words for generating test name.
            Default is 6 words.
    test_cls_name (str): a test class name for test script.  This test class
            name only be applicable for unittest or pytest.
            Default is TestDynamicGenTestScript.

    author (str): author name.  Default is empty.
    email (str): author name.  Default is empty.
    company (str): company name.  Default is empty.

    filename (str): save a generated test script to file name.
    kwargs (dict): an optional keyword arguments.
            Community edition will use the following keywords:
                prepended_ws, appended_ws, ignore_case
            Pro or Enterprise edition will be deprecated and removed in
                the upcoming migration to regexapp version 1.x.
                prepended_ws, appended_ws, ignore_case, other keywords

    patterns (list): a list of patterns.
    test_report (str): a test report.
    test_result (bool): a test result.
    user_data_pattern_table (OrderedDict): a variable holds (user_data, pattern) pair.
    pattern_user_data_table (OrderedDict): a variable holds (pattern, user_data) pair.
    test_data_pattern_table (OrderedDict): a variable holds (test_data, pattern) pair.
    pattern_test_data_table (OrderedDict): a variable holds (pattern, test_data) pair.

    Methods
    -------
    RegexBuilder.validate_data(data, name) -> bool
    build() -> None
    test(showed=True) -> bool
    create_unittest() -> str
    create_pytest() -> str
    create_rf_test() -> str
    create_python_test() -> str

    Raises
    ------
    RegexBuilderError: if user_data or test_data is invalid format.
    """
    def __init__(self, user_data='', test_data='',
                 prepended_ws=False, appended_ws=False, ignore_case=False,
                 test_name='', is_line=False, is_exact=False,
                 max_words=6, test_cls_name='TestDynamicGenTestScript',
                 author='', email='', company='', filename='',
                 **kwargs
                 ):

        self.raw_user_data = user_data
        self.user_data = user_data
        self.test_data = test_data

        self.prepended_ws = prepended_ws
        self.appended_ws = appended_ws
        self.ignore_case = ignore_case

        self.test_name = test_name
        self.is_line = is_line
        self.is_exact = is_exact
        self.max_words = max_words
        self.test_cls_name = test_cls_name
        self.author = author
        self.email = email
        self.company = company
        self.filename = filename
        self.kwargs = kwargs

        self.patterns = []
        self.test_report = ''
        self.test_result = False
        self.user_data_pattern_table = OrderedDict()    # user data via pattern
        self.pattern_user_data_table = OrderedDict()    # pattern via user data
        self.test_data_pattern_table = OrderedDict()    # test data via pattern
        self.pattern_test_data_table = OrderedDict()    # pattern via test data

        BASELINE_REF.load_reference(BASELINE_REF.user_ref_loc, is_warning=False)

    @classmethod
    def validate_data(cls, **kwargs):
        """validate data

        Parameters
        ----------
        kwargs (dict): keyword argument

        Returns
        -------
        bool: True or False

        Raises
        ------
        RegexBuilderError: if failed to validate data.
        """
        if not kwargs:
            msg = 'CANT validate data without providing data.'
            raise RegexBuilderError(msg)

        is_validated = True
        for name, data in kwargs.items():
            fmt = '{} MUST be string or list of string.'
            if not isinstance(data, (list, str)):
                msg = fmt.format(name)
                raise RegexBuilderError(msg)

            if isinstance(data, list):
                for line in data:
                    if not isinstance(line, str):
                        msg = fmt.format(name)
                        raise RegexBuilderError(msg)
            is_validated &= True if data else False
        return is_validated

    def build(self):
        """Build regex pattern"""
        pattern = r"# \S+commercial use: generated by[^\r\n]+[\r\n]+" \
                  r"# Created Date: [^\r\n]+[\r\n]+#{4,} *[\r\n]+"
        if re.match(pattern, self.raw_user_data.lstrip()):
            # excluding commercial use text in user data
            self.user_data = re.sub(pattern, "", self.raw_user_data.lstrip())

        data = self.user_data
        self.__class__.validate_data(user_data=data)

        if not data:
            self.test_report = 'CANT build regex pattern with an empty data.'
            print(self.test_report)
            return

        if self.is_line:
            lst_of_user_data = data[:] if isinstance(data, (list, tuple)) else data.splitlines()
        else:
            if isinstance(data, str):
                lst_of_user_data = [data]
            else:
                lst_of_user_data = []
                for item in data:
                    if isinstance(item, (list, tuple)):
                        lst_of_user_data.append('\n'.join(map(str, item)))
                    else:
                        lst_of_user_data.append(str(item))

        for user_data in lst_of_user_data:
            if self.is_line:
                pattern = LinePattern(
                    user_data,
                    prepended_ws=self.prepended_ws,
                    appended_ws=self.appended_ws,
                    ignore_case=self.ignore_case
                )
            else:
                pattern = MultilinePattern(
                    user_data,
                    ignore_case=self.ignore_case,
                    is_exact=self.is_exact
                )

            pattern not in self.patterns and self.patterns.append(pattern)
            self.user_data_pattern_table[user_data] = pattern
            self.pattern_user_data_table[pattern] = user_data

    def test(self, showed=False):
        """test regex pattern via test data.

        Parameters
        ----------
        showed (bool): show test report if set to True.  Default is False.

        Returns
        -------
        bool: True if passed a test, otherwise, False.
        """
        data = self.test_data
        self.__class__.validate_data(test_data=data)

        if not data:
            self.test_report = 'CANT run test with an empty data.'
            showed and print(self.test_report)
            return False

        if self.is_line:
            lst_of_test_data = data[:] if isinstance(data, (list, tuple)) else data.splitlines()
        else:
            if isinstance(data, str):
                lst_of_test_data = [data]
            else:
                lst_of_test_data = []
                for item in data:
                    if isinstance(item, (list, tuple)):
                        lst_of_test_data.append('\n'.join(map(str, item)))
                    else:
                        lst_of_test_data.append(str(item))

        result = ['Test Data:', '-' * 9, '\n'.join(lst_of_test_data), '']
        result += ['Matched Result:', '-' * 14]

        test_result = True
        for pat in self.patterns:
            is_matched = False
            lst = []
            for test_data in lst_of_test_data:
                match = re.search(pat, test_data)
                if match:
                    is_matched = True
                    match.groupdict() and lst.append(match.groupdict())
                    self.test_data_pattern_table[test_data] = pat
                    self.pattern_test_data_table[pat] = test_data

            test_result &= is_matched
            tr = 'NO' if not is_matched else lst if lst else 'YES'
            result.append('pattern: {}'.format(pat))
            result.append('matched: {}'.format(tr))
            result.append('-' * 10)

        self.test_result = test_result
        self.test_report = '\n'.join(result)
        showed and print(self.test_report)

        return test_result

    def create_unittest(self):
        """dynamically generate Python unittest script

        Returns
        -------
        str: python unittest script
        """
        factory = DynamicTestScriptBuilder(test_info=self)
        script = factory.create_unittest()
        return script

    def create_pytest(self):
        """dynamically generate Python pytest script

        Returns
        -------
        str: python pytest script
        """
        factory = DynamicTestScriptBuilder(test_info=self)
        script = factory.create_pytest()
        return script

    def create_rf_test(self):
        """dynamically generate Robotframework script

        Returns
        -------
        str: Robotframework test script
        """
        factory = DynamicTestScriptBuilder(test_info=self)
        script = factory.create_rf_test()
        return script

    def create_python_test(self):
        """dynamically generate Python test script

        Returns
        -------
        str: python test script
        """
        factory = DynamicTestScriptBuilder(test_info=self)
        script = factory.create_python_test()
        return script


def add_reference(name='', pattern='', **kwargs):
    """add keyword reference to PatternReference.  This is an inline adding
    PatternReference for quick test.

    Parameters
    ----------
    name (str): a keyword.
    pattern (str): a regex pattern.
    kwargs (dict): keyword argument which will use for special case such as datetime.

    Raises
    ------
    PatternReferenceError: if adding an existing keyword from
        system_references.yaml or user_references.yaml
    """
    if not name:
        fmt = '{} keyword can not be empty name.'
        PatternReferenceError(fmt.format(name))

    obj = dict(pattern=pattern,
               description='inline_{}_{}'.format(name, pattern))
    if name not in REF:
        REF[name] = obj
    else:
        if name == 'datetime':
            for key, value in kwargs.items():
                if re.match(r'format\d+$', key):
                    REF['datetime'][key] = value
        else:
            if name not in BASELINE_REF:
                REF[name] = obj
            else:
                fmt = ('{} already exists in system_references.yaml '
                       'or user_references.yaml')
                raise PatternReferenceError(fmt.format(name))


def remove_reference(name=''):
    """remove keyword reference from PatternReference.  This method only remove
    any inline adding keyword reference.

    Parameters
    ----------
    name (str): a keyword.

    Raises
    ------
    PatternReferenceError: if removing an existing keyword from
        system_references.yaml or user_references.yaml
    """
    if not name:
        fmt = '{} keyword can not be empty name.'
        PatternReferenceError(fmt.format(name))

    if name in REF:
        if name not in BASELINE_REF:
            REF.pop(name)
        else:
            if name == 'datetime':
                REF['datetime'] = deepcopy(BASELINE_REF['datetime'])
            else:
                fmt = ('CANT remove {!r} from system_references.yaml '
                       'or user_references.yaml')
                raise PatternReferenceError(fmt.format(name))
    else:
        fmt = 'CANT remove {!r} keyword because it does not exist.'
        raise PatternReferenceError(fmt.format(name))


class DynamicTestScriptBuilder:
    """
    Dynamically generate test scripts for multiple frameworks.

    This builder class constructs test scripts (unittest, pytest,
    Robot Framework, or generic Python snippets) based on provided
    regex patterns and test data. It supports both direct use of a
    `RegexBuilder` instance and a simplified list format containing
    user_data and test_data. The builder automates test name generation,
    pattern compilation, and script creation.

    Attributes
    ----------
    test_info : RegexBuilder or list
        Either a `RegexBuilder` instance or a twoâ€‘element list
        containing [user_data, test_data].
    test_name : str
        Predefined test name. Defaults to empty string.
        - unittest: uses predefined name or generates one from test data.
        - pytest: uses predefined name.
        - Robot Framework: may use either predefined or generated name.
    is_line : bool
        Flag to enable LinePattern. Defaults to False.
    max_words : int
        Maximum number of words used when generating a test name.
        Default is 6.
    test_cls_name : str
        Name of the test class for unittest/pytest scripts.
        Default is "TestDynamicGenTestScript".
    author : str
        Author name. Defaults to empty string.
    email : str
        Author email. Defaults to empty string.
    company : str
        Company name. Defaults to empty string.
    filename : str
        File name to save the generated test script.
    kwargs : dict
        Optional keyword arguments. Community edition supports:
        `prepended_ws`, `appended_ws`, `ignore_case`.
        Pro/Enterprise keywords are deprecated in regexapp v1.x.
    lst_of_tests : list
        Compiled list of test cases, each containing test name,
        test data, prepared data, and pattern.
    test_data : str
        Test data string used for validation.
    patterns : list
        List of regex patterns generated from user data.

    Methods
    -------
    compile_test_info() -> None
        Prepare a list of test cases from `test_info`.
    generate_test_name(test_data='') -> str
        Generate a valid test name from provided test data.
    create_unittest() -> str
        Generate a Python unittest script.
    create_pytest() -> str
        Generate a Python pytest script.
    create_rf_test() -> str
        Generate a Robot Framework test script (not yet implemented).
    create_python_test() -> str
        Generate a generic Python test script snippet.
    """
    def __init__(self, test_info=None, test_name='', is_line=False,
                 max_words=6, test_cls_name='TestDynamicGenTestScript',
                 author='', email='', company='', filename='',
                 **kwargs):

        self.test_info = test_info
        if isinstance(test_info, RegexBuilder):
            self.test_name = test_info.test_name
            self.is_line = is_line or test_info.is_line
            self.max_words = test_info.max_words
            self.test_cls_name = test_info.test_cls_name

            self.author = author or test_info.author
            self.email = email or test_info.email
            self.company = company or test_info.company
            self.filename = filename or test_info.filename

            self.prepended_ws = test_info.prepended_ws
            self.appended_ws = test_info.appended_ws
            self.ignore_case = test_info.ignore_case
            self.kwargs = test_info.kwargs
        else:
            self.test_name = test_name
            self.is_line = is_line
            self.max_words = max_words
            self.test_cls_name = test_cls_name

            self.author = author
            self.email = email
            self.company = company
            self.filename = filename

            self.prepended_ws = kwargs.get('prepended_ws', False)
            self.appended_ws = kwargs.get('appended_ws', False)
            self.ignore_case = kwargs.get('ignore_case', False)
            self.kwargs = kwargs

        'prepended_ws' in self.kwargs and self.kwargs.pop('prepended_ws')
        'appended_ws' in self.kwargs and self.kwargs.pop('appended_ws')
        'ignore_case' in self.kwargs and self.kwargs.pop('ignore_case')

        self.lst_of_tests = []
        self.test_data = None
        self.patterns = None
        self.compile_test_info()

    def compile_test_info(self):
        """prepare a list of test cases from test info"""

        self.lst_of_tests = []
        test_info = self.test_info
        if isinstance(test_info, RegexBuilder):
            # testable = deepcopy(test_info)
            testable = copy(test_info)
            self.test_data = testable.test_data
        else:
            chk = isinstance(test_info, list) and len(test_info) == 2
            if not chk:
                raise RegexBuilderError('Invalid test_info format')

            user_data, test_data = self.test_info
            self.test_data = test_data

            testable = RegexBuilder(
                user_data=user_data, test_data=test_data,
                is_line=self.is_line,
                prepended_ws=self.prepended_ws,
                appended_ws=self.appended_ws,
                ignore_case=self.ignore_case
            )
        testable.build()
        testable.test()

        self.patterns = testable.patterns

        user_data_pattern_table = testable.user_data_pattern_table
        pattern_user_data_table = testable.pattern_user_data_table
        test_data_pattern_table = testable.test_data_pattern_table

        if not test_data_pattern_table and not user_data_pattern_table:
            raise RegexBuilderError('No prepared_data to build test script')

        for test_data, pattern in test_data_pattern_table.items():
            test_name = self.generate_test_name(test_data=test_data)
            prepared_data = pattern_user_data_table.get(pattern)
            self.lst_of_tests.append([test_name, test_data, prepared_data, pattern])

    def generate_test_name(self, test_data=''):
        """
        Generate a valid test function name from provided test data.

        This method normalizes the input string, extracts up to `max_words`
        words, and converts them into a safe identifier suitable for use
        as a test function name. If a predefined `self.test_name` exists,
        it will be used instead. The final name is guaranteed to start
        with the prefix ``test_``.

        Parameters
        ----------
        test_data : str, optional
            Raw test data string used to derive the test name.
            Defaults to an empty string.

        Returns
        -------
        str
            A sanitized test name string that:
            - Contains only alphanumeric characters and underscores.
            - Is truncated to at most `max_words` words.
            - Always begins with ``test_``.
        """
        pat = r'[^0-9a-zA-Z]*\s+[^0-9a-zA-Z]*'
        test_data = str(test_data).lower().strip()
        test_data = ' '.join(re.split(pat, test_data)[:self.max_words])
        test_name = self.test_name or test_data
        test_name = re.sub(r'[^0-9a-z]+', '_', test_name)
        test_name = test_name.strip('_')
        if not test_name.startswith('test_'):
            test_name = 'test_{}'.format(test_name)
        return test_name

    def create_unittest(self):
        """
        Generate a Python unittest script from the current builder state.

        This method uses the `UnittestBuilder` to construct a complete
        unittest script based on the test cases and configuration stored
        in the `DynamicTestScriptBuilder` instance. The generated script
        is also saved to the file specified by `self.filename`.

        Returns
        -------
        str
            A string containing the full Python unittest script.
            The script is written to disk if `self.filename` is set.
        """
        factory = UnittestBuilder(self)
        test_script = factory.create()
        save_file(self.filename, test_script)
        return test_script

    def create_pytest(self):
        """
        Generate a Python pytest script from the current builder state.

        This method uses the `PytestBuilder` to construct a complete
        pytest script based on the test cases and configuration stored
        in the `DynamicTestScriptBuilder` instance. The generated script
        is also saved to the file specified by `self.filename`.

        Returns
        -------
        str
            A string containing the full Python pytest script.
            The script is written to disk if `self.filename` is set.
        """
        factory = PytestBuilder(self)
        test_script = factory.create()
        save_file(self.filename, test_script)
        return test_script

    def create_rf_test(self):     # noqa
        """
        Generate a Robot Framework test script.

        This method is intended to construct a Robot Framework test script
        based on the current builder state (test cases, configuration, and
        patterns). At present, the implementation is not available and will
        raise a ``NotImplementedError``.

        Returns
        -------
        str
            A Robot Framework test script string once implemented.

        Raises
        ------
        NotImplementedError
            Always raised until Robot Framework test generation is
            implemented.
        """
        msg = 'TODO: need to implement generated_rf_test for robotframework'
        NotImplementedError(msg)

    def create_python_test(self):
        """dynamically generate Python test script

        Returns
        -------
        str: a Python test script
        """
        factory = PythonSnippetBuilder(self)
        test_script = factory.create()
        save_file(self.filename, test_script)
        return test_script


class UnittestBuilder:
    """Create Unittest script

    Attributes
    ----------
    tc_gen (DynamicGenTestScript): an DynamicGenTestScript instance.
    module_docstring (str): a Python snippet docstring.

    Methods
    -------
    create_testcase_class() -> str
    create_testcase_method() -> str
    create_testcase_load() -> str
    create() -> str
    """
    def __init__(self, tc_gen):
        self.tc_gen = tc_gen
        self.module_docstring = create_docstring(
            test_framework='unittest',
            author=tc_gen.author,
            email=tc_gen.email,
            company=tc_gen.company,
            **tc_gen.kwargs
        )

    def create_testcase_class(self):
        """return partial unit test class definition"""

        tmpl = """
          {module_docstring}

          import unittest
          import re

          class {test_cls_name}(unittest.TestCase):
              def __init__(self, test_name='', test_data=None, pattern=None):
                  super().__init__(test_name)
                  self.test_data = test_data
                  self.pattern = pattern
        """
        tmpl = dedent(tmpl).strip()

        tc_gen = self.tc_gen
        partial_script = tmpl.format(
            module_docstring=self.module_docstring,
            test_cls_name=tc_gen.test_cls_name
        )

        return partial_script

    def create_testcase_method(self):
        """return partial unit test method definition"""

        tmpl = """
            def {test_name}(self):
                result = re.search(self.pattern, self.test_data)
                self.assertIsNotNone(result)
        """
        tmpl = dedent(tmpl).strip()

        tc_gen = self.tc_gen
        lst = []

        for test in tc_gen.lst_of_tests:
            test_name = test[0]
            method_def = tmpl.format(test_name=test_name)
            method_def = indent(method_def, ' ' * 4)
            if method_def not in lst:
                lst.append(method_def)
                lst.append('')

        partial_script = '\n'.join(lst)
        return partial_script

    def create_testcase_load(self):
        """return partial unit test load_tests function definition"""

        tmpl = """
            def load_tests(loader, tests, pattern):
                test_cases = unittest.TestSuite()
                
                {data_insertion}
                
                for arg in arguments:
                    test_name, test_data, pattern = arg
                    testcase = {test_cls_name}(
                        test_name=test_name,
                        test_data=test_data,
                        pattern=pattern
                    )
                    test_cases.addTest(testcase)
                return test_cases
        """
        tmpl = dedent(tmpl).strip()

        tmpl_data = """
            arguments.append(
                (
                    {test_name},    # test name
                    {test_data},    # test data
                    r{pattern}   # pattern
                )
            )
        """
        tmpl_data = dedent(tmpl_data).strip()

        tc_gen = self.tc_gen
        lst = ['arguments = list()']

        test_desc_fmt = '    # test case #{:0{}} - {}'
        spacers = len(str(len(tc_gen.lst_of_tests)))
        for index, test in enumerate(tc_gen.lst_of_tests, 1):
            test_name, test_data, _, pattern = test
            test_data = enclose_string(test_data)
            data = tmpl_data.format(
                test_name=enclose_string(test_name),
                test_data='__test_data_placeholder__',
                pattern=enclose_string(pattern))
            lst.append('')
            lst.append(test_desc_fmt.format(index, spacers, test_name))
            new_data = indent(data, ' ' * 4)
            new_data = new_data.replace('__test_data_placeholder__', test_data)
            lst.append(new_data)

        data_insertion = '\n'.join(lst)
        sub_script = tmpl.format(
            data_insertion=data_insertion,
            test_cls_name=tc_gen.test_cls_name
        )
        return sub_script

    def create(self):
        """return Python unittest script"""
        tc_class = self.create_testcase_class()
        tc_method = self.create_testcase_method()
        tc_load = self.create_testcase_load()

        test_script = '{}\n\n{}\n\n{}'.format(tc_class, tc_method, tc_load)
        return test_script


class PytestBuilder:
    """Create Pytest script

    Attributes
    ----------
    tc_gen (DynamicGenTestScript): an DynamicGenTestScript instance.
    module_docstring (str): a Python snippet docstring.

    Methods
    -------
    create() -> str
    """
    def __init__(self, tc_gen):
        self.tc_gen = tc_gen
        self.module_docstring = create_docstring(
            test_framework='pytest',
            author=tc_gen.author,
            email=tc_gen.email,
            company=tc_gen.company,
            **tc_gen.kwargs
        )

    def create(self):
        """return pytest script"""

        tmpl = """
            {module_docstring}
            
            import pytest
            import re
            
            class {test_cls_name}:
                @pytest.mark.parametrize(
                    ('test_data', 'pattern'),
                    (
                        {parametrize_data}
                    )
                )
                def {test_name}(self, test_data, pattern):
                    result = re.search(pattern, test_data)
                    assert result is not None
        """
        tmpl = dedent(tmpl).strip()

        tmpl_data = """
            (
                {test_data},    # test data
                r{pattern}   # pattern
            ),
        """
        tmpl_data = dedent(tmpl_data).strip()

        tc_gen = self.tc_gen
        lst = []
        placeholder_table = dict()
        for index, test in enumerate(tc_gen.lst_of_tests):
            _, test_data, _, pattern = test
            test_data = enclose_string(test_data)
            key = '__test_data_placeholder_{}__'.format(index)
            placeholder_table[key] = test_data

            kw = dict(test_data=key,
                      pattern=enclose_string(pattern))
            parametrize_item = tmpl_data.format(**kw)
            parametrize_item = indent(parametrize_item, ' ' * 12)
            lst.append(parametrize_item)

        parametrize_data = '\n'.join(lst).strip()

        for key, value in placeholder_table.items():
            parametrize_data = parametrize_data.replace(key, value)

        test_name = tc_gen.test_name or 'test_generating_script'
        if not test_name.startswith('test_'):
            test_name = 'test_{}'.format(test_name)

        test_script = tmpl.format(
            module_docstring=self.module_docstring,
            test_cls_name=tc_gen.test_cls_name,
            test_name=test_name,
            parametrize_data=parametrize_data
        )
        test_script = '\n'.join(line.rstrip() for line in test_script.splitlines())
        return test_script


class PythonSnippetBuilder:
    """Create Python snippet test script

    Attributes
    ----------
    tc_gen (DynamicGenTestScript): an DynamicGenTestScript instance.
    module_docstring (str): a Python snippet docstring.

    Methods
    -------
    create() -> str
    create_line_via_pattern_script(test_data, pattern) -> str
    create_line_via_patterns_script(test_data, patterns) -> str
    create_multiline_via_pattern_script(test_data, pattern) -> str
    """
    def __init__(self, tc_gen):
        self.tc_gen = tc_gen
        self.module_docstring = create_docstring(
            test_framework='test',
            author=tc_gen.author,
            email=tc_gen.email,
            company=tc_gen.company,
            **tc_gen.kwargs
        )

    def create_line_via_pattern_script(self, test_data, pattern):
        """return python test script - line via pattern

        Parameters
        ----------
        test_data (str): a test data.
        pattern (str): a regex pattern.

        Returns
        -------
        str: a python test script
        """

        tmpl = '''
            {module_docstring}

            import re

            # test data
            test_data = {test_data}

            # regex pattern
            pattern = r{pattern}

            def test_regex(test_data, pattern):
                """test regular expression

                Parameters
                ----------
                test_data (str): a test data
                pattern (str): a regular expression pattern
                """
                print("Pattern: {{}}".format(pattern))
                is_matched = False
                for index, line in enumerate(test_data.splitlines(), 1):
                    match = re.search(pattern, line)
                    if match:
                        is_matched = True
                        if match.groupdict():
                            print("Result{{}}: {{}}".format(index, match.groupdict()))
                        else:
                            print("Result{{}}: {{}}".format(index, match.group()))
                else:
                    if not is_matched:
                        print("Result: No match")

            # function call
            test_regex(test_data, pattern)
        '''
        tmpl = dedent(tmpl).strip()

        test_script = tmpl.format(
            module_docstring=self.module_docstring,
            test_data=test_data,
            pattern=pattern
        )
        return test_script

    def create_line_via_patterns_script(self, test_data, patterns):
        """return python snippet script - line via patterns

        Parameters
        ----------
        test_data (str): a test data.
        patterns (list): a list of patterns.

        Returns
        -------
        str: a python test script
        """
        tmpl = '''
            {module_docstring}
            
            import re
            
            # test data
            test_data = {test_data}
            
            # list of regex pattern
            patterns = [
                {patterns}
            ]
            
            def test_regex(test_data, patterns):
                """test regular expression
            
                Parameters
                ----------
                test_data (str): a test data
                patterns (list): a list of regular expression pattern
                """
            
                for pattern in patterns:
                    is_matched = False
                    for line in test_data.splitlines():
                        match = re.search(pattern, line)
                        if match:
                            is_matched = True
                            print("Pattern: {{}}".format(pattern))
                            if match.groupdict():
                                print("Result: {{}}".format(match.groupdict()))
                            else:
                                print("Result: {{}}".format(match.group()))
                            print("-" * 10)
                    else:
                        if not is_matched:
                            print("Result: No match")
            
            # function call
            test_regex(test_data, patterns)
        '''
        tmpl = dedent(tmpl).strip()

        lst = []
        for pattern in patterns:
            lst.append('r{}'.format(enclose_string(pattern)))
        patterns = indent(',\n'.join(lst), '    ').strip()
        test_script = tmpl.format(
            module_docstring=self.module_docstring,
            test_data=test_data, patterns=patterns
        )
        return test_script

    def create_multiline_via_pattern_script(self, test_data, pattern):
        """return python test script - multiline via pattern

        Parameters
        ----------
        test_data (str): a test data.
        pattern (str): a regex pattern.

        Returns
        -------
        str: a python test script
        """
        tmpl = '''
            {module_docstring}
            
            import re
            
            # test data
            test_data = {test_data}
            
            # regex pattern
            pattern = r{pattern}
            
            def test_regex(test_data, pattern):
                """test regular expression
            
                Parameters
                ----------
                test_data (str): a test data
                pattern (str): a regular expression pattern
                """
            
                print("Pattern: {{}}".format(pattern))
                match = re.search(pattern, test_data)
                if match:
                    if match.groupdict():
                        print("Result: {{}}".format(match.groupdict()))
                    else:
                        print("Result: {{}}".format(match.group()))
                else:
                    print("Result: No match")
            
            # function call
            test_regex(test_data, pattern)
        '''
        tmpl = dedent(tmpl).strip()
        test_script = tmpl.format(
            module_docstring=self.module_docstring,
            test_data=test_data, pattern=pattern
        )
        return test_script

    def create(self):
        """return python test script"""
        tc_gen = self.tc_gen
        if self.tc_gen.is_line:
            if isinstance(tc_gen.test_data, (list, tuple)):
                test_data = enclose_string('\n'.join(tc_gen.test_data))
            else:
                test_data = enclose_string(tc_gen.test_data)

            if len(tc_gen.patterns) == 1:
                pattern = enclose_string(tc_gen.patterns[0])
                test_script = self.create_line_via_pattern_script(
                    test_data, pattern
                )
            else:
                test_script = self.create_line_via_patterns_script(
                    test_data, tc_gen.patterns
                )
        else:
            if isinstance(tc_gen.test_data, (list, tuple)):
                test_data = enclose_string(tc_gen.test_data[0])
            else:
                test_data = enclose_string(tc_gen.test_data)

            pattern = enclose_string(tc_gen.patterns[0])
            test_script = self.create_multiline_via_pattern_script(
                test_data, pattern
            )

        return test_script


class NonCommercialUseCls:
    def __init__(self, user_data, is_line=False, is_multi_test_data=False,
                 is_exact=False):
        self.user_data = str(user_data)
        self.is_line = is_line
        self.is_multi_test_data = is_multi_test_data
        self.is_exact = is_exact
        self.factory = None
        self.process()
        self.comment = (f"# Non-commercial use: generated by RegexApp v.{version} "
                        f"(geekstrident.com)\n"
                        f"# Created Date: {datetime.now():%Y-%m-%d %H:%M}\n"
                        "################################")

    def process(self):
        if not self.user_data.strip():
            raise NoUserDataError("Please provide valid user data.")
        self.factory = RegexBuilder(self.user_data, is_line=self.is_line,
                                    is_exact=self.is_exact)
        self.factory.build()

    def get_pattern_snippet(self):
        pattern = "pattern = r%s" % enclose_string(self.factory.patterns[0])
        snippet = f"{self.comment}\n{pattern}"
        return snippet

    def get_code_snippet(self):
        func = self.get_snippet_v2 if self.is_multi_test_data else self.get_snippet_v1
        code_snippet = func()
        return code_snippet

    def get_snippet_v1(self):
        pattern = "pattern = r%s" % enclose_string(self.factory.patterns[0])
        script = dedent(f"""
            import re

            def test_generated_pattern(test_data, pattern):
              match = re.search(pattern, test_data)
              if match:
                print(match)
                print(match.group())
                match.groupdict() and print(match.groupdict())
              else:
                print('??? Generated pattern NOT match any data ???')      
            
            {pattern}
            test_data = '''...'''   # replace actual data in ellipsis
            test_generated_pattern(test_data, pattern)
            ################################""").strip()
        code_snippet = f"{self.comment}\n{script}"
        return code_snippet

    def get_snippet_v2(self):
        pattern = "pattern = r%s" % enclose_string(self.factory.patterns[0])
        script = dedent(f"""
            import re

            def test_generated_pattern(test_data, pattern):
              split_pat = r'(?i)\\r?\\n? *<<separator>> *\\r?\\n?'
              if re.search(split_pat, test_data):
                blocks = re.split(split_pat, test_data)
              else:
                blocks = test_data.splitlines()
              for i, block in enumerate(blocks, 1):
                match = re.search(pattern, block)
                print('##### block #%s #####' % i)
                if match:
                  print('%s\\n%s' % (match, match.group()))
                  match.groupdict() and print(match.groupdict())
                else:
                  print('??? Generated pattern NOT match data in block #%s ???' % i)      
            
            {pattern}
            test_data = '''...'''   # replace actual data in ellipsis
            test_generated_pattern(test_data, pattern)
            ################################""").strip()
        code_snippet = f"{self.comment}\n{script}"
        return code_snippet

    def get_test_result(self, test_data):
        test_data = str(test_data)
        if not test_data:
            raise NoTestDataError("Please provide valid test data.")
        if self.is_multi_test_data:
            test_result = self.get_tresult_v2(test_data)
        else:
            test_result = self.get_tresult_v1(test_data)
        return test_result

    def get_tresult_v1(self, test_data):
        pattern = self.factory.patterns[0]
        match = re.search(pattern, test_data)
        if not match:
            return "??? Generated pattern NOT match any data ???"

        test_result = f"{match}\n{match.group()}"
        if match.groupdict():
            test_result = f"{test_result}\n{match.groupdict()}"
        return test_result

    def get_tresult_v2(self, test_data):
        pattern = self.factory.patterns[0]
        split_pat = r'(?i)\r?\n? *<<separator>> *\r?\n?'
        if re.search(split_pat, test_data):
            blocks = re.split(split_pat, test_data)
        else:
            blocks = test_data.splitlines()
        lst = list()
        for i, block in enumerate(blocks, 1):
            match = re.search(pattern, block)
            lst.append(f"##### block #{i} #####")
            if not match:
                lst.append(f"??? Generated pattern NOT match data in block #{i} ???")
                continue
            lst.append(f"{match}\n{match.group()}")
            match.groupdict() and lst.append(f"{match.groupdict()}")
        test_result = str.join("\n", lst)
        return test_result
