{"version":3,"file":"3431.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/dataconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/statedb.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/restorablepool.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/statedb/lib/interfaces.js"],"sourcesContent":["\"use strict\";\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module statedb\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./dataconnector\"), exports);\n__exportStar(require(\"./interfaces\"), exports);\n__exportStar(require(\"./restorablepool\"), exports);\n__exportStar(require(\"./statedb\"), exports);\n__exportStar(require(\"./tokens\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataConnector = void 0;\n/**\n * An abstract class that adheres to the data connector interface.\n *\n * @typeparam T - The basic entity response type a service's connector.\n *\n * @typeparam U - The basic entity request type, which is conventionally the\n * same as the response type but may be different if a service's implementation\n * requires input data to be different from output responses. Defaults to `T`.\n *\n * @typeparam V - The basic token applied to a request, conventionally a string\n * ID or filter, but may be set to a different type when an implementation\n * requires it. Defaults to `string`.\n *\n * @typeparam W - The type of the optional `query` parameter of the `list`\n * method. Defaults to `string`.\n *\n * #### Notes\n * The only abstract method in this class is the `fetch` method, which must be\n * reimplemented by all subclasses. The `remove` and `save` methods have a\n * default implementation that returns a promise that will always reject. This\n * class is a convenience superclass for connectors that only need to `fetch`.\n */\nclass DataConnector {\n    /**\n     * Retrieve the list of items available from the data connector.\n     *\n     * @param query - The optional query filter to apply to the connector request.\n     *\n     * @returns A promise that always rejects with an error.\n     *\n     * #### Notes\n     * Subclasses should reimplement if they support a back-end that can list.\n     */\n    async list(query) {\n        throw new Error('DataConnector#list method has not been implemented.');\n    }\n    /**\n     * Remove a value using the data connector.\n     *\n     * @param id - The identifier for the data being removed.\n     *\n     * @returns A promise that always rejects with an error.\n     *\n     * #### Notes\n     * Subclasses should reimplement if they support a back-end that can remove.\n     */\n    async remove(id) {\n        throw new Error('DataConnector#remove method has not been implemented.');\n    }\n    /**\n     * Save a value using the data connector.\n     *\n     * @param id - The identifier for the data being saved.\n     *\n     * @param value - The data being saved.\n     *\n     * @returns A promise that always rejects with an error.\n     *\n     * #### Notes\n     * Subclasses should reimplement if they support a back-end that can save.\n     */\n    async save(id, value) {\n        throw new Error('DataConnector#save method has not been implemented.');\n    }\n}\nexports.DataConnector = DataConnector;\n//# sourceMappingURL=dataconnector.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IStateDB = void 0;\nconst coreutils_1 = require(\"@lumino/coreutils\");\n/**\n * The default state database token.\n */\nexports.IStateDB = new coreutils_1.Token('@jupyterlab/coreutils:IStateDB', `A service for the JupyterLab state database.\n  Use this if you want to store data that will persist across page loads.\n  See \"state database\" for more information.`);\n//# sourceMappingURL=tokens.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StateDB = void 0;\nconst signaling_1 = require(\"@lumino/signaling\");\n/**\n * The default concrete implementation of a state database.\n */\nclass StateDB {\n    /**\n     * Create a new state database.\n     *\n     * @param options - The instantiation options for a state database.\n     */\n    constructor(options = {}) {\n        this._changed = new signaling_1.Signal(this);\n        const { connector, transform } = options;\n        this._connector = connector || new StateDB.Connector();\n        if (!transform) {\n            this._ready = Promise.resolve(undefined);\n        }\n        else {\n            this._ready = transform.then(transformation => {\n                const { contents, type } = transformation;\n                switch (type) {\n                    case 'cancel':\n                        return;\n                    case 'clear':\n                        return this._clear();\n                    case 'merge':\n                        return this._merge(contents || {});\n                    case 'overwrite':\n                        return this._overwrite(contents || {});\n                    default:\n                        return;\n                }\n            });\n        }\n    }\n    /**\n     * A signal that emits the change type any time a value changes.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Clear the entire database.\n     */\n    async clear() {\n        await this._ready;\n        await this._clear();\n    }\n    /**\n     * Retrieve a saved bundle from the database.\n     *\n     * @param id - The identifier used to retrieve a data bundle.\n     *\n     * @returns A promise that bears a data payload if available.\n     *\n     * #### Notes\n     * The `id` values of stored items in the state database are formatted:\n     * `'namespace:identifier'`, which is the same convention that command\n     * identifiers in JupyterLab use as well. While this is not a technical\n     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n     * using the `list(namespace: string)` method.\n     *\n     * The promise returned by this method may be rejected if an error occurs in\n     * retrieving the data. Non-existence of an `id` will succeed with the `value`\n     * `undefined`.\n     */\n    async fetch(id) {\n        await this._ready;\n        return this._fetch(id);\n    }\n    /**\n     * Retrieve all the saved bundles for a namespace.\n     *\n     * @param namespace The namespace prefix to retrieve.\n     *\n     * @returns A promise that bears a collection of payloads for a namespace.\n     *\n     * #### Notes\n     * Namespaces are entirely conventional entities. The `id` values of stored\n     * items in the state database are formatted: `'namespace:identifier'`, which\n     * is the same convention that command identifiers in JupyterLab use as well.\n     *\n     * If there are any errors in retrieving the data, they will be logged to the\n     * console in order to optimistically return any extant data without failing.\n     * This promise will always succeed.\n     */\n    async list(namespace) {\n        await this._ready;\n        return this._list(namespace);\n    }\n    /**\n     * Remove a value from the database.\n     *\n     * @param id - The identifier for the data being removed.\n     *\n     * @returns A promise that is rejected if remove fails and succeeds otherwise.\n     */\n    async remove(id) {\n        await this._ready;\n        await this._remove(id);\n        this._changed.emit({ id, type: 'remove' });\n    }\n    /**\n     * Save a value in the database.\n     *\n     * @param id - The identifier for the data being saved.\n     *\n     * @param value - The data being saved.\n     *\n     * @returns A promise that is rejected if saving fails and succeeds otherwise.\n     *\n     * #### Notes\n     * The `id` values of stored items in the state database are formatted:\n     * `'namespace:identifier'`, which is the same convention that command\n     * identifiers in JupyterLab use as well. While this is not a technical\n     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n     * using the `list(namespace: string)` method.\n     */\n    async save(id, value) {\n        await this._ready;\n        await this._save(id, value);\n        this._changed.emit({ id, type: 'save' });\n    }\n    /**\n     * Return a serialized copy of the state database's entire contents.\n     *\n     * @returns A promise that resolves with the database contents as JSON.\n     */\n    async toJSON() {\n        await this._ready;\n        const { ids, values } = await this._list();\n        return values.reduce((acc, val, idx) => {\n            acc[ids[idx]] = val;\n            return acc;\n        }, {});\n    }\n    /**\n     * Clear the entire database.\n     */\n    async _clear() {\n        await Promise.all((await this._list()).ids.map(id => this._remove(id)));\n    }\n    /**\n     * Fetch a value from the database.\n     */\n    async _fetch(id) {\n        const value = await this._connector.fetch(id);\n        if (value) {\n            return JSON.parse(value).v;\n        }\n    }\n    /**\n     * Fetch a list from the database.\n     */\n    async _list(namespace = '') {\n        const { ids, values } = await this._connector.list(namespace);\n        return {\n            ids,\n            values: values.map(val => JSON.parse(val).v)\n        };\n    }\n    /**\n     * Merge data into the state database.\n     */\n    async _merge(contents) {\n        await Promise.all(Object.keys(contents).map(key => contents[key] && this._save(key, contents[key])));\n    }\n    /**\n     * Overwrite the entire database with new contents.\n     */\n    async _overwrite(contents) {\n        await this._clear();\n        await this._merge(contents);\n    }\n    /**\n     * Remove a key in the database.\n     */\n    async _remove(id) {\n        return this._connector.remove(id);\n    }\n    /**\n     * Save a key and its value in the database.\n     */\n    async _save(id, value) {\n        return this._connector.save(id, JSON.stringify({ v: value }));\n    }\n}\nexports.StateDB = StateDB;\n/**\n * A namespace for StateDB statics.\n */\n(function (StateDB) {\n    /**\n     * An in-memory string key/value data connector.\n     */\n    class Connector {\n        constructor() {\n            this._storage = {};\n        }\n        /**\n         * Retrieve an item from the data connector.\n         */\n        async fetch(id) {\n            return this._storage[id];\n        }\n        /**\n         * Retrieve the list of items available from the data connector.\n         *\n         * @param namespace - If not empty, only keys whose first token before `:`\n         * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.\n         */\n        async list(namespace = '') {\n            return Object.keys(this._storage).reduce((acc, val) => {\n                if (namespace === '' ? true : namespace === val.split(':')[0]) {\n                    acc.ids.push(val);\n                    acc.values.push(this._storage[val]);\n                }\n                return acc;\n            }, { ids: [], values: [] });\n        }\n        /**\n         * Remove a value using the data connector.\n         */\n        async remove(id) {\n            delete this._storage[id];\n        }\n        /**\n         * Save a value using the data connector.\n         */\n        async save(id, value) {\n            this._storage[id] = value;\n        }\n    }\n    StateDB.Connector = Connector;\n})(StateDB || (exports.StateDB = StateDB = {}));\n//# sourceMappingURL=statedb.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RestorablePool = void 0;\nconst coreutils_1 = require(\"@lumino/coreutils\");\nconst properties_1 = require(\"@lumino/properties\");\nconst signaling_1 = require(\"@lumino/signaling\");\n/**\n * An object pool that supports restoration.\n *\n * @typeparam T - The type of object being tracked.\n */\nclass RestorablePool {\n    /**\n     * Create a new restorable pool.\n     *\n     * @param options - The instantiation options for a restorable pool.\n     */\n    constructor(options) {\n        this._added = new signaling_1.Signal(this);\n        this._current = null;\n        this._currentChanged = new signaling_1.Signal(this);\n        this._hasRestored = false;\n        this._isDisposed = false;\n        this._objects = new Set();\n        this._restore = null;\n        this._restored = new coreutils_1.PromiseDelegate();\n        this._updated = new signaling_1.Signal(this);\n        this.namespace = options.namespace;\n    }\n    /**\n     * A signal emitted when an object object is added.\n     *\n     * #### Notes\n     * This signal will only fire when an object is added to the pool.\n     * It will not fire if an object injected into the pool.\n     */\n    get added() {\n        return this._added;\n    }\n    /**\n     * The current object.\n     *\n     * #### Notes\n     * The restorable pool does not set `current`. It is intended for client use.\n     *\n     * If `current` is set to an object that does not exist in the pool, it is a\n     * no-op.\n     */\n    get current() {\n        return this._current;\n    }\n    set current(obj) {\n        if (this._current === obj) {\n            return;\n        }\n        if (obj !== null && this._objects.has(obj)) {\n            this._current = obj;\n            this._currentChanged.emit(this._current);\n        }\n    }\n    /**\n     * A signal emitted when the current widget changes.\n     */\n    get currentChanged() {\n        return this._currentChanged;\n    }\n    /**\n     * Test whether the pool is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A promise resolved when the restorable pool has been restored.\n     */\n    get restored() {\n        return this._restored.promise;\n    }\n    /**\n     * The number of objects held by the pool.\n     */\n    get size() {\n        return this._objects.size;\n    }\n    /**\n     * A signal emitted when an object is updated.\n     */\n    get updated() {\n        return this._updated;\n    }\n    /**\n     * Add a new object to the pool.\n     *\n     * @param obj - The object object being added.\n     *\n     * #### Notes\n     * The object passed into the pool is added synchronously; its existence in\n     * the pool can be checked with the `has()` method. The promise this method\n     * returns resolves after the object has been added and saved to an underlying\n     * restoration connector, if one is available.\n     */\n    async add(obj) {\n        var _a, _b;\n        if (obj.isDisposed) {\n            const warning = 'A disposed object cannot be added.';\n            console.warn(warning, obj);\n            throw new Error(warning);\n        }\n        if (this._objects.has(obj)) {\n            const warning = 'This object already exists in the pool.';\n            console.warn(warning, obj);\n            throw new Error(warning);\n        }\n        this._objects.add(obj);\n        obj.disposed.connect(this._onInstanceDisposed, this);\n        if (Private.injectedProperty.get(obj)) {\n            return;\n        }\n        if (this._restore) {\n            const { connector } = this._restore;\n            const objName = this._restore.name(obj);\n            if (objName) {\n                const name = `${this.namespace}:${objName}`;\n                const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);\n                Private.nameProperty.set(obj, name);\n                await connector.save(name, { data });\n            }\n        }\n        // Emit the added signal.\n        this._added.emit(obj);\n    }\n    /**\n     * Dispose of the resources held by the pool.\n     *\n     * #### Notes\n     * Disposing a pool does not affect the underlying data in the data connector,\n     * it simply disposes the client-side pool without making any connector calls.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._current = null;\n        this._isDisposed = true;\n        this._objects.clear();\n        signaling_1.Signal.clearData(this);\n    }\n    /**\n     * Find the first object in the pool that satisfies a filter function.\n     *\n     * @param fn The filter function to call on each object.\n     */\n    find(fn) {\n        const values = this._objects.values();\n        for (const value of values) {\n            if (fn(value)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Iterate through each object in the pool.\n     *\n     * @param fn - The function to call on each object.\n     */\n    forEach(fn) {\n        this._objects.forEach(fn);\n    }\n    /**\n     * Filter the objects in the pool based on a predicate.\n     *\n     * @param fn - The function by which to filter.\n     */\n    filter(fn) {\n        const filtered = [];\n        this.forEach(obj => {\n            if (fn(obj)) {\n                filtered.push(obj);\n            }\n        });\n        return filtered;\n    }\n    /**\n     * Inject an object into the restorable pool without the pool handling its\n     * restoration lifecycle.\n     *\n     * @param obj - The object to inject into the pool.\n     */\n    inject(obj) {\n        Private.injectedProperty.set(obj, true);\n        return this.add(obj);\n    }\n    /**\n     * Check if this pool has the specified object.\n     *\n     * @param obj - The object whose existence is being checked.\n     */\n    has(obj) {\n        return this._objects.has(obj);\n    }\n    /**\n     * Restore the objects in this pool's namespace.\n     *\n     * @param options - The configuration options that describe restoration.\n     *\n     * @returns A promise that resolves when restoration has completed.\n     *\n     * #### Notes\n     * This function should almost never be invoked by client code. Its primary\n     * use case is to be invoked by a layout restorer plugin that handles\n     * multiple restorable pools and, when ready, asks them each to restore their\n     * respective objects.\n     */\n    async restore(options) {\n        if (this._hasRestored) {\n            throw new Error('This pool has already been restored.');\n        }\n        this._hasRestored = true;\n        const { command, connector, registry, when } = options;\n        const namespace = this.namespace;\n        const promises = when\n            ? [connector.list(namespace)].concat(when)\n            : [connector.list(namespace)];\n        this._restore = options;\n        const [saved] = await Promise.all(promises);\n        const values = await Promise.all(saved.ids.map(async (id, index) => {\n            const value = saved.values[index];\n            const args = value && value.data;\n            if (args === undefined) {\n                return connector.remove(id);\n            }\n            // Execute the command and if it fails, delete the state restore data.\n            return registry\n                .execute(command, args)\n                .catch(() => connector.remove(id));\n        }));\n        this._restored.resolve();\n        return values;\n    }\n    /**\n     * Save the restore data for a given object.\n     *\n     * @param obj - The object being saved.\n     */\n    async save(obj) {\n        var _a, _b;\n        const injected = Private.injectedProperty.get(obj);\n        if (!this._restore || !this.has(obj) || injected) {\n            return;\n        }\n        const { connector } = this._restore;\n        const objName = this._restore.name(obj);\n        const oldName = Private.nameProperty.get(obj);\n        const newName = objName ? `${this.namespace}:${objName}` : '';\n        if (oldName && oldName !== newName) {\n            await connector.remove(oldName);\n        }\n        // Set the name property irrespective of whether the new name is null.\n        Private.nameProperty.set(obj, newName);\n        if (newName) {\n            const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);\n            await connector.save(newName, { data });\n        }\n        if (oldName !== newName) {\n            this._updated.emit(obj);\n        }\n    }\n    /**\n     * Clean up after disposed objects.\n     */\n    _onInstanceDisposed(obj) {\n        this._objects.delete(obj);\n        if (obj === this._current) {\n            this._current = null;\n            this._currentChanged.emit(this._current);\n        }\n        if (Private.injectedProperty.get(obj)) {\n            return;\n        }\n        if (!this._restore) {\n            return;\n        }\n        const { connector } = this._restore;\n        const name = Private.nameProperty.get(obj);\n        if (name) {\n            void connector.remove(name);\n        }\n    }\n}\nexports.RestorablePool = RestorablePool;\n/*\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property to indicate whether an object has been injected.\n     */\n    Private.injectedProperty = new properties_1.AttachedProperty({\n        name: 'injected',\n        create: () => false\n    });\n    /**\n     * An attached property for an object's ID.\n     */\n    Private.nameProperty = new properties_1.AttachedProperty({\n        name: 'name',\n        create: () => ''\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=restorablepool.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=interfaces.js.map"],"names":["__createBinding","this","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__exportStar","exports","p","prototype","hasOwnProperty","call","value","DataConnector","list","query","Error","remove","id","save","IStateDB","coreutils_1","Token","StateDB","signaling_1","constructor","options","_changed","Signal","connector","transform","_connector","Connector","_ready","then","transformation","contents","type","_clear","_merge","_overwrite","Promise","resolve","changed","clear","fetch","_fetch","namespace","_list","_remove","emit","_save","toJSON","ids","values","reduce","acc","val","idx","all","map","JSON","parse","v","keys","key","stringify","_storage","split","push","RestorablePool","properties_1","Private","_added","_current","_currentChanged","_hasRestored","_isDisposed","_objects","Set","_restore","_restored","PromiseDelegate","_updated","added","current","obj","has","currentChanged","isDisposed","restored","promise","size","updated","add","_a","_b","warning","console","warn","disposed","connect","_onInstanceDisposed","injectedProperty","objName","name","data","args","nameProperty","set","dispose","clearData","find","fn","forEach","filter","filtered","inject","restore","command","registry","when","promises","concat","saved","async","index","execute","catch","injected","oldName","newName","delete","AttachedProperty"],"ignoreList":[],"sourceRoot":""}