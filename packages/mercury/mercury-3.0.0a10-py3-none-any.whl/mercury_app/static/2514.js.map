{"version":3,"file":"2514.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/application/lib/layoutrestorer.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/application/lib/mimerenderers.js"],"sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { JSONExt, PromiseDelegate, Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\n/**\n * The layout restorer token.\n */\nexport const ILayoutRestorer = new Token('@jupyterlab/application:ILayoutRestorer', 'A service providing application layout restoration functionality. Use this to have your activities restored across page loads.');\n/**\n * The data connector key for restorer data.\n */\nconst KEY = 'layout-restorer:data';\n/**\n * The default implementation of a layout restorer.\n *\n * #### Notes\n * The lifecycle for state restoration is subtle. The sequence of events is:\n *\n * 1. The layout restorer plugin is instantiated and makes a `fetch` call to\n *    the data connector that stores the layout restoration data. The `fetch`\n *    call returns a promise that resolves in step 6, below.\n *\n * 2. Other plugins that care about state restoration require the layout\n *    restorer as a dependency.\n *\n * 3. As each load-time plugin initializes (which happens before the front-end\n *    application has `started`), it instructs the layout restorer whether\n *    the restorer ought to `restore` its widgets by passing in its widget\n *    tracker.\n *    Alternatively, a plugin that does not require its own widget tracker\n *    (because perhaps it only creates a single widget, like a command palette),\n *    can simply `add` its widget along with a persistent unique name to the\n *    layout restorer so that its layout state can be restored when the lab\n *    application restores.\n *\n * 4. After all the load-time plugins have finished initializing, the front-end\n *    application `started` promise will resolve. This is the `first`\n *    promise that the layout restorer waits for. By this point, all of the\n *    plugins that care about restoration will have instructed the layout\n *    restorer to `restore` their widget trackers.\n *\n * 5. The layout restorer will then instruct each plugin's widget tracker\n *    to restore its state and reinstantiate whichever widgets it wants. The\n *    tracker returns a promise to the layout restorer that resolves when it\n *    has completed restoring the tracked widgets it cares about.\n *\n * 6. As each widget tracker finishes restoring the widget instances it cares\n *    about, it resolves the promise that was returned to the layout restorer\n *    (in step 5). After all of the promises that the restorer is awaiting have\n *    settled, the restorer then resolves the outstanding `fetch` promise\n *    (from step 1) and hands off a layout state object to the application\n *    shell's `restoreLayout` method for restoration.\n *\n * 7. Once the application shell has finished restoring the layout, the\n *    JupyterLab application's `restored` promise is resolved.\n *\n * Of particular note are steps 5 and 6: since data restoration of plugins\n * is accomplished by executing commands, the command that is used to restore\n * the data of each plugin must return a promise that only resolves when the\n * widget has been created and added to the plugin's widget tracker.\n */\nexport class LayoutRestorer {\n    /**\n     * Create a layout restorer.\n     */\n    constructor(options) {\n        this._deferred = new Array();\n        this._deferredMainArea = null;\n        this._firstDone = false;\n        this._promisesDone = false;\n        this._promises = [];\n        this._restored = new PromiseDelegate();\n        this._trackers = new Set();\n        this._widgets = new Map();\n        this._mode = 'multiple-document';\n        this._connector = options.connector;\n        this._first = options.first;\n        this._registry = options.registry;\n        if (options.mode) {\n            this._mode = options.mode;\n        }\n        void this._first\n            .then(() => {\n            this._firstDone = true;\n        })\n            .then(() => Promise.all(this._promises))\n            .then(() => {\n            this._promisesDone = true;\n            // Release the tracker set.\n            this._trackers.clear();\n        })\n            .then(() => {\n            this._restored.resolve(void 0);\n        });\n    }\n    /**\n     * Whether full layout restoration is deferred and is currently incomplete.\n     *\n     * #### Notes\n     * This flag is useful for tracking when the application has started in\n     * 'single-document' mode and the main area has not yet been restored.\n     */\n    get isDeferred() {\n        return this._deferred.length > 0;\n    }\n    /**\n     * A promise resolved when the layout restorer is ready to receive signals.\n     */\n    get restored() {\n        return this._restored.promise;\n    }\n    /**\n     * Add a widget to be tracked by the layout restorer.\n     */\n    add(widget, name) {\n        Private.nameProperty.set(widget, name);\n        this._widgets.set(name, widget);\n        widget.disposed.connect(this._onWidgetDisposed, this);\n    }\n    /**\n     * Fetch the layout state for the application.\n     *\n     * #### Notes\n     * Fetching the layout relies on all widget restoration to be complete, so\n     * calls to `fetch` are guaranteed to return after restoration is complete.\n     */\n    async fetch() {\n        var _a;\n        const blank = {\n            fresh: true,\n            mainArea: null,\n            downArea: null,\n            leftArea: null,\n            rightArea: null,\n            topArea: null,\n            relativeSizes: null\n        };\n        const layout = this._connector.fetch(KEY);\n        try {\n            const [data] = await Promise.all([layout, this.restored]);\n            if (!data) {\n                return blank;\n            }\n            const { main, down, left, right, relativeSizes, top } = data;\n            // If any data exists, then this is not a fresh session.\n            const fresh = false;\n            // Rehydrate main area.\n            let mainArea = null;\n            if (this._mode === 'multiple-document') {\n                mainArea = this._rehydrateMainArea(main);\n            }\n            else {\n                this._deferredMainArea = main;\n            }\n            // Rehydrate down area.\n            const downArea = this._rehydrateDownArea(down);\n            // Rehydrate left area.\n            const leftArea = this._rehydrateSideArea(left);\n            // Rehydrate right area.\n            const rightArea = this._rehydrateSideArea(right);\n            return {\n                fresh,\n                mainArea,\n                downArea,\n                leftArea,\n                rightArea,\n                relativeSizes: relativeSizes || null,\n                topArea: (_a = top) !== null && _a !== void 0 ? _a : null\n            };\n        }\n        catch (error) {\n            return blank;\n        }\n    }\n    /**\n     * Restore the widgets of a particular widget tracker.\n     *\n     * @param tracker - The widget tracker whose widgets will be restored.\n     *\n     * @param options - The restoration options.\n     */\n    async restore(tracker, options) {\n        if (this._firstDone) {\n            throw new Error('restore() must be called before `first` has resolved.');\n        }\n        const { namespace } = tracker;\n        if (this._trackers.has(namespace)) {\n            throw new Error(`The tracker \"${namespace}\" is already restored.`);\n        }\n        const { args, command, name, when } = options;\n        // Add the tracker to the private trackers collection.\n        this._trackers.add(namespace);\n        // Whenever a new widget is added to the tracker, record its name.\n        tracker.widgetAdded.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                this.add(widget, `${namespace}:${widgetName}`);\n            }\n        }, this);\n        // Whenever a widget is updated, get its new name.\n        tracker.widgetUpdated.connect((_, widget) => {\n            const widgetName = name(widget);\n            if (widgetName) {\n                const name = `${namespace}:${widgetName}`;\n                Private.nameProperty.set(widget, name);\n                this._widgets.set(name, widget);\n            }\n        });\n        const first = this._first;\n        if (this._mode == 'multiple-document') {\n            const promise = tracker\n                .restore({\n                args: args || (() => JSONExt.emptyObject),\n                command,\n                connector: this._connector,\n                name,\n                registry: this._registry,\n                when: when ? [first].concat(when) : first\n            })\n                .catch(error => {\n                console.error(error);\n            });\n            this._promises.push(promise);\n            return promise;\n        }\n        tracker.defer({\n            args: args || (() => JSONExt.emptyObject),\n            command,\n            connector: this._connector,\n            name,\n            registry: this._registry,\n            when: when ? [first].concat(when) : first\n        });\n        this._deferred.push(tracker);\n    }\n    /**\n     * Restore the application layout if its restoration has been deferred.\n     *\n     * @returns - the rehydrated main area.\n     */\n    async restoreDeferred() {\n        if (!this.isDeferred) {\n            return null;\n        }\n        // Empty the deferred list and wait for all trackers to restore.\n        const wait = Promise.resolve();\n        const promises = this._deferred.map(t => wait.then(() => t.restore()));\n        this._deferred.length = 0;\n        await Promise.all(promises);\n        // Rehydrate the main area layout.\n        return this._rehydrateMainArea(this._deferredMainArea);\n    }\n    /**\n     * Save the layout state for the application.\n     */\n    save(layout) {\n        var _a;\n        // If there are promises that are unresolved, bail.\n        if (!this._promisesDone) {\n            const warning = 'save() was called prematurely.';\n            console.warn(warning);\n            return Promise.reject(warning);\n        }\n        const dehydrated = {};\n        // Save the cached main area layout if restoration is deferred.\n        dehydrated.main = this.isDeferred\n            ? this._deferredMainArea\n            : this._dehydrateMainArea(layout.mainArea);\n        // Update only the current widget in the db when restoration is deferred.\n        // Useful for providing the tab title in doc mode.\n        if (this.isDeferred) {\n            const currentWidget = (_a = layout.mainArea) === null || _a === void 0 ? void 0 : _a.currentWidget;\n            if (currentWidget) {\n                const widgetName = Private.nameProperty.get(currentWidget);\n                dehydrated.main = {\n                    ...dehydrated.main,\n                    current: widgetName || undefined\n                };\n            }\n        }\n        dehydrated.down = this._dehydrateDownArea(layout.downArea);\n        dehydrated.left = this._dehydrateSideArea(layout.leftArea);\n        dehydrated.right = this._dehydrateSideArea(layout.rightArea);\n        dehydrated.relativeSizes = layout.relativeSizes;\n        dehydrated.top = { ...layout.topArea };\n        return this._connector.save(KEY, dehydrated);\n    }\n    /**\n     * Dehydrate a main area description into a serializable object.\n     */\n    _dehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.serializeMain(area);\n    }\n    /**\n     * Rehydrate a serialized main area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateMainArea(area) {\n        if (!area) {\n            return null;\n        }\n        return Private.deserializeMain(area, this._widgets);\n    }\n    /**\n     * Dehydrate a down area description into a serializable object.\n     */\n    _dehydrateDownArea(area) {\n        if (!area) {\n            return null;\n        }\n        const dehydrated = {\n            size: area.size\n        };\n        if (area.currentWidget) {\n            const current = Private.nameProperty.get(area.currentWidget);\n            if (current) {\n                dehydrated.current = current;\n            }\n        }\n        if (area.widgets) {\n            dehydrated.widgets = area.widgets\n                .map(widget => Private.nameProperty.get(widget))\n                .filter(name => !!name);\n        }\n        return dehydrated;\n    }\n    /**\n     * Rehydrate a serialized side area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateDownArea(area) {\n        var _a;\n        if (!area) {\n            return { currentWidget: null, size: 0.0, widgets: null };\n        }\n        const internal = this._widgets;\n        const currentWidget = area.current && internal.has(`${area.current}`)\n            ? internal.get(`${area.current}`)\n            : null;\n        const widgets = !Array.isArray(area.widgets)\n            ? null\n            : area.widgets\n                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)\n                .filter(widget => !!widget);\n        return {\n            currentWidget: currentWidget,\n            size: (_a = area.size) !== null && _a !== void 0 ? _a : 0.0,\n            widgets: widgets\n        };\n    }\n    /**\n     * Dehydrate a side area description into a serializable object.\n     */\n    _dehydrateSideArea(area) {\n        if (!area) {\n            return null;\n        }\n        const dehydrated = {\n            collapsed: area.collapsed,\n            visible: area.visible\n        };\n        if (area.currentWidget) {\n            const current = Private.nameProperty.get(area.currentWidget);\n            if (current) {\n                dehydrated.current = current;\n            }\n        }\n        if (area.widgets) {\n            dehydrated.widgets = area.widgets\n                .map(widget => Private.nameProperty.get(widget))\n                .filter(name => !!name);\n        }\n        if (area.widgetStates) {\n            dehydrated.widgetStates = area.widgetStates;\n        }\n        return dehydrated;\n    }\n    /**\n     * Rehydrate a serialized side area description object.\n     *\n     * #### Notes\n     * This function consumes data that can become corrupted, so it uses type\n     * coercion to guarantee the dehydrated object is safely processed.\n     */\n    _rehydrateSideArea(area) {\n        var _a, _b;\n        if (!area) {\n            return {\n                collapsed: true,\n                currentWidget: null,\n                visible: true,\n                widgets: null,\n                widgetStates: {\n                    ['null']: {\n                        sizes: null,\n                        expansionStates: null\n                    }\n                }\n            };\n        }\n        const internal = this._widgets;\n        const collapsed = (_a = area.collapsed) !== null && _a !== void 0 ? _a : false;\n        const currentWidget = area.current && internal.has(`${area.current}`)\n            ? internal.get(`${area.current}`)\n            : null;\n        const widgets = !Array.isArray(area.widgets)\n            ? null\n            : area.widgets\n                .map(name => internal.has(`${name}`) ? internal.get(`${name}`) : null)\n                .filter(widget => !!widget);\n        const widgetStates = area.widgetStates;\n        return {\n            collapsed,\n            currentWidget: currentWidget,\n            widgets: widgets,\n            visible: (_b = area.visible) !== null && _b !== void 0 ? _b : true,\n            widgetStates: widgetStates\n        };\n    }\n    /**\n     * Handle a widget disposal.\n     */\n    _onWidgetDisposed(widget) {\n        const name = Private.nameProperty.get(widget);\n        this._widgets.delete(name);\n    }\n}\n/*\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for a widget's ID in the serialized restore data.\n     */\n    Private.nameProperty = new AttachedProperty({\n        name: 'name',\n        create: owner => ''\n    });\n    /**\n     * Serialize individual areas within the main area.\n     */\n    function serializeArea(area) {\n        if (!area || !area.type) {\n            return null;\n        }\n        if (area.type === 'tab-area') {\n            return {\n                type: 'tab-area',\n                currentIndex: area.currentIndex,\n                widgets: area.widgets\n                    .map(widget => Private.nameProperty.get(widget))\n                    .filter(name => !!name)\n            };\n        }\n        return {\n            type: 'split-area',\n            orientation: area.orientation,\n            sizes: area.sizes,\n            children: area.children\n                .map(serializeArea)\n                .filter(area => !!area)\n        };\n    }\n    /**\n     * Return a dehydrated, serializable version of the main dock panel.\n     */\n    function serializeMain(area) {\n        const dehydrated = {\n            dock: (area && area.dock && serializeArea(area.dock.main)) || null\n        };\n        if (area) {\n            if (area.currentWidget) {\n                const current = Private.nameProperty.get(area.currentWidget);\n                if (current) {\n                    dehydrated.current = current;\n                }\n            }\n        }\n        return dehydrated;\n    }\n    Private.serializeMain = serializeMain;\n    /**\n     * Deserialize individual areas within the main area.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is:\n     * `ITabArea | ISplitArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeArea(area, names) {\n        if (!area) {\n            return null;\n        }\n        // Because this data is saved to a foreign data source, its type safety is\n        // not guaranteed when it is retrieved, so exhaustive checks are necessary.\n        const type = area.type || 'unknown';\n        if (type === 'unknown' || (type !== 'tab-area' && type !== 'split-area')) {\n            console.warn(`Attempted to deserialize unknown type: ${type}`);\n            return null;\n        }\n        if (type === 'tab-area') {\n            const { currentIndex, widgets } = area;\n            const hydrated = {\n                type: 'tab-area',\n                currentIndex: currentIndex || 0,\n                widgets: (widgets &&\n                    widgets\n                        .map(widget => names.get(widget))\n                        .filter(widget => !!widget)) ||\n                    []\n            };\n            // Make sure the current index is within bounds.\n            if (hydrated.currentIndex > hydrated.widgets.length - 1) {\n                hydrated.currentIndex = 0;\n            }\n            return hydrated;\n        }\n        const { orientation, sizes, children } = area;\n        const hydrated = {\n            type: 'split-area',\n            orientation: orientation,\n            sizes: sizes || [],\n            children: (children &&\n                children\n                    .map(child => deserializeArea(child, names))\n                    .filter(widget => !!widget)) ||\n                []\n        };\n        return hydrated;\n    }\n    /**\n     * Return the hydrated version of the main dock panel, ready to restore.\n     *\n     * #### Notes\n     * Because this data comes from a potentially unreliable foreign source, it is\n     * typed as a `JSONObject`; but the actual expected type is: `IMainArea`.\n     *\n     * For fault tolerance, types are manually checked in deserialization.\n     */\n    function deserializeMain(area, names) {\n        if (!area) {\n            return null;\n        }\n        const name = area.current || null;\n        const dock = area.dock || null;\n        return {\n            currentWidget: (name && names.has(name) && names.get(name)) || null,\n            dock: dock ? { main: deserializeArea(dock, names) } : null\n        };\n    }\n    Private.deserializeMain = deserializeMain;\n})(Private || (Private = {}));\n//# sourceMappingURL=layoutrestorer.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { MimeDocumentFactory } from '@jupyterlab/docregistry';\nimport { IRenderMimeRegistry } from '@jupyterlab/rendermime';\nimport { ITranslator } from '@jupyterlab/translation';\nimport { LabIcon } from '@jupyterlab/ui-components';\nimport { Token } from '@lumino/coreutils';\nimport { AttachedProperty } from '@lumino/properties';\nimport { ILayoutRestorer } from './layoutrestorer';\n/**\n * The mime document tracker token.\n */\nexport const IMimeDocumentTracker = new Token('@jupyterlab/application:IMimeDocumentTracker', 'A widget tracker for documents rendered using a mime renderer extension. Use this if you want to list and interact with documents rendered by such extensions.');\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugins(extensions) {\n    const plugins = [];\n    const namespace = 'application-mimedocuments';\n    const tracker = new WidgetTracker({ namespace });\n    extensions.forEach(mod => {\n        let data = mod.default;\n        // Handle CommonJS exports.\n        if (!mod.hasOwnProperty('__esModule')) {\n            data = mod;\n        }\n        if (!Array.isArray(data)) {\n            data = [data];\n        }\n        data.forEach(item => {\n            plugins.push(createRendermimePlugin(tracker, item));\n        });\n    });\n    // Also add a meta-plugin handling state restoration\n    // and exposing the mime document widget tracker.\n    plugins.push({\n        id: '@jupyterlab/application-extension:mimedocument',\n        description: 'Provides a mime document widget tracker.',\n        optional: [ILayoutRestorer],\n        provides: IMimeDocumentTracker,\n        autoStart: true,\n        activate: (app, restorer) => {\n            if (restorer) {\n                void restorer.restore(tracker, {\n                    command: 'docmanager:open',\n                    args: widget => ({\n                        path: widget.context.path,\n                        factory: Private.factoryNameProperty.get(widget)\n                    }),\n                    name: widget => `${widget.context.path}:${Private.factoryNameProperty.get(widget)}`\n                });\n            }\n            return tracker;\n        }\n    });\n    return plugins;\n}\n/**\n * Create rendermime plugins for rendermime extension modules.\n */\nexport function createRendermimePlugin(tracker, item) {\n    return {\n        id: item.id,\n        description: item.description,\n        requires: [IRenderMimeRegistry, ITranslator],\n        autoStart: true,\n        activate: (app, rendermime, translator) => {\n            // Add the mime renderer.\n            if (item.rank !== undefined) {\n                rendermime.addFactory(item.rendererFactory, item.rank);\n            }\n            else {\n                rendermime.addFactory(item.rendererFactory);\n            }\n            // Handle the widget factory.\n            if (!item.documentWidgetFactoryOptions) {\n                return;\n            }\n            const registry = app.docRegistry;\n            let options = [];\n            if (Array.isArray(item.documentWidgetFactoryOptions)) {\n                options = item.documentWidgetFactoryOptions;\n            }\n            else {\n                options = [\n                    item.documentWidgetFactoryOptions\n                ];\n            }\n            if (item.fileTypes) {\n                item.fileTypes.forEach(ft => {\n                    if (ft.icon) {\n                        // upconvert the contents of the icon field to a proper LabIcon\n                        ft = { ...ft, icon: LabIcon.resolve({ icon: ft.icon }) };\n                    }\n                    app.docRegistry.addFileType(ft);\n                });\n            }\n            options.forEach(option => {\n                const toolbarFactory = option.toolbarFactory\n                    ? (w) => option.toolbarFactory(w.content.renderer)\n                    : undefined;\n                const factory = new MimeDocumentFactory({\n                    renderTimeout: item.renderTimeout,\n                    dataType: item.dataType,\n                    rendermime,\n                    modelName: option.modelName,\n                    name: option.name,\n                    primaryFileType: registry.getFileType(option.primaryFileType),\n                    fileTypes: option.fileTypes,\n                    defaultFor: option.defaultFor,\n                    defaultRendered: option.defaultRendered,\n                    toolbarFactory,\n                    translator,\n                    factory: item.rendererFactory\n                });\n                registry.addWidgetFactory(factory);\n                factory.widgetCreated.connect((sender, widget) => {\n                    Private.factoryNameProperty.set(widget, factory.name);\n                    // Notify the widget tracker if restore data needs to update.\n                    widget.context.pathChanged.connect(() => {\n                        void tracker.save(widget);\n                    });\n                    void tracker.add(widget);\n                });\n            });\n        }\n    };\n}\n/**\n * Private namespace for the module.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for keeping the factory name\n     * that was used to create a mimedocument.\n     */\n    Private.factoryNameProperty = new AttachedProperty({\n        name: 'factoryName',\n        create: () => undefined\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=mimerenderers.js.map"],"names":["ILayoutRestorer","Token","KEY","LayoutRestorer","constructor","options","this","_deferred","Array","_deferredMainArea","_firstDone","_promisesDone","_promises","_restored","PromiseDelegate","_trackers","Set","_widgets","Map","_mode","_connector","connector","_first","first","_registry","registry","mode","then","Promise","all","clear","resolve","isDeferred","length","restored","promise","add","widget","name","Private","nameProperty","set","disposed","connect","_onWidgetDisposed","fetch","_a","blank","fresh","mainArea","downArea","leftArea","rightArea","topArea","relativeSizes","layout","data","main","down","left","right","top","_rehydrateMainArea","_rehydrateDownArea","_rehydrateSideArea","error","restore","tracker","Error","namespace","has","args","command","when","widgetAdded","_","widgetName","widgetUpdated","JSONExt","emptyObject","concat","catch","console","push","defer","restoreDeferred","wait","promises","map","t","save","warning","warn","reject","dehydrated","_dehydrateMainArea","currentWidget","get","current","undefined","_dehydrateDownArea","_dehydrateSideArea","area","serializeMain","deserializeMain","size","widgets","filter","internal","isArray","collapsed","visible","widgetStates","_b","sizes","expansionStates","delete","serializeArea","type","currentIndex","orientation","children","deserializeArea","names","hydrated","child","AttachedProperty","create","owner","dock","IMimeDocumentTracker","createRendermimePlugins","extensions","plugins","WidgetTracker","forEach","mod","default","hasOwnProperty","item","createRendermimePlugin","id","description","optional","provides","autoStart","activate","app","restorer","path","context","factory","factoryNameProperty","requires","IRenderMimeRegistry","ITranslator","rendermime","translator","rank","addFactory","rendererFactory","documentWidgetFactoryOptions","docRegistry","fileTypes","ft","icon","LabIcon","addFileType","option","toolbarFactory","w","content","renderer","MimeDocumentFactory","renderTimeout","dataType","modelName","primaryFileType","getFileType","defaultFor","defaultRendered","addWidgetFactory","widgetCreated","sender","pathChanged"],"ignoreList":[],"sourceRoot":""}