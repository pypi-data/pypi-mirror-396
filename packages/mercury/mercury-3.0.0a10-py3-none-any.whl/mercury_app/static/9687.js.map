{"version":3,"file":"9687.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/messaging/dist/index.es6.js"],"sourcesContent":["import { every, retro, some, ArrayExt } from '@lumino/algorithm';\nimport { LinkedList } from '@lumino/collections';\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module messaging\n */\n/**\n * A message which can be delivered to a message handler.\n *\n * #### Notes\n * This class may be subclassed to create complex message types.\n */\nclass Message {\n    /**\n     * Construct a new message.\n     *\n     * @param type - The type of the message.\n     */\n    constructor(type) {\n        this.type = type;\n    }\n    /**\n     * Test whether the message is conflatable.\n     *\n     * #### Notes\n     * Message conflation is an advanced topic. Most message types will\n     * not make use of this feature.\n     *\n     * If a conflatable message is posted to a handler while another\n     * conflatable message of the same `type` has already been posted\n     * to the handler, the `conflate()` method of the existing message\n     * will be invoked. If that method returns `true`, the new message\n     * will not be enqueued. This allows messages to be compressed, so\n     * that only a single instance of the message type is processed per\n     * cycle, no matter how many times messages of that type are posted.\n     *\n     * Custom message types may reimplement this property.\n     *\n     * The default implementation is always `false`.\n     */\n    get isConflatable() {\n        return false;\n    }\n    /**\n     * Conflate this message with another message of the same `type`.\n     *\n     * @param other - A conflatable message of the same `type`.\n     *\n     * @returns `true` if the message was successfully conflated, or\n     *   `false` otherwise.\n     *\n     * #### Notes\n     * Message conflation is an advanced topic. Most message types will\n     * not make use of this feature.\n     *\n     * This method is called automatically by the message loop when the\n     * given message is posted to the handler paired with this message.\n     * This message will already be enqueued and conflatable, and the\n     * given message will have the same `type` and also be conflatable.\n     *\n     * This method should merge the state of the other message into this\n     * message as needed so that when this message is finally delivered\n     * to the handler, it receives the most up-to-date information.\n     *\n     * If this method returns `true`, it signals that the other message\n     * was successfully conflated and that message will not be enqueued.\n     *\n     * If this method returns `false`, the other message will be enqueued\n     * for normal delivery.\n     *\n     * Custom message types may reimplement this method.\n     *\n     * The default implementation always returns `false`.\n     */\n    conflate(other) {\n        return false;\n    }\n}\n/**\n * A convenience message class which conflates automatically.\n *\n * #### Notes\n * Message conflation is an advanced topic. Most user code will not\n * make use of this class.\n *\n * This message class is useful for creating message instances which\n * should be conflated, but which have no state other than `type`.\n *\n * If conflation of stateful messages is required, a custom `Message`\n * subclass should be created.\n */\nclass ConflatableMessage extends Message {\n    /**\n     * Test whether the message is conflatable.\n     *\n     * #### Notes\n     * This property is always `true`.\n     */\n    get isConflatable() {\n        return true;\n    }\n    /**\n     * Conflate this message with another message of the same `type`.\n     *\n     * #### Notes\n     * This method always returns `true`.\n     */\n    conflate(other) {\n        return true;\n    }\n}\n/**\n * The namespace for the global singleton message loop.\n */\nvar MessageLoop;\n(function (MessageLoop) {\n    /**\n     * A function that cancels the pending loop task; `null` if unavailable.\n     */\n    let pending = null;\n    /**\n     * Schedules a function for invocation as soon as possible asynchronously.\n     *\n     * @param fn The function to invoke when called back.\n     *\n     * @returns An anonymous function that will unschedule invocation if possible.\n     */\n    const schedule = (resolved => (fn) => {\n        let rejected = false;\n        resolved.then(() => !rejected && fn());\n        return () => {\n            rejected = true;\n        };\n    })(Promise.resolve());\n    /**\n     * Send a message to a message handler to process immediately.\n     *\n     * @param handler - The handler which should process the message.\n     *\n     * @param msg - The message to deliver to the handler.\n     *\n     * #### Notes\n     * The message will first be sent through any installed message hooks\n     * for the handler. If the message passes all hooks, it will then be\n     * delivered to the `processMessage` method of the handler.\n     *\n     * The message will not be conflated with pending posted messages.\n     *\n     * Exceptions in hooks and handlers will be caught and logged.\n     */\n    function sendMessage(handler, msg) {\n        // Lookup the message hooks for the handler.\n        let hooks = messageHooks.get(handler);\n        // Handle the common case of no installed hooks.\n        if (!hooks || hooks.length === 0) {\n            invokeHandler(handler, msg);\n            return;\n        }\n        // Invoke the message hooks starting with the newest first.\n        let passed = every(retro(hooks), hook => {\n            return hook ? invokeHook(hook, handler, msg) : true;\n        });\n        // Invoke the handler if the message passes all hooks.\n        if (passed) {\n            invokeHandler(handler, msg);\n        }\n    }\n    MessageLoop.sendMessage = sendMessage;\n    /**\n     * Post a message to a message handler to process in the future.\n     *\n     * @param handler - The handler which should process the message.\n     *\n     * @param msg - The message to post to the handler.\n     *\n     * #### Notes\n     * The message will be conflated with the pending posted messages for\n     * the handler, if possible. If the message is not conflated, it will\n     * be queued for normal delivery on the next cycle of the event loop.\n     *\n     * Exceptions in hooks and handlers will be caught and logged.\n     */\n    function postMessage(handler, msg) {\n        // Handle the common case of a non-conflatable message.\n        if (!msg.isConflatable) {\n            enqueueMessage(handler, msg);\n            return;\n        }\n        // Conflate the message with an existing message if possible.\n        let conflated = some(messageQueue, posted => {\n            if (posted.handler !== handler) {\n                return false;\n            }\n            if (!posted.msg) {\n                return false;\n            }\n            if (posted.msg.type !== msg.type) {\n                return false;\n            }\n            if (!posted.msg.isConflatable) {\n                return false;\n            }\n            return posted.msg.conflate(msg);\n        });\n        // Enqueue the message if it was not conflated.\n        if (!conflated) {\n            enqueueMessage(handler, msg);\n        }\n    }\n    MessageLoop.postMessage = postMessage;\n    /**\n     * Install a message hook for a message handler.\n     *\n     * @param handler - The message handler of interest.\n     *\n     * @param hook - The message hook to install.\n     *\n     * #### Notes\n     * A message hook is invoked before a message is delivered to the\n     * handler. If the hook returns `false`, no other hooks will be\n     * invoked and the message will not be delivered to the handler.\n     *\n     * The most recently installed message hook is executed first.\n     *\n     * If the hook is already installed, this is a no-op.\n     */\n    function installMessageHook(handler, hook) {\n        // Look up the hooks for the handler.\n        let hooks = messageHooks.get(handler);\n        // Bail early if the hook is already installed.\n        if (hooks && hooks.indexOf(hook) !== -1) {\n            return;\n        }\n        // Add the hook to the end, so it will be the first to execute.\n        if (!hooks) {\n            messageHooks.set(handler, [hook]);\n        }\n        else {\n            hooks.push(hook);\n        }\n    }\n    MessageLoop.installMessageHook = installMessageHook;\n    /**\n     * Remove an installed message hook for a message handler.\n     *\n     * @param handler - The message handler of interest.\n     *\n     * @param hook - The message hook to remove.\n     *\n     * #### Notes\n     * It is safe to call this function while the hook is executing.\n     *\n     * If the hook is not installed, this is a no-op.\n     */\n    function removeMessageHook(handler, hook) {\n        // Lookup the hooks for the handler.\n        let hooks = messageHooks.get(handler);\n        // Bail early if the hooks do not exist.\n        if (!hooks) {\n            return;\n        }\n        // Lookup the index of the hook and bail if not found.\n        let i = hooks.indexOf(hook);\n        if (i === -1) {\n            return;\n        }\n        // Clear the hook and schedule a cleanup of the array.\n        hooks[i] = null;\n        scheduleCleanup(hooks);\n    }\n    MessageLoop.removeMessageHook = removeMessageHook;\n    /**\n     * Clear all message data associated with a message handler.\n     *\n     * @param handler - The message handler of interest.\n     *\n     * #### Notes\n     * This will clear all posted messages and hooks for the handler.\n     */\n    function clearData(handler) {\n        // Lookup the hooks for the handler.\n        let hooks = messageHooks.get(handler);\n        // Clear all messsage hooks for the handler.\n        if (hooks && hooks.length > 0) {\n            ArrayExt.fill(hooks, null);\n            scheduleCleanup(hooks);\n        }\n        // Clear all posted messages for the handler.\n        for (const posted of messageQueue) {\n            if (posted.handler === handler) {\n                posted.handler = null;\n                posted.msg = null;\n            }\n        }\n    }\n    MessageLoop.clearData = clearData;\n    /**\n     * Process the pending posted messages in the queue immediately.\n     *\n     * #### Notes\n     * This function is useful when posted messages must be processed immediately.\n     *\n     * This function should normally not be needed, but it may be\n     * required to work around certain browser idiosyncrasies.\n     *\n     * Recursing into this function is a no-op.\n     */\n    function flush() {\n        // Bail if recursion is detected or if there is no pending task.\n        if (flushGuard || pending === null) {\n            return;\n        }\n        // Unschedule the pending loop task.\n        pending();\n        pending = null;\n        // Run the message loop within the recursion guard.\n        flushGuard = true;\n        runMessageLoop();\n        flushGuard = false;\n    }\n    MessageLoop.flush = flush;\n    /**\n     * Get the message loop exception handler.\n     *\n     * @returns The current exception handler.\n     *\n     * #### Notes\n     * The default exception handler is `console.error`.\n     */\n    function getExceptionHandler() {\n        return exceptionHandler;\n    }\n    MessageLoop.getExceptionHandler = getExceptionHandler;\n    /**\n     * Set the message loop exception handler.\n     *\n     * @param handler - The function to use as the exception handler.\n     *\n     * @returns The old exception handler.\n     *\n     * #### Notes\n     * The exception handler is invoked when a message handler or a\n     * message hook throws an exception.\n     */\n    function setExceptionHandler(handler) {\n        let old = exceptionHandler;\n        exceptionHandler = handler;\n        return old;\n    }\n    MessageLoop.setExceptionHandler = setExceptionHandler;\n    /**\n     * The queue of posted message pairs.\n     */\n    const messageQueue = new LinkedList();\n    /**\n     * A mapping of handler to array of installed message hooks.\n     */\n    const messageHooks = new WeakMap();\n    /**\n     * A set of message hook arrays which are pending cleanup.\n     */\n    const dirtySet = new Set();\n    /**\n     * The message loop exception handler.\n     */\n    let exceptionHandler = (err) => {\n        console.error(err);\n    };\n    /**\n     * A guard flag to prevent flush recursion.\n     */\n    let flushGuard = false;\n    /**\n     * Invoke a message hook with the specified handler and message.\n     *\n     * Returns the result of the hook, or `true` if the hook throws.\n     *\n     * Exceptions in the hook will be caught and logged.\n     */\n    function invokeHook(hook, handler, msg) {\n        let result = true;\n        try {\n            if (typeof hook === 'function') {\n                result = hook(handler, msg);\n            }\n            else {\n                result = hook.messageHook(handler, msg);\n            }\n        }\n        catch (err) {\n            exceptionHandler(err);\n        }\n        return result;\n    }\n    /**\n     * Invoke a message handler with the specified message.\n     *\n     * Exceptions in the handler will be caught and logged.\n     */\n    function invokeHandler(handler, msg) {\n        try {\n            handler.processMessage(msg);\n        }\n        catch (err) {\n            exceptionHandler(err);\n        }\n    }\n    /**\n     * Add a message to the end of the message queue.\n     *\n     * This will automatically schedule a run of the message loop.\n     */\n    function enqueueMessage(handler, msg) {\n        // Add the posted message to the queue.\n        messageQueue.addLast({ handler, msg });\n        // Bail if a loop task is already pending.\n        if (pending !== null) {\n            return;\n        }\n        // Schedule a run of the message loop.\n        pending = schedule(runMessageLoop);\n    }\n    /**\n     * Run an iteration of the message loop.\n     *\n     * This will process all pending messages in the queue. If a message\n     * is added to the queue while the message loop is running, it will\n     * be processed on the next cycle of the loop.\n     */\n    function runMessageLoop() {\n        // Clear the task so the next loop can be scheduled.\n        pending = null;\n        // If the message queue is empty, there is nothing else to do.\n        if (messageQueue.isEmpty) {\n            return;\n        }\n        // Add a sentinel value to the end of the queue. The queue will\n        // only be processed up to the sentinel. Messages posted during\n        // this cycle will execute on the next cycle.\n        let sentinel = { handler: null, msg: null };\n        messageQueue.addLast(sentinel);\n        // Enter the message loop.\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            // Remove the first posted message in the queue.\n            let posted = messageQueue.removeFirst();\n            // If the value is the sentinel, exit the loop.\n            if (posted === sentinel) {\n                return;\n            }\n            // Dispatch the message if it has not been cleared.\n            if (posted.handler && posted.msg) {\n                sendMessage(posted.handler, posted.msg);\n            }\n        }\n    }\n    /**\n     * Schedule a cleanup of a message hooks array.\n     *\n     * This will add the array to the dirty set and schedule a deferred\n     * cleanup of the array contents. On cleanup, any `null` hook will\n     * be removed from the array.\n     */\n    function scheduleCleanup(hooks) {\n        if (dirtySet.size === 0) {\n            schedule(cleanupDirtySet);\n        }\n        dirtySet.add(hooks);\n    }\n    /**\n     * Cleanup the message hook arrays in the dirty set.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupDirtySet() {\n        dirtySet.forEach(cleanupHooks);\n        dirtySet.clear();\n    }\n    /**\n     * Cleanup the dirty hooks in a message hooks array.\n     *\n     * This will remove any `null` hook from the array.\n     *\n     * This function should only be invoked asynchronously, when the\n     * stack frame is guaranteed to not be on the path of user code.\n     */\n    function cleanupHooks(hooks) {\n        ArrayExt.removeAllWhere(hooks, isNull);\n    }\n    /**\n     * Test whether a value is `null`.\n     */\n    function isNull(value) {\n        return value === null;\n    }\n})(MessageLoop || (MessageLoop = {}));\n\nexport { ConflatableMessage, Message, MessageLoop };\n//# sourceMappingURL=index.es6.js.map\n"],"names":["MessageLoop","Message","constructor","type","this","isConflatable","conflate","other","ConflatableMessage","pending","schedule","resolved","Promise","resolve","fn","rejected","then","sendMessage","handler","msg","hooks","messageHooks","get","length","invokeHandler","passed","every","retro","hook","result","messageHook","err","exceptionHandler","invokeHook","postMessage","some","messageQueue","posted","enqueueMessage","installMessageHook","indexOf","push","set","removeMessageHook","i","scheduleCleanup","clearData","ArrayExt","fill","flush","flushGuard","runMessageLoop","getExceptionHandler","setExceptionHandler","old","LinkedList","WeakMap","dirtySet","Set","console","error","processMessage","addLast","isEmpty","sentinel","removeFirst","size","cleanupDirtySet","add","forEach","cleanupHooks","clear","removeAllWhere","isNull","value"],"ignoreList":[],"sourceRoot":""}