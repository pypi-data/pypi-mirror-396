{"version":3,"file":"8832.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/logconsole/lib/logger.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/logconsole/lib/registry.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/logconsole/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/logconsole/lib/widget.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { OutputAreaModel } from '@jupyterlab/outputarea';\nimport { OutputModel } from '@jupyterlab/rendermime';\nimport { Signal } from '@lumino/signaling';\n/**\n * Log Output Model with timestamp which provides\n * item information for Output Area Model.\n */\nexport class LogOutputModel extends OutputModel {\n    /**\n     * Construct a LogOutputModel.\n     *\n     * @param options - The model initialization options.\n     */\n    constructor(options) {\n        super(options);\n        this.timestamp = new Date(options.value.timestamp);\n        this.level = options.value.level;\n    }\n}\n/**\n * Implementation of `IContentFactory` for Output Area Model\n * which creates LogOutputModel instances.\n */\nclass LogConsoleModelContentFactory extends OutputAreaModel.ContentFactory {\n    /**\n     * Create a rendermime output model from notebook output.\n     */\n    createOutputModel(options) {\n        return new LogOutputModel(options);\n    }\n}\n/**\n * Output Area Model implementation which is able to\n * limit number of outputs stored.\n */\nexport class LoggerOutputAreaModel extends OutputAreaModel {\n    constructor({ maxLength, ...options }) {\n        super(options);\n        this.maxLength = maxLength;\n    }\n    /**\n     * Add an output, which may be combined with previous output.\n     *\n     * @returns The total number of outputs.\n     *\n     * #### Notes\n     * The output bundle is copied. Contiguous stream outputs of the same `name`\n     * are combined. The oldest outputs are possibly removed to ensure the total\n     * number of outputs is at most `.maxLength`.\n     */\n    add(output) {\n        super.add(output);\n        this._applyMaxLength();\n        return this.length;\n    }\n    /**\n     * Whether an output should combine with the previous output.\n     *\n     * We combine if the two outputs are in the same second, which is the\n     * resolution for our time display.\n     */\n    shouldCombine(options) {\n        const { value, lastModel } = options;\n        const oldSeconds = Math.trunc(lastModel.timestamp.getTime() / 1000);\n        const newSeconds = Math.trunc(value.timestamp / 1000);\n        return oldSeconds === newSeconds;\n    }\n    /**\n     * Get an item at the specified index.\n     */\n    get(index) {\n        return super.get(index);\n    }\n    /**\n     * Maximum number of outputs to store in the model.\n     */\n    get maxLength() {\n        return this._maxLength;\n    }\n    set maxLength(value) {\n        this._maxLength = value;\n        this._applyMaxLength();\n    }\n    /**\n     * Manually apply length limit.\n     */\n    _applyMaxLength() {\n        if (this.list.length > this._maxLength) {\n            this.list.removeRange(0, this.list.length - this._maxLength);\n        }\n    }\n}\n/**\n * A concrete implementation of ILogger.\n */\nexport class Logger {\n    /**\n     * Construct a Logger.\n     *\n     * @param options Constructor options\n     */\n    constructor(options) {\n        var _a;\n        this._isDisposed = false;\n        this._contentChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._rendermime = null;\n        this._version = 0;\n        this.source = options.source;\n        this.outputAreaModel = new LoggerOutputAreaModel({\n            contentFactory: new LogConsoleModelContentFactory(),\n            maxLength: options.maxLength\n        });\n        this._level = (_a = options.level) !== null && _a !== void 0 ? _a : 'warning';\n    }\n    /**\n     * The maximum number of outputs stored.\n     *\n     * #### Notes\n     * Oldest entries will be trimmed to ensure the length is at most\n     * `.maxLength`.\n     */\n    get maxLength() {\n        return this.outputAreaModel.maxLength;\n    }\n    set maxLength(value) {\n        this.outputAreaModel.maxLength = value;\n    }\n    /**\n     * The level of outputs logged\n     */\n    get level() {\n        return this._level;\n    }\n    set level(newValue) {\n        const oldValue = this._level;\n        if (oldValue === newValue) {\n            return;\n        }\n        this._level = newValue;\n        this._log({\n            output: {\n                output_type: 'display_data',\n                data: {\n                    'text/plain': `Log level set to ${newValue}`\n                }\n            },\n            level: 'metadata'\n        });\n        this._stateChanged.emit({ name: 'level', oldValue, newValue });\n    }\n    /**\n     * Number of outputs logged.\n     */\n    get length() {\n        return this.outputAreaModel.length;\n    }\n    /**\n     * A signal emitted when the list of log messages changes.\n     */\n    get contentChanged() {\n        return this._contentChanged;\n    }\n    /**\n     * A signal emitted when the log state changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * Rendermime to use when rendering outputs logged.\n     */\n    get rendermime() {\n        return this._rendermime;\n    }\n    set rendermime(value) {\n        if (value !== this._rendermime) {\n            const oldValue = this._rendermime;\n            const newValue = (this._rendermime = value);\n            this._stateChanged.emit({ name: 'rendermime', oldValue, newValue });\n        }\n    }\n    /**\n     * The number of messages that have ever been stored.\n     */\n    get version() {\n        return this._version;\n    }\n    /**\n     * Log an output to logger.\n     *\n     * @param log - The output to be logged.\n     */\n    log(log) {\n        // Filter by our current log level\n        if (Private.LogLevel[log.level] <\n            Private.LogLevel[this._level]) {\n            return;\n        }\n        let output = null;\n        switch (log.type) {\n            case 'text':\n                output = {\n                    output_type: 'display_data',\n                    data: {\n                        'text/plain': log.data\n                    }\n                };\n                break;\n            case 'html':\n                output = {\n                    output_type: 'display_data',\n                    data: {\n                        'text/html': log.data\n                    }\n                };\n                break;\n            case 'output':\n                output = log.data;\n                break;\n            default:\n                break;\n        }\n        if (output) {\n            this._log({\n                output,\n                level: log.level\n            });\n        }\n    }\n    /**\n     * Clear all outputs logged.\n     */\n    clear() {\n        this.outputAreaModel.clear(false);\n        this._contentChanged.emit('clear');\n    }\n    /**\n     * Add a checkpoint to the log.\n     */\n    checkpoint() {\n        this._log({\n            output: {\n                output_type: 'display_data',\n                data: {\n                    'text/html': '<hr/>'\n                }\n            },\n            level: 'metadata'\n        });\n    }\n    /**\n     * Whether the logger is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose the logger.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this.clear();\n        this._rendermime = null;\n        Signal.clearData(this);\n    }\n    _log(options) {\n        // First, make sure our version reflects the new message so things\n        // triggering from the signals below have the correct version.\n        this._version++;\n        // Next, trigger any displays of the message\n        this.outputAreaModel.add({\n            ...options.output,\n            timestamp: Date.now(),\n            level: options.level\n        });\n        // Finally, tell people that the message was appended (and possibly\n        // already displayed).\n        this._contentChanged.emit('append');\n    }\n}\n/**\n * The namespace for Logger class private statics.\n */\nvar Private;\n(function (Private) {\n    /**\n     * The log level enum.\n     */\n    let LogLevel;\n    (function (LogLevel) {\n        LogLevel[LogLevel[\"debug\"] = 0] = \"debug\";\n        LogLevel[LogLevel[\"info\"] = 1] = \"info\";\n        LogLevel[LogLevel[\"warning\"] = 2] = \"warning\";\n        LogLevel[LogLevel[\"error\"] = 3] = \"error\";\n        LogLevel[LogLevel[\"critical\"] = 4] = \"critical\";\n        LogLevel[LogLevel[\"metadata\"] = 5] = \"metadata\";\n    })(LogLevel = Private.LogLevel || (Private.LogLevel = {}));\n})(Private || (Private = {}));\n//# sourceMappingURL=logger.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Signal } from '@lumino/signaling';\nimport { Logger } from './logger';\n/**\n * A concrete implementation of ILoggerRegistry.\n */\nexport class LoggerRegistry {\n    /**\n     * Construct a LoggerRegistry.\n     *\n     * @param options.defaultRendermime - Default rendermime to render outputs\n     * with when logger is not supplied with one.\n     */\n    constructor(options) {\n        var _a;\n        this._loggers = new Map();\n        this._registryChanged = new Signal(this);\n        this._isDisposed = false;\n        this._defaultRendermime = options.defaultRendermime;\n        this._maxLength = options.maxLength;\n        this._defaultLogLevel = (_a = options.defaultLogLevel) !== null && _a !== void 0 ? _a : 'warning';\n    }\n    /**\n     * Get the logger for the specified source.\n     *\n     * @param source - The name of the log source.\n     *\n     * @returns The logger for the specified source.\n     */\n    getLogger(source) {\n        const loggers = this._loggers;\n        let logger = loggers.get(source);\n        if (logger) {\n            return logger;\n        }\n        logger = new Logger({\n            source,\n            maxLength: this.maxLength,\n            level: this.defaultLogLevel\n        });\n        logger.rendermime = this._defaultRendermime;\n        loggers.set(source, logger);\n        this._registryChanged.emit('append');\n        return logger;\n    }\n    /**\n     * Get all loggers registered.\n     *\n     * @returns The array containing all registered loggers.\n     */\n    getLoggers() {\n        return Array.from(this._loggers.values());\n    }\n    /**\n     * A signal emitted when the logger registry changes.\n     */\n    get registryChanged() {\n        return this._registryChanged;\n    }\n    /**\n     * The max length for loggers.\n     */\n    get maxLength() {\n        return this._maxLength;\n    }\n    set maxLength(value) {\n        this._maxLength = value;\n        this._loggers.forEach(logger => {\n            logger.maxLength = value;\n        });\n    }\n    /**\n     * The default log level for new loggers.\n     * The new value will be applied to new loggers only.\n     */\n    get defaultLogLevel() {\n        return this._defaultLogLevel;\n    }\n    set defaultLogLevel(value) {\n        this._defaultLogLevel = value;\n    }\n    /**\n     * Whether the register is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose the registry and all loggers.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        this._loggers.forEach(x => x.dispose());\n        Signal.clearData(this);\n    }\n}\n//# sourceMappingURL=registry.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The Logger Registry token.\n */\nexport const ILoggerRegistry = new Token('@jupyterlab/logconsole:ILoggerRegistry', 'A service providing a logger infrastructure.');\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { OutputArea } from '@jupyterlab/outputarea';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Signal } from '@lumino/signaling';\nimport { PanelLayout, StackedPanel, Widget } from '@lumino/widgets';\nfunction toTitleCase(value) {\n    return value.length === 0 ? value : value[0].toUpperCase() + value.slice(1);\n}\n/**\n * Log console output prompt implementation\n */\nclass LogConsoleOutputPrompt extends Widget {\n    constructor() {\n        super();\n        this._timestampNode = document.createElement('div');\n        this.node.append(this._timestampNode);\n    }\n    /**\n     * Date & time when output is logged.\n     */\n    set timestamp(value) {\n        this._timestamp = value;\n        this._timestampNode.innerHTML = this._timestamp.toLocaleTimeString();\n        this.update();\n    }\n    /**\n     * Log level\n     */\n    set level(value) {\n        this._level = value;\n        this.node.dataset.logLevel = value;\n        this.update();\n    }\n    update() {\n        if (this._level !== undefined && this._timestamp !== undefined) {\n            this.node.title = `${this._timestamp.toLocaleString()}; ${toTitleCase(this._level)} level`;\n        }\n    }\n}\n/**\n * Output Area implementation displaying log outputs\n * with prompts showing log timestamps.\n */\nclass LogConsoleOutputArea extends OutputArea {\n    /**\n     * Create an output item with a prompt and actual output\n     */\n    createOutputItem(model) {\n        const panel = super.createOutputItem(model);\n        if (panel === null) {\n            // Could not render model\n            return null;\n        }\n        // first widget in panel is prompt of type LoggerOutputPrompt\n        const prompt = panel.widgets[0];\n        prompt.timestamp = model.timestamp;\n        prompt.level = model.level;\n        return panel;\n    }\n    /**\n     * Handle an input request from a kernel by doing nothing.\n     */\n    onInputRequest(msg, future) {\n        return;\n    }\n}\n/**\n * Implementation of `IContentFactory` for Output Area\n * which creates custom output prompts.\n */\nclass LogConsoleContentFactory extends OutputArea.ContentFactory {\n    /**\n     * Create the output prompt for the widget.\n     */\n    createOutputPrompt() {\n        return new LogConsoleOutputPrompt();\n    }\n}\n/**\n * Implements a panel which supports pinning the position to the end if it is\n * scrolled to the end.\n *\n * #### Notes\n * This is useful for log viewing components or chat components that append\n * elements at the end. We would like to automatically scroll when the user\n * has scrolled to the bottom, but not change the scrolling when the user has\n * changed the scroll position.\n */\nexport class ScrollingWidget extends Widget {\n    constructor({ content, ...options }) {\n        super(options);\n        this._observer = null;\n        this.addClass('jp-Scrolling');\n        const layout = (this.layout = new PanelLayout());\n        layout.addWidget(content);\n        this._content = content;\n        this._sentinel = document.createElement('div');\n        this.node.appendChild(this._sentinel);\n    }\n    /**\n     * The content widget.\n     */\n    get content() {\n        return this._content;\n    }\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        // defer so content gets a chance to attach first\n        requestAnimationFrame(() => {\n            this._sentinel.scrollIntoView();\n            this._scrollHeight = this.node.scrollHeight;\n        });\n        // Set up intersection observer for the sentinel\n        if (typeof IntersectionObserver !== 'undefined') {\n            this._observer = new IntersectionObserver(args => {\n                this._handleScroll(args);\n            }, { root: this.node, threshold: 1 });\n            this._observer.observe(this._sentinel);\n        }\n    }\n    onBeforeDetach(msg) {\n        if (this._observer) {\n            this._observer.disconnect();\n        }\n    }\n    onAfterShow(msg) {\n        if (this._tracking) {\n            this._sentinel.scrollIntoView();\n        }\n    }\n    _handleScroll([entry]) {\n        if (entry.isIntersecting) {\n            this._tracking = true;\n        }\n        else if (this.isVisible) {\n            const currentHeight = this.node.scrollHeight;\n            if (currentHeight === this._scrollHeight) {\n                // Likely the user scrolled manually\n                this._tracking = false;\n            }\n            else {\n                // We assume we scrolled because our size changed, so scroll to the end.\n                this._sentinel.scrollIntoView();\n                this._scrollHeight = currentHeight;\n                this._tracking = true;\n            }\n        }\n    }\n}\n/**\n * A StackedPanel implementation that creates Output Areas\n * for each log source and activates as source is switched.\n */\nexport class LogConsolePanel extends StackedPanel {\n    /**\n     * Construct a LogConsolePanel instance.\n     *\n     * @param loggerRegistry - The logger registry that provides\n     * logs to be displayed.\n     */\n    constructor(loggerRegistry, translator) {\n        super();\n        this._outputAreas = new Map();\n        this._source = null;\n        this._sourceChanged = new Signal(this);\n        this._sourceDisplayed = new Signal(this);\n        this._loggersWatched = new Set();\n        this.translator = translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this._loggerRegistry = loggerRegistry;\n        this.addClass('jp-LogConsolePanel');\n        loggerRegistry.registryChanged.connect((sender, args) => {\n            this._bindLoggerSignals();\n        }, this);\n        this._bindLoggerSignals();\n        this._placeholder = new Widget();\n        this._placeholder.addClass('jp-LogConsoleListPlaceholder');\n        this.addWidget(this._placeholder);\n    }\n    /**\n     * The logger registry providing the logs.\n     */\n    get loggerRegistry() {\n        return this._loggerRegistry;\n    }\n    /**\n     * The current logger.\n     */\n    get logger() {\n        if (this.source === null) {\n            return null;\n        }\n        return this.loggerRegistry.getLogger(this.source);\n    }\n    /**\n     * The log source displayed\n     */\n    get source() {\n        return this._source;\n    }\n    set source(name) {\n        if (name === this._source) {\n            return;\n        }\n        const oldValue = this._source;\n        const newValue = (this._source = name);\n        this._showOutputFromSource(newValue);\n        this._handlePlaceholder();\n        this._sourceChanged.emit({ oldValue, newValue, name: 'source' });\n    }\n    /**\n     * The source version displayed.\n     */\n    get sourceVersion() {\n        const source = this.source;\n        return source !== null\n            ? this._loggerRegistry.getLogger(source).version\n            : null;\n    }\n    /**\n     * Signal for source changes\n     */\n    get sourceChanged() {\n        return this._sourceChanged;\n    }\n    /**\n     * Signal for source changes\n     */\n    get sourceDisplayed() {\n        return this._sourceDisplayed;\n    }\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        this._updateOutputAreas();\n        this._showOutputFromSource(this._source);\n        this._handlePlaceholder();\n    }\n    onAfterShow(msg) {\n        super.onAfterShow(msg);\n        if (this.source !== null) {\n            this._sourceDisplayed.emit({\n                source: this.source,\n                version: this.sourceVersion\n            });\n        }\n    }\n    _bindLoggerSignals() {\n        const loggers = this._loggerRegistry.getLoggers();\n        for (const logger of loggers) {\n            if (this._loggersWatched.has(logger.source)) {\n                continue;\n            }\n            logger.contentChanged.connect((sender, args) => {\n                this._updateOutputAreas();\n                this._handlePlaceholder();\n            }, this);\n            logger.stateChanged.connect((sender, change) => {\n                if (change.name !== 'rendermime') {\n                    return;\n                }\n                const viewId = `source:${sender.source}`;\n                const outputArea = this._outputAreas.get(viewId);\n                if (outputArea) {\n                    if (change.newValue) {\n                        // cast away readonly\n                        outputArea.rendermime = change.newValue;\n                    }\n                    else {\n                        outputArea.dispose();\n                    }\n                }\n            }, this);\n            this._loggersWatched.add(logger.source);\n        }\n    }\n    _showOutputFromSource(source) {\n        // If the source is null, pick a unique name so all output areas hide.\n        const viewId = source === null ? 'null source' : `source:${source}`;\n        this._outputAreas.forEach((outputArea, name) => {\n            var _a, _b;\n            // Show/hide the output area parents, the scrolling windows.\n            if (outputArea.id === viewId) {\n                (_a = outputArea.parent) === null || _a === void 0 ? void 0 : _a.show();\n                if (outputArea.isVisible) {\n                    this._sourceDisplayed.emit({\n                        source: this.source,\n                        version: this.sourceVersion\n                    });\n                }\n            }\n            else {\n                (_b = outputArea.parent) === null || _b === void 0 ? void 0 : _b.hide();\n            }\n        });\n        const title = source === null\n            ? this._trans.__('Log Console')\n            : this._trans.__('Log: %1', source);\n        this.title.label = title;\n        this.title.caption = title;\n    }\n    _handlePlaceholder() {\n        if (this.source === null) {\n            this._placeholder.node.textContent = this._trans.__('No source selected.');\n            this._placeholder.show();\n        }\n        else if (this._loggerRegistry.getLogger(this.source).length === 0) {\n            this._placeholder.node.textContent = this._trans.__('No log messages.');\n            this._placeholder.show();\n        }\n        else {\n            this._placeholder.hide();\n            this._placeholder.node.textContent = '';\n        }\n    }\n    _updateOutputAreas() {\n        const loggerIds = new Set();\n        const loggers = this._loggerRegistry.getLoggers();\n        for (const logger of loggers) {\n            const source = logger.source;\n            const viewId = `source:${source}`;\n            loggerIds.add(viewId);\n            // add view for logger if not exist\n            if (!this._outputAreas.has(viewId)) {\n                const outputArea = new LogConsoleOutputArea({\n                    rendermime: logger.rendermime,\n                    contentFactory: new LogConsoleContentFactory(),\n                    model: logger.outputAreaModel\n                });\n                outputArea.id = viewId;\n                // Attach the output area so it is visible, so the accounting\n                // functions below record the outputs actually displayed.\n                const w = new ScrollingWidget({\n                    content: outputArea\n                });\n                this.addWidget(w);\n                this._outputAreas.set(viewId, outputArea);\n                // This is where the source object is associated with the output area.\n                // We capture the source from this environment in the closure.\n                const outputUpdate = (sender) => {\n                    // If the current log console panel source is the source associated\n                    // with this output area, and the output area is visible, then emit\n                    // the logConsolePanel source displayed signal.\n                    if (this.source === source && sender.isVisible) {\n                        // We assume that the output area has been updated to the current\n                        // version of the source.\n                        this._sourceDisplayed.emit({\n                            source: this.source,\n                            version: this.sourceVersion\n                        });\n                    }\n                };\n                // Notify messages were displayed any time the output area is updated\n                // and update for any outputs rendered on construction.\n                outputArea.outputLengthChanged.connect(outputUpdate, this);\n                // Since the output area was attached above, we can rely on its\n                // visibility to account for the messages displayed.\n                outputUpdate(outputArea);\n            }\n        }\n        // remove output areas that do not have corresponding loggers anymore\n        const viewIds = this._outputAreas.keys();\n        for (const viewId of viewIds) {\n            if (!loggerIds.has(viewId)) {\n                const outputArea = this._outputAreas.get(viewId);\n                outputArea === null || outputArea === void 0 ? void 0 : outputArea.dispose();\n                this._outputAreas.delete(viewId);\n            }\n        }\n    }\n}\n//# sourceMappingURL=widget.js.map"],"names":["Private","LogOutputModel","OutputModel","constructor","options","super","this","timestamp","Date","value","level","LogConsoleModelContentFactory","OutputAreaModel","ContentFactory","createOutputModel","LoggerOutputAreaModel","maxLength","add","output","_applyMaxLength","length","shouldCombine","lastModel","Math","trunc","getTime","get","index","_maxLength","list","removeRange","Logger","_a","_isDisposed","_contentChanged","Signal","_stateChanged","_rendermime","_version","source","outputAreaModel","contentFactory","_level","newValue","oldValue","_log","output_type","data","emit","name","contentChanged","stateChanged","rendermime","version","log","LogLevel","type","clear","checkpoint","isDisposed","dispose","clearData","now","LoggerRegistry","_loggers","Map","_registryChanged","_defaultRendermime","defaultRendermime","_defaultLogLevel","defaultLogLevel","getLogger","loggers","logger","set","getLoggers","Array","from","values","registryChanged","forEach","x","ILoggerRegistry","Token","LogConsoleOutputPrompt","Widget","_timestampNode","document","createElement","node","append","_timestamp","innerHTML","toLocaleTimeString","update","dataset","logLevel","undefined","title","toLocaleString","toUpperCase","slice","LogConsoleOutputArea","OutputArea","createOutputItem","model","panel","prompt","widgets","onInputRequest","msg","future","LogConsoleContentFactory","createOutputPrompt","ScrollingWidget","content","_observer","addClass","layout","PanelLayout","addWidget","_content","_sentinel","appendChild","onAfterAttach","requestAnimationFrame","scrollIntoView","_scrollHeight","scrollHeight","IntersectionObserver","args","_handleScroll","root","threshold","observe","onBeforeDetach","disconnect","onAfterShow","_tracking","entry","isIntersecting","isVisible","currentHeight","LogConsolePanel","StackedPanel","loggerRegistry","translator","_outputAreas","_source","_sourceChanged","_sourceDisplayed","_loggersWatched","Set","nullTranslator","_trans","load","_loggerRegistry","connect","sender","_bindLoggerSignals","_placeholder","_showOutputFromSource","_handlePlaceholder","sourceVersion","sourceChanged","sourceDisplayed","_updateOutputAreas","has","change","viewId","outputArea","_b","id","parent","show","hide","__","label","caption","textContent","loggerIds","w","outputUpdate","outputLengthChanged","viewIds","keys","delete"],"ignoreList":[],"sourceRoot":""}