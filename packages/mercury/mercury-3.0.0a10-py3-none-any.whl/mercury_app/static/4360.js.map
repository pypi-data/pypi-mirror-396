{"version":3,"file":"4360.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/markedparser-extension/lib/index.js"],"sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module markedparser-extension\n */\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { LruCache } from '@jupyterlab/coreutils';\nimport { IEditorLanguageRegistry } from '@jupyterlab/codemirror';\nimport { IMarkdownParser } from '@jupyterlab/rendermime';\nimport { IMermaidMarkdown } from '@jupyterlab/mermaid';\n// highlight cache key separator\nconst FENCE = '```~~~';\n/**\n * Create a markdown parser\n *\n * @param languages Editor languages\n * @returns Markdown parser\n */\nexport function createMarkdownParser(languages, options) {\n    return {\n        render: (content) => {\n            return Private.render(content, languages, options);\n        }\n    };\n}\n/**\n * The markdown parser plugin.\n */\nconst plugin = {\n    id: '@jupyterlab/markedparser-extension:plugin',\n    description: 'Provides the Markdown parser.',\n    autoStart: true,\n    provides: IMarkdownParser,\n    requires: [IEditorLanguageRegistry],\n    optional: [IMermaidMarkdown],\n    activate: (app, languages, mermaidMarkdown) => {\n        return createMarkdownParser(languages, {\n            blocks: mermaidMarkdown ? [mermaidMarkdown] : []\n        });\n    }\n};\n/**\n * Export the plugin as default.\n */\nexport default plugin;\n/**\n * A namespace for private marked functions\n */\nvar Private;\n(function (Private) {\n    let _initializing = null;\n    let _marked = null;\n    let _blocks = [];\n    let _languages = null;\n    let _markedOptions = {};\n    let _highlights = new LruCache();\n    async function render(content, languages, options) {\n        _languages = languages;\n        if (!_marked) {\n            _marked = await initializeMarked(options);\n        }\n        return _marked(content, _markedOptions);\n    }\n    Private.render = render;\n    /**\n     * Load marked lazily and exactly once.\n     */\n    async function initializeMarked(options) {\n        if (_marked) {\n            return _marked;\n        }\n        if (_initializing) {\n            return await _initializing.promise;\n        }\n        // order blocks by `rank`\n        _blocks = (options === null || options === void 0 ? void 0 : options.blocks) || [];\n        _blocks = _blocks.sort((a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : Infinity) - ((_b = b.rank) !== null && _b !== void 0 ? _b : Infinity); });\n        _initializing = new PromiseDelegate();\n        // load marked lazily, and exactly once\n        const [{ marked, Renderer }, plugins] = await Promise.all([\n            import('marked'),\n            loadMarkedPlugins()\n        ]);\n        // use load marked plugins\n        for (const plugin of plugins) {\n            marked.use(plugin);\n        }\n        // finish marked configuration\n        _markedOptions = {\n            // use the explicit async paradigm for `walkTokens`\n            async: true,\n            // enable all built-in GitHub-flavored Markdown opinions\n            gfm: true,\n            // asynchronously prepare for any special tokens, like highlighting and mermaid\n            walkTokens,\n            // use custom renderer\n            renderer: makeRenderer(Renderer)\n        };\n        // complete initialization\n        _marked = marked;\n        _initializing.resolve(_marked);\n        return _marked;\n    }\n    Private.initializeMarked = initializeMarked;\n    /**\n     * Load and use marked plugins.\n     *\n     * As of writing, both of these features would work without plugins, but emit\n     * deprecation warnings.\n     */\n    async function loadMarkedPlugins() {\n        // use loaded marked plugins\n        return Promise.all([\n            (async () => (await import('marked-gfm-heading-id')).gfmHeadingId())(),\n            (async () => (await import('marked-mangle')).mangle())()\n        ]);\n    }\n    /**\n     * Build a custom marked renderer.\n     */\n    function makeRenderer(Renderer_) {\n        const renderer = new Renderer_();\n        const originalCode = renderer.code;\n        renderer.code = ({ text, lang, escaped }) => {\n            // handle block renderers\n            for (const block of _blocks) {\n                if (lang && block.languages.includes(lang)) {\n                    const rendered = block.render(text);\n                    if (rendered != null) {\n                        return rendered;\n                    }\n                }\n            }\n            // handle known highlighting\n            const key = `${lang}${FENCE}${text}${FENCE}`;\n            const highlight = _highlights.get(key);\n            if (highlight != null) {\n                return highlight;\n            }\n            // fall back to calling with the renderer as `this`\n            return originalCode.call(renderer, { text, lang, escaped });\n        };\n        return renderer;\n    }\n    /**\n     * Apply and cache syntax highlighting for code blocks.\n     */\n    async function highlight(token) {\n        const { lang, text } = token;\n        if (!lang || !_languages) {\n            // no language(s), no highlight\n            return;\n        }\n        const key = `${lang}${FENCE}${text}${FENCE}`;\n        if (_highlights.get(key)) {\n            // already cached, don't make another DOM element\n            return;\n        }\n        const el = document.createElement('div');\n        try {\n            await _languages.highlight(text, _languages.findBest(lang), el);\n            const html = `<pre><code class=\"language-${lang}\">${el.innerHTML}</code></pre>`;\n            _highlights.set(key, html);\n        }\n        catch (err) {\n            console.error(`Failed to highlight ${lang} code`, err);\n        }\n        finally {\n            el.remove();\n        }\n    }\n    /**\n     * After parsing, lazily load and render or highlight code blocks\n     */\n    async function walkTokens(token) {\n        switch (token.type) {\n            case 'code':\n                if (token.lang) {\n                    for (const block of _blocks) {\n                        if (block.languages.includes(token.lang)) {\n                            await block.walk(token.text);\n                            return;\n                        }\n                    }\n                }\n                await highlight(token);\n        }\n    }\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map"],"names":["FENCE","createMarkdownParser","languages","options","render","content","Private","id","description","autoStart","provides","IMarkdownParser","requires","IEditorLanguageRegistry","optional","IMermaidMarkdown","activate","app","mermaidMarkdown","blocks","_initializing","_marked","_blocks","_languages","_markedOptions","_highlights","LruCache","async","initializeMarked","promise","sort","a","b","_a","_b","rank","Infinity","PromiseDelegate","marked","Renderer","plugins","Promise","all","loadMarkedPlugins","plugin","use","gfm","walkTokens","renderer","makeRenderer","resolve","gfmHeadingId","mangle","Renderer_","originalCode","code","text","lang","escaped","block","includes","rendered","key","highlight","get","call","token","type","walk","el","document","createElement","findBest","html","innerHTML","set","err","console","error","remove"],"ignoreList":[],"sourceRoot":""}