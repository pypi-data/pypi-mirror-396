{"version":3,"file":"6626.bundle.js","mappings":"2MASO,MAKMA,EAASC,OAAOD,OAKhBE,EAAOD,OAAOC,KAcdC,GAPSF,OAAOG,OAON,CAACC,EAAKC,KAC3B,IAAK,MAAMC,KAAOF,EAChBC,EAAED,EAAIE,GAAMA,KAyBHC,EAASH,GAAOH,EAAKG,GAAKG,OAM1BC,EAAOJ,GAAOH,EAAKG,GAAKG,OAoBxBE,EAAUL,IAErB,IAAK,MAAMM,KAAMN,EACf,OAAO,EAET,OAAO,GAyBIO,EAAc,CAACP,EAAKE,IAAQN,OAAOY,UAAUC,eAAeC,KAAKV,EAAKE,GAOtES,EAAY,CAACC,EAAGC,IAAMD,IAAMC,GAAMT,EAAKQ,KAAOR,EAAKS,IAvB3C,EAACb,EAAKC,KACzB,IAAK,MAAMC,KAAOF,EAChB,IAAKC,EAAED,EAAIE,GAAMA,GACf,OAAO,EAGX,OAAO,GAiB6DY,CAAMF,EAAG,CAACG,EAAKb,UAAiBc,IAARD,GAAqBR,EAAYM,EAAGX,KAASW,EAAEX,KAASa,GAMzIE,EAASrB,OAAOqB,OAUhBC,EAAcC,IACzB,IAAK,MAAMjB,KAAOiB,EAAG,CACnB,MAAMC,EAAID,EAAEjB,GACK,iBAANkB,GAA+B,mBAANA,GAClCF,EAAWC,EAAEjB,GAEjB,CACA,OAAOe,EAAOE,G,iFCnIT,MAAME,EAAOC,GAAOA,EAAIA,EAAInB,OAAS,GAsB/BoB,EAAW,CAACC,EAAMC,KAC7B,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAItB,OAAQuB,IAC9BF,EAAKG,KAAKF,EAAIC,KAYLE,EAAOC,MAAMD,KA+BbE,EAAO,CAACR,EAAKrB,KACxB,IAAK,IAAIyB,EAAI,EAAGA,EAAIJ,EAAInB,OAAQuB,IAC9B,GAAIzB,EAAEqB,EAAII,GAAIA,EAAGJ,GACf,OAAO,EAGX,OAAO,GAyBIS,EAAS,CAACC,EAAK/B,KAC1B,MAAMgC,EAAQ,IAAIJ,MAAMG,GACxB,IAAK,IAAIN,EAAI,EAAGA,EAAIM,EAAKN,IACvBO,EAAMP,GAAKzB,EAAEyB,EAAGO,GAElB,OAAOA,GAYIC,EAAUL,MAAMK,O,gFC/GtB,MAAMC,EACX,WAAAC,GAKEC,KAAKC,WAAa,MACpB,CAOA,EAAAC,CAAIC,EAAMvC,GAER,OADA,KAAmBoC,KAAKC,WAAkC,EAAQ,MAAYG,IAAIxC,GAC3EA,CACT,CAOA,IAAAyC,CAAMF,EAAMvC,GAIV,MAAM0C,EAAK,IAAIC,KACbP,KAAKQ,IAAIL,EAAyB,GAClCvC,KAAK2C,IAEPP,KAAKE,GAAGC,EAAyB,EACnC,CAOA,GAAAK,CAAKL,EAAMvC,GACT,MAAM6C,EAAYT,KAAKC,WAAWS,IAAIP,QACpBxB,IAAd8B,IACFA,EAAUE,OAAO/C,GACM,IAAnB6C,EAAU1C,MACZiC,KAAKC,WAAWU,OAAOR,GAG7B,CAYA,IAAAS,CAAMT,EAAMI,GAEV,OAAO,MAAYP,KAAKC,WAAWS,IAAIP,IAAS,QAAczC,UAAUD,QAAQG,GAAKA,KAAK2C,GAC5F,CAEA,OAAAM,GACEb,KAAKC,WAAa,MACpB,EAUK,MAAMa,EACX,WAAAf,GAKEC,KAAKC,WAAa,MACpB,CAMA,EAAAC,CAAIC,EAAMvC,GACR,KAAmBoC,KAAKC,WAAYE,EAAM,MAAYC,IAAIxC,EAC5D,CAMA,IAAAyC,CAAMF,EAAMvC,GAIV,MAAM0C,EAAK,IAAIC,KACbP,KAAKQ,IAAIL,EAAMG,GACf1C,KAAK2C,IAEPP,KAAKE,GAAGC,EAAMG,EAChB,CAMA,GAAAE,CAAKL,EAAMvC,GACT,MAAM6C,EAAYT,KAAKC,WAAWS,IAAIP,QACpBxB,IAAd8B,IACFA,EAAUE,OAAO/C,GACM,IAAnB6C,EAAU1C,MACZiC,KAAKC,WAAWU,OAAOR,GAG7B,CAWA,IAAAS,CAAMT,EAAMI,GAEV,OAAO,MAAYP,KAAKC,WAAWS,IAAIP,IAAS,QAAczC,UAAUD,QAAQG,GAAKA,KAAK2C,GAC5F,CAEA,OAAAM,GACEb,KAAKC,WAAa,MACpB,E,oCCxJK,MAAMc,EAAS,IAAM,IAAIC,G,oCCQzB,MAOMC,EAAcC,KAAKC,G,yFCrBzB,MAAMC,EAAsBC,OAAO,YCgB7BC,EAAU,CAACC,EAAIhB,EAAMlB,EAAI,KACpC,IACE,KAAOA,EAAIkC,EAAGzD,OAAQuB,IACpBkC,EAAGlC,MAAMkB,EAEb,CAAE,QACIlB,EAAIkC,EAAGzD,QACTwD,EAAQC,EAAIhB,EAAMlB,EAAI,EAE1B,GAkBWmC,EAAKjD,GAAKA,EA2BVkD,EAAe,CAAClD,EAAGC,KAC9B,GAAID,IAAMC,EACR,OAAO,EAET,GAAS,MAALD,GAAkB,MAALC,GAAaD,EAAEwB,cAAgBvB,EAAEuB,YAChD,OAAO,EAET,GAAqC,MAAjCxB,EAAE,GACJ,OAAOA,EAAE,GAA4BC,GAEvC,OAAQD,EAAEwB,aACR,KAAK2B,YACHnD,EAAI,IAAIoD,WAAWpD,GACnBC,EAAI,IAAImD,WAAWnD,GAErB,KAAKmD,WACH,GAAIpD,EAAEqD,aAAepD,EAAEoD,WACrB,OAAO,EAET,IAAK,IAAIvC,EAAI,EAAGA,EAAId,EAAET,OAAQuB,IAC5B,GAAId,EAAEc,KAAOb,EAAEa,GACb,OAAO,EAGX,MAEF,KAAK2B,IACH,GAAIzC,EAAER,OAASS,EAAET,KACf,OAAO,EAET,IAAK,MAAM8D,KAAStD,EAClB,IAAKC,EAAEsD,IAAID,GACT,OAAO,EAGX,MAEF,KAAKE,IACH,GAAIxD,EAAER,OAASS,EAAET,KACf,OAAO,EAET,IAAK,MAAMF,KAAOU,EAAEf,OAClB,IAAKgB,EAAEsD,IAAIjE,KAAS4D,EAAalD,EAAEmC,IAAI7C,GAAMW,EAAEkC,IAAI7C,IACjD,OAAO,EAGX,MAEF,KAAKN,OACH,GAAI,KAAcgB,KAAO,KAAcC,GACrC,OAAO,EAET,IAAK,MAAMX,KAAOU,EAChB,IAAK,KAAmBA,EAAGV,KAAS4D,EAAalD,EAAEV,GAAMW,EAAEX,IACzD,OAAO,EAGX,MACF,KAAK2B,MACH,GAAIjB,EAAET,SAAWU,EAAEV,OACjB,OAAO,EAET,IAAK,IAAIuB,EAAI,EAAGA,EAAId,EAAET,OAAQuB,IAC5B,IAAKoC,EAAalD,EAAEc,GAAIb,EAAEa,IACxB,OAAO,EAGX,MACF,QACE,OAAO,EAEX,OAAO,GAWI2C,EAAU,CAACH,EAAOI,IAAYA,EAAQC,SAASL,GAGrC,I,wECrJhB,MAAMM,EAAQC,KAAKD,MAEbE,GADOD,KAAKE,KACNF,KAAKC,KAsBXE,GArBOH,KAAKI,KACJJ,KAAKK,MACLL,KAAKM,MACNN,KAAKO,KACNP,KAAKQ,IACJR,KAAKS,KAgBN,CAACtE,EAAGC,IAAMD,EAAIC,EAAID,EAAIC,GAQ5BsE,EAAM,CAACvE,EAAGC,IAAMD,EAAIC,EAAID,EAAIC,EAmB5BuE,GAjBQC,OAAOC,MAETb,KAAKc,IASJd,KAAKe,KAMKC,GAAW,IAANA,EAAUA,EAAI,EAAI,EAAIA,EAAI,E,uEC3CtD,MAAMrC,EAAS,IAAM,IAAIgB,IAUnBsB,EAAOC,IAClB,MAAMC,EAAIxC,IAEV,OADAuC,EAAE7F,QAAQ,CAAC+F,EAAGC,KAAQF,EAAEG,IAAID,EAAGD,KACxBD,GAmBII,EAAiB,CAACC,EAAK/F,EAAKgG,KACvC,IAAIH,EAAME,EAAIlD,IAAI7C,GAIlB,YAHYc,IAAR+E,GACFE,EAAIF,IAAI7F,EAAK6F,EAAMG,KAEdH,GAcIE,EAAM,CAACN,EAAG1F,KACrB,MAAMkG,EAAM,GACZ,IAAK,MAAOjG,EAAKgE,KAAUyB,EACzBQ,EAAIxE,KAAK1B,EAAEiE,EAAOhE,IAEpB,OAAOiG,GAeIC,EAAM,CAACT,EAAG1F,KACrB,IAAK,MAAOC,EAAKgE,KAAUyB,EACzB,GAAI1F,EAAEiE,EAAOhE,GACX,OAAO,EAGX,OAAO,E","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/object.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/array.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/observable.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/set.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/time.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/traits.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/function.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/math.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/map.js"],"sourcesContent":["/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nexport const create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nexport const assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nexport const keys = Object.keys\n\n/**\n * @template V\n * @param {{[key:string]: V}} obj\n * @return {Array<V>}\n */\nexport const values = Object.values\n\n/**\n * @template V\n * @param {{[k:string]:V}} obj\n * @param {function(V,string):any} f\n */\nexport const forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @todo implement mapToArray & map\n *\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nexport const map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @deprecated use object.size instead\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const size = obj => keys(obj).length\n\n/**\n * @template {{ [key:string|number|symbol]: any }} T\n * @param {T} obj\n * @param {(v:T[keyof T],k:keyof T)=>boolean} f\n * @return {boolean}\n */\nexport const some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object|null|undefined} obj\n */\nexport const isEmpty = obj => {\n  // eslint-disable-next-line no-unreachable-loop\n  for (const _k in obj) {\n    return false\n  }\n  return true\n}\n\n/**\n * @template {{ [key:string|number|symbol]: any }} T\n * @param {T} obj\n * @param {(v:T[keyof T],k:keyof T)=>boolean} f\n * @return {boolean}\n */\nexport const every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|number|symbol} key\n * @return {boolean}\n */\nexport const hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a === b || (size(a) === size(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n\n/**\n * Make an object immutable. This hurts performance and is usually not needed if you perform good\n * coding practices.\n */\nexport const freeze = Object.freeze\n\n/**\n * Make an object and all its children immutable.\n * This *really* hurts performance and is usually not needed if you perform good coding practices.\n *\n * @template {any} T\n * @param {T} o\n * @return {Readonly<T>}\n */\nexport const deepFreeze = (o) => {\n  for (const key in o) {\n    const c = o[key]\n    if (typeof c === 'object' || typeof c === 'function') {\n      deepFreeze(o[key])\n    }\n  }\n  return freeze(o)\n}\n\n/**\n * Get object property. Create T if property is undefined and set T on object.\n *\n * @function\n * @template {object} KV\n * @template {keyof KV} [K=keyof KV]\n * @param {KV} o\n * @param {K} key\n * @param {() => KV[K]} createT\n * @return {KV[K]}\n */\nexport const setIfUndefined = (o, key, createT) => hasProperty(o, key) ? o[key] : (o[key] = createT())\n","/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\nimport * as set from './set.js'\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template {ArrayLike<any>} ARR\n *\n * @param {ARR} arr\n * @param {ARR extends ArrayLike<infer S> ? ((value:S, index:number, arr:ARR) => boolean) : any} f\n * @return {boolean}\n */\nexport const every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template {ArrayLike<any>} ARR\n *\n * @param {ARR} arr\n * @param {ARR extends ArrayLike<infer S> ? ((value:S, index:number, arr:ARR) => boolean) : never} f\n * @return {boolean}\n */\nexport const some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nexport const unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nexport const fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nexport const isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nexport const unique = arr => from(set.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nexport const uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = set.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n\n/**\n * @template {ArrayLike<any>} ARR\n * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER\n * @param {ARR} arr\n * @param {MAPPER} mapper\n * @return {Array<MAPPER extends function(...any): infer M ? M : never>}\n */\nexport const map = (arr, mapper) => {\n  /**\n   * @type {Array<any>}\n   */\n  const res = Array(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))\n  }\n  return /** @type {any} */ (res)\n}\n\n/**\n * This function bubble-sorts a single item to the correct position. The sort happens in-place and\n * might be useful to ensure that a single item is at the correct position in an otherwise sorted\n * array.\n *\n * @example\n *  const arr = [3, 2, 5]\n *  arr.sort((a, b) => a - b)\n *  arr // => [2, 3, 5]\n *  arr.splice(1, 0, 7)\n *  array.bubbleSortItem(arr, 1, (a, b) => a - b)\n *  arr // => [2, 3, 5, 7]\n *\n * @template T\n * @param {Array<T>} arr\n * @param {number} i\n * @param {(a:T,b:T) => number} compareFn\n */\nexport const bubblesortItem = (arr, i, compareFn) => {\n  const n = arr[i]\n  let j = i\n  // try to sort to the right\n  while (j + 1 < arr.length && compareFn(n, arr[j + 1]) > 0) {\n    arr[j] = arr[j + 1]\n    arr[++j] = n\n  }\n  if (i === j && j > 0) { // no change yet\n    // sort to the left\n    while (j > 0 && compareFn(arr[j - 1], n) > 0) {\n      arr[j] = arr[j - 1]\n      arr[--j] = n\n    }\n  }\n  return j\n}\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n * @experimental\n *\n * This is basically a (better typed) duplicate of Observable, which will replace Observable in the\n * next release.\n *\n * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS\n */\nexport class ObservableV2 {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<string, Set<any>>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)\n    return f\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, /** @type {any} */ (_f))\n      f(...args)\n    }\n    this.on(name, /** @type {any} */ (_f))\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name The event name.\n   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n/* c8 ignore end */\n","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T|undefined}\n */\nexport const first = set => set.values().next().value\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => new Set(entries)\n","/**\n * Utility module to work with time.\n *\n * @module time\n */\n\nimport * as metric from './metric.js'\nimport * as math from './math.js'\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nexport const getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nexport const getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10Î¼s.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nexport const humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1)\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = math.floor(d / 60) % 60\n  const hours = math.floor(d / 3600) % 24\n  const days = math.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* c8 ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n","export const EqualityTraitSymbol = Symbol('Equality')\n\n/**\n * @typedef {{ [EqualityTraitSymbol]:(other:EqualityTrait)=>boolean }} EqualityTrait\n */\n","/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\nimport * as array from './array.js'\nimport * as object from './object.js'\nimport * as traits from './traits.js'\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nexport const callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nexport const nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nexport const apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nexport const id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nexport const equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nexport const equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((array.isArray(a) && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))))\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalityDeep = (a, b) => {\n  if (a === b) {\n    return true\n  }\n  if (a == null || b == null || a.constructor !== b.constructor) {\n    return false\n  }\n  if (a[traits.EqualityTraitSymbol] != null) {\n    return a[traits.EqualityTraitSymbol](b)\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n\n/**\n * @template V\n * @template {V} OPTS\n *\n * @param {V} value\n * @param {Array<OPTS>} options\n */\n// @ts-ignore\nexport const isOneOf = (value, options) => options.includes(value)\n/* c8 ignore stop */\n\nexport const isArray = array.isArray\n\n/**\n * @param {any} s\n * @return {s is String}\n */\nexport const isString = (s) => s && s.constructor === String\n\n/**\n * @param {any} n\n * @return {n is Number}\n */\nexport const isNumber = n => n != null && n.constructor === Number\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {any} n\n * @param {TYPE} T\n * @return {n is InstanceType<TYPE>}\n */\nexport const is = (n, T) => n && n.constructor === T\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {TYPE} T\n */\nexport const isTemplate = (T) =>\n  /**\n   * @param {any} n\n   * @return {n is InstanceType<TYPE>}\n   **/\n  n => n && n.constructor === T\n","/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n","/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template K,V\n * @param {Map<K,V>} m\n * @return {Map<K,V>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n"],"names":["assign","Object","keys","forEach","values","obj","f","key","length","size","isEmpty","_k","hasProperty","prototype","hasOwnProperty","call","equalFlat","a","b","every","val","undefined","freeze","deepFreeze","o","c","last","arr","appendTo","dest","src","i","push","from","Array","some","unfold","len","array","isArray","ObservableV2","constructor","this","_observers","on","name","add","once","_f","args","off","observers","get","delete","emit","destroy","Observable","create","Set","getUnixTime","Date","now","EqualityTraitSymbol","Symbol","callAll","fs","id","equalityDeep","ArrayBuffer","Uint8Array","byteLength","value","has","Map","isOneOf","options","includes","floor","Math","abs","ceil","min","imul","round","log10","log2","log","sqrt","max","isNegativeZero","Number","isNaN","pow","sign","n","copy","m","r","v","k","set","setIfUndefined","map","createT","res","any"],"ignoreList":[],"sourceRoot":""}