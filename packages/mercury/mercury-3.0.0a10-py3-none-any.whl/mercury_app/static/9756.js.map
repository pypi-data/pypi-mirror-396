{"version":3,"file":"9756.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/cell-toolbar/lib/celltoolbartracker.js"],"sourcesContent":["/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { createDefaultFactory } from '@jupyterlab/apputils';\nimport { ObservableList } from '@jupyterlab/observables';\nimport { ReactWidget, Toolbar } from '@jupyterlab/ui-components';\nimport { some } from '@lumino/algorithm';\nimport { Signal } from '@lumino/signaling';\nimport { nullTranslator } from '@jupyterlab/translation';\n/*\n * Text mime types\n */\nconst TEXT_MIME_TYPES = [\n    'text/plain',\n    'application/vnd.jupyter.stdout',\n    'application/vnd.jupyter.stderr'\n];\n/**\n * Widget cell toolbar classes\n */\nconst CELL_TOOLBAR_CLASS = 'jp-cell-toolbar';\n// @deprecated to be removed\nconst CELL_MENU_CLASS = 'jp-cell-menu';\n/**\n * Class for a cell whose contents overlap with the cell toolbar\n */\nconst TOOLBAR_OVERLAP_CLASS = 'jp-toolbar-overlap';\n/**\n * Watch a notebook so that a cell toolbar appears on the active cell\n */\nexport class CellToolbarTracker {\n    /**\n     * CellToolbarTracker constructor\n     *\n     * @param panel The notebook panel\n     * @param toolbar The toolbar; deprecated use {@link toolbarFactory} instead\n     * @param toolbarFactory The toolbar factory\n     */\n    constructor(panel, toolbar, toolbarFactory, translator) {\n        this._isDisposed = false;\n        this._toolbar = null;\n        this._toolbarItems = null;\n        this._toolbarFactory = null;\n        this._panel = panel;\n        this._previousActiveCell = this._panel.content.activeCell;\n        this._toolbarItems = toolbar !== null && toolbar !== void 0 ? toolbar : null;\n        this._toolbarFactory = toolbarFactory !== null && toolbarFactory !== void 0 ? toolbarFactory : null;\n        this._enabled = true; // If this has been set to false, it will be modified after settings are available\n        this._trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab');\n        if (this._toolbarItems === null && this._toolbarFactory === null) {\n            throw Error('You must provide the toolbarFactory or the toolbar items.');\n        }\n        // deprecated to be removed when we remove toolbar from input arguments\n        if (!this._toolbarFactory && this._toolbarItems) {\n            this._onToolbarChanged();\n            this._toolbarItems.changed.connect(this._onToolbarChanged, this);\n        }\n        // Only add the toolbar to the notebook's active cell (if any) once it has fully rendered and been revealed.\n        void panel.revealed.then(() => {\n            requestAnimationFrame(() => {\n                const notebook = panel.content;\n                this._onActiveCellChanged(notebook);\n                // Handle subsequent changes of active cell.\n                notebook.activeCellChanged.connect(this._onActiveCellChanged, this);\n                // Check whether the toolbar should be rendered upon a layout change\n                notebook.renderingLayoutChanged.connect(this._onActiveCellChanged, this);\n                notebook.disposed.connect(() => {\n                    notebook.activeCellChanged.disconnect(this._onActiveCellChanged);\n                });\n            });\n        });\n    }\n    /**\n     * @deprecated Will become protected in JupyterLab 5\n     */\n    _onMetadataChanged(model, args) {\n        if (args.key === 'jupyter') {\n            if (typeof args.newValue === 'object' &&\n                args.newValue.source_hidden === true &&\n                (args.type === 'add' || args.type === 'change')) {\n                // Cell just became hidden; remove toolbar\n                this._removeToolbar(model);\n            }\n            // Check whether input visibility changed\n            else if (typeof args.oldValue === 'object' &&\n                args.oldValue.source_hidden === true) {\n                // Cell just became visible; add toolbar\n                this._addToolbar(model);\n            }\n        }\n    }\n    /**\n     * @deprecated Will become protected in JupyterLab 5\n     */\n    _onActiveCellChanged(notebook) {\n        if (this._previousActiveCell && !this._previousActiveCell.isDisposed) {\n            // Disposed cells do not have a model anymore.\n            this._removeToolbar(this._previousActiveCell.model);\n            this._previousActiveCell.model.metadataChanged.disconnect(this._onMetadataChanged);\n        }\n        const activeCell = notebook.activeCell;\n        // Change previously active cell.\n        this._previousActiveCell = activeCell;\n        if (activeCell === null || activeCell.inputHidden) {\n            return;\n        }\n        activeCell.model.metadataChanged.connect(this._onMetadataChanged, this);\n        this._addToolbar(activeCell.model);\n    }\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Whether the cell toolbar is shown, if there is enough room\n     */\n    get enabled() {\n        return this._enabled;\n    }\n    /**\n     * Sets whether the cell toolbar is shown, if there is enough room\n     */\n    set enabled(value) {\n        this._enabled = value;\n        this._onToolbarChanged();\n    }\n    dispose() {\n        var _a, _b;\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        (_a = this._toolbarItems) === null || _a === void 0 ? void 0 : _a.changed.disconnect(this._onToolbarChanged, this);\n        (_b = this._toolbar) === null || _b === void 0 ? void 0 : _b.dispose();\n        this._panel = null;\n        Signal.clearData(this);\n    }\n    _addToolbar(model) {\n        // Do nothing if the toolbar shouldn't be visible.\n        if (!this.enabled) {\n            return;\n        }\n        const cell = this._getCell(model);\n        if (cell && !cell.isDisposed) {\n            const toolbarWidget = (this._toolbar = new Toolbar());\n            // Note: CELL_MENU_CLASS is deprecated.\n            toolbarWidget.addClass(CELL_MENU_CLASS);\n            toolbarWidget.addClass(CELL_TOOLBAR_CLASS);\n            toolbarWidget.node.setAttribute('aria-label', this._trans.__('Cell toolbar'));\n            const promises = [cell.ready];\n            if (this._toolbarFactory) {\n                // Use our custom factory directly instead of setToolbar\n                const toolbarItems = this._toolbarFactory(cell);\n                for (const { name, widget } of toolbarItems) {\n                    toolbarWidget.addItem(name, widget);\n                    if (widget instanceof ReactWidget &&\n                        widget.renderPromise !== undefined) {\n                        widget.update();\n                        promises.push(widget.renderPromise);\n                    }\n                }\n            }\n            else {\n                for (const { name, widget } of this._toolbarItems) {\n                    toolbarWidget.addItem(name, widget);\n                    if (widget instanceof ReactWidget &&\n                        widget.renderPromise !== undefined) {\n                        widget.update();\n                        promises.push(widget.renderPromise);\n                    }\n                }\n            }\n            promises.push(cell.ready);\n            // Wait for all the buttons to be rendered before attaching the toolbar.\n            Promise.all(promises)\n                .then(() => {\n                var _a;\n                if (cell.isDisposed || ((_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.activeCell) !== cell) {\n                    toolbarWidget.dispose();\n                    return;\n                }\n                // Hide the toolbar by default, to avoid temporary overlapping.\n                cell.node.classList.add(TOOLBAR_OVERLAP_CLASS);\n                cell.inputArea.layout.insertWidget(0, toolbarWidget);\n                // For rendered markdown, watch for resize events.\n                cell.displayChanged.connect(this._resizeEventCallback, this);\n                // Watch for changes in the cell's contents.\n                cell.model.contentChanged.connect(this._changedEventCallback, this);\n                // Hide the cell toolbar if it overlaps with cell contents\n                this._updateCellForToolbarOverlap(cell);\n            })\n                .catch(e => {\n                console.error('Error rendering buttons of the cell toolbar: ', e);\n            });\n        }\n    }\n    _getCell(model) {\n        var _a;\n        return (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.widgets.find(widget => widget.model === model);\n    }\n    _removeToolbar(model) {\n        var _a, _b;\n        const cell = this._getCell(model);\n        if (cell && !cell.isDisposed) {\n            // Attempt to remove the resize and changed event handlers.\n            cell.displayChanged.disconnect(this._resizeEventCallback, this);\n        }\n        model.contentChanged.disconnect(this._changedEventCallback, this);\n        if (((_a = this._toolbar) === null || _a === void 0 ? void 0 : _a.parent) === (cell === null || cell === void 0 ? void 0 : cell.inputArea) &&\n            ((_b = this._toolbar) === null || _b === void 0 ? void 0 : _b.isDisposed) === false) {\n            this._toolbar.dispose();\n        }\n    }\n    /**\n     * Call back on settings changes\n     *\n     * @deprecated To remove when toolbar can not be provided directly to the tracker\n     */\n    _onToolbarChanged() {\n        var _a;\n        // Reset toolbar when settings changes\n        const activeCell = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n        if (activeCell) {\n            this._removeToolbar(activeCell.model);\n            this._addToolbar(activeCell.model);\n        }\n    }\n    _changedEventCallback() {\n        var _a;\n        const activeCell = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n        if (activeCell === null || activeCell === undefined) {\n            return;\n        }\n        this._updateCellForToolbarOverlap(activeCell);\n    }\n    _resizeEventCallback() {\n        var _a;\n        const activeCell = (_a = this._panel) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n        if (activeCell === null || activeCell === undefined) {\n            return;\n        }\n        this._updateCellForToolbarOverlap(activeCell);\n    }\n    _updateCellForToolbarOverlap(activeCell) {\n        // When we do change in cell, the browser might not have completed the layout\n        // update if we don't wait, resulting in the previous width being returned\n        // using `getBoundingClientRect().width` in later functions. This also wait for\n        // the toolbar to be rendered the first time (on page reload), allowing us to\n        // retrieve the right widgets width.\n        requestIdleCallback(() => {\n            // Remove the \"toolbar overlap\" class from the cell, rendering the cell's toolbar\n            const activeCellElement = activeCell.node;\n            activeCellElement.classList.remove(TOOLBAR_OVERLAP_CLASS);\n            if (this._cellToolbarOverlapsContents(activeCell)) {\n                // Add the \"toolbar overlap\" class to the cell, completely concealing the toolbar,\n                // if the first line of the content overlaps with it at all\n                activeCellElement.classList.add(TOOLBAR_OVERLAP_CLASS);\n            }\n        });\n    }\n    _cellToolbarOverlapsContents(activeCell) {\n        var _a, _b, _c, _d;\n        // Fail safe when the active cell is not ready yet\n        if (!activeCell.model) {\n            return false;\n        }\n        const cellType = activeCell.model.type;\n        // If the toolbar is too large for the current cell, hide it.\n        const editorRect = (_a = activeCell.editorWidget) === null || _a === void 0 ? void 0 : _a.node.getBoundingClientRect();\n        const cellLeft = (_b = editorRect === null || editorRect === void 0 ? void 0 : editorRect.left) !== null && _b !== void 0 ? _b : 0;\n        const cellRight = (_c = editorRect === null || editorRect === void 0 ? void 0 : editorRect.right) !== null && _c !== void 0 ? _c : 0;\n        const toolbarLeft = this._cellToolbarLeft(activeCell);\n        if (toolbarLeft === null) {\n            return false;\n        }\n        // The toolbar should not take up more than 50% of the cell.\n        if ((cellLeft + cellRight) / 2 > toolbarLeft) {\n            return true;\n        }\n        if (cellType === 'markdown' && activeCell.rendered) {\n            // Check for overlap in rendered markdown content\n            return this._markdownOverlapsToolbar(activeCell);\n        }\n        // Check for overlap in code content\n        if (((_d = this._panel) === null || _d === void 0 ? void 0 : _d.content.renderingLayout) === 'default') {\n            return this._codeOverlapsToolbar(activeCell);\n        }\n        else {\n            return this._outputOverlapsToolbar(activeCell);\n        }\n    }\n    /**\n     * Check for overlap between rendered Markdown and the cell toolbar\n     *\n     * @param activeCell A rendered MarkdownCell\n     * @returns `true` if the first line of the output overlaps with the cell toolbar, `false` otherwise\n     */\n    _markdownOverlapsToolbar(activeCell) {\n        const markdownOutput = activeCell.inputArea; // Rendered markdown appears in the input area\n        if (!markdownOutput) {\n            return false;\n        }\n        // Get the rendered markdown as a widget.\n        const markdownOutputWidget = markdownOutput.renderedInput;\n        const markdownOutputElement = markdownOutputWidget.node;\n        const firstOutputElementChild = markdownOutputElement.firstElementChild;\n        if (firstOutputElementChild === null) {\n            return false;\n        }\n        // Temporarily set the element's max width so that the bounding client rectangle only encompasses the content.\n        const oldMaxWidth = firstOutputElementChild.style.maxWidth;\n        firstOutputElementChild.style.maxWidth = 'max-content';\n        const lineRight = firstOutputElementChild.getBoundingClientRect().right;\n        // Reinstate the old max width.\n        firstOutputElementChild.style.maxWidth = oldMaxWidth;\n        const toolbarLeft = this._cellToolbarLeft(activeCell);\n        return toolbarLeft === null ? false : lineRight > toolbarLeft;\n    }\n    _outputOverlapsToolbar(activeCell) {\n        const outputArea = activeCell.outputArea.node;\n        if (outputArea) {\n            const outputs = outputArea.querySelectorAll('[data-mime-type]');\n            const toolbarRect = this._cellToolbarRect(activeCell);\n            if (toolbarRect) {\n                const { left: toolbarLeft, bottom: toolbarBottom } = toolbarRect;\n                return some(outputs, output => {\n                    const node = output.firstElementChild;\n                    if (node) {\n                        const range = new Range();\n                        if (TEXT_MIME_TYPES.includes(output.getAttribute('data-mime-type') || '')) {\n                            // If the node is plain text, it's in a <pre>. To get the true bounding box of the\n                            // text, the node contents need to be selected.\n                            range.selectNodeContents(node);\n                        }\n                        else {\n                            range.selectNode(node);\n                        }\n                        const { right: nodeRight, top: nodeTop } = range.getBoundingClientRect();\n                        // Note: y-coordinate increases toward the bottom of page\n                        return nodeRight > toolbarLeft && nodeTop < toolbarBottom;\n                    }\n                    return false;\n                });\n            }\n        }\n        return false;\n    }\n    _codeOverlapsToolbar(activeCell) {\n        const editorWidget = activeCell.editorWidget;\n        const editor = activeCell.editor;\n        if (!editorWidget || !editor) {\n            return false;\n        }\n        if (editor.lineCount < 1) {\n            return false; // Nothing in the editor\n        }\n        const codeMirrorLines = editorWidget.node.getElementsByClassName('cm-line');\n        if (codeMirrorLines.length < 1) {\n            return false; // No lines present\n        }\n        let lineRight = codeMirrorLines[0].getBoundingClientRect().left;\n        const range = document.createRange();\n        range.selectNodeContents(codeMirrorLines[0]);\n        lineRight += range.getBoundingClientRect().width;\n        const toolbarLeft = this._cellToolbarLeft(activeCell);\n        return toolbarLeft === null ? false : lineRight > toolbarLeft;\n    }\n    _cellToolbarRect(activeCell) {\n        var _a;\n        if (((_a = this._toolbar) === null || _a === void 0 ? void 0 : _a.parent) !== activeCell.inputArea) {\n            return null;\n        }\n        const activeCellToolbar = this._toolbar.node;\n        return activeCellToolbar.getBoundingClientRect();\n    }\n    _cellToolbarLeft(activeCell) {\n        var _a;\n        return ((_a = this._cellToolbarRect(activeCell)) === null || _a === void 0 ? void 0 : _a.left) || null;\n    }\n}\nconst defaultToolbarItems = [\n    {\n        command: 'notebook:duplicate-below',\n        name: 'duplicate-cell'\n    },\n    {\n        command: 'notebook:move-cell-up',\n        name: 'move-cell-up'\n    },\n    {\n        command: 'notebook:move-cell-down',\n        name: 'move-cell-down'\n    },\n    {\n        command: 'notebook:insert-cell-above',\n        name: 'insert-cell-above'\n    },\n    {\n        command: 'notebook:insert-cell-below',\n        name: 'insert-cell-below'\n    },\n    {\n        command: 'notebook:delete-cell',\n        name: 'delete-cell'\n    }\n];\n/**\n * Widget extension that creates a CellToolbarTracker each time a notebook is\n * created.\n */\nexport class CellBarExtension {\n    constructor(commands, toolbarFactory) {\n        this._commands = commands;\n        this._toolbarFactory = toolbarFactory !== null && toolbarFactory !== void 0 ? toolbarFactory : this.defaultToolbarFactory;\n    }\n    createItemFactory(commands) {\n        return createDefaultFactory(commands);\n    }\n    get defaultToolbarFactory() {\n        const itemFactory = this.createItemFactory(this._commands);\n        return (widget, commandArgs) => new ObservableList({\n            values: defaultToolbarItems.map(item => {\n                const itemWithArgs = commandArgs\n                    ? {\n                        ...item,\n                        args: { ...item.args, ...commandArgs }\n                    }\n                    : item;\n                return {\n                    name: item.name,\n                    widget: itemFactory(CellBarExtension.FACTORY_NAME, widget, itemWithArgs)\n                };\n            })\n        });\n    }\n    createNew(panel) {\n        // Create a factory that passes the widget ID to the toolbar factory\n        const factoryWithWidgetId = (widget) => {\n            return this._toolbarFactory(widget, {\n                [CellBarExtension.WIDGET_ID_ARG]: panel.id\n            });\n        };\n        return (this._tracker = new CellToolbarTracker(panel, undefined, factoryWithWidgetId));\n    }\n    /**\n     * Whether the cell toolbar is displayed, if there is enough room for it\n     */\n    get enabled() {\n        return this._tracker.enabled;\n    }\n    /**\n     * Sets whether the cell toolbar is displayed, if there is enough room for it\n     */\n    set enabled(value) {\n        if (this._tracker) {\n            this._tracker.enabled = value;\n        }\n    }\n}\nCellBarExtension.FACTORY_NAME = 'Cell';\nCellBarExtension.WIDGET_ID_ARG = 'widgetId';\n//# sourceMappingURL=celltoolbartracker.js.map"],"names":["TEXT_MIME_TYPES","TOOLBAR_OVERLAP_CLASS","CellToolbarTracker","constructor","panel","toolbar","toolbarFactory","translator","this","_isDisposed","_toolbar","_toolbarItems","_toolbarFactory","_panel","_previousActiveCell","content","activeCell","_enabled","_trans","nullTranslator","load","Error","_onToolbarChanged","changed","connect","revealed","then","requestAnimationFrame","notebook","_onActiveCellChanged","activeCellChanged","renderingLayoutChanged","disposed","disconnect","_onMetadataChanged","model","args","key","newValue","source_hidden","type","oldValue","_addToolbar","_removeToolbar","isDisposed","metadataChanged","inputHidden","enabled","value","dispose","_a","_b","Signal","clearData","cell","_getCell","toolbarWidget","Toolbar","addClass","node","setAttribute","__","promises","ready","toolbarItems","name","widget","addItem","ReactWidget","undefined","renderPromise","update","push","Promise","all","classList","add","inputArea","layout","insertWidget","displayChanged","_resizeEventCallback","contentChanged","_changedEventCallback","_updateCellForToolbarOverlap","catch","e","console","error","widgets","find","parent","requestIdleCallback","activeCellElement","remove","_cellToolbarOverlapsContents","_c","_d","cellType","editorRect","editorWidget","getBoundingClientRect","cellLeft","left","cellRight","right","toolbarLeft","_cellToolbarLeft","rendered","_markdownOverlapsToolbar","renderingLayout","_codeOverlapsToolbar","_outputOverlapsToolbar","markdownOutput","firstOutputElementChild","renderedInput","firstElementChild","oldMaxWidth","style","maxWidth","lineRight","outputArea","outputs","querySelectorAll","toolbarRect","_cellToolbarRect","bottom","toolbarBottom","some","output","range","Range","includes","getAttribute","selectNodeContents","selectNode","nodeRight","top","nodeTop","editor","lineCount","codeMirrorLines","getElementsByClassName","length","document","createRange","width","defaultToolbarItems","command","CellBarExtension","commands","_commands","defaultToolbarFactory","createItemFactory","createDefaultFactory","itemFactory","commandArgs","ObservableList","values","map","item","itemWithArgs","FACTORY_NAME","createNew","_tracker","WIDGET_ID_ARG","id"],"ignoreList":[],"sourceRoot":""}