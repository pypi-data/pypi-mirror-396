use pi_lang::{DetectionConfig, ToolType, ToolchainType};
use pi_lang_rust::detect_rust_projects;
use std::fs;
use std::path::Path;
use tempfile::TempDir;

#[test]
fn test_detect_simple_rust_project() {
    let temp_dir = TempDir::new().unwrap();
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    assert!(!project.tools.is_empty());

    let cargo_tool = project.tools.iter().find(|t| t.name == "cargo").unwrap();
    assert_eq!(cargo_tool.tool_type, ToolType::Manager);
    assert!(cargo_tool.confidence >= 0.95);
}

#[test]
fn test_detect_rust_project_with_lockfile() {
    let temp_dir = TempDir::new().unwrap();
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();
    fs::write(temp_dir.path().join("Cargo.lock"), "# Generated by Cargo").unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    let cargo_tools: Vec<_> = project.tools.iter().filter(|t| t.name == "cargo").collect();

    // Should have high confidence tool from lockfile
    let lockfile_tool = cargo_tools
        .iter()
        .find(|t| t.evidence.contains(&"Cargo.lock".to_string()));
    assert!(lockfile_tool.is_some());
    assert!(lockfile_tool.unwrap().confidence >= 0.98);
}

#[test]
fn test_no_rust_project() {
    let temp_dir = TempDir::new().unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 0);
}

#[test]
fn test_workspace_detection() {
    let temp_dir = TempDir::new().unwrap();
    let workspace_cargo = r#"
[workspace]
members = ["crate1", "crate2"]
resolver = "2"

[workspace.dependencies]
serde = "1.0"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), workspace_cargo).unwrap();

    // Create workspace members with proper source files
    fs::create_dir_all(temp_dir.path().join("crate1/src")).unwrap();
    fs::write(
        temp_dir.path().join("crate1/Cargo.toml"),
        r#"
[package]
name = "crate1"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(temp_dir.path().join("crate1/src/lib.rs"), "").unwrap();

    fs::create_dir_all(temp_dir.path().join("crate2/src")).unwrap();
    fs::write(
        temp_dir.path().join("crate2/Cargo.toml"),
        r#"
[package]
name = "crate2"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(temp_dir.path().join("crate2/src/lib.rs"), "").unwrap();

    // Use config with max_depth to ensure we scan subdirectories
    let config = DetectionConfig {
        max_depth: 2,
        ..Default::default()
    };

    let projects = detect_rust_projects(temp_dir.path(), Some(&config)).unwrap();
    assert_eq!(
        projects.len(),
        1,
        "Should detect only workspace root, got: {:?}",
        projects
            .iter()
            .map(|p| &p.workspace.root)
            .collect::<Vec<_>>()
    );

    let project = &projects[0];
    // Use canonicalized paths for comparison
    let expected_root = temp_dir.path().canonicalize().unwrap();
    let actual_root = project
        .workspace
        .root
        .canonicalize()
        .unwrap_or_else(|_| project.workspace.root.clone());
    assert_eq!(actual_root, expected_root);
    assert!(
        !project.workspace.members.is_empty(),
        "Workspace should have members"
    );
}

#[test]
fn test_invalid_cargo_toml() {
    let temp_dir = TempDir::new().unwrap();
    let invalid_cargo_content = r#"
[package
name = "invalid-toml"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), invalid_cargo_content).unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    // Should still detect as Rust project even if metadata parsing fails
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    assert!(!project.tools.is_empty());
}

#[test]
fn test_on_actual_pi_project() {
    // Test detection on the actual Pi project
    let current_dir = std::env::current_dir().unwrap();
    let project_root = current_dir
        .ancestors()
        .find(|path| path.join("Cargo.toml").exists())
        .expect("Could not find Cargo.toml in project hierarchy");

    let projects = detect_rust_projects(project_root, None).unwrap();
    assert_eq!(projects.len(), 1, "Should detect the Pi project");

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);

    // Should detect cargo
    assert!(
        project.tools.iter().any(|t| t.name == "cargo"),
        "Should detect cargo tool"
    );

    // Should have workspace members (this is a workspace project)
    assert!(
        !project.workspace.members.is_empty(),
        "Pi project should have workspace members"
    );
}

#[test]
fn test_from_subdirectory() {
    // Create a temporary project structure for testing
    let temp_dir = TempDir::new().unwrap();

    // Create workspace root
    fs::write(
        temp_dir.path().join("Cargo.toml"),
        r#"
[workspace]
members = ["member1"]

[workspace.dependencies]
serde = "1.0"
"#,
    )
    .unwrap();

    // Create workspace member with proper source files
    let member_dir = temp_dir.path().join("member1");
    fs::create_dir_all(member_dir.join("src")).unwrap();
    fs::write(
        member_dir.join("Cargo.toml"),
        r#"
[package]
name = "member1"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(member_dir.join("src/lib.rs"), "").unwrap();

    // Get the src directory (already created above)
    let src_dir = member_dir.join("src");

    // Try to detect from the src subdirectory
    let projects = detect_rust_projects(&src_dir, None).unwrap();

    // Should find the workspace root, not be empty
    assert_eq!(
        projects.len(),
        1,
        "Should detect workspace root from subdirectory"
    );
    let project = &projects[0];
    // Use canonicalized paths for comparison to handle symlinks
    let expected_root = temp_dir.path().canonicalize().unwrap();
    let actual_root = project
        .workspace
        .root
        .canonicalize()
        .unwrap_or_else(|_| project.workspace.root.clone());
    assert_eq!(actual_root, expected_root);
}

#[test]
fn test_multiple_rust_projects_in_subdirectories() {
    let temp_dir = TempDir::new().unwrap();

    // Create multiple Rust projects in subdirectories with proper source files
    let project1_dir = temp_dir.path().join("project1");
    fs::create_dir_all(project1_dir.join("src")).unwrap();
    fs::write(
        project1_dir.join("Cargo.toml"),
        r#"
[package]
name = "project1"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(project1_dir.join("src/lib.rs"), "").unwrap();

    let project2_dir = temp_dir.path().join("subdir").join("project2");
    fs::create_dir_all(project2_dir.join("src")).unwrap();
    fs::write(
        project2_dir.join("Cargo.toml"),
        r#"
[package]
name = "project2"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(project2_dir.join("src/lib.rs"), "").unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 2, "Should detect both Rust projects");

    let project_names: Vec<_> = projects
        .iter()
        .map(|p| p.workspace.root.file_name().unwrap().to_str().unwrap())
        .collect();
    assert!(project_names.contains(&"project1"));
    assert!(project_names.contains(&"project2"));
}

#[test]
fn test_custom_detection_config() {
    let temp_dir = TempDir::new().unwrap();

    // Create a project in a directory that we'll configure to skip
    let skip_dir = temp_dir.path().join("skip_me");
    fs::create_dir_all(skip_dir.join("src")).unwrap();
    fs::write(
        skip_dir.join("Cargo.toml"),
        r#"
[package]
name = "should-be-skipped"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(skip_dir.join("src/lib.rs"), "").unwrap();

    // Create a normal project
    let normal_dir = temp_dir.path().join("normal");
    fs::create_dir_all(normal_dir.join("src")).unwrap();
    fs::write(
        normal_dir.join("Cargo.toml"),
        r#"
[package]
name = "normal-project"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(normal_dir.join("src/lib.rs"), "").unwrap();

    // Test with custom config that skips the directory
    let mut config = DetectionConfig::default();
    config.skip_dirs.push("skip_me".to_string());
    config.max_depth = 2;

    let projects = detect_rust_projects(temp_dir.path(), Some(&config)).unwrap();
    assert_eq!(projects.len(), 1, "Should only detect the normal project");

    let project = &projects[0];
    assert!(project.workspace.root.ends_with("normal"));
}

#[test]
fn test_workspace_member_filtering() {
    let temp_dir = TempDir::new().unwrap();

    // Create a workspace root
    fs::write(
        temp_dir.path().join("Cargo.toml"),
        r#"
[workspace]
members = ["member1", "member2"]
resolver = "2"

[workspace.dependencies]
serde = "1.0"
"#,
    )
    .unwrap();

    // Create workspace members with proper source files
    let member1_dir = temp_dir.path().join("member1");
    fs::create_dir_all(member1_dir.join("src")).unwrap();
    fs::write(
        member1_dir.join("Cargo.toml"),
        r#"
[package]
name = "member1"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(member1_dir.join("src/lib.rs"), "").unwrap();

    let member2_dir = temp_dir.path().join("member2");
    fs::create_dir_all(member2_dir.join("src")).unwrap();
    fs::write(
        member2_dir.join("Cargo.toml"),
        r#"
[package]
name = "member2"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(member2_dir.join("src/lib.rs"), "").unwrap();

    // Use a config with max_depth to ensure we scan the subdirectories
    let config = DetectionConfig {
        max_depth: 2,
        ..Default::default()
    };

    let projects = detect_rust_projects(temp_dir.path(), Some(&config)).unwrap();
    // Should detect only the workspace root, not the individual members
    assert_eq!(
        projects.len(),
        1,
        "Should detect only workspace root, got: {:?}",
        projects
            .iter()
            .map(|p| &p.workspace.root)
            .collect::<Vec<_>>()
    );

    let project = &projects[0];
    // Use canonicalized paths for comparison
    let expected_root = temp_dir.path().canonicalize().unwrap();
    let actual_root = project
        .workspace
        .root
        .canonicalize()
        .unwrap_or_else(|_| project.workspace.root.clone());
    assert_eq!(actual_root, expected_root);
    assert!(
        !project.workspace.members.is_empty(),
        "Workspace should have members"
    );
}

#[test]
fn test_max_depth_limiting() {
    let temp_dir = TempDir::new().unwrap();

    // Create nested Rust projects with proper source files
    let shallow_dir = temp_dir.path().join("shallow");
    fs::create_dir_all(shallow_dir.join("src")).unwrap();
    fs::write(
        shallow_dir.join("Cargo.toml"),
        r#"
[package]
name = "shallow"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(shallow_dir.join("src/lib.rs"), "").unwrap();

    let deep_dir = temp_dir.path().join("level1").join("level2").join("deep");
    fs::create_dir_all(deep_dir.join("src")).unwrap();
    fs::write(
        deep_dir.join("Cargo.toml"),
        r#"
[package]
name = "deep"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(deep_dir.join("src/lib.rs"), "").unwrap();

    // Test with max_depth = 1 (should only find shallow project)
    let config = DetectionConfig {
        max_depth: 1,
        ..Default::default()
    };

    let projects = detect_rust_projects(temp_dir.path(), Some(&config)).unwrap();
    assert_eq!(projects.len(), 1, "Should only find shallow project");

    let project = &projects[0];
    assert!(project.workspace.root.ends_with("shallow"));
}

#[test]
fn test_detection_config_integration() {
    let temp_dir = TempDir::new().unwrap();

    // Create multiple projects at different depths
    let shallow_project = temp_dir.path().join("shallow");
    fs::create_dir_all(shallow_project.join("src")).unwrap();
    fs::write(
        shallow_project.join("Cargo.toml"),
        r#"
[package]
name = "shallow"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(shallow_project.join("src/lib.rs"), "").unwrap();

    let deep_project = temp_dir.path().join("level1").join("level2").join("deep");
    fs::create_dir_all(deep_project.join("src")).unwrap();
    fs::write(
        deep_project.join("Cargo.toml"),
        r#"
[package]
name = "deep"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(deep_project.join("src/lib.rs"), "").unwrap();

    let skip_project = temp_dir.path().join("skip_this");
    fs::create_dir_all(skip_project.join("src")).unwrap();
    fs::write(
        skip_project.join("Cargo.toml"),
        r#"
[package]
name = "skip_this"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(skip_project.join("src/lib.rs"), "").unwrap();

    // Test with default config (should find all)
    let projects_default = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(
        projects_default.len(),
        3,
        "Default config should find all projects"
    );

    // Test with limited depth
    let config_limited = DetectionConfig {
        max_depth: 1,
        ..Default::default()
    };
    let projects_limited = detect_rust_projects(temp_dir.path(), Some(&config_limited)).unwrap();
    assert_eq!(
        projects_limited.len(),
        2,
        "Limited depth should exclude deep project"
    );

    // Test with skip directory
    let mut config_skip = DetectionConfig::default();
    config_skip.skip_dirs.push("skip_this".to_string());
    let projects_skip = detect_rust_projects(temp_dir.path(), Some(&config_skip)).unwrap();
    assert_eq!(
        projects_skip.len(),
        2,
        "Skip config should exclude skip_this project"
    );

    // Test with both limitations
    let mut config_both = DetectionConfig {
        max_depth: 1,
        ..Default::default()
    };
    config_both.skip_dirs.push("skip_this".to_string());
    let projects_both = detect_rust_projects(temp_dir.path(), Some(&config_both)).unwrap();
    assert_eq!(
        projects_both.len(),
        1,
        "Combined config should find only shallow project"
    );

    let remaining_project = &projects_both[0];
    assert!(remaining_project.workspace.root.ends_with("shallow"));
}

#[test]
fn test_lenient_error_handling_nonexistent_directory() {
    let nonexistent_path = Path::new("/this/path/definitely/does/not/exist");
    let result = detect_rust_projects(nonexistent_path, None);

    // Should return an error for non-existent top-level directory
    assert!(result.is_err());
    let error = result.err().unwrap();
    assert!(error.to_string().contains("Directory does not exist"));
}

#[test]
fn test_lenient_error_handling_file_instead_of_directory() {
    let temp_dir = TempDir::new().unwrap();
    let file_path = temp_dir.path().join("not_a_directory.txt");
    fs::write(&file_path, "This is a file, not a directory").unwrap();

    let result = detect_rust_projects(&file_path, None);

    // Should return an error when given a file instead of directory
    assert!(result.is_err());
    let error = result.err().unwrap();
    assert!(error.to_string().contains("Path is not a directory"));
}

#[test]
fn test_lenient_error_handling_continues_on_internal_errors() {
    let temp_dir = TempDir::new().unwrap();

    // Create a valid project
    fs::write(
        temp_dir.path().join("Cargo.toml"),
        r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(temp_dir.path().join("Cargo.lock"), "# Generated by Cargo").unwrap();

    // Create a subdirectory with permission issues (on Unix systems)
    let problematic_dir = temp_dir.path().join("problematic");
    fs::create_dir(&problematic_dir).unwrap();

    // Create a Cargo.toml in the problematic directory
    fs::write(
        problematic_dir.join("Cargo.toml"),
        r#"
[package]
name = "problematic-project"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();

    // Make the directory unreadable (this will cause errors during scanning)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&problematic_dir).unwrap().permissions();
        perms.set_mode(0o000); // No permissions
        fs::set_permissions(&problematic_dir, perms).unwrap();
    }

    // Detection should succeed despite internal errors
    let result = detect_rust_projects(temp_dir.path(), None);

    // Restore permissions for cleanup
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&problematic_dir).unwrap().permissions();
        perms.set_mode(0o755); // Full permissions
        fs::set_permissions(&problematic_dir, perms).unwrap();
    }

    // Should succeed and detect at least the main project
    assert!(result.is_ok());
    let projects = result.unwrap();
    assert!(!projects.is_empty());

    // Should detect cargo from the main directory
    let main_project = &projects[0];
    assert!(
        main_project
            .tools
            .iter()
            .map(|t| t.name.as_str())
            .any(|x| x == "cargo")
    );
}

#[test]
fn test_lenient_error_handling_invalid_cargo_toml_content() {
    let temp_dir = TempDir::new().unwrap();

    // Create a valid Cargo.lock
    fs::write(temp_dir.path().join("Cargo.lock"), "# Generated by Cargo").unwrap();

    // Create an invalid Cargo.toml that will cause parsing errors
    fs::write(
        temp_dir.path().join("Cargo.toml"),
        r#"
[package
name = "test-project" # This is invalid TOML - missing closing bracket
version = "0.1.0"
"#,
    )
    .unwrap();

    // Detection should continue despite TOML parsing errors
    let result = detect_rust_projects(temp_dir.path(), None);
    assert!(result.is_ok());

    let projects = result.unwrap();
    assert!(!projects.is_empty());

    // Should still detect cargo (even if metadata parsing fails)
    let project = &projects[0];
    assert!(
        project
            .tools
            .iter()
            .map(|t| t.name.as_str())
            .any(|x| x == "cargo")
    );
}

#[test]
fn test_lenient_error_handling_empty_directory() {
    let temp_dir = TempDir::new().unwrap();

    // Detection on empty directory should succeed but find nothing
    let result = detect_rust_projects(temp_dir.path(), None);
    assert!(result.is_ok());

    let projects = result.unwrap();
    assert!(projects.is_empty());
}

#[test]
fn test_lenient_error_handling_invalid_rust_toolchain() {
    let temp_dir = TempDir::new().unwrap();

    // Create a valid Cargo.toml
    fs::write(
        temp_dir.path().join("Cargo.toml"),
        r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();

    // Create an invalid rust-toolchain.toml
    fs::write(
        temp_dir.path().join("rust-toolchain.toml"),
        r#"
[toolchain
channel = "invalid toml
"#,
    )
    .unwrap();

    // Detection should succeed despite rust-toolchain parsing errors
    let result = detect_rust_projects(temp_dir.path(), None);
    assert!(result.is_ok());

    let projects = result.unwrap();
    assert!(!projects.is_empty());

    // Should detect cargo but no toolchain environments due to parsing error
    let project = &projects[0];
    assert!(
        project
            .tools
            .iter()
            .map(|t| t.name.as_str())
            .any(|x| x == "cargo")
    );
    assert_eq!(project.toolchain_envs.len(), 0);
}

#[test]
fn test_rust_toolchain_toml_detection() {
    let temp_dir = TempDir::new().unwrap();

    // Create a basic Cargo.toml
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    // Create rust-toolchain.toml
    let toolchain_content = r#"
[toolchain]
channel = "1.70.0"
components = [ "rustfmt", "clippy" ]
targets = [ "wasm32-unknown-unknown" ]
profile = "minimal"
"#;
    fs::write(
        temp_dir.path().join("rust-toolchain.toml"),
        toolchain_content,
    )
    .unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    assert_eq!(project.toolchain_envs.len(), 1);

    let toolchain_env = &project.toolchain_envs[0];
    assert_eq!(toolchain_env.version.as_ref(), Some(&"1.70.0".to_string()));
    assert_eq!(
        toolchain_env.project.as_ref(),
        Some(&temp_dir.path().to_path_buf())
    );
}

#[test]
fn test_rust_toolchain_legacy_detection() {
    let temp_dir = TempDir::new().unwrap();

    // Create a basic Cargo.toml
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    // Create legacy rust-toolchain file
    fs::write(temp_dir.path().join("rust-toolchain"), "stable").unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    assert_eq!(project.toolchain_envs.len(), 1);

    let toolchain_env = &project.toolchain_envs[0];
    assert_eq!(toolchain_env.version.as_ref(), Some(&"stable".to_string()));
    assert_eq!(
        toolchain_env.project.as_ref(),
        Some(&temp_dir.path().to_path_buf())
    );
}

#[test]
fn test_rust_toolchain_priority() {
    let temp_dir = TempDir::new().unwrap();

    // Create a basic Cargo.toml
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    // Create both rust-toolchain.toml and rust-toolchain
    let toolchain_toml_content = r#"
[toolchain]
channel = "1.70.0"
"#;
    fs::write(
        temp_dir.path().join("rust-toolchain.toml"),
        toolchain_toml_content,
    )
    .unwrap();
    fs::write(temp_dir.path().join("rust-toolchain"), "stable").unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    // Should only have one toolchain env (TOML takes priority)
    assert_eq!(project.toolchain_envs.len(), 1);

    let toolchain_env = &project.toolchain_envs[0];
    assert_eq!(toolchain_env.version.as_ref(), Some(&"1.70.0".to_string()));
}

#[test]
fn test_invalid_rust_toolchain_file() {
    let temp_dir = TempDir::new().unwrap();

    // Create a basic Cargo.toml
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    // Create invalid rust-toolchain.toml
    let invalid_toolchain_content = r#"
[toolchain
channel = "invalid
"#;
    fs::write(
        temp_dir.path().join("rust-toolchain.toml"),
        invalid_toolchain_content,
    )
    .unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    // Should still detect the project but without toolchain envs
    assert_eq!(project.toolchain_envs.len(), 0);
}

#[test]
fn test_no_rust_toolchain_file() {
    let temp_dir = TempDir::new().unwrap();

    // Create a basic Cargo.toml
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    // Should detect the project but without toolchain envs
    assert_eq!(project.toolchain_envs.len(), 0);
}

#[test]
fn test_rust_version_constraint() {
    let temp_dir = TempDir::new().unwrap();

    // Create a Cargo.toml with rust-version constraint
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
rust-version = "1.70"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    assert_eq!(
        project.toolchain_version_constraint,
        Some("1.70".to_string())
    );
}

#[test]
fn test_rust_workspace_version_constraint() {
    let temp_dir = TempDir::new().unwrap();

    // Create a simple Cargo.toml with workspace.package.rust-version constraint
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"

[workspace]
members = []

[workspace.package]
rust-version = "1.75"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    assert_eq!(
        project.toolchain_version_constraint,
        Some("1.75".to_string())
    );
}

#[test]
fn test_rust_no_version_constraint() {
    let temp_dir = TempDir::new().unwrap();

    // Create a Cargo.toml without rust-version constraint
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    assert_eq!(project.toolchain_version_constraint, None);
}

#[test]
fn test_rust_toolchain_toml_as_version_constraint() {
    let temp_dir = TempDir::new().unwrap();

    // Create a Cargo.toml without rust-version
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    // Create rust-toolchain.toml with version
    let toolchain_content = r#"
[toolchain]
channel = "1.75.0"
components = [ "rustfmt", "clippy" ]
"#;
    fs::write(
        temp_dir.path().join("rust-toolchain.toml"),
        toolchain_content,
    )
    .unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    // Should use version from rust-toolchain.toml since no rust-version in Cargo.toml
    assert_eq!(
        project.toolchain_version_constraint,
        Some("1.75.0".to_string())
    );
}

#[test]
fn test_rust_version_priority_over_toolchain() {
    let temp_dir = TempDir::new().unwrap();

    // Create a Cargo.toml with rust-version
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
rust-version = "1.70"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    // Create rust-toolchain.toml with different version
    let toolchain_content = r#"
[toolchain]
channel = "1.75.0"
"#;
    fs::write(
        temp_dir.path().join("rust-toolchain.toml"),
        toolchain_content,
    )
    .unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    // Should prefer rust-version from Cargo.toml over rust-toolchain.toml
    assert_eq!(
        project.toolchain_version_constraint,
        Some("1.70".to_string())
    );
}

#[test]
fn test_rust_toolchain_legacy_as_version_constraint() {
    let temp_dir = TempDir::new().unwrap();

    // Create a Cargo.toml without rust-version
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    // Create legacy rust-toolchain file with version
    fs::write(temp_dir.path().join("rust-toolchain"), "1.73.0").unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    // Should use version from legacy rust-toolchain file since no rust-version in Cargo.toml
    assert_eq!(
        project.toolchain_version_constraint,
        Some("1.73.0".to_string())
    );
}

#[test]
fn test_rust_project_name_and_description() {
    let temp_dir = TempDir::new().unwrap();

    // Test basic package with name and description
    let cargo_content = r#"
[package]
name = "my-awesome-project"
version = "0.1.0"
edition = "2021"
description = "A really awesome Rust project that does amazing things"
authors = ["Test Author <test@example.com>"]
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);
    assert_eq!(project.name, Some("my-awesome-project".to_string()));
    assert_eq!(
        project.description,
        Some("A really awesome Rust project that does amazing things".to_string())
    );
}

#[test]
fn test_rust_project_name_only() {
    let temp_dir = TempDir::new().unwrap();

    // Test package with name but no description
    let cargo_content = r#"
[package]
name = "simple-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.name, Some("simple-project".to_string()));
    assert_eq!(project.description, None);
}

#[test]
fn test_rust_workspace_name_and_description() {
    let temp_dir = TempDir::new().unwrap();

    // Test workspace with workspace-level metadata
    let workspace_cargo = r#"
[workspace]
members = ["crate1"]
resolver = "2"

[workspace.package]
name = "workspace-project"
description = "A workspace containing multiple crates"
version = "1.0.0"
edition = "2021"

[workspace.dependencies]
serde = "1.0"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), workspace_cargo).unwrap();

    // Create workspace member
    fs::create_dir_all(temp_dir.path().join("crate1/src")).unwrap();
    fs::write(
        temp_dir.path().join("crate1/Cargo.toml"),
        r#"
[package]
name = "crate1"
version = "0.1.0"
edition = "2021"
description = "First crate in workspace"
"#,
    )
    .unwrap();
    fs::write(temp_dir.path().join("crate1/src/lib.rs"), "").unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();

    // May detect 1 or 2 projects depending on workspace filtering logic
    assert!(!projects.is_empty());

    let temp_canonical = temp_dir.path().canonicalize().unwrap();

    // Find the workspace root project
    let workspace_project = projects
        .iter()
        .find(|p| {
            let project_canonical = p
                .workspace
                .root
                .canonicalize()
                .unwrap_or_else(|_| p.workspace.root.clone());
            project_canonical == temp_canonical
        })
        .expect("Should find workspace root project");

    // Should get workspace metadata or fallback to directory name
    assert!(workspace_project.name.is_some());

    // For workspace, we expect the directory name since workspace.package.name doesn't exist
    let expected_name = temp_dir
        .path()
        .file_name()
        .and_then(|n| n.to_str())
        .map(std::string::ToString::to_string);

    assert_eq!(workspace_project.name, expected_name);

    // Description should be from workspace.package if available
    assert_eq!(
        workspace_project.description,
        Some("A workspace containing multiple crates".to_string())
    );
}

#[test]
#[allow(clippy::too_many_lines)]
fn test_rust_version_constraint_comprehensive() {
    let temp_dir = TempDir::new().unwrap();

    // Test 1: rust-version in Cargo.toml takes priority
    let subdir1 = temp_dir.path().join("priority_test");
    fs::create_dir_all(&subdir1).unwrap();
    fs::write(
        subdir1.join("Cargo.toml"),
        r#"
[package]
name = "priority-test"
version = "0.1.0"
edition = "2021"
rust-version = "1.70"
"#,
    )
    .unwrap();
    fs::write(
        subdir1.join("rust-toolchain.toml"),
        r#"
[toolchain]
channel = "1.75.0"
"#,
    )
    .unwrap();

    // Test 2: rust-toolchain.toml used when no rust-version
    let subdir2 = temp_dir.path().join("fallback_toml");
    fs::create_dir_all(&subdir2).unwrap();
    fs::write(
        subdir2.join("Cargo.toml"),
        r#"
[package]
name = "fallback-toml"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(
        subdir2.join("rust-toolchain.toml"),
        r#"
[toolchain]
channel = "1.72"
"#,
    )
    .unwrap();

    // Test 3: legacy rust-toolchain used when no rust-version and no rust-toolchain.toml
    let subdir3 = temp_dir.path().join("fallback_legacy");
    fs::create_dir_all(&subdir3).unwrap();
    fs::write(
        subdir3.join("Cargo.toml"),
        r#"
[package]
name = "fallback-legacy"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(subdir3.join("rust-toolchain"), "stable").unwrap();

    // Test 4: no version constraint when neither is present
    let subdir4 = temp_dir.path().join("no_constraint");
    fs::create_dir_all(&subdir4).unwrap();
    fs::write(
        subdir4.join("Cargo.toml"),
        r#"
[package]
name = "no-constraint"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();

    // Test each subdirectory
    let config = DetectionConfig {
        max_depth: 2,
        ..Default::default()
    };

    let projects = detect_rust_projects(temp_dir.path(), Some(&config)).unwrap();
    assert_eq!(projects.len(), 4);

    // Find each project and verify its version constraint
    for project in &projects {
        let project_name = project
            .workspace
            .root
            .file_name()
            .unwrap()
            .to_str()
            .unwrap();
        match project_name {
            "priority_test" => {
                assert_eq!(
                    project.toolchain_version_constraint,
                    Some("1.70".to_string())
                );
            }
            "fallback_toml" => {
                assert_eq!(
                    project.toolchain_version_constraint,
                    Some("1.72".to_string())
                );
            }
            "fallback_legacy" => {
                assert_eq!(
                    project.toolchain_version_constraint,
                    Some("stable".to_string())
                );
            }
            "no_constraint" => {
                assert_eq!(project.toolchain_version_constraint, None);
            }
            _ => panic!("Unexpected project: {project_name}"),
        }
    }
}

#[test]
fn test_devtools_detection_integration() {
    let temp_dir = TempDir::new().unwrap();

    // Create a comprehensive Rust project with dev tool config files
    let cargo_content = r#"
[package]
name = "test-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();
    fs::write(temp_dir.path().join("Cargo.lock"), "# Generated by Cargo").unwrap();

    // Create dev tool configuration files
    fs::write(
        temp_dir.path().join("rustfmt.toml"),
        "max_width = 100\ntab_spaces = 2\n",
    )
    .unwrap();
    fs::write(
        temp_dir.path().join("clippy.toml"),
        "cyclomatic-complexity-threshold = 25\n",
    )
    .unwrap();
    fs::write(
        temp_dir.path().join("deny.toml"),
        "[licenses]\nallow = [\"MIT\", \"Apache-2.0\"]\n",
    )
    .unwrap();
    fs::write(
        temp_dir.path().join("nextest.toml"),
        "[profile.default]\nretries = 2\n",
    )
    .unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);

    // Should detect cargo as primary manager
    assert!(project.tools.iter().any(|t| t.name == "cargo"));

    // Should detect formatting and diagnostic tools
    let tool_names: Vec<&str> = project.tools.iter().map(|t| t.name.as_str()).collect();
    assert!(tool_names.contains(&"rustfmt"));
    assert!(tool_names.contains(&"clippy"));
    assert!(tool_names.contains(&"cargo-deny"));
    assert!(tool_names.contains(&"cargo-nextest"));

    // Verify tool types are correct
    let rustfmt_tool = project.tools.iter().find(|t| t.name == "rustfmt").unwrap();
    assert_eq!(rustfmt_tool.tool_type, ToolType::Formatter);
    assert!((rustfmt_tool.confidence - 0.95).abs() < f64::EPSILON); // High confidence due to config file

    let clippy_tool = project.tools.iter().find(|t| t.name == "clippy").unwrap();
    assert_eq!(clippy_tool.tool_type, ToolType::Diagnostic);
    assert!((clippy_tool.confidence - 0.95).abs() < f64::EPSILON); // High confidence due to config file

    let deny_tool = project
        .tools
        .iter()
        .find(|t| t.name == "cargo-deny")
        .unwrap();
    assert_eq!(deny_tool.tool_type, ToolType::Diagnostic);
    assert!((deny_tool.confidence - 0.95).abs() < f64::EPSILON);

    let nextest_tool = project
        .tools
        .iter()
        .find(|t| t.name == "cargo-nextest")
        .unwrap();
    assert_eq!(nextest_tool.tool_type, ToolType::Testing);
    assert!((nextest_tool.confidence - 0.95).abs() < f64::EPSILON);

    // Verify evidence is provided
    assert!(rustfmt_tool.evidence.contains(&"rustfmt.toml".to_string()));
    assert!(clippy_tool.evidence.contains(&"clippy.toml".to_string()));
    assert!(deny_tool.evidence.contains(&"deny.toml".to_string()));
    assert!(nextest_tool.evidence.contains(&"nextest.toml".to_string()));
}

#[test]
fn test_implied_devtools_without_config_files() {
    let temp_dir = TempDir::new().unwrap();

    // Create a basic Rust project without explicit dev tool config files
    let cargo_content = r#"
[package]
name = "basic-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);

    // Should detect implied rustfmt and clippy tools
    let tool_names: Vec<&str> = project.tools.iter().map(|t| t.name.as_str()).collect();
    assert!(tool_names.contains(&"cargo"));
    assert!(tool_names.contains(&"rustfmt"));
    assert!(tool_names.contains(&"clippy"));

    // Implied tools should have lower confidence
    let rustfmt_tool = project.tools.iter().find(|t| t.name == "rustfmt").unwrap();
    assert_eq!(rustfmt_tool.tool_type, ToolType::Formatter);
    assert!((rustfmt_tool.confidence - 0.80).abs() < f64::EPSILON); // Lower confidence for implied tools

    let clippy_tool = project.tools.iter().find(|t| t.name == "clippy").unwrap();
    assert_eq!(clippy_tool.tool_type, ToolType::Diagnostic);
    assert!((clippy_tool.confidence - 0.80).abs() < f64::EPSILON); // Lower confidence for implied tools

    // Verify evidence shows they are implied
    assert!(rustfmt_tool.evidence.iter().any(|e| e.contains("implied")));
    assert!(clippy_tool.evidence.iter().any(|e| e.contains("implied")));
}

#[test]
fn test_devtools_confidence_bump_with_config_files() {
    let temp_dir = TempDir::new().unwrap();

    // Create a Rust project with some config files
    let cargo_content = r#"
[package]
name = "config-project"
version = "0.1.0"
edition = "2021"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), cargo_content).unwrap();

    // Create only rustfmt config (not clippy)
    fs::write(temp_dir.path().join("rustfmt.toml"), "max_width = 120\n").unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1);

    let project = &projects[0];

    // Should have both rustfmt and clippy
    let tool_names: Vec<&str> = project.tools.iter().map(|t| t.name.as_str()).collect();
    assert!(tool_names.contains(&"rustfmt"));
    assert!(tool_names.contains(&"clippy"));

    // rustfmt should have high confidence due to config file
    let rustfmt_tool = project.tools.iter().find(|t| t.name == "rustfmt").unwrap();
    assert!((rustfmt_tool.confidence - 0.95).abs() < f64::EPSILON);
    assert!(rustfmt_tool.evidence.contains(&"rustfmt.toml".to_string()));

    // clippy should have implied confidence (no config file)
    let clippy_tool = project.tools.iter().find(|t| t.name == "clippy").unwrap();
    assert!((clippy_tool.confidence - 0.80).abs() < f64::EPSILON);
    assert!(clippy_tool.evidence.iter().any(|e| e.contains("implied")));
}

#[test]
#[allow(clippy::too_many_lines)]
fn test_package_struct_usage_in_workspace() {
    let temp_dir = TempDir::new().unwrap();

    // Create workspace root
    let workspace_cargo = r#"
[workspace]
members = ["crate1", "crate2"]
resolver = "2"

[workspace.dependencies]
serde = "1.0"
"#;
    fs::write(temp_dir.path().join("Cargo.toml"), workspace_cargo).unwrap();

    // Create workspace member 1 with specific dev tools
    fs::create_dir_all(temp_dir.path().join("crate1/src")).unwrap();
    fs::write(
        temp_dir.path().join("crate1/Cargo.toml"),
        r#"
[package]
name = "crate1"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(temp_dir.path().join("crate1/src/lib.rs"), "").unwrap();
    // Add rustfmt config to crate1
    fs::write(
        temp_dir.path().join("crate1/rustfmt.toml"),
        "max_width = 100\n",
    )
    .unwrap();

    // Create workspace member 2 with different dev tools
    fs::create_dir_all(temp_dir.path().join("crate2/src")).unwrap();
    fs::write(
        temp_dir.path().join("crate2/Cargo.toml"),
        r#"
[package]
name = "crate2"
version = "0.1.0"
edition = "2021"
"#,
    )
    .unwrap();
    fs::write(temp_dir.path().join("crate2/src/lib.rs"), "").unwrap();
    // Add clippy config to crate2
    fs::write(
        temp_dir.path().join("crate2/clippy.toml"),
        "cyclomatic-complexity-threshold = 25\n",
    )
    .unwrap();
    // Add Cargo.lock to crate2
    fs::write(
        temp_dir.path().join("crate2/Cargo.lock"),
        "# Generated by Cargo",
    )
    .unwrap();

    let projects = detect_rust_projects(temp_dir.path(), None).unwrap();
    assert_eq!(projects.len(), 1, "Should detect only workspace root");

    let project = &projects[0];

    // Should detect cargo at project level
    assert!(
        project.tools.iter().any(|t| t.name == "cargo"),
        "Should detect cargo in workspace member"
    );

    // Should have workspace members with their own tools
    assert_eq!(project.workspace.members.len(), 2);

    // Check crate1 package
    let crate1_pkg = project
        .workspace
        .members
        .iter()
        .find(|p| p.name == "crate1")
        .expect("Should find crate1 package");

    let crate1_tool_names: Vec<&str> = crate1_pkg.tools.iter().map(|t| t.name.as_str()).collect();
    assert!(
        crate1_tool_names.contains(&"cargo"),
        "crate1 should have cargo manager"
    );
    assert!(
        crate1_tool_names.contains(&"rustfmt"),
        "crate1 should have rustfmt formatter"
    );
    assert!(
        crate1_tool_names.contains(&"clippy"),
        "crate1 should have clippy diagnostic"
    );

    // Check that crate1's rustfmt has high confidence due to config file
    let crate1_rustfmt = crate1_pkg
        .tools
        .iter()
        .find(|t| t.name == "rustfmt")
        .expect("Should find rustfmt in crate1");
    assert!(
        (crate1_rustfmt.confidence - 0.95).abs() < f64::EPSILON,
        "crate1 rustfmt should have high confidence due to config"
    );

    // Check crate2 package
    let crate2_pkg = project
        .workspace
        .members
        .iter()
        .find(|p| p.name == "crate2")
        .expect("Should find crate2 package");

    let crate2_tool_names: Vec<&str> = crate2_pkg.tools.iter().map(|t| t.name.as_str()).collect();
    assert!(
        crate2_tool_names.contains(&"cargo"),
        "crate2 should have cargo manager"
    );
    assert!(
        crate2_tool_names.contains(&"rustfmt"),
        "crate2 should have rustfmt formatter"
    );
    assert!(
        crate2_tool_names.contains(&"clippy"),
        "crate2 should have clippy diagnostic"
    );

    // Check that crate2's clippy has high confidence due to config file
    let crate2_clippy = crate2_pkg
        .tools
        .iter()
        .find(|t| t.name == "clippy")
        .expect("Should find clippy in crate2");
    assert!(
        (crate2_clippy.confidence - 0.95).abs() < f64::EPSILON,
        "crate2 clippy should have high confidence due to config"
    );

    // Check that crate2's cargo has highest confidence due to Cargo.lock
    let crate2_cargo_tools: Vec<_> = crate2_pkg
        .tools
        .iter()
        .filter(|t| t.name == "cargo")
        .collect();
    let highest_cargo = crate2_cargo_tools
        .iter()
        .max_by(|a, b| a.confidence.partial_cmp(&b.confidence).unwrap())
        .unwrap();
    assert!(
        (highest_cargo.confidence - 0.98).abs() < f64::EPSILON,
        "crate2 cargo should have highest confidence due to lockfile"
    );

    // Test new convenience methods for getting all tools from workspace
    let all_formatter_tools = project.all_tools_of_type(ToolType::Formatter);
    assert!(
        all_formatter_tools
            .iter()
            .map(|t| t.name.as_str())
            .any(|x| x == "rustfmt"),
        "Should detect rustfmt formatter"
    );

    let all_diagnostic_tools = project.all_tools_of_type(ToolType::Diagnostic);
    assert!(
        all_diagnostic_tools
            .iter()
            .map(|t| t.name.as_str())
            .any(|x| x == "clippy"),
        "Should detect clippy diagnostic"
    );

    // Test holistic view - should include tools from both project and packages
    let all_tools = project.all_tools();
    assert!(
        all_tools.len() > project.tools.len(),
        "Should have more tools when including packages"
    );

    // Verify tools are sorted by confidence
    for i in 1..all_tools.len() {
        assert!(
            all_tools[i - 1].confidence >= all_tools[i].confidence,
            "All tools should be sorted by confidence"
        );
    }

    // Verify package paths are canonical
    for package in &project.workspace.members {
        assert!(
            package.path.is_absolute(),
            "Package path should be absolute"
        );
    }
}

#[test]
fn test_devtools_detection_on_actual_pi_project() {
    // Test detection on the actual Pi project
    let current_dir = std::env::current_dir().unwrap();
    let project_root = current_dir
        .ancestors()
        .find(|path| path.join("Cargo.toml").exists())
        .expect("Could not find Cargo.toml in project hierarchy");

    let projects = detect_rust_projects(project_root, None).unwrap();
    assert_eq!(projects.len(), 1, "Should detect the Pi project");

    let project = &projects[0];
    assert_eq!(project.toolchain_type, ToolchainType::Rust);

    // Should detect cargo
    assert!(
        project.tools.iter().any(|t| t.name == "cargo"),
        "Should detect cargo tool"
    );

    // Should detect implied rustfmt and clippy tools
    let tool_names: Vec<&str> = project.tools.iter().map(|t| t.name.as_str()).collect();
    assert!(
        tool_names.contains(&"rustfmt"),
        "Should detect implied rustfmt tool"
    );
    assert!(
        tool_names.contains(&"clippy"),
        "Should detect implied clippy tool"
    );

    // Verify tool types and confidence levels
    let rustfmt_tool = project.tools.iter().find(|t| t.name == "rustfmt").unwrap();
    assert_eq!(rustfmt_tool.tool_type, ToolType::Formatter);
    assert!(
        (rustfmt_tool.confidence - 0.80).abs() < f64::EPSILON,
        "Implied rustfmt should have moderate confidence"
    );
    assert!(
        rustfmt_tool.evidence.iter().any(|e| e.contains("implied")),
        "rustfmt evidence should show it's implied"
    );

    let clippy_tool = project.tools.iter().find(|t| t.name == "clippy").unwrap();
    assert_eq!(clippy_tool.tool_type, ToolType::Diagnostic);
    assert!(
        (clippy_tool.confidence - 0.80).abs() < f64::EPSILON,
        "Implied clippy should have moderate confidence"
    );
    assert!(
        clippy_tool.evidence.iter().any(|e| e.contains("implied")),
        "clippy evidence should show it's implied"
    );

    // Should have workspace members (this is a workspace project)
    assert!(
        !project.workspace.members.is_empty(),
        "Pi project should have workspace members"
    );

    // Verify all tools have reasonable confidence levels
    for tool in &project.tools {
        assert!(
            tool.confidence > 0.0 && tool.confidence <= 1.0,
            "Tool {} should have valid confidence: {}",
            tool.name,
            tool.confidence
        );
        assert!(
            !tool.evidence.is_empty(),
            "Tool {} should have evidence",
            tool.name
        );
    }

    // Check that tools are sorted by confidence (highest first)
    let mut prev_confidence = 1.0;
    for tool in &project.tools {
        assert!(
            tool.confidence <= prev_confidence,
            "Tools should be sorted by confidence (highest first)"
        );
        prev_confidence = tool.confidence;
    }
}
