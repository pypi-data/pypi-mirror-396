//! Lockfile detection for Python packaging tools
//!
//! This module provides functionality to detect and identify Python packaging
//! lockfiles, which are the highest-confidence indicators of which tools
//! are being used in a project.

use pi_lang::{DetectedTool, ToolType};
use std::path::Path;

/// Known Python packaging lockfiles and their associated tools
static LOCKFILE_PATTERNS: &[(&str, &str, ToolType)] = &[
    ("uv.lock", "uv", ToolType::Manager),
    ("poetry.lock", "poetry", ToolType::Manager),
    ("pdm.lock", "pdm", ToolType::Manager),
    ("Pipfile.lock", "pipenv", ToolType::Manager),
];

static CONDA_LOCK_PATTERNS: &[&str] = &["conda-lock.yml", "conda-lock.yaml"];

pub(crate) fn detect_lockfiles<P: AsRef<Path>>(dir: P) -> Vec<DetectedTool> {
    let mut detected = Vec::new();
    let dir = dir.as_ref();

    for &(filename, tool_name, ref tool_type) in LOCKFILE_PATTERNS {
        let lockfile_path = dir.join(filename);
        if lockfile_path.is_file() {
            detected.push(DetectedTool {
                tool_type: *tool_type,
                name: tool_name.to_string(),
                confidence: 0.95, // High confidence for lockfiles
                evidence: vec![filename.to_string()],
            });
        }
    }

    // Check for conda lockfiles (which can have various patterns)
    if let Ok(entries) = std::fs::read_dir(dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if let Some(filename) = path.file_name().and_then(|n| n.to_str()) {
                // Check for conda-lock patterns
                if CONDA_LOCK_PATTERNS.contains(&filename)
                    || filename.ends_with(".conda-lock.yml")
                    || filename.ends_with(".conda-lock.yaml")
                {
                    detected.push(DetectedTool {
                        tool_type: ToolType::Environment,
                        name: "conda-lock".to_string(),
                        confidence: 0.90,
                        evidence: vec![filename.to_string()],
                    });
                }
            }
        }
    }

    detected
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_detect_lockfiles_empty_dir() {
        let temp_dir = TempDir::new().unwrap();
        let detected = detect_lockfiles(temp_dir.path());
        assert!(detected.is_empty());
    }

    #[test]
    fn test_detect_lockfiles_with_uv() {
        let temp_dir = TempDir::new().unwrap();
        let lockfile_path = temp_dir.path().join("uv.lock");
        fs::write(&lockfile_path, "# This file was autogenerated by uv\n").unwrap();

        let detected = detect_lockfiles(temp_dir.path());
        assert_eq!(detected.len(), 1);
        assert_eq!(detected[0].name, "uv");
        assert_eq!(detected[0].tool_type, ToolType::Manager);
        assert!((detected[0].confidence - 0.95).abs() < f64::EPSILON);
        assert_eq!(detected[0].evidence, vec!["uv.lock"]);
    }

    #[test]
    fn test_detect_lockfiles_with_poetry() {
        let temp_dir = TempDir::new().unwrap();
        let lockfile_path = temp_dir.path().join("poetry.lock");
        fs::write(&lockfile_path, "# This file is automatically generated\n").unwrap();

        let detected = detect_lockfiles(temp_dir.path());
        assert_eq!(detected.len(), 1);
        assert_eq!(detected[0].name, "poetry");
        assert_eq!(detected[0].tool_type, ToolType::Manager);
    }

    #[test]
    fn test_detect_lockfiles_with_conda_lock() {
        let temp_dir = TempDir::new().unwrap();
        let lockfile_path = temp_dir.path().join("conda-lock.yml");
        fs::write(&lockfile_path, "# Generated by conda-lock\n").unwrap();

        let detected = detect_lockfiles(temp_dir.path());
        assert_eq!(detected.len(), 1);
        assert_eq!(detected[0].name, "conda-lock");
        assert_eq!(detected[0].tool_type, ToolType::Environment);
    }

    #[test]
    fn test_detect_lockfiles_with_wildcard_conda_lock() {
        let temp_dir = TempDir::new().unwrap();
        let lockfile_path = temp_dir.path().join("requirements.conda-lock.yml");
        fs::write(&lockfile_path, "# Generated by conda-lock\n").unwrap();

        let detected = detect_lockfiles(temp_dir.path());
        assert_eq!(detected.len(), 1);
        assert_eq!(detected[0].name, "conda-lock");
        assert_eq!(detected[0].tool_type, ToolType::Environment);
    }

    #[test]
    fn test_detect_multiple_lockfiles() {
        let temp_dir = TempDir::new().unwrap();

        // Create multiple lockfiles (this would be unusual but possible)
        fs::write(temp_dir.path().join("uv.lock"), "uv lock").unwrap();
        fs::write(temp_dir.path().join("poetry.lock"), "poetry lock").unwrap();

        let detected = detect_lockfiles(temp_dir.path());
        assert_eq!(detected.len(), 2);

        let tool_names: Vec<&str> = detected.iter().map(|t| t.name.as_str()).collect();
        assert!(tool_names.contains(&"uv"));
        assert!(tool_names.contains(&"poetry"));
    }
}
