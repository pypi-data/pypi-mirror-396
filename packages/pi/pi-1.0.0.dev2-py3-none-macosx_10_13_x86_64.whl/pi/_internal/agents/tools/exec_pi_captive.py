import asyncio
import asyncio.subprocess
import codecs
import os
from typing import Any

from pydantic_ai import RunContext
from pydantic_ai.messages import ToolReturn
from pydantic_ai.toolsets import FunctionToolset

from pi._internal.agents.deps import PiDeps
from pi._internal.agents.common import suppress_errors
from pi._internal import protocols


exec_toolset = FunctionToolset[PiDeps]()


async def get_prefix(ctx: RunContext[PiDeps]) -> list[str]:
    shell = protocols.shell.interface(ctx.deps.bus)
    pi_info = await shell.pi_info()
    pi_executable = pi_info.path
    return [pi_executable, "captive"]


async def subshell_exec(cmd: list[str], timeout: int = 120) -> str:
    process = await asyncio.create_subprocess_exec(
        *cmd,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )

    stdout, stderr = await asyncio.wait_for(
        process.communicate(),
        timeout=timeout,
    )

    output = stdout.decode("utf-8", errors="replace")
    if stderr:
        error_output = stderr.decode("utf-8", errors="replace")
        if error_output.strip():
            output += f"\nSTDERR:\n{error_output}"

    return output


async def exec_pi_captive(
    ctx: RunContext[PiDeps],
    args: list[str],
    timeout: int = 120,
) -> str:
    """
    Execute a pi captive command using asyncio subprocess.

    Args:
        args: Arguments to pass to 'pi captive' subcommand
        timeout: Timeout in seconds

    Returns:
        Command output as string
    """
    shell = protocols.shell.interface(ctx.deps.bus)
    pi_info = await shell.pi_info()
    pi_executable = pi_info.path

    process_info = await shell.process_info()
    cwd = process_info.cwd or os.getcwd()

    process: asyncio.subprocess.Process | None = None

    # Wrap the command with cd to execute in the correct working directory
    # For 'run' subcommand, wrap the shell command with cd
    if args and args[0] == "run" and "sh" in args and "-c" in args:
        # Find the command after "-c" and wrap it
        try:
            c_index = args.index("-c")
            if c_index + 1 < len(args):
                command_str = args[c_index + 1]
                args[c_index + 1] = f"cd {cwd} && {command_str}"
        except ValueError:
            pass

    cmd = [pi_executable, "captive"] + args

    try:
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE,
        )

        stdout, stderr = await asyncio.wait_for(
            process.communicate(),
            timeout=timeout,
        )

        output = stdout.decode("utf-8", errors="replace")
        if stderr:
            error_output = stderr.decode("utf-8", errors="replace")
            if error_output.strip():
                output += f"\nSTDERR:\n{error_output}"

        return output

    except asyncio.TimeoutError:
        if process:
            process.kill()
            await process.wait()
        return f"Command timed out after {timeout} seconds"
    except Exception as e:
        return f"Error executing command: {str(e)}"


@exec_toolset.tool
@suppress_errors
async def exec(
    ctx: RunContext[PiDeps],
    command: str,
    tag: str | None = None,
    kill: bool = False,
    timeout: int = 60,
) -> ToolReturn:
    """
    Execute bash command in a session.

    Args:
        command: Shell command to execute
        tag: Custom tag for the process, will be autogenerated if not provided
        kill: Kill the process with the same tag if it exists
        timeout: Command timeout in seconds
    """
    assert ctx.tool_call_id is not None, "tool_call_id must not be None"
    assert ctx.tool_name is not None, "tool_name must not be None"

    try:
        unescaped_command = codecs.decode(command, "unicode_escape")
    except (UnicodeDecodeError, ValueError):
        unescaped_command = command

    # Build pi captive run command
    prefix = await get_prefix(ctx)
    prefix += ["run"]

    if kill:
        prefix.append("--kill")
    if tag:
        prefix.extend(["--tag", tag])
    if timeout:
        prefix.extend(["--timeout", str(timeout)])

    # Always wrap in shell to support composition operators and shell features
    target = ["sh", "-c", unescaped_command]

    result = await subshell_exec(prefix + target, timeout=timeout)

    to_llm = result
    metadata = {
        "command": command,
        "tag": tag,
        "kill": kill,
        "timeout": timeout,
    }

    return ToolReturn(
        return_value=to_llm,
        metadata=metadata,
    )


@exec_toolset.tool
@suppress_errors
async def send_input(
    ctx: RunContext[PiDeps],
    tag: str | None = None,
    pid: int | None = None,
    text: str | None = None,
    keys: list[str] | None = None,
) -> ToolReturn:
    """
    Send input to the process.

    Args:
        tag: Tag of the process, optional if pid is provided
        pid: Pid of the process, optional if tag is provided
        text: Text to send to the process, example: "y". Supports escape
            sequences like newline.
        keys: Keys to send to the process, example: ["Ctrl+C"]
    """
    assert ctx.tool_call_id is not None, "tool_call_id must not be None"
    assert ctx.tool_name is not None, "tool_name must not be None"

    assert tag is not None or pid is not None, (
        "Either tag or pid must be provided"
    )
    assert text is not None or keys is not None, (
        "Either text or keys must be provided"
    )

    command = await get_prefix(ctx)
    command += ["resume"]

    if tag:
        command.extend(["--tag", tag])
    elif pid:
        command.extend(["--pid", str(pid)])

    if text:
        command.extend(["--text", text])

    if keys:
        for key in keys:
            command.extend(["--key", key])

    result = await subshell_exec(command)

    to_llm = result
    metadata = {
        "tag": tag,
        "pid": pid,
        "text": text,
        "keys": keys,
    }

    return ToolReturn(return_value=to_llm, metadata=metadata)


@exec_toolset.tool
@suppress_errors
async def read_log(
    ctx: RunContext[PiDeps],
    tag: str | None = None,
    pid: int | None = None,
    head: bool = False,
    tail: bool = True,
    all: bool = False,
) -> ToolReturn:
    """
    Read the log of the process.

    Args:
        tag: Tag of the process, optional if pid is provided
        pid: Pid of the process, optional if tag is provided
        head: Read the first 10 lines of the log, optional
        tail: Read the last 10 lines of the log, optional
        all: Read the entire log, optional
    """
    assert ctx.tool_call_id is not None, "tool_call_id must not be None"
    assert ctx.tool_name is not None, "tool_name must not be None"

    assert tag is not None or pid is not None, (
        "Either tag or pid must be provided"
    )

    # Build pi captive log command
    command = await get_prefix(ctx)
    command += ["log"]

    if tag:
        command.extend(["--tag", tag])
    elif pid:
        command.extend(["--pid", str(pid)])

    if all:
        command.append("--all")
    elif head:
        command.append("--head")
    elif tail:
        command.append("--tail")

    result = await subshell_exec(command)

    to_llm = result
    metadata = {
        "tag": tag,
        "pid": pid,
        "head": head,
        "tail": tail,
        "all": all,
    }

    return ToolReturn(return_value=to_llm, metadata=metadata)


@exec_toolset.tool
@suppress_errors
async def list_processes(ctx: RunContext[PiDeps]) -> ToolReturn:
    """
    List all active processes.
    """
    assert ctx.tool_call_id is not None, "tool_call_id must not be None"
    assert ctx.tool_name is not None, "tool_name must not be None"

    command = await get_prefix(ctx)
    command += ["ls"]

    result = await subshell_exec(command)

    to_llm = result
    metadata: dict[str, Any] = {}

    return ToolReturn(return_value=to_llm, metadata=metadata)


@exec_toolset.tool
@suppress_errors
async def kill(
    ctx: RunContext[PiDeps],
    tag: str | None = None,
    pid: int | None = None,
    all: bool = False,
) -> ToolReturn:
    """
    Kill a process.

    Args:
        tag: Tag of the process, optional if pid is provided
        pid: Pid of the process, optional if tag is provided
        all: Kill all processes, optional
    """
    assert ctx.tool_call_id is not None, "tool_call_id must not be None"
    assert ctx.tool_name is not None, "tool_name must not be None"

    assert tag is not None or pid is not None or all, (
        "Either tag or pid or all must be provided"
    )

    # Build pi captive kill command
    command = await get_prefix(ctx)
    command += ["kill"]

    if all:
        command.append("--all")
    elif tag:
        command.extend(["--tag", tag])
    elif pid:
        command.extend(["--pid", str(pid)])

    result = await subshell_exec(command)

    to_llm = result
    metadata = {
        "tag": tag,
        "pid": pid,
        "all": all,
    }

    return ToolReturn(return_value=to_llm, metadata=metadata)


@exec_toolset.tool
@suppress_errors
async def wait(ctx: RunContext[PiDeps], duration: int = 2) -> ToolReturn:
    """
    Wait for a specified duration.
    Useful when you need to wait for a long-running command to complete,
    e.g. database migrations.
    """
    assert ctx.tool_call_id is not None, "tool_call_id must not be None"
    assert ctx.tool_name is not None, "tool_name must not be None"

    await asyncio.sleep(duration)

    to_llm = f"Waited for {duration} seconds"
    metadata = {
        "duration": duration,
    }

    return ToolReturn(return_value=to_llm, metadata=metadata)
