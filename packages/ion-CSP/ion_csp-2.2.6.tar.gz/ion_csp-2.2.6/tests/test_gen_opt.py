import csv
import json
import pytest
import signal
import psutil
import logging
import subprocess
from typing import List
from pathlib import Path
from unittest.mock import patch, MagicMock

from ion_CSP.gen_opt import (
    CrystalGenerator,
    Comp_CompatibilityError,
    _get_available_gpus,
    _wait_for_gpu,
)


# ==================== 帮助函数：创建模拟的离子组分文件 ====================
def create_ion_files(tmp_path: Path) -> List[Path]:
    """创建模拟的离子结构文件（如 N2H6.gjf 与 N5.gjf）"""
    ion_files = []
    path1, path2 = tmp_path / "N2H6.gjf", tmp_path / "N5.gjf"
    path1.write_text(
        r"""%chk=GISYIR.chk
#P B3LYP/6-31G*

Generated by Multiwfn

  2  1
N      0.73082600   -0.07120700   -0.03991000
N     -0.73082700    0.07120700    0.03991000
H      0.98863400   -1.06315900   -0.23934100
H      1.11329300    0.53155800   -0.80188100
H      1.17309100    0.21250300    0.86237400
H     -1.17309200   -0.21250300   -0.86237400
H     -1.11329400   -0.53155800    0.80188100
H     -0.98863400    1.06315900    0.23934100

""",
        encoding="utf-8",
    )
    ion_files.append(path1)
    path2.write_text(r"""%chk=N5.chk
#P B3LYP/6-31G*

Generated by Multiwfn

 -1  1
N      5.68107100   -0.02073700    5.05520300
N      5.75024300   -1.54374400    6.57460400
N      4.99576900   -0.58483300    6.04587900
N      6.86056300   -0.63037300    4.97316600
N      6.90312600   -1.57214500    5.91086700
 
""")
    ion_files.append(path2)
    return ion_files


# ==================== 常量配置 ====================
SAMPLE_SPECIES = ["N2H6.gjf", "N5.gjf"]
SAMPLE_ION_NUMBERS = [1, 2]
SAMPLE_CELL_ATOMS = 18  # (8 atoms in N2H6) * 1 + (5 atoms in N5) * 2 = 18


# ==================== pytest fixture: 创建干净测试环境 ====================
@pytest.fixture
def crystal_generator(tmp_path: Path):
    """
    创建一个干净的 CrystalGenerator 实例，自动构建目录结构和模拟文件。
    """
    # 创建模拟的离子组分文件
    _ = create_ion_files(tmp_path)

    # 创建模拟的 mlp_opt.py 和 model.pt（模拟 importlib.resources）
    mlp_opt_file = tmp_path / "mlp_opt.py"
    mlp_opt_file.write_text("print('MLP optimization script')", encoding="utf-8")

    model_file = tmp_path / "model.pt"
    model_file.write_text("dummy model content", encoding="utf-8")

    # 创建一个 mock 的 importlib.resources.files
    with patch("importlib.resources.files") as mock_resources:
        # 模拟 mlp_opt.py 和 model.pt 的路径
        mock_resources.side_effect = (
            lambda pkg: tmp_path if pkg == "ion_CSP" else tmp_path / "model"
        )

        # 创建 CrystalGenerator 实例
        crystal_generator = CrystalGenerator(
            work_dir=tmp_path,
            ion_numbers=SAMPLE_ION_NUMBERS,
            species=SAMPLE_SPECIES,
        )
        crystal_generator.POSCAR_dir.mkdir(exist_ok=True)
        crystal_generator.group_counts = [1, 2, 1, 1]
        yield crystal_generator


# ==================== 测试 __init__ ====================
def test_crystal_generator_init(crystal_generator: CrystalGenerator, tmp_path: Path):
    """测试初始化逻辑"""
    cg = crystal_generator
    assert cg.base_dir == tmp_path
    assert cg.ion_numbers == [1, 2]
    assert cg.species == ["N2H6.gjf", "N5.gjf"]
    assert len(cg.species_paths) == 2
    assert cg.cell_atoms == 18
    # 确保目录已创建
    assert cg.generation_dir.exists()
    assert cg.POSCAR_dir == tmp_path / "1_generated/POSCAR_Files"
    assert cg.POSCAR_dir.exists()
    assert cg.primitive_cell_dir == tmp_path / "1_generated/primitive_cell"


# ==================== 测试 _sequentially_read_files ====================
def test_sequentially_read_files_success(crystal_generator: CrystalGenerator):
    """测试文件按数字顺序正确排序"""
    # 模拟 pyxtal 生成的 POSCAR 文件
    for i in range(5):
        poscar_content = """System for test
1.0
5.0 0.0 0.0
0.0 5.0 0.0
0.0 0.0 5.0
C N
1 1
Direct
0.0 0.0 0.0
0.5 0.5 0.5
"""
        (crystal_generator.POSCAR_dir / f"POSCAR_{i}").write_text(
            poscar_content, encoding="utf-8"
        )

    files = crystal_generator._sequentially_read_files(
        crystal_generator.POSCAR_dir, prefix_name="POSCAR_"
    )
    assert len(files) == 5
    assert files[0] == (0, "POSCAR_0")
    assert files[-1] == (4, "POSCAR_4")


def test_sequentially_read_files_invalid_name(crystal_generator: CrystalGenerator):
    """测试非法文件名（非数字后缀）被过滤"""
    # 模拟 pyxtal 生成的 POSCAR 文件
    for i in range(5):
        poscar_content = """System for test
1.0
5.0 0.0 0.0
0.0 5.0 0.0
0.0 0.0 5.0
C N
1 1
Direct
0.0 0.0 0.0
0.5 0.5 0.5
"""
        (crystal_generator.POSCAR_dir / f"POSCAR_{i}").write_text(
            poscar_content, encoding="utf-8"
        )
    (crystal_generator.POSCAR_dir / "POSCAR_xxx").touch()
    files = crystal_generator._sequentially_read_files(
        crystal_generator.POSCAR_dir, prefix_name="POSCAR_"
    )
    assert len(files) == 5  # xxx 被过滤
    assert "POSCAR_xxx" not in [f[1] for f in files]


def test_sequentially_read_files_no_files_found(
    crystal_generator: CrystalGenerator, caplog
):
    """
    Test that _sequentially_read_files raises FileNotFoundError when no files with prefix are found.
    """
    # 确保 POSCAR_dir 是空的（即使有其他文件，只要没有 POSCAR_* 就行）
    # 你可以创建一个无关文件，确保它不会被误读
    (crystal_generator.POSCAR_dir / "random_file.txt").touch()

    # 调用方法，应触发 FileNotFoundError
    with pytest.raises(FileNotFoundError) as exc_info:
        crystal_generator._sequentially_read_files(
            crystal_generator.POSCAR_dir, prefix_name="POSCAR_"
        )

    # 验证异常信息
    expected_msg = (
        f"No files found with prefix 'POSCAR_' in {crystal_generator.POSCAR_dir}"
    )
    assert expected_msg in str(exc_info.value)

    # 验证日志是否正确记录
    assert "No files found with prefix 'POSCAR_' in" in caplog.text
    assert caplog.records[-1].levelname == "ERROR"
    assert (
        caplog.records[-1].message
        == f"No files found with prefix 'POSCAR_' in {crystal_generator.POSCAR_dir}"
    )


# ==================== 测试 generate_structures ====================
@patch("ion_CSP.gen_opt.pyxtal")
def test_generate_structures_success(
    mock_pyxtal, crystal_generator: CrystalGenerator, tmp_path: Path, caplog
):
    """测试结构生成成功路径"""
    # 捕获日志
    caplog.set_level(logging.INFO)
    # 模拟 pyxtal 成功生成
    mock_structure = MagicMock()
    mock_structure.to_file = MagicMock()
    mock_pyxtal.return_value = mock_structure

    # 模拟生成 5 个结构，分布在 2 个空间群
    mock_structure.from_random.side_effect = [None] * 10
    crystal_generator.generate_structures(num_per_group=5, space_groups_limit=2)

    # 验证
    assert mock_pyxtal.call_count == 10
    assert mock_structure.from_random.call_count == 10
    assert mock_structure.to_file.call_count == 10

    # 验证 CSV 文件
    csv_path = tmp_path / "1_generated" / "generation.csv"
    assert csv_path.exists()
    with open(csv_path, "r", encoding="utf-8") as f:
        reader = csv.reader(f)
        rows = list(reader)
    assert rows[0] == ["Space_group", "POSCAR_num", "Bad_num", "Exception"]
    assert rows[1] == ["1", "5", "0", "None"]  # 只有第一个空间群被用（limit=2）
    assert len(rows) == 3  # 包含表头与空间群1和2
    assert rows[1][1] == "5"  # 空间群1生成5个结构
    assert rows[1][2] == "0"  # 空间群1无异常结构
    assert rows[1][3] == "None"  # 空间群1未发生异常
    assert rows[2][1] == "5"  # 空间群2生成5个结构
    assert rows[2][2] == "0"  # 空间群2无异常结构
    assert rows[2][3] == "None"  # 空间群2未发生异常

    # 验证日志
    assert (
        "Using pyxtal.from_random, 10 ion crystal structures were randomly generated"
    ) in caplog.text


@patch("ion_CSP.gen_opt.pyxtal")
def test_generate_structures_compatability_error(
    mock_pyxtal, crystal_generator: CrystalGenerator, tmp_path: Path
):
    """测试生成时出现 Comp_CompatibilityError，跳过当前空间群"""
    mock_structure = MagicMock()
    mock_structure.to_file = MagicMock()
    mock_pyxtal.return_value = mock_structure

    # 第一个结构成功，第二个触发异常
    def side_effect(*args, **kwargs):
        if mock_structure.from_random.call_count <= 5:
            return None
        else:
            raise Comp_CompatibilityError("Incompatible composition")  # 模拟异常

    mock_structure.from_random.side_effect = side_effect

    crystal_generator.generate_structures(num_per_group=5, space_groups_limit=2)

    # 验证 CSV
    csv_path = tmp_path / "1_generated" / "generation.csv"
    with open(csv_path, "r", encoding="utf-8") as f:
        reader = csv.reader(f)
        rows = list(reader)
    assert rows[1][2] == "0"  # Bad_num 仍为 0
    assert rows[1][3] == "None"  # Exception 仍为 None
    assert rows[2][2] == "0"  # Bad_num 为 5
    assert rows[2][3] == "Comp_CompatibilityError"  # Exception 更新为异常类型

    # 验证结构生成函数的调用次数（第一个空间群成功生成5个，第二个空间群尝试1次失败后结束）
    assert mock_structure.from_random.call_count == 6


# ==================== 测试 _find_space_group ====================
def test_find_space_group_success(crystal_generator: CrystalGenerator):
    """测试空间群查找成功"""
    assert crystal_generator._find_space_group(0) == 1
    assert crystal_generator._find_space_group(1) == 2
    assert crystal_generator._find_space_group(2) == 2
    assert crystal_generator._find_space_group(3) == 3
    assert crystal_generator._find_space_group(4) == 4


def test_find_space_group_not_found(crystal_generator: CrystalGenerator):
    """测试找不到空间群"""
    with pytest.raises(ValueError, match="POSCAR 99 not found"):
        crystal_generator._find_space_group(99)


# ==================== 测试 _single_phonopy_processing ====================
@patch("subprocess.run")
@patch("ion_CSP.gen_opt.read")
def test_single_phonopy_processing_success(
    mock_read,
    mock_run,
    crystal_generator: CrystalGenerator,
):
    """测试 phonopy 处理成功路径"""
    # 标准 VASP POSCAR 格式
    pposcar_content = """PPOSCAR for test
1.0
5.0 0.0 0.0
0.0 5.0 0.0
0.0 0.0 5.0
C N
1 1
Direct
0.0 0.0 0.0
0.5 0.5 0.5"""

    # 模拟 subprocess.run 成功，并在执行后创建合法 VASP 格式的 PPOSCAR 文件
    def mock_subprocess_run(*args, **kwargs):
        pposcar_path = crystal_generator.POSCAR_dir / "PPOSCAR"

        pposcar_path.write_text(pposcar_content.strip(), encoding="utf-8")
        assert pposcar_path.exists(), "PPOSCAR not created!"
        return MagicMock(returncode=0)

    mock_run.side_effect = mock_subprocess_run

    # 模拟创建在结构生成阶段所生成的 CSV 文件
    crystal_generator.generation_csv_file = (
        crystal_generator.generation_dir / "generation.csv"
    )
    crystal_generator.generation_csv_file.write_text(
        "Space_group,POSCAR_num,Bad_num,Exception\n1,0,0,None\n", encoding="utf-8"
    )

    # 模拟 ase.io.read 返回模拟的 Atoms 对象
    mock_atoms = MagicMock()
    mock_atoms.get_number_of_atoms.return_value = crystal_generator.cell_atoms
    mock_atoms.__len__.return_value = crystal_generator.cell_atoms
    mock_read.return_value = mock_atoms  # 返回模拟对象

    # 创建原始 POSCAR 文件（已由 fixture 创建）
    poscar_src = crystal_generator.POSCAR_dir / "POSCAR_0"
    # 创建原始 POSCAR 文件（phonopy 读取的输入）
    poscar_src.write_text(
        "POSCAR for test\n1.0\n5.0 0.0 0.0\n0.0 5.0 0.0\n0.0 0.0 5.0\nC N\n1 1\nDirect\n0.0 0.0 0.0\n0.5 0.5 0.5",
        encoding="utf-8",
    )
    assert poscar_src.exists()

    # 创建目标目录
    crystal_generator.primitive_cell_dir.mkdir(exist_ok=True)

    # 真实执行 _single_phonopy_processing
    crystal_generator._single_phonopy_processing("POSCAR_0")

    # 验证 subprocess 被调用
    mock_run.assert_called_once_with(
        ["phonopy", "--symmetry", str(crystal_generator.POSCAR_dir / "POSCAR")],
        cwd=str(crystal_generator.POSCAR_dir),
        check=True,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.STDOUT,
    )

    # 验证 read 被调用（读取移动后的文件）
    mock_read.assert_called_once_with(crystal_generator.primitive_cell_dir / "POSCAR_0")

    # 验证文件系统真实变化
    # 1. POSCAR_0 被复制为 POSCAR
    assert (crystal_generator.POSCAR_dir / "POSCAR").exists()
    assert (
        crystal_generator.POSCAR_dir / "POSCAR"
    ).read_text() == poscar_src.read_text()

    # 2. PPOSCAR 被移动为 primitive_cell/POSCAR_0
    dst_path = crystal_generator.primitive_cell_dir / "POSCAR_0"
    assert dst_path.exists()
    assert dst_path.read_text() == pposcar_content

    # 3. 原始 PPOSCAR 被删除
    assert not (crystal_generator.POSCAR_dir / "PPOSCAR").exists()

    # 4. 验证没有调用 os.remove（因为原子数匹配）
    mock_read.assert_called_once()
    mock_run.assert_called_once()


@patch("subprocess.run")
@patch("ion_CSP.gen_opt.read")
def test_single_phonopy_processing_atom_mismatch(
    mock_read,
    mock_run,
    crystal_generator: CrystalGenerator,
):
    """测试原子数不匹配，删除文件并更新 CSV"""

    # 1. 准备 PPOSCAR 内容（与 success 一致）
    pposcar_content = """PPOSCAR for test
1.0
5.0 0.0 0.0
0.0 5.0 0.0
0.0 0.0 5.0
C N
1 1
Direct
0.0 0.0 0.0
0.5 0.5 0.5"""

    # 2. 模拟 subprocess.run 成功并生成 PPOSCAR
    def mock_subprocess_run(*args, **kwargs):
        pposcar_path = crystal_generator.POSCAR_dir / "PPOSCAR"
        pposcar_path.parent.mkdir(exist_ok=True, parents=True)  # 确保目录存在
        pposcar_path.write_text(pposcar_content.strip(), encoding="utf-8")
        assert pposcar_path.exists(), "PPOSCAR not created!"
        return MagicMock(returncode=0)

    mock_run.side_effect = mock_subprocess_run  # 使用 side_effect，不是 return_value

    # 3. 创建初始 CSV 文件（使用 crystal_generator 的真实路径）
    crystal_generator.generation_csv_file = (
        crystal_generator.generation_dir / "generation.csv"
    )
    crystal_generator.generation_csv_file.write_text(
        "Space_group,POSCAR_num,Bad_num,Exception\n1,1,0,None\n", encoding="utf-8"
    )

    # 4. 创建输入 POSCAR_0
    poscar_src = crystal_generator.POSCAR_dir / "POSCAR_0"
    poscar_src.parent.mkdir(exist_ok=True, parents=True)
    poscar_src.write_text(
        "POSCAR for test\n1.0\n5.0 0.0 0.0\n0.0 5.0 0.0\n0.0 0.0 5.0\nC N\n1 1\nDirect\n0.0 0.0 0.0\n0.5 0.5 0.5",
        encoding="utf-8",
    )
    assert poscar_src.exists()

    # 5. 创建目标目录
    crystal_generator.primitive_cell_dir.mkdir(exist_ok=True, parents=True)

    # 6. 模拟 ase.io.read 返回对象，支持 len() 和 get_number_of_atoms()
    mock_atoms = MagicMock()
    mock_atoms.get_number_of_atoms.return_value = (
        99  # 设置为不匹配的值（比如 99 ≠ cell_atoms）
    )
    mock_atoms.__len__.return_value = 99  # 让 len() 返回 99，触发不匹配
    mock_read.return_value = mock_atoms

    # 7. 执行被测函数（真实执行 shutil.move, os.remove, csv 更新）
    crystal_generator._single_phonopy_processing("POSCAR_0")

    # 8. 验证 subprocess.run 被调用
    mock_run.assert_called_once_with(
        ["phonopy", "--symmetry", str(crystal_generator.POSCAR_dir / "POSCAR")],
        cwd=str(crystal_generator.POSCAR_dir),
        check=True,
        stdout=subprocess.DEVNULL,
        stderr=subprocess.STDOUT,
    )

    # 9. 验证 ase.io.read 被调用（读取移动后的文件）
    dst_path = crystal_generator.primitive_cell_dir / "POSCAR_0"
    mock_read.assert_called_once_with(dst_path)

    # 10. 验证文件系统真实变化
    # 10.1 PPOSCAR 被生成
    assert not (crystal_generator.POSCAR_dir / "PPOSCAR").exists()
    # 10.2 因为原子数不匹配，文件被删除
    assert not dst_path.exists(), "File should be deleted due to atom mismatch!"
    # 10.3 原始 POSCAR_0 仍然存在（复制，不是移动）
    assert poscar_src.exists()
    # 10.4 原始 PPOSCAR 被删除（shutil.move 后原文件消失）
    assert not (crystal_generator.POSCAR_dir / "PPOSCAR").exists()

    # 11. 验证 CSV 文件被正确更新
    with open(crystal_generator.generation_csv_file, "r", encoding="utf-8") as f:
        reader = csv.reader(f)
        rows = list(reader)

    # 表头 + 一行数据
    assert len(rows) == 2
    assert rows[1][0] == "1"  # Space_group
    assert rows[1][1] == "1"  # POSCAR_num
    assert rows[1][2] == "1"  # Bad_num 增加了 1
    assert rows[1][3] == "AtomNumberError"  # Exception 更新

    # 12. 验证 mock_read 和 mock_run 只被调用一次
    mock_read.assert_called_once()
    mock_run.assert_called_once()


@pytest.mark.parametrize(
    "exception_type, exception_msg, expected_log_pattern",
    [
        (
            subprocess.CalledProcessError,
            subprocess.CalledProcessError(
                returncode=1,
                cmd=["phonopy", "--symmetry", "POSCAR"],
                stderr="Phonopy error: invalid structure",
            ),
            "Phonopy execution failed for POSCAR_0",
        ),
        (
            FileNotFoundError,
            FileNotFoundError("[Errno 2] No such file or directory: 'PPOSCAR'"),
            "Phonopy execution failed for POSCAR_0",
        ),
    ],
    ids=[
        "CalledProcessError",
        "FileNotFoundError",
    ],
)
def test_single_phonopy_processing_exception(
    exception_type,
    exception_msg,
    expected_log_pattern,
    crystal_generator: CrystalGenerator,
    caplog,
):
    """测试 _single_phonopy_processing 捕获并正确处理所有异常类型"""

    # 1. 准备基础文件结构
    poscar_src = crystal_generator.POSCAR_dir / "POSCAR_0"
    poscar_src.parent.mkdir(exist_ok=True, parents=True)
    poscar_src.write_text(
        "POSCAR for test\n1.0\n5.0 0.0 0.0\n0.0 5.0 0.0\n0.0 0.0 5.0\nC N\n1 1\nDirect\n0.0 0.0 0.0\n0.5 0.5 0.5",
        encoding="utf-8",
    )

    crystal_generator.primitive_cell_dir.mkdir(exist_ok=True, parents=True)
    crystal_generator.generation_csv_file = (
        crystal_generator.generation_dir / "generation.csv"
    )
    crystal_generator.generation_csv_file.write_text(
        "Space_group,POSCAR_num,Bad_num,Exception\n1,1,0,None\n", encoding="utf-8"
    )

    # 2. 模拟 ase.io.read 返回一个 mock 对象
    mock_atoms = MagicMock()
    mock_atoms.get_number_of_atoms.return_value = crystal_generator.cell_atoms

    # 3. 根据异常类型，mock 不同的函数
    with (
        patch("subprocess.run") as mock_run,
        patch("ase.io.read", return_value=mock_atoms),
    ):
        if exception_type is subprocess.CalledProcessError:
            # 1. phonopy 命令失败 → 日志应为 "Phonopy execution failed..."
            mock_run.side_effect = exception_msg

        elif exception_type is FileNotFoundError:
            # 2. phonopy 成功，但 PPOSCAR 文件不存在 → 日志应为 "Phonopy execution failed..."
            mock_run.return_value = MagicMock(returncode=0)
            # 模拟 PPOSCAR 不存在
            with patch("pathlib.Path.exists", return_value=False):
                pass  # 无需额外 patch，shutil.move 会抛 FileNotFoundError

        # 4. 设置日志级别
        caplog.set_level(logging.ERROR)

        # 5. 执行并捕获异常
        with pytest.raises(exception_type) as exc_info:
            crystal_generator._single_phonopy_processing("POSCAR_0")

        # 6. 验证异常类型
        assert isinstance(exc_info.value, exception_type)

        # 7. 验证日志内容
        assert expected_log_pattern in caplog.text

        # 8. 验证异常对象
        if exception_type is subprocess.CalledProcessError:
            assert exc_info.value.returncode == 1
            assert "invalid structure" in str(exc_info.value.stderr)
        elif exception_type is Exception:
            assert str(exc_info.value) == "Unexpected Error"


def test_single_phonopy_processing_atom_number_mismatch_updates_csv(
    crystal_generator: CrystalGenerator, tmp_path: Path, caplog
):
    """测试当原子数不匹配时，_single_phonopy_processing 正确更新 generation.csv 中对应空间群的 Bad_num 和 Exception"""
    # 1. 创建 generation.csv 文件
    csv_path = tmp_path / "generation.csv"
    csv_content = """Space_group,POSCAR_num,Bad_num,Exception
1,5,0,None
2,5,0,None
3,3,0,None
"""
    csv_path.write_text(csv_content, encoding="utf-8")
    crystal_generator.generation_csv_file = csv_path
    crystal_generator.group_counts = [5, 5, 3]  # 空间群1、2、3分别生成5、5、3个结构

    # 2. 创建 POSCAR_6 文件（关键：必须存在）
    poscar_dir = tmp_path / "1_generated/POSCAR_Files"
    poscar_dir.mkdir(parents=True, exist_ok=True)
    filename = "POSCAR_6"
    (poscar_dir / filename).touch()  # 创建空文件，避免 FileNotFoundError
    primitive_cell_dir = tmp_path / "1_generated/primitive_cell"
    primitive_cell_dir.mkdir(parents=True, exist_ok=True)

    # 3. 模拟 subprocess.run 成功执行（不真实调用 phonopy）
    with patch("subprocess.run", return_value=MagicMock(returncode=0)) as mock_run:
        # 4. 模拟 PPOSCAR 文件被生成（phonopy 输出）
        pposcar_path = poscar_dir / "PPOSCAR"
        pposcar_path.write_text(
            """System for test
1.0
5.0 0.0 0.0
0.0 5.0 0.0
0.0 0.0 5.0
C N
1 1
Direct
0.0 0.0 0.0
0.5 0.5 0.5
""",
            encoding="utf-8",
        )

        # 5. 模拟 ase.io.read 返回原子数不匹配的结构
        mock_atoms = MagicMock()
        mock_atoms.get_number_of_atoms.return_value = 99  # 不等于 self.cell_atoms
        mock_atoms.__len__.return_value = 99
        with patch("ase.io.read", return_value=mock_atoms):
            # 6. 执行方法
            crystal_generator._single_phonopy_processing(filename)

    # 7. 验证 CSV 文件被正确更新
    with open(csv_path, "r", encoding="utf-8") as f:
        reader = csv.reader(f)
        rows = list(reader)
    assert rows[2][0] == "2"  # 空间群2
    assert rows[2][2] == "1"  # Bad_num 增加1
    assert rows[2][3] == "AtomNumberError"  # Exception 更新
    assert rows[1][2] == "0"  # 空间群1未变
    assert rows[3][2] == "0"  # 空间群3未变

    # 8. 验证日志
    assert "Deleted POSCAR_6 due to atom number mismatch" in caplog.text
    assert mock_run.called_once()
    assert "Phonopy execution failed" not in caplog.text  # 因为 run 被 mock 成功


def test_single_phonopy_processing_space_group_not_found_in_csv(
    crystal_generator: CrystalGenerator, tmp_path: Path, caplog
):
    """测试当 CSV 中不存在对应 space_group 行时，不更新任何行，不抛异常"""
    # 1. 创建 generation.csv 文件，只包含空间群 1，不包含空间群 2
    csv_path = tmp_path / "generation.csv"
    csv_content = """Space_group,POSCAR_num,Bad_num,Exception
1,5,0,None
"""
    csv_path.write_text(csv_content, encoding="utf-8")
    crystal_generator.generation_csv_file = csv_path
    crystal_generator.group_counts = [5, 5]  # 空间群1:0-4, 空间群2:5-9

    # 2. 创建 POSCAR_6 文件（属于空间群2，索引6在5-9范围内）
    poscar_dir = tmp_path / "1_generated/POSCAR_Files"
    poscar_dir.mkdir(parents=True, exist_ok=True)
    filename = "POSCAR_6"
    (poscar_dir / filename).touch()  # 创建空文件

    # 3. 创建 primitive_cell 目录（关键修复！）
    crystal_generator.primitive_cell_dir.mkdir(parents=True, exist_ok=True)

    # 4. 模拟 phonopy 成功执行并生成 PPOSCAR
    with patch("subprocess.run", return_value=MagicMock(returncode=0)):
        pposcar_path = poscar_dir / "PPOSCAR"
        pposcar_path.write_text(
            """System for test
1.0
5.0 0.0 0.0
0.0 5.0 0.0
0.0 0.0 5.0
C N
1 1
Direct
0.0 0.0 0.0
0.5 0.5 0.5
""",
            encoding="utf-8",
        )

        # 5. 模拟 ase.io.read 返回原子数不匹配的结构
        mock_atoms = MagicMock()
        mock_atoms.get_number_of_atoms.return_value = 99
        mock_atoms.__len__.return_value = 99
        with patch("ase.io.read", return_value=mock_atoms):
            # 6. 执行方法 —— 不应抛出异常
            crystal_generator._single_phonopy_processing(filename)

    # 7. 验证：CSV 文件未被修改（因为没有空间群2的行）
    with open(csv_path, "r", encoding="utf-8") as f:
        reader = csv.reader(f)
        rows = list(reader)
    assert rows[1][2] == "0"  # 空间群1的 Bad_num 未变
    assert rows[1][3] == "None"  # 空间群1的 Exception 未变

    # 8. 验证日志：仍记录删除
    assert "Deleted POSCAR_6 due to atom number mismatch" in caplog.text
    # 但不应有“更新 CSV”的日志，因为未找到对应空间群


# ==================== 测试 phonopy_processing ====================
def test_phonopy_processing_success(crystal_generator: CrystalGenerator, caplog):
    """测试 phonopy_processing 成功路径"""
    caplog.set_level(logging.INFO)
    # 创建 POSCAR 文件
    for i in range(3):
        (crystal_generator.POSCAR_dir / f"POSCAR_{i}").write_text(
            "dummy", encoding="utf-8"
        )

    with patch(
        "ion_CSP.gen_opt.CrystalGenerator._single_phonopy_processing"
    ) as mock_single:
        crystal_generator.phonopy_processing()

    # 验证
    assert mock_single.call_count == 3
    assert ("The phonopy processing has been completed!!") in caplog.text


# ==================== 测试 dpdisp_mlp_tasks ====================
@pytest.mark.parametrize(
    "context_type, nodes, parent, gpu",
    [
        ("LocalContext", 2, "", 1),
        ("SSHContext", 1, "data/", 0),
    ],
)
@patch("dpdispatcher.Submission.run_submission")
@patch("dpdispatcher.Submission.__init__", return_value=None)
@patch("dpdispatcher.Task.__init__", return_value=None)
@patch("dpdispatcher.contexts.ssh_context.SSHSession._setup_ssh")
@patch("dpdispatcher.contexts.ssh_context.SSHSession.ensure_alive")
@patch("dpdispatcher.contexts.ssh_context.SSHSession.sftp", new_callable=MagicMock)
@patch("shutil.rmtree")
def test_dpdisp_mlp_tasks_local_and_remote(
    mock_rmtree,
    mock_sftp,
    mock_ensure_alive,
    mock_setup_ssh,
    mock_task,
    mock_sub,
    mock_run,
    context_type,
    nodes,
    parent,
    gpu,
    crystal_generator: CrystalGenerator,
    tmp_path: Path,
    caplog,
):
    """测试本地 GPU 和远程 SSH 模式"""
    caplog.set_level(logging.INFO)

    # 1. 创建 machine 和 resources 文件（JSON 格式）
    machine_path = tmp_path / "machine.json"
    resources_path = tmp_path / "resources.json"

    machine_config = {
        "context_type": context_type,
        "local_root": "./",
        "remote_root": "/remote/workplace",
        "batch_type": "Shell",
    }
    if context_type == "SSHContext":
        machine_config["remote_profile"] = {
            "hostname": "your.host.name.IPv4",
            "username": "your_username",
        }

    machine_path.write_text(json.dumps(machine_config, indent=2), encoding="utf-8")

    resources_config = {
        "number_node": 1,
        "cpu_per_node": 4,
        "gpu_per_node": gpu,
        "group_size": 1,
    }
    resources_path.write_text(json.dumps(resources_config, indent=2), encoding="utf-8")

    # 2. 创建输入文件：3 个 POSCAR_0,1,2
    crystal_generator.primitive_cell_dir.mkdir(exist_ok=True, parents=True)
    for i in range(3):
        (crystal_generator.primitive_cell_dir / f"POSCAR_{i}").write_text(
            "dummy POSCAR", encoding="utf-8"
        )

    # 3. 创建 mlp_opt.py、model.pt 和 PID 文件
    crystal_generator.mlp_opt_file = tmp_path / "mlp_opt.py"
    crystal_generator.model_file = tmp_path / "model.pt"
    crystal_generator.mlp_opt_file.write_text("def main(): pass", encoding="utf-8")
    crystal_generator.model_file.write_text("model weights", encoding="utf-8")

    # 4. 设置 mock_sftp 为一个哑对象（避免 AttributeError）
    # 这个对象不需要做任何事，只要不抛错就行
    mock_sftp.return_value = MagicMock()
    mock_sftp.return_value.mkdir = MagicMock()  # 防止调用 mkdir 时报错

    # 5.在每个 pop{n} 目录下**提前创建模拟的 CONTCAR 和 OUTCAR 文件**
    # 因为 dpdispatcher.run_submission() 会“执行”任务，我们模拟它成功生成了输出
    dpdisp_base = crystal_generator.primitive_cell_dir
    for pop in range(nodes):
        task_dir = dpdisp_base / f"{parent}pop{pop}"
        task_dir.mkdir(exist_ok=True, parents=True)

        # 模拟任务执行后生成的输出文件
        for i in range(3):
            if i % nodes == pop:  # 该节点负责的文件
                (task_dir / f"CONTCAR_{i}").write_text(
                    f"CONTCAR_{i} content", encoding="utf-8"
                )
                (task_dir / f"OUTCAR_{i}").write_text(
                    f"OUTCAR_{i} content\nTOTEN = -10.123456\n", encoding="utf-8"
                )

    # 6. 使用固定job_id执行被测函数
    with patch("uuid.uuid4") as mock_uuid:
        mock_uuid.return_value = "test-job-123"

        # 创建PID文件
        pid_file = Path("/tmp/dpdisp_job_test-job-123.pid")
        pid_file.parent.mkdir(exist_ok=True)
        pid_file.write_text("12345", encoding="utf-8")

        # 7. 执行被测函数
        crystal_generator.dpdisp_mlp_tasks(
            machine_path=str(machine_path),
            resources_path=str(resources_path),
            nodes=nodes,
        )

    # 8. 验证日志
    assert "Batch optimization completed!!!" in caplog.text

    # 9. 验证 pop 目录创建
    for i in range(nodes):
        pop_dir = crystal_generator.primitive_cell_dir / (parent + f"pop{i}")
        assert pop_dir.exists(), f"pop{i} directory not created"

    # 10. 验证每个 pop 目录包含正确文件
    for i in range(nodes):
        pop_dir = crystal_generator.primitive_cell_dir / (parent + f"pop{i}")
        assert (pop_dir / "mlp_opt.py").exists()
        assert (pop_dir / "model.pt").exists()
        # 验证分配的 POSCAR 文件（根据你的分发逻辑）
        # 假设你按 index % nodes 分配
        for j in range(3):
            if j % nodes == i:
                assert (pop_dir / f"POSCAR_{j}").exists()

    # 11. 验证优化后文件被复制到 mlp_optimized
    optimized_dir = crystal_generator.base_dir / "2_mlp_optimized"
    assert optimized_dir.exists()
    assert len(list(optimized_dir.rglob("CONTCAR_*"))) == 3
    assert len(list(optimized_dir.rglob("OUTCAR_*"))) == 3

    # 12. 验证中间文件被清理
    assert not (crystal_generator.primitive_cell_dir / "mlp_opt.py").exists()
    assert not (crystal_generator.primitive_cell_dir / "model.pt").exists()

    # 14. 验证 rmtree 被调用
    mock_rmtree.assert_called()

    # 15. 验证 dpdispatcher 被调用
    mock_sub.assert_called()
    mock_task.assert_called()
    mock_run.assert_called_once()

    # 16. 验证 ssh_context 被调用
    if context_type == "SSHContext":
        mock_setup_ssh.assert_called_once()
        mock_ensure_alive.assert_called_once()


@patch("dpdispatcher.Submission.run_submission")
@patch("dpdispatcher.Submission.__init__")
@patch("dpdispatcher.Task.__init__", return_value=None)
@patch("dpdispatcher.contexts.ssh_context.SSHSession._setup_ssh")
@patch("dpdispatcher.contexts.ssh_context.SSHSession.ensure_alive")
@patch("dpdispatcher.contexts.ssh_context.SSHSession.sftp", new_callable=MagicMock)
@patch("shutil.rmtree")
def test_dpdisp_mlp_tasks_remote_exception(
    mock_rmtree,
    mock_sftp,
    mock_ensure_alive,
    mock_setup_ssh,
    mock_task,
    mock_sub,
    mock_run,
    crystal_generator: CrystalGenerator,
    tmp_path: Path,
    caplog,
):
    """测试 dpdisp_mlp_tasks 在提交失败时的异常处理"""
    # 1. 准备文件
    machine_path = tmp_path / "machine.json"
    resources_path = tmp_path / "resources.json"
    machine_config = {
        "context_type": "SSHContext",
        "local_root": "./",
        "remote_root": "/remote/workplace",
        "batch_type": "Shell",
        "remote_profile": {
            "hostname": "your.host.name.IPv4",
            "username": "your_username",
        },
    }

    machine_path.write_text(json.dumps(machine_config, indent=2), encoding="utf-8")
    resources_config = {
        "number_node": 1,
        "cpu_per_node": 4,
        "gpu_per_node": 0,
        "group_size": 1,
    }
    resources_path.write_text(json.dumps(resources_config, indent=2), encoding="utf-8")

    crystal_generator.primitive_cell_dir.mkdir(exist_ok=True, parents=True)
    for i in range(3):
        (crystal_generator.primitive_cell_dir / f"POSCAR_{i}").write_text(
            "dummy", encoding="utf-8"
        )
    crystal_generator.mlp_opt_file = tmp_path / "mlp_opt.py"
    crystal_generator.model_file = tmp_path / "model.pt"
    crystal_generator.mlp_opt_file.write_text("def main(): pass", encoding="utf-8")
    crystal_generator.model_file.write_text("model weights", encoding="utf-8")

    mock_sftp.return_value = MagicMock()
    mock_sftp.return_value.mkdir = MagicMock()

    mock_sub.side_effect = lambda *args, **kwargs: None
    # 模拟 run_submission 抛异常
    mock_run.side_effect = Exception("Submission failed due to network error")

    # 执行
    with pytest.raises(Exception, match="Submission failed due to network error"):
        crystal_generator.dpdisp_mlp_tasks(
            machine_path=str(machine_path),
            resources_path=str(resources_path),
            nodes=1,
        )

    # 验证日志中记录了错误
    assert (
        "Submission failed with error: Submission failed due to network error"
        in caplog.text
    )

    # 验证 submission 被创建
    mock_sub.assert_called_once()
    mock_run.assert_called_once()
    mock_task.assert_called()
    mock_rmtree.assert_called()


# ==================== 测试 _signal_handler 私有函数 ====================
@patch("sys.exit")
@patch("ion_CSP.gen_opt.CrystalGenerator._terminate_tasks")
def test_signal_handler_success(
    mock_terminate, mock_exit, crystal_generator: CrystalGenerator
):
    """直接测试类方法 _signal_handler 是否行为正确"""

    # 模拟 submission
    mock_submission = MagicMock()
    crystal_generator._submission = mock_submission

    # 模拟日志
    with patch("logging.info") as mock_info:
        # 模拟触发 SIGINT
        crystal_generator._signal_handler(signal.SIGINT, None)

        # 验证
        mock_info.assert_any_call(
            "Received signal 2 (Ctrl+C or kill), stopping all submitted tasks..."
        )
        mock_terminate.assert_called_once()
        mock_info.assert_any_call("All tasks stopped gracefully.")
        mock_exit.assert_called_once_with(0)


@patch("sys.exit")
@patch("ion_CSP.gen_opt.CrystalGenerator._terminate_tasks")
def test_signal_handler_no_active_submission(
    mock_terminate, mock_exit, crystal_generator: CrystalGenerator
):
    """直接测试类方法 _signal_handler 在无 active submission 时的行为"""

    # 模拟 submission 为空
    crystal_generator._submission = None

    # 模拟日志
    with patch("logging.warning") as mock_warning:
        # 模拟触发 SIGINT
        crystal_generator._signal_handler(signal.SIGINT, None)

        # 验证
        mock_terminate.assert_not_called()
        mock_warning.assert_any_call("No active submission to stop.")
        mock_exit.assert_called_once_with(0)


@patch("sys.exit")
@patch("ion_CSP.gen_opt.CrystalGenerator._terminate_tasks")
@patch("logging.error")
def test_signal_handler_terminate_tasks_raises_exception(
    mock_logging_error, mock_terminate, mock_exit, crystal_generator: CrystalGenerator
):
    """
    Test that _signal_handler logs an error and exits gracefully
    when _terminate_tasks() raises an exception.
    """
    # 1. 模拟 _terminate_tasks 抛出异常
    mock_terminate.side_effect = Exception(
        "Failed to terminate tasks due to network timeout"
    )

    # 2. 模拟 submission 存在（确保进入 try 块）
    mock_submission = MagicMock()
    crystal_generator._submission = mock_submission

    # 3. 捕获 sys.exit(0) 调用
    # 4. 执行信号处理器
    crystal_generator._signal_handler(signal.SIGINT, None)

    # 5. 验证 _terminate_tasks 被调用
    mock_terminate.assert_called_once()

    # 6. 验证错误日志被记录
    mock_logging_error.assert_called_once_with(
        "Failed to stop submission: Failed to terminate tasks due to network timeout"
    )

    # 7. 验证 sys.exit(0) 仍被调用（即使终止失败）
    mock_exit.assert_called_once_with(0)


# ==================== 测试 _terminate_tasks 私有函数 ====================
def test_terminate_tasks_sshcontext_success(
    caplog, crystal_generator: CrystalGenerator
):
    """测试 SSHContext 模式下，remote_profile 完整，命令成功执行"""
    caplog.set_level(logging.INFO)
    crystal_generator._job_id = "test-job-123"
    mock_submission = MagicMock()
    mock_submission.machine.serialize.return_value = {
        "context_type": "SSHContext",
        "remote_profile": {"hostname": "192.168.1.10", "username": "user"},
    }
    crystal_generator._submission = mock_submission

    # 模拟 ssh 命令成功
    with patch(
        "subprocess.run", return_value=MagicMock(returncode=0, stderr="", stdout="")
    ):
        crystal_generator._terminate_tasks()

    # 验证三条日志：启动、成功
    assert len(caplog.records) == 2
    assert caplog.records[0].levelname == "INFO"
    assert (
        caplog.records[0].message
        == f"Terminating remote tasks on 192.168.1.10 with JOB_ID={crystal_generator._job_id}..."
    )
    assert caplog.records[1].levelname == "INFO"
    assert (
        caplog.records[1].message
        == "Remote termination command executed successfully on 192.168.1.10"
    )


def test_terminate_tasks_localcontext_success(
    caplog, crystal_generator: CrystalGenerator
):
    """测试 LocalContext 模式下成功杀死匹配的进程"""
    caplog.set_level(logging.INFO)
    crystal_generator._job_id = "test-job-123"
    mock_submission = MagicMock()
    mock_submission.machine.serialize.return_value = {"context_type": "LocalContext"}
    crystal_generator._submission = mock_submission

    # 模拟两个进程：一个匹配，一个不匹配
    proc1 = MagicMock()
    proc1.pid = 123
    proc1.info = {
        "pid": 123,
        "name": "python",
        "environ": {"DPDISPATCHER_JOB_ID": "test-job-123"},
    }
    proc1.terminate.return_value = None
    proc1.wait.return_value = None
    proc1.is_running.return_value = False

    proc2 = MagicMock()
    proc2.pid = 456
    proc2.info = {
        "pid": 456,
        "name": "python",
        "environ": {"DPDISPATCHER_JOB_ID": "other-job"},
    }

    with patch("psutil.process_iter", return_value=[proc1, proc2]):
        crystal_generator._terminate_tasks()

    # 验证日志：应有两条 INFO
    assert len(caplog.records) == 2
    assert caplog.records[0].levelname == "INFO"
    assert (
        caplog.records[0].message
        == f"Terminating local tasks with JOB_ID={crystal_generator._job_id}..."
    )
    assert caplog.records[1].levelname == "INFO"
    assert (
        caplog.records[1].message
        == f"Killing local process 123 (JOB_ID={crystal_generator._job_id})"
    )


def test_terminate_tasks_no_job_id(caplog, crystal_generator: CrystalGenerator):
    """测试 _job_id 不存在或为空时，不执行任何操作"""
    caplog.set_level(logging.INFO)
    crystal_generator._job_id = None
    crystal_generator._terminate_tasks()
    assert len(caplog.records) == 0  # 无任何日志

    crystal_generator._job_id = ""
    crystal_generator._terminate_tasks()
    assert len(caplog.records) == 0  # 仍无日志


def test_terminate_tasks_no_submission(caplog, crystal_generator: CrystalGenerator):
    """测试 _submission 不存在或为 None 时，不执行任何操作"""
    caplog.set_level(logging.INFO)
    crystal_generator._job_id = "test-job-123"
    crystal_generator._submission = None
    crystal_generator._terminate_tasks()
    assert len(caplog.records) == 0

    delattr(crystal_generator, "_submission")
    crystal_generator._terminate_tasks()
    assert len(caplog.records) == 0


def test_terminate_tasks_serialize_raises_attribute_error(
    caplog, crystal_generator: CrystalGenerator
):
    """测试 self._submission.machine.serialize() 抛出 AttributeError"""
    caplog.set_level(logging.ERROR)
    crystal_generator._job_id = "test-job-123"
    mock_submission = MagicMock()
    mock_submission.machine.serialize.side_effect = AttributeError(
        "No machine attribute"
    )
    crystal_generator._submission = mock_submission

    crystal_generator._terminate_tasks()

    # 验证只有一条 ERROR 日志
    assert len(caplog.records) == 1
    assert caplog.records[0].levelname == "ERROR"
    assert (
        caplog.records[0].message
        == "Cannot retrieve machine information for termination."
    )


def test_terminate_tasks_localcontext_timeout_expired(
    caplog, crystal_generator: CrystalGenerator
):
    """测试 LocalContext 模式下 proc.wait() 超时，应调用 proc.kill()"""
    caplog.set_level(logging.INFO)
    crystal_generator._job_id = "test-job-123"
    mock_submission = MagicMock()
    mock_submission.machine.serialize.return_value = {"context_type": "LocalContext"}
    crystal_generator._submission = mock_submission

    proc = MagicMock()
    proc.pid = 123
    proc.info = {
        "pid": 123,
        "name": "python",
        "environ": {"DPDISPATCHER_JOB_ID": "test-job-123"},
    }
    proc.terminate.return_value = None
    proc.wait.side_effect = psutil.TimeoutExpired(seconds=5)  # 模拟超时
    proc.kill.return_value = None
    proc.is_running.return_value = False  # kill 后不再运行

    with patch("psutil.process_iter", return_value=[proc]):
        crystal_generator._terminate_tasks()

    # 验证：应有两条日志：启动 + 杀死
    assert len(caplog.records) == 2
    assert caplog.records[0].levelname == "INFO"
    assert (
        caplog.records[0].message
        == f"Terminating local tasks with JOB_ID={crystal_generator._job_id}..."
    )
    assert caplog.records[1].levelname == "INFO"
    assert (
        caplog.records[1].message
        == f"Killing local process 123 (JOB_ID={crystal_generator._job_id})"
    )

    # 验证行为：terminate 被调用，wait 抛异常，kill 被调用
    proc.terminate.assert_called_once()
    proc.wait.assert_called_once_with(timeout=5)
    proc.kill.assert_called_once()


def test_terminate_tasks_localcontext_psutil_exceptions(
    caplog, crystal_generator: CrystalGenerator
):
    """测试 LocalContext 中遇到 psutil 异常时，不崩溃，不记录错误"""
    caplog.set_level(logging.INFO)
    crystal_generator._job_id = "test-job-123"
    mock_submission = MagicMock()
    mock_submission.machine.serialize.return_value = {"context_type": "LocalContext"}
    crystal_generator._submission = mock_submission

    # 模拟一个进程，但访问 environ 时抛出异常
    proc = MagicMock()
    proc.info = {
        "pid": 123,
        "name": "python",
        "environ": {"DPDISPATCHER_JOB_ID": "test-job-123"},
    }
    proc.terminate.side_effect = psutil.NoSuchProcess(123)
    proc.wait.side_effect = psutil.AccessDenied()
    proc.is_running.side_effect = psutil.ZombieProcess(123)

    with patch("psutil.process_iter", return_value=[proc]):
        crystal_generator._terminate_tasks()

    # 验证：只记录了启动日志，没有 error，没有 warning
    assert len(caplog.records) == 1
    assert caplog.records[0].levelname == "INFO"
    assert (
        caplog.records[0].message
        == f"Terminating local tasks with JOB_ID={crystal_generator._job_id}..."
    )


def test_terminate_tasks_sshcontext_missing_remote_profile(
    caplog, crystal_generator: CrystalGenerator
):
    """测试 SSHContext 但 remote_profile 缺失 hostname 或 username"""
    caplog.set_level(logging.WARNING)
    crystal_generator._job_id = "test-job-123"
    mock_submission = MagicMock()
    mock_submission.machine.serialize.return_value = {
        "context_type": "SSHContext",
        "remote_profile": {},  # 缺少 hostname 和 username
    }
    crystal_generator._submission = mock_submission

    crystal_generator._terminate_tasks()

    # 验证只有一条 WARNING
    assert len(caplog.records) == 1
    assert caplog.records[0].levelname == "WARNING"
    assert (
        caplog.records[0].message
        == "Cannot terminate remote tasks: missing remote_profile"
    )


def test_terminate_tasks_sshcontext_command_failed(
    caplog, crystal_generator: CrystalGenerator
):
    """测试 SSHContext 中 pkill 命令执行失败（非零返回码）"""
    caplog.set_level(logging.INFO)
    crystal_generator._job_id = "test-job-123"
    mock_submission = MagicMock()
    mock_submission.machine.serialize.return_value = {
        "context_type": "SSHContext",
        "remote_profile": {"hostname": "192.168.1.10", "username": "user"},
    }
    crystal_generator._submission = mock_submission

    # 模拟 ssh 命令失败
    mock_result = MagicMock()
    mock_result.returncode = 1
    mock_result.stderr = "Permission denied"
    mock_result.stdout = ""

    with patch("subprocess.run", return_value=mock_result):
        crystal_generator._terminate_tasks()

    # 验证两条日志：启动 + 失败警告
    assert len(caplog.records) == 2
    assert caplog.records[0].levelname == "INFO"
    assert (
        caplog.records[0].message
        == f"Terminating remote tasks on 192.168.1.10 with JOB_ID={crystal_generator._job_id}..."
    )
    assert caplog.records[1].levelname == "WARNING"
    assert caplog.records[1].message == "Remote termination failed: Permission denied"


def test_terminate_tasks_sshcontext_subprocess_exception(
    caplog, crystal_generator: CrystalGenerator
):
    """测试 SSHContext 中 subprocess.run 抛出异常（如 ssh 命令不存在）"""
    caplog.set_level(logging.INFO)  # 必须设为 INFO，才能捕获启动日志
    crystal_generator._job_id = "test-job-123"
    mock_submission = MagicMock()
    mock_submission.machine.serialize.return_value = {
        "context_type": "SSHContext",
        "remote_profile": {"hostname": "192.168.1.10", "username": "user"},
    }
    crystal_generator._submission = mock_submission

    # 模拟 subprocess.run 抛出 OSError（如 ssh 未安装）
    with patch(
        "subprocess.run",
        side_effect=OSError("[Errno 2] No such file or directory: 'ssh'"),
    ):
        crystal_generator._terminate_tasks()

    # 验证：应有两条日志
    assert len(caplog.records) == 2

    # 第一条：启动日志（INFO）
    assert caplog.records[0].levelname == "INFO"
    assert (
        caplog.records[0].message
        == f"Terminating remote tasks on 192.168.1.10 with JOB_ID={crystal_generator._job_id}..."
    )

    # 第二条：错误日志（ERROR）
    assert caplog.records[1].levelname == "ERROR"
    assert (
        "Failed to execute remote termination: [Errno 2] No such file or directory: 'ssh'"
        in caplog.records[1].message
    )


def test_terminate_tasks_unknown_context_type(
    caplog, crystal_generator: CrystalGenerator
):
    """测试未知 context_type（如 DockerContext）"""
    caplog.set_level(logging.WARNING)
    crystal_generator._job_id = "test-job-123"
    mock_submission = MagicMock()
    mock_submission.machine.serialize.return_value = {
        "context_type": "DockerContext",
        "remote_profile": {},
    }
    crystal_generator._submission = mock_submission

    crystal_generator._terminate_tasks()

    # 验证只有一条 WARNING
    assert len(caplog.records) == 1
    assert caplog.records[0].levelname == "WARNING"
    assert (
        caplog.records[0].message
        == "Unknown context_type: DockerContext, cannot terminate tasks"
    )


# ==================== 测试 _get_available_gpus 私有函数 ====================
def test_get_available_gpus_empty_output(caplog):
    """测试 nvidia-smi 返回空时的行为"""
    with patch("subprocess.check_output", return_value="") as mock_check:
        result = _get_available_gpus()
        assert result == []
        mock_check.assert_called_once()
        assert (
            "Error while getting GPU info" not in caplog.text
        )  # 没有报错日志，因为是正常空输出


def test_get_available_gpus_invalid_output(caplog):
    """测试 nvidia-smi 返回格式错误"""
    with patch("subprocess.check_output", return_value="invalid line") as mock_check:
        result = _get_available_gpus()
        assert result == []
        mock_check.assert_called_once()
        assert (
            "Unexpected error: invalid literal for int() with base 10: 'invalid line'\n"
            in caplog.text
        )  # 应该有解析错误日志


def test_get_available_gpus_called_error(caplog):
    """测试 nvidia-smi 调用失败"""
    with patch(
        "subprocess.check_output",
        side_effect=subprocess.CalledProcessError(1, "nvidia-smi"),
    ) as mock_check:
        result = _get_available_gpus()
        assert result == []
        mock_check.assert_called_once()
        assert "Error while getting GPU info" in caplog.text


def test_get_available_gpus_no_available_gpus():
    """测试所有 GPU 都被占用（无可用）"""
    output = """0,950,1000
1,850,1000
2,900,1000"""
    with patch("subprocess.check_output", return_value=output) as mock_check:
        result = _get_available_gpus(memory_percent_threshold=50)
        assert result == []  # 所有都 >50%，无可用
        mock_check.assert_called_once()


def test_get_available_gpus_some_available():
    """测试部分 GPU 可用，验证排序和阈值过滤"""
    output = """0,100,1000
1,450,1000
2,300,1000
3,600,1000"""
    with patch("subprocess.check_output", return_value=output) as mock_check:
        result = _get_available_gpus(memory_percent_threshold=50)
        # 应该返回：0(10%), 2(30%), 1(45%) —— 按负载升序
        assert result == [0, 2, 1]  # 索引顺序按内存使用升序
        mock_check.assert_called_once()


def test_get_available_gpus_all_available():
    """测试所有 GPU 都可用"""
    output = """0,50,1000
1,150,1000
2,250,1000"""
    with patch("subprocess.check_output", return_value=output) as mock_check:
        result = _get_available_gpus(memory_percent_threshold=100)
        assert result == [0, 1, 2]  # 按负载排序
        mock_check.assert_called_once()


# ==================== 测试 _wait_for_gpu 私有函数 ====================
def test_wait_for_gpu_immediate_available(caplog):
    """测试第一次就找到可用 GPU，立即返回"""
    caplog.set_level(logging.INFO)
    with (
        patch(
            "subprocess.check_output", return_value="0,10,1024\n1,45,1024"
        ) as mock_check,
        patch("time.sleep") as mock_sleep,
    ):
        selected = _wait_for_gpu(memory_percent_threshold=50, wait_time=10)
        assert selected == 0  # 最空闲的 GPU
        mock_check.assert_called_once()  # 只调用一次，立即返回
        mock_sleep.assert_not_called()  # 没有等待
        assert "Available GPU: [0, 1]" in caplog.text
        assert "Using GPU: 0" in caplog.text


def test_wait_for_gpu_wait_then_available(caplog):
    """测试第一次没有，第二次有，等待一次后返回"""

    caplog.set_level(logging.INFO)
    # 第一次调用：无可用 GPU
    # 第二次调用：有可用 GPU
    call_count = 0  # 用外部变量计数，避免闭包问题

    def side_effect(*args, **kwargs):
        nonlocal call_count
        call_count += 1
        if call_count == 1:
            return "0,1000,1000"  # 无 GPU
        elif call_count == 2:
            return "0,100,1000"  # 有 GPU
        else:
            return "0,100,1000"

    side_effect.call_count = 0

    with (
        patch("subprocess.check_output", side_effect=side_effect) as mock_check,
        patch("time.sleep") as mock_sleep,
    ):
        selected = _wait_for_gpu(memory_percent_threshold=50, wait_time=5)
        assert "No available GPUs found. Waiting for 5 second ..." in caplog.text
        assert "Available GPU: []" in caplog.text
        mock_sleep.assert_called_once_with(5)
        assert mock_check.call_count == 2
        assert selected == 0
        assert "Available GPU: [0]" in caplog.text
        assert "Using GPU: 0" in caplog.text


def test_wait_for_gpu_timeout_no_gpu(caplog):
    """测试等待超时仍无可用 GPU，函数应持续运行（无限循环）"""
    caplog.set_level(logging.INFO)

    # 1. 定义 side_effect，它会调用 3 次，第 4 次返回有效值（但不会执行）
    call_count_check = 0  # 用于计数 check_output

    def side_effect(*args, **kwargs):
        nonlocal call_count_check
        call_count_check += 1
        if call_count_check <= 3:
            return ""  # 模拟 nvidia-smi 失败
        return "0,10,1024"  # 不会执行到这

    # 2. 先 patch，再定义 sleep 的 side_effect，避免闭包捕获旧对象
    with (
        patch("subprocess.check_output", side_effect=side_effect) as mock_check,
        patch("time.sleep") as mock_sleep,
    ):
        # 3. 在 patch 内部定义 sleep 的 side_effect，确保它引用的是新 mock 对象
        sleep_call_count = 0  # 本地计数器

        def mock_sleep_func(seconds):
            nonlocal sleep_call_count
            sleep_call_count += 1
            if sleep_call_count >= 3:
                raise KeyboardInterrupt("Test interrupt")
            return None  # 防止返回值干扰

        mock_sleep.side_effect = mock_sleep_func  # 动态绑定，确保是最新 mock

        # 4. 执行函数
        try:
            _wait_for_gpu(memory_percent_threshold=50, wait_time=1)
        except KeyboardInterrupt:
            pass

        # 5. 验证
        assert mock_check.call_count == 3  # 调用了 3 次
        assert sleep_call_count == 3  # sleep 被调用了 3 次
        assert "No available GPUs found. Waiting for 1 second ..." in caplog.text
        assert "Unexpected error: invalid literal for int()" in caplog.text


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--cov=ion_CSP.gen_opt"])
