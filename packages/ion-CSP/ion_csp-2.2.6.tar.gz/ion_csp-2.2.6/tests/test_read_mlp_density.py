import csv
import shutil
import pytest
import tempfile
from pathlib import Path
from subprocess import CalledProcessError
from unittest.mock import patch, MagicMock

from ion_CSP.read_mlp_density import ReadMlpDensity


@pytest.fixture
def setup_temp_dirs():
    """创建临时目录结构用于测试"""
    with tempfile.TemporaryDirectory() as tmpdir:
        base_dir = Path(tmpdir)
        work_dir = base_dir / "test_work"
        work_dir.mkdir(parents=True, exist_ok=True)

        # 创建2_mlp_optimized目录结构
        mlp_dir = work_dir / "2_mlp_optimized"
        mlp_dir.mkdir(exist_ok=True)

        yield work_dir, mlp_dir


@pytest.fixture
def sample_contcar_files(setup_temp_dirs):
    """创建示例CONTCAR和OUTCAR文件用于测试"""
    work_dir, mlp_dir = setup_temp_dirs

    # 创建 config.yaml
    config_path = work_dir / "config.yaml"
    config_path.write_text(
        """
gen_opt:
  species: ["H2O.json", "H2O.json"]
  ion_numbers: [2, 1]
""",
        encoding="utf-8",
    )

    # 创建 species JSON 文件
    (work_dir / "H2O.json").write_text('{"volume": 50.0}', encoding="utf-8")
    (work_dir / "H2O.json").write_text('{"volume": 30.0}', encoding="utf-8")

    # 创建10个示例
    # 创建10个示例CONTCAR文件
    for i in range(1, 11):
        contcar_file = mlp_dir / f"CONTCAR_{i}"
        outcar_file = mlp_dir / f"OUTCAR_{i}"

        # 写入简化的CONTCAR内容
        contcar_content = f"""Generated by ASE
1.0
{"2.0 0.0 0.0"}
{"0.0 2.0 0.0"}
{"0.0 0.0 2.0"}
H O
2 1
Direct
{0.0} {0.0} {0.0}
{0.5} {0.5} {0.5}
{0.25} {0.25} {0.25}
"""
        contcar_file.write_text(contcar_content)

        # 写入简化的OUTCAR内容（包含TOTEN行）
        outcar_content = """
some initial lines
TOTEN = -100.00000000 -10.00000000
other lines
"""
        outcar_file.write_text(outcar_content)

    return work_dir, mlp_dir


# ==================== 测试 __init__ ====================
def test_init_success(setup_temp_dirs):
    """测试初始化成功情况"""
    work_dir, _ = setup_temp_dirs
    reader = ReadMlpDensity(work_dir)

    assert reader.base_dir == work_dir.resolve()
    assert reader.folder_dir == work_dir / "2_mlp_optimized"
    assert reader.max_density_dir == work_dir / "2_mlp_optimized" / "max_density"
    assert reader.min_energy_dir == work_dir / "2_mlp_optimized" / "min_energy"
    assert reader.primitive_cell_dir is None


def test_init_custom_folder(setup_temp_dirs):
    """测试使用自定义文件夹名称初始化"""
    work_dir, _ = setup_temp_dirs
    custom_dir = work_dir / "custom_mlp"
    custom_dir.mkdir(exist_ok=True)

    reader = ReadMlpDensity(work_dir, folder="custom_mlp")
    assert reader.folder_dir == custom_dir


def test_init_nonexistent_folder(setup_temp_dirs):
    """测试初始化时文件夹不存在的情况"""
    work_dir, _ = setup_temp_dirs
    with pytest.raises(FileNotFoundError, match="does not exist"):
        ReadMlpDensity(work_dir, folder="nonexistent_folder")


# ==================== 测试 _sequentially_read_files ====================
def test_sequentially_read_files_success(sample_contcar_files):
    """测试顺序读取文件功能 - 成功情况"""
    work_dir, mlp_dir = sample_contcar_files
    reader = ReadMlpDensity(work_dir)

    files = reader._sequentially_read_files(mlp_dir, "CONTCAR_")

    assert len(files) == 10
    # 检查文件是否按数字顺序排序
    numbers = [num for num, name in files]
    assert numbers == list(range(1, 11))


def test_sequentially_read_files_empty_dir(setup_temp_dirs):
    """测试空目录的文件读取"""
    work_dir, mlp_dir = setup_temp_dirs
    reader = ReadMlpDensity(work_dir)

    files = reader._sequentially_read_files(mlp_dir, "CONTCAR_")
    assert len(files) == 0


def test_sequentially_read_files_mixed_files(setup_temp_dirs):
    """测试混合文件类型的读取"""
    work_dir, mlp_dir = setup_temp_dirs

    # 创建混合文件
    (mlp_dir / "CONTCAR_1").write_text("test")
    (mlp_dir / "CONTCAR_2").write_text("test")
    (mlp_dir / "other_file.txt").write_text("test")
    (mlp_dir / "CONTCAR_abc").write_text("test")  # 非数字后缀

    reader = ReadMlpDensity(work_dir)
    files = reader._sequentially_read_files(mlp_dir, "CONTCAR_")

    # 应该只找到数字后缀的文件
    assert len(files) == 2
    assert files[0][0] == 1
    assert files[1][0] == 2


# ==================== 测试 read_property_and_sort ====================
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_read_property_and_sort_density_success(
    mock_read_vasp, mock_identify, sample_contcar_files
):
    """测试按密度排序成功情况"""
    work_dir, mlp_dir = sample_contcar_files

    # 模拟ASE原子对象
    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0  # 固定体积
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]  # 固定质量
    mock_read_vasp.return_value = mock_atoms

    # 模拟分子识别函数
    mock_identify.return_value = ({}, True, {})

    reader = ReadMlpDensity(work_dir)

    # 测试按密度排序
    reader.read_property_and_sort(n_screen=5, sort_by="density", molecules_screen=True)
    # 验证max_density目录被创建
    assert reader.max_density_dir.exists()

    # 验证生成的文件
    contcar_files = list(reader.max_density_dir.glob("CONTCAR_*"))
    assert len(contcar_files) == 5

    # 验证CSV文件
    csv_file = reader.max_density_dir / "mlp_density_energy.csv"
    assert csv_file.exists()


@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_read_property_and_sort_energy_success(
    mock_read_vasp, mock_identify, sample_contcar_files
):
    """测试按能量排序成功情况"""
    work_dir, mlp_dir = sample_contcar_files

    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})

    reader = ReadMlpDensity(work_dir)
    reader.read_property_and_sort(n_screen=3, sort_by="energy", molecules_screen=False)

    assert reader.min_energy_dir.exists()
    assert len(list(reader.min_energy_dir.glob("CONTCAR_*"))) == 3


@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_read_property_and_sort_invalid_sort_by(
    mock_read_vasp, mock_identify, sample_contcar_files
):
    """测试无效的排序参数"""
    work_dir, mlp_dir = sample_contcar_files

    reader = ReadMlpDensity(work_dir)

    with pytest.raises(
        ValueError, match="sort_by parameter must be either 'density' or 'energy'"
    ):
        reader.read_property_and_sort(sort_by="invalid_sort")


@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_read_property_and_sort_insufficient_ionic_crystals(
    mock_read_vasp, mock_identify, sample_contcar_files
):
    """测试离子晶体数量不足的情况"""
    work_dir, mlp_dir = sample_contcar_files

    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms

    # 模拟只有2个结构符合离子晶体条件，但要求5个
    mock_identify.return_value = ({}, False, {})  # molecules_flag = False

    reader = ReadMlpDensity(work_dir)

    with pytest.raises(
        ValueError, match="Only 0 ionic crystals with original ions found"
    ):
        reader.read_property_and_sort(n_screen=5, molecules_screen=True)


@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_read_property_and_sort_missing_outcar(
    mock_read_vasp, mock_identify, sample_contcar_files
):
    """测试OUTCAR文件缺失的情况"""
    work_dir, mlp_dir = sample_contcar_files

    # 删除一些OUTCAR文件模拟缺失
    for i in range(6, 11):
        (mlp_dir / f"OUTCAR_{i}").unlink(missing_ok=True)

    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})

    reader = ReadMlpDensity(work_dir)

    # 应该能正常处理，跳过缺失OUTCAR的文件
    reader.read_property_and_sort(n_screen=3, molecules_screen=False)

    # 验证只有前3个文件被处理（有OUTCAR的）
    csv_file = reader.sort_value_dir / "mlp_density_energy.csv"
    with open(csv_file, "r") as f:
        reader_csv = csv.reader(f)
        rows = list(reader_csv)
        # 标题行 + 3个数据行
        assert len(rows) == 4


@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_read_property_and_sort_contcar_not_found(
    mock_read_vasp, mock_identify, setup_temp_dirs
):
    """测试CONTCAR文件不存在的情况"""
    work_dir, mlp_dir = setup_temp_dirs

    # 只创建OUTCAR文件，不创建CONTCAR
    for i in range(1, 6):
        (mlp_dir / f"OUTCAR_{i}").write_text("TOTEN = -100.00000000 eV")

    reader = ReadMlpDensity(work_dir)

    with pytest.raises(FileNotFoundError):
        reader.read_property_and_sort(n_screen=3, molecules_screen=False)


@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_read_property_and_sort_backup_mechanism(
    mock_read_vasp, mock_identify, sample_contcar_files
):
    """测试备份机制"""
    work_dir, mlp_dir = sample_contcar_files

    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})

    reader = ReadMlpDensity(work_dir)

    # 第一次运行
    reader.read_property_and_sort(n_screen=3, sort_by="density")

    # 创建一些文件模拟已存在的情况
    existing_file = reader.max_density_dir / "test_file.txt"
    existing_file.write_text("test content")

    # 第二次运行应该触发备份机制
    reader.read_property_and_sort(n_screen=2, sort_by="density")

    # 验证备份目录存在
    backup_dir = mlp_dir / "backup" / "max_density"
    assert backup_dir.exists()


@pytest.mark.parametrize(
    "n_screen,sort_by,molecules_screen,detail_log",
    [
        (5, "density", True, False),
        (3, "energy", False, True),
        (1, "density", True, True),
    ],
)
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_read_property_parameterized(
    mock_read_vasp,
    mock_identify,
    sample_contcar_files,
    n_screen,
    sort_by,
    molecules_screen,
    detail_log,
):
    """参数化测试不同的输入组合"""
    work_dir, mlp_dir = sample_contcar_files

    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})

    reader = ReadMlpDensity(work_dir)

    # 测试各种参数组合
    reader.read_property_and_sort(
        n_screen=n_screen,
        sort_by=sort_by,
        molecules_screen=molecules_screen,
        detail_log=detail_log,
    )

    target_dir = (
        reader.max_density_dir if sort_by == "density" else reader.min_energy_dir
    )
    assert target_dir.exists()
    assert len(list(target_dir.glob("CONTCAR_*"))) == min(n_screen, 10)


# ==================== 测试 phonopy_processing_max_density ====================
@patch("subprocess.run")
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_phonopy_processing_success(
    mock_read_vasp, mock_identify, mock_subprocess, sample_contcar_files
):
    """测试phonopy处理成功情况"""
    work_dir, mlp_dir = sample_contcar_files

    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})
    mock_subprocess.return_value.returncode = 0

    reader = ReadMlpDensity(work_dir)
    reader.read_property_and_sort(n_screen=3, sort_by="density")

    # 测试phonopy处理
    reader.phonopy_processing_max_density()

    assert reader.primitive_cell_dir.exists()
    assert (work_dir / "3_for_vasp_opt").exists()


def test_phonopy_processing_without_sorting(setup_temp_dirs):
    """测试未先运行排序就进行phonopy处理"""
    work_dir, mlp_dir = setup_temp_dirs

    reader = ReadMlpDensity(work_dir)

    with pytest.raises(
        ValueError, match="Please run read_property_and_sort method first"
    ):
        reader.phonopy_processing_max_density()


@patch("subprocess.run")
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_phonopy_processing_specific_directory(
    mock_read_vasp, mock_identify, mock_subprocess, sample_contcar_files
):
    """测试指定目录的phonopy处理"""
    work_dir, mlp_dir = sample_contcar_files

    reader = ReadMlpDensity(work_dir)

    # 创建自定义目录和文件
    custom_dir = mlp_dir / "custom_processing"
    custom_dir.mkdir(exist_ok=True)

    # 创建真正的 PPOSCAR 文件（真实存在）
    pposcar_path = custom_dir / "PPOSCAR"
    pposcar_path.write_text("PPOSCAR content")

    (custom_dir / "CONTCAR_1").write_text("test content")
    (custom_dir / "OUTCAR_1").write_text("TOTEN = -100.00000000 -10.00000000")

    # 模拟 phonopy 成功
    mock_subprocess.return_value.returncode = 0

    # 运行
    reader.phonopy_processing_max_density(specific_directory=str(custom_dir))

    # 验证：PPOSCAR 被复制为 CONTCAR_1
    primitive_cell_dir = mlp_dir / "primitive_cell"
    contcar_file = primitive_cell_dir / "CONTCAR_1"
    assert primitive_cell_dir.exists()
    assert contcar_file.exists()
    assert contcar_file.read_text() == "PPOSCAR content"


def test_phonopy_processing_specific_directory_not_exists(setup_temp_dirs):
    """测试指定目录不存在的情况"""
    work_dir, mlp_dir = setup_temp_dirs

    reader = ReadMlpDensity(work_dir)
    specific_directory = mlp_dir / "nonexistent_dir"
    with pytest.raises(
        FileNotFoundError,
        match=f"The specified directory {specific_directory} does not exist",
    ):
        reader.phonopy_processing_max_density(
            specific_directory=str(specific_directory)
        )


@patch("subprocess.run")
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_phonopy_processing_backup_existing_files(
    mock_read_vasp, mock_identify, mock_subprocess, sample_contcar_files
):
    """测试当 primitive_cell_dir 已存在文件时，是否正确备份"""
    work_dir, mlp_dir = sample_contcar_files

    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})

    mock_subprocess.return_value.returncode = 0

    reader = ReadMlpDensity(work_dir)
    reader.read_property_and_sort(n_screen=1, sort_by="density")

    # 手动创建 CONTCAR_1 与 PPOSCAR 文件（phonopy 的输入与输出）
    contcar_path = reader.sort_value_dir / "CONTCAR_1"
    contcar_path.write_text("CONTCAR content for atom 1")
    pposcar_path = reader.sort_value_dir / "PPOSCAR"
    pposcar_path.write_text("PPOSCAR content")

    # 创建 primitive_cell_dir 并创建文件
    reader.primitive_cell_dir = reader.sort_value_dir.parent / "primitive_cell"
    reader.primitive_cell_dir.mkdir(exist_ok=True)
    test_file = reader.primitive_cell_dir / "existing_file.txt"
    test_file.write_text("backup me")
    assert test_file.exists(), "Test file should exist before backup"
    # 调用触发备份逻辑
    reader.phonopy_processing_max_density()

    # 验证：旧文件被备份
    backup_dir = reader.folder_dir / "backup" / "primitive_cell"
    assert backup_dir.exists(), "Backup directory should be created"
    assert (backup_dir / "existing_file.txt").exists(), "Old file was not backed up!"
    assert not test_file.exists(), "Original file should be moved (not copied)"

    # 验证：新文件被生成（来自 PPOSCAR）
    assert (reader.primitive_cell_dir / "CONTCAR_1").exists(), (
        "New CONTCAR was not generated from PPOSCAR!"
    )


@patch("subprocess.run")
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_phonopy_processing_no_pposcar_generated(
    mock_read_vasp, mock_identify, mock_subprocess, sample_contcar_files, caplog
):
    """测试当 phonopy 成功但未生成 PPOSCAR 时，是否记录警告"""
    work_dir, mlp_dir = sample_contcar_files

    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})

    # 模拟 phonopy 成功，但不生成 PPOSCAR
    mock_subprocess.return_value.returncode = 0

    reader = ReadMlpDensity(work_dir)
    reader.read_property_and_sort(n_screen=1, sort_by="density")

    # 不创建 PPOSCAR 文件
    reader.phonopy_dir = reader.max_density_dir
    reader.phonopy_dir.mkdir(exist_ok=True)
    (reader.phonopy_dir / "POSCAR").touch()

    reader.phonopy_processing_max_density()

    # 验证警告被记录
    assert "PPOSCAR not generated for CONTCAR_0.498_1" in caplog.text


@patch("subprocess.run")
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_phonopy_processing_expected_failure(
    mock_read_vasp, mock_identify, mock_subprocess, sample_contcar_files
):
    """测试phonopy处理失败情况"""
    work_dir, mlp_dir = sample_contcar_files
    # 模拟ASE原子对象
    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})

    # 正确模拟 phonopy 命令失败时抛出的异常类型
    mock_subprocess.side_effect = CalledProcessError(
        returncode=1,
        cmd=["phonopy", "--symmetry", "POSCAR"],
        output=b"phonopy: error: symmetry analysis failed\n",
    )

    reader = ReadMlpDensity(work_dir)
    reader.read_property_and_sort(n_screen=2, sort_by="density")

    # 现在调用 phonopy_processing_max_density —— 它**不应该抛出任何异常！**
    # 因为你的代码用 try/except 捕获了所有异常，并用 continue 跳过
    reader.phonopy_processing_max_density()

    # 验证日志文件被创建（说明错误被记录）
    log_file = reader.primitive_cell_dir / "phonopy.log"
    assert log_file.exists()

    # 验证日志中包含错误信息
    with open(log_file, "r", encoding="utf-8") as f:
        log_content = f.read()
        assert "Processing file: CONTCAR_0.498_1" in log_content
        assert (
            "Phonopy processing failed for file: CONTCAR_0.498_2 with return code: 1. Check phonopy.log for details."
            in log_content
        )


@patch("subprocess.run")
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_phonopy_processing_unexpected_exception(
    mock_read_vasp, mock_identify, mock_subprocess, sample_contcar_files
):
    """测试 phonopy 处理时发生未预期异常（如权限错误）"""
    work_dir, mlp_dir = sample_contcar_files

    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})

    # 模拟一个非 subprocess 的异常，如 PermissionError
    mock_subprocess.side_effect = PermissionError("Permission denied")

    reader = ReadMlpDensity(work_dir)
    reader.read_property_and_sort(n_screen=1, sort_by="density")

    # 调用 phonopy，应捕获异常并继续
    reader.phonopy_processing_max_density()

    # 验证日志中包含错误信息
    log_file = reader.primitive_cell_dir / "phonopy.log"
    assert log_file.exists()
    with open(log_file, "r", encoding="utf-8") as f:
        log_content = f.read()
        assert (
            "Processing file: CONTCAR_0.498_1 with unexpected error: Permission denied"
            in log_content
        )


@patch("subprocess.run")
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_phonopy_processing_no_contcar_files(
    mock_read_vasp, mock_identify, mock_subprocess, sample_contcar_files
):
    """测试当 phonopy_dir 中无 CONTCAR 文件时抛出异常"""
    work_dir, mlp_dir = sample_contcar_files
    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})
    mock_subprocess.return_value.returncode = 0

    reader = ReadMlpDensity(work_dir)
    reader.read_property_and_sort(n_screen=1, sort_by="density")

    # 提前删除目录下文件，使其成为一个空目录
    for f in reader.sort_value_dir.iterdir():
        f.unlink()

    with pytest.raises(
        FileNotFoundError, match="No CONTCAR files found for phonopy processing"
    ):
        reader.phonopy_processing_max_density()


@patch("subprocess.run")
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_phonopy_processing_missing_outcar_and_csv(
    mock_read_vasp, mock_identify, mock_subprocess, sample_contcar_files, caplog
):
    """测试当 OUTCAR 或 mlp_density_energy.csv 不存在时，是否记录警告"""
    work_dir, mlp_dir = sample_contcar_files

    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})

    mock_subprocess.return_value.returncode = 0

    reader = ReadMlpDensity(work_dir)
    reader.read_property_and_sort(n_screen=1, sort_by="density")

    reader.phonopy_dir = reader.max_density_dir
    # 删除 OUTCAR 和 CSV
    (reader.phonopy_dir / "OUTCAR_0.498_1").unlink(missing_ok=True)
    (reader.phonopy_dir / "mlp_density_energy.csv").unlink(missing_ok=True)

    reader.phonopy_processing_max_density()

    assert "OUTCAR_0.498_1 not found for CONTCAR_0.498_1" in caplog.text
    assert "mlp_density_energy.csv not found" in caplog.text


@patch("subprocess.run")
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_phonopy_processing_for_vasp_opt_dir_not_exists(
    mock_read_vasp, mock_identify, mock_subprocess, sample_contcar_files
):
    """测试当 3_for_vasp_opt 目录不存在时，是否能正确创建"""
    work_dir, mlp_dir = sample_contcar_files
    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})
    mock_subprocess.return_value.returncode = 0

    reader = ReadMlpDensity(work_dir)
    reader.read_property_and_sort(n_screen=1, sort_by="density")

    reader.phonopy_processing_max_density()
    # 删除 3_for_vasp_opt
    for_vasp_opt_dir = reader.base_dir / "3_for_vasp_opt"
    if for_vasp_opt_dir.exists():
        shutil.rmtree(for_vasp_opt_dir)

    # 手动创建 CONTCAR_1 与 PPOSCAR 文件（phonopy 的输入与输出）
    contcar_path = reader.sort_value_dir / "CONTCAR_0.498_1"
    contcar_path.write_text("CONTCAR content for atom 1")
    pposcar_path = reader.sort_value_dir / "PPOSCAR"
    pposcar_path.write_text("PPOSCAR content")

    reader.phonopy_processing_max_density()

    # 验证它被创建了
    assert for_vasp_opt_dir.exists()
    assert (for_vasp_opt_dir / "CONTCAR_0.498_1").exists()


@patch("subprocess.run")
@patch("ion_CSP.read_mlp_density.identify_molecules")
@patch("ion_CSP.read_mlp_density.read_vasp")
def test_phonopy_processing_for_vasp_opt_dir_exists(
    mock_read_vasp, mock_identify, mock_subprocess, sample_contcar_files
):
    """测试当 3_for_vasp_opt 目录存在时，是否被正确删除"""
    work_dir, mlp_dir = sample_contcar_files
    mock_atoms = MagicMock()
    mock_atoms.get_volume.return_value = 10.0
    mock_atoms.get_masses.return_value = [1.0, 1.0, 1.0]
    mock_read_vasp.return_value = mock_atoms
    mock_identify.return_value = ({}, True, {})
    mock_subprocess.return_value.returncode = 0

    reader = ReadMlpDensity(work_dir)
    reader.read_property_and_sort(n_screen=1, sort_by="density")

    # 创建 3_for_vasp_opt 目录并放一个文件
    for_vasp_opt_dir = reader.base_dir / "3_for_vasp_opt"
    for_vasp_opt_dir.mkdir(exist_ok=True)
    temp_file = for_vasp_opt_dir / "temp_file.txt"
    temp_file.write_text("to be deleted")

    # 创建 CONTCAR 与 PPOSCAR
    (reader.sort_value_dir / "CONTCAR_0.498_1").write_text("CONTCAR content")
    (reader.sort_value_dir / "PPOSCAR").write_text("PPOSCAR content")

    # 执行
    reader.phonopy_processing_max_density()

    # 验证：原目录下所有内容被删除
    assert not temp_file.exists(), (
        "Temporary file in 3_for_vasp_opt folder should be deleted before copytree"
    )

    # 验证：新目录被创建
    assert for_vasp_opt_dir.exists()
    assert (for_vasp_opt_dir / "CONTCAR_0.498_1").exists()


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--cov=ion_CSP.read_mlp_density"])
