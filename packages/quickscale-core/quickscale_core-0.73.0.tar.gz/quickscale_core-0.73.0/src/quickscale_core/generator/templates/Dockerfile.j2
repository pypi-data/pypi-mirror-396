# syntax=docker/dockerfile:1
# Multi-stage build for production Django application

# Stage 1: Builder - Install dependencies and build artifacts
FROM python:3.12-slim as builder

# Set environment variables for Python
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Install system dependencies required for building Python packages
RUN echo "üì¶ Installing system build dependencies..." && \
    apt-get update && apt-get install -y --no-install-recommends \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/* && \
    echo "‚úÖ System dependencies installed"

# Install Poetry
RUN echo "üì¶ Installing Poetry..." && \
    pip install poetry==2.2.1 && \
    echo "‚úÖ Poetry installed: $(poetry --version)"

# Set working directory
WORKDIR /app

# Copy dependency files first for better caching
COPY pyproject.toml poetry.lock ./

# Copy application code (needed for path dependencies like embedded modules)
# We copy early to ensure Poetry can resolve path dependencies in pyproject.toml
# Note: This means code changes will invalidate the dependency cache, but it's
# necessary for projects with embedded modules (path dependencies)
COPY . .

# Configure Poetry to not create virtual environments (we're in a container)
RUN poetry config virtualenvs.create false

# Build argument to control dependency installation
ARG INSTALL_DEV=false

# Install dependencies with retry logic for network resilience
# For development (INSTALL_DEV=true): Install all dependencies including dev
# For production (INSTALL_DEV=false): Install only main dependencies
# Retry up to 3 times to handle transient network issues (PyPI timeouts)
RUN echo "üì¶ Installing Python dependencies (INSTALL_DEV=$INSTALL_DEV)..." && \
    export POETRY_HTTP_TIMEOUT=120 && \
    for attempt in 1 2 3; do \
        echo "  Attempt $attempt of 3..." && \
        if [ "$INSTALL_DEV" = "true" ]; then \
            poetry install --no-root --no-interaction --no-ansi && break; \
        else \
            poetry install --only main --no-root --no-interaction --no-ansi && break; \
        fi; \
        if [ $attempt -lt 3 ]; then \
            echo "  ‚ö†Ô∏è Attempt $attempt failed, retrying in 5 seconds..." && sleep 5; \
        else \
            echo "  ‚ùå All attempts failed" && exit 1; \
        fi; \
    done && \
    echo "‚úÖ Python dependencies installed"

# Stage 2: Runtime - Create minimal production image
FROM python:3.12-slim

# Set environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    DJANGO_SETTINGS_MODULE={{ project_name }}.settings.production

# Port configuration
ARG PORT=8000
ENV PORT=${PORT}

# Install runtime dependencies only
RUN echo "üì¶ Installing runtime dependencies..." && \
    apt-get update && apt-get install -y --no-install-recommends \
    libpq5 \
    && rm -rf /var/lib/apt/lists/* && \
    echo "‚úÖ Runtime dependencies installed"

# Create non-root user for security
RUN echo "üë§ Creating django user..." && \
    groupadd -r django && useradd -r -g django django && \
    echo "‚úÖ User created"

# Set working directory
WORKDIR /app

# Copy installed dependencies from builder stage
RUN echo "üì¶ Copying Python packages from builder..."
COPY --from=builder /usr/local/lib/python3.12/site-packages /usr/local/lib/python3.12/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin
RUN echo "‚úÖ Python packages copied"

# Copy application code
RUN echo "üìã Copying application code..."
COPY --chown=django:django . .
RUN echo "‚úÖ Application code copied"

# Make start.sh executable
RUN chmod +x /app/start.sh && \
    echo "‚úÖ Startup script configured"

# Create necessary directories with correct permissions
RUN echo "üìÅ Creating application directories..." && \
    mkdir -p /app/staticfiles /app/media /app/logs && \
    chown -R django:django /app && \
    echo "‚úÖ Directories created"

# Switch to non-root user
USER django

# Collect static files (safe to run at build time, doesn't need DATABASE_URL)
RUN echo "üì¶ Collecting static files..." && \
    python manage.py collectstatic --noinput && \
    echo "‚úÖ Static files collected: $(ls -lh /app/staticfiles | wc -l) files"

# Expose port
EXPOSE ${PORT}

# Health check - verify gunicorn is responding (any response including 404/500 means it's alive)
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD python -c "import os, urllib.request; urllib.request.urlopen(f'http://localhost:{os.environ.get(\"PORT\", \"8000\")}/', timeout=5)"

# Note: Migrations should run via railway.json startCommand at deployment time
# This ensures DATABASE_URL is available when migrations run
# Run gunicorn
CMD gunicorn {{ project_name }}.wsgi:application --bind 0.0.0.0:${PORT} --workers 4 --timeout 60 --access-logfile - --error-logfile -
