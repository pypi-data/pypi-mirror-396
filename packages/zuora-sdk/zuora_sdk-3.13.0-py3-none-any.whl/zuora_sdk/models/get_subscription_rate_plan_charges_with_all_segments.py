# coding: utf-8

"""
    Zuora API Reference

    REST API reference for the Zuora Billing, Payments, and Central Platform! Check out the [REST API Overview](https://www.zuora.com/developer/api-references/api/overview/).

    The version of the OpenAPI document: 2025-08-12
    Contact: docs@zuora.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import field_validator
from datetime import date
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from zuora_sdk.models.apply_discount_to import ApplyDiscountTo
from zuora_sdk.models.billing_period import BillingPeriod
from zuora_sdk.models.billing_period_alignment import BillingPeriodAlignment
from zuora_sdk.models.billing_timing import BillingTiming
from zuora_sdk.models.charge_function import ChargeFunction
from zuora_sdk.models.charge_list_price_base import ChargeListPriceBase
from zuora_sdk.models.charge_model import ChargeModel
from zuora_sdk.models.charge_model_configuration_for_subscription import ChargeModelConfigurationForSubscription
from zuora_sdk.models.charge_type import ChargeType
from zuora_sdk.models.commitment_type import CommitmentType
from zuora_sdk.models.delivery_schedule import DeliverySchedule
from zuora_sdk.models.discount_apply_detail import DiscountApplyDetail
from zuora_sdk.models.discount_level import DiscountLevel
from zuora_sdk.models.end_date_condition import EndDateCondition
from zuora_sdk.models.interval_pricing import IntervalPricing
from zuora_sdk.models.overage_calculation_option import OverageCalculationOption
from zuora_sdk.models.overage_unused_units_credit_option import OverageUnusedUnitsCreditOption
from zuora_sdk.models.price_change_option import PriceChangeOption
from zuora_sdk.models.rate_plan_charge_segment import RatePlanChargeSegment
from zuora_sdk.models.rate_plan_charge_tier import RatePlanChargeTier
from zuora_sdk.models.rating_group import RatingGroup
from zuora_sdk.models.smoothing_model import SmoothingModel
from zuora_sdk.models.trigger_event import TriggerEvent
from zuora_sdk.models.up_to_periods_type import UpToPeriodsType
from zuora_sdk.models.usage_record_rating_option import UsageRecordRatingOption
from zuora_sdk.models.validity_period_type import ValidityPeriodType
from typing import Optional, Set
from typing_extensions import Self

class GetSubscriptionRatePlanChargesWithAllSegments(BaseModel):
    """
    GetSubscriptionRatePlanChargesWithAllSegments
    """ # noqa: E501
    # avoid validation
    def __init__(self, **kwargs):
        # Directly assign values without validation using `construct()`
        model = self.construct(**kwargs)
        self.__dict__.update(model.__dict__)

        _dict_all = convert_snake_dict_to_camel(kwargs, self.model_fields, self.__properties)

        _dict = self.to_alias_dict(_dict_all)
        for field_name, field_info in self.model_fields.items():
            alias = field_info.alias or field_name
            if alias in _dict:
                self.__dict__[field_name] = _dict.get(alias)
        self.update_additional_properties(self, _dict_all)
        pass

    def __setattr__(self, name, value):
        # Override setattr to bypass validation when setting attributes
        object.__setattr__(self, name, value)

    billing_day: Optional[StrictStr] = Field(default=None, alias="billingDay")
    billing_period: Optional[BillingPeriod] = Field(default=None, alias="billingPeriod")
    billing_period_alignment: Optional[BillingPeriodAlignment] = Field(default=None, alias="billingPeriodAlignment")
    billing_timing: Optional[BillingTiming] = Field(default=None, alias="billingTiming")
    charge_segments: Optional[List[RatePlanChargeSegment]] = Field(default=None, description="Billing cycle day (BCD), which is when bill runs generate invoices for charges associated with the product rate plan charge or the account.    Values:  * `DefaultFromCustomer` * `SpecificDayofMonth(# of the month)` * `SubscriptionStartDay` * `ChargeTriggerDay` * `SpecificDayofWeek/dayofweek`: in which dayofweek is the day in the week you define your billing periods to start.  In the response data, a day-of-the-month ordinal value (`first`-`31st`) appears in place of the hash sign above (\"#\"). If this value exceeds the number of days in a particular month, the last day of the month is used as the BCD. ", alias="chargeSegments")
    exclude_item_billing_from_revenue_accounting: Optional[StrictBool] = Field(default=None, alias="excludeItemBillingFromRevenueAccounting")
    exclude_item_booking_from_revenue_accounting: Optional[StrictBool] = Field(default=None, alias="excludeItemBookingFromRevenueAccounting")
    invoice_schedule_id: Optional[StrictStr] = Field(default=None, alias="invoiceScheduleId")
    is_allocation_eligible: Optional[StrictBool] = Field(default=None, alias="isAllocationEligible")
    is_unbilled: Optional[StrictBool] = Field(default=None, alias="isUnbilled")
    list_price_base: Optional[ChargeListPriceBase] = Field(default=None, alias="listPriceBase")
    model: Optional[ChargeModel] = None
    name: Optional[StrictStr] = None
    number: Optional[StrictStr] = None
    number_of_periods: Optional[StrictInt] = Field(default=None, alias="numberOfPeriods")
    original_charge_id: Optional[StrictStr] = Field(default=None, alias="originalChargeId")
    overage_calculation_option: Optional[OverageCalculationOption] = Field(default=None, alias="overageCalculationOption")
    overage_unused_units_credit_option: Optional[OverageUnusedUnitsCreditOption] = Field(default=None, alias="overageUnusedUnitsCreditOption")
    product_category: Optional[StrictStr] = Field(default=None, alias="productCategory")
    product_class: Optional[StrictStr] = Field(default=None, alias="productClass")
    product_family: Optional[StrictStr] = Field(default=None, alias="productFamily")
    product_line: Optional[StrictStr] = Field(default=None, alias="productLine")
    product_rate_plan_charge_id: Optional[StrictStr] = Field(default=None, alias="productRatePlanChargeId")
    product_rate_plan_charge_number: Optional[StrictStr] = Field(default=None, alias="productRatePlanChargeNumber")
    rating_group: Optional[RatingGroup] = Field(default=None, alias="ratingGroup")
    smoothing_model: Optional[SmoothingModel] = Field(default=None, alias="smoothingModel")
    specific_billing_period: Optional[StrictInt] = Field(default=None, alias="specificBillingPeriod")
    specific_list_price_base: Optional[Annotated[int, Field(le=200, strict=True, ge=1)]] = Field(default=None, alias="specificListPriceBase")
    type: Optional[ChargeType] = None
    unused_units_credit_rates: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="unusedUnitsCreditRates")
    uom: Optional[StrictStr] = Field(default=None, description="Specifies the units to measure usage.")
    usage_record_rating_option: Optional[UsageRecordRatingOption] = Field(default=None, alias="usageRecordRatingOption")
    version: Optional[StrictInt] = None
    amended_by_order_on: Optional[date] = Field(default=None, description="The date when the rate plan charge is amended through an order or amendment. This field is to standardize the booking date information to increase audit ability and traceability of data between Zuora Billing and Zuora Revenue. It is mapped as the booking date for a sale order line in Zuora Revenue. ", alias="amendedByOrderOn")
    apply_discount_to: Optional[ApplyDiscountTo] = Field(default=None, alias="applyDiscountTo")
    charge_function: Optional[ChargeFunction] = Field(default=None, alias="chargeFunction")
    charge_model_configuration: Optional[ChargeModelConfigurationForSubscription] = Field(default=None, alias="chargeModelConfiguration")
    charged_through_date: Optional[date] = Field(default=None, description="The date through which a customer has been billed for the charge. ", alias="chargedThroughDate")
    commitment_type: Optional[CommitmentType] = Field(default=None, alias="commitmentType")
    prepaid_committed_amount: Optional[StrictStr] = Field(default=None, alias="prepaidCommittedAmount")
    product_charge_definition_id: Optional[StrictStr] = Field(default=None, alias="productChargeDefinitionId")
    is_stacked_discount: Optional[StrictBool] = Field(default=None, alias="isStackedDiscount")
    reflect_discount_in_net_amount: Optional[StrictBool] = Field(default=None, alias="reflectDiscountInNetAmount")
    centralized_price: Optional[StrictBool] = Field(default=None, alias="centralizedPrice")
    number_of_deliveries: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="numberOfDeliveries")
    credit_option: Optional[StrictStr] = Field(default=None, description="**Note**: This field is only available if you have the [Prepaid with Drawdown](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/J_Billing_Operations/Prepaid_with_Drawdown) feature enabled.  To use this field, you must set the `X-Zuora-WSDL-Version` request header to 114 or higher. Otherwise, an error occurs.  The way to calculate credit. See [Credit Option](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/J_Billing_Operations/Prepaid_with_Drawdown/Create_prepayment_charge#Credit_Option) for more information. ", alias="creditOption")
    currency: Optional[StrictStr] = Field(default=None, description="Currency used by the account. For example, `USD` or `EUR`.")
    delivery_schedule: Optional[DeliverySchedule] = Field(default=None, alias="deliverySchedule")
    description: Optional[StrictStr] = Field(default=None, description="Description of the rate plan charge.")
    discount_amount: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The amount of the discount.", alias="discountAmount")
    discount_apply_details: Optional[List[DiscountApplyDetail]] = Field(default=None, description="Container for the application details about a discount rate plan charge.   Only discount rate plan charges have values in this field. ", alias="discountApplyDetails")
    discount_class: Optional[StrictStr] = Field(default=None, description="The class that the discount belongs to. The discount class defines the order in which discount rate plan charges are applied.  For more information, see [Manage Discount Classes](https://knowledgecenter.zuora.com/BC_Subscription_Management/Product_Catalog/B_Charge_Models/Manage_Discount_Classes). ", alias="discountClass")
    discount_level: Optional[DiscountLevel] = Field(default=None, alias="discountLevel")
    discount_percentage: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The amount of the discount as a percentage. ", alias="discountPercentage")
    apply_to_billing_period_partially: Optional[StrictBool] = Field(default=None, description="Allow the discount duration to be aligned with the billing period partially. **Note**: This field is only available if you have the Enhanced Discounts feature enabled. ", alias="applyToBillingPeriodPartially")
    dmrc: Optional[StrictStr] = Field(default=None, description="The change (delta) of monthly recurring charge exists when the change in monthly recurring revenue caused by an amendment or a new subscription. ")
    done: Optional[StrictBool] = Field(default=None, description="A value of `true` indicates that an invoice for a charge segment has been completed. A value of `false` indicates that an invoice has not been completed for the charge segment. ")
    drawdown_rate: Optional[StrictStr] = Field(default=None, alias="drawdownRate")
    drawdown_uom: Optional[StrictStr] = Field(default=None, description="Specifies the units to measure usage.", alias="drawdownUom")
    dtcv: Optional[StrictStr] = Field(default=None, description="After an amendment or an AutomatedPriceChange event, `dtcv` displays the change (delta) for the total contract value (TCV) amount for this charge, compared with its previous value with recurring charge types. ")
    effective_end_date: Optional[date] = Field(default=None, alias="effectiveEndDate")
    effective_start_date: Optional[date] = Field(default=None, alias="effectiveStartDate")
    end_date_condition: Optional[EndDateCondition] = Field(default=None, alias="endDateCondition")
    id: Optional[StrictStr] = None
    included_units: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="includedUnits")
    overage_price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="overagePrice")
    input_argument_id: Optional[StrictStr] = Field(default=None, alias="inputArgumentId")
    is_committed: Optional[StrictBool] = Field(default=None, alias="isCommitted")
    is_prepaid: Optional[StrictBool] = Field(default=None, alias="isPrepaid")
    is_rollover: Optional[StrictBool] = Field(default=None, alias="isRollover")
    mrr: Optional[StrictStr] = None
    original_order_date: Optional[date] = Field(default=None, alias="originalOrderDate")
    prepaid_operation_type: Optional[StrictStr] = Field(default=None, alias="prepaidOperationType")
    prepaid_quantity: Optional[StrictStr] = Field(default=None, alias="prepaidQuantity")
    prepaid_total_quantity: Optional[StrictStr] = Field(default=None, alias="prepaidTotalQuantity")
    prepaid_uom: Optional[StrictStr] = Field(default=None, description="Specifies the units to measure usage.", alias="prepaidUOM")
    quantity: Optional[Union[StrictFloat, StrictInt]] = None
    price: Optional[Union[StrictFloat, StrictInt]] = None
    original_list_price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="originalListPrice")
    price_change_option: Optional[PriceChangeOption] = Field(default=PriceChangeOption.NOCHANGE, alias="priceChangeOption")
    price_increase_percentage: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="priceIncreasePercentage")
    pricing_summary: Optional[StrictStr] = Field(default=None, alias="pricingSummary")
    processed_through_date: Optional[date] = Field(default=None, alias="processedThroughDate")
    rollover_apply: Optional[StrictStr] = Field(default=None, alias="rolloverApply")
    rollover_period_length: Optional[StrictInt] = Field(default=None, alias="rolloverPeriodLength")
    rollover_periods: Optional[StrictInt] = Field(default=None, alias="rolloverPeriods")
    proration_option: Optional[StrictStr] = Field(default=None, alias="prorationOption")
    segment: Optional[StrictInt] = None
    specific_end_date: Optional[date] = Field(default=None, alias="specificEndDate")
    subscription_charge_interval_pricing: Optional[List[IntervalPricing]] = Field(default=None, alias="subscriptionChargeIntervalPricing")
    tcv: Optional[StrictStr] = None
    tiers: Optional[List[RatePlanChargeTier]] = None
    trigger_date: Optional[date] = Field(default=None, alias="triggerDate")
    trigger_event: Optional[TriggerEvent] = Field(default=None, alias="triggerEvent")
    upsell_origin_charge_number: Optional[StrictStr] = Field(default=None, description="**Note**: The Quantity Upsell feature is in Limited Availability. If you wish to have access to the feature, submit a request at [Zuora Global Support](https://support.zuora.com).  The identifier of the original upselling charge associated with the current charge. ", alias="upsellOriginChargeNumber")
    up_to_periods: Optional[StrictInt] = Field(default=None, alias="upToPeriods")
    up_to_periods_type: Optional[UpToPeriodsType] = Field(default=None, alias="upToPeriodsType")
    validity_period_type: Optional[ValidityPeriodType] = Field(default=None, alias="validityPeriodType")
    price_upsell_quantity_stacked: Optional[StrictBool] = Field(default=None, description="This field is availabe when PriceUpsellQuantityStacked permission enabled", alias="priceUpsellQuantityStacked")
    pob_policy: Optional[StrictStr] = Field(default=None, description="The POB policy type, it is available when permission EnableAdditionalRevenueFields is on ", alias="pobPolicy")
    sales_price: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, alias="salesPrice")
    estimated_end_date: Optional[date] = Field(default=None, alias="estimatedEndDate")
    estimated_start_date: Optional[date] = Field(default=None, alias="estimatedStartDate")
    taxable: Optional[StrictBool] = None
    tax_code: Optional[StrictStr] = Field(default=None, alias="taxCode")
    tax_mode: Optional[StrictStr] = Field(default=None, alias="taxMode")
    pricing_attributes: Optional[Dict[str, Any]] = Field(default=None, description="Container for pricing attributes used in dynamic pricing.  **Note**: This field is only available when DynamicPricing permission enabled. ", alias="pricingAttributes")
    is_dimensional_price: Optional[StrictBool] = Field(default=None, description="Indicates whether the charge uses dimensional pricing.  **Note**: This field is only available when DynamicPricing permission enabled. ", alias="isDimensionalPrice")
    is_price_negotiated: Optional[StrictBool] = Field(default=None, description="Indicates whether the charge uses negotiated pricing. **Note**: This field is only available when NegotiatedPriceTable permission enabled. ", alias="isPriceNegotiated")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["billingDay", "billingPeriod", "billingPeriodAlignment", "billingTiming", "chargeSegments", "excludeItemBillingFromRevenueAccounting", "excludeItemBookingFromRevenueAccounting", "invoiceScheduleId", "isAllocationEligible", "isUnbilled", "listPriceBase", "model", "name", "number", "numberOfPeriods", "originalChargeId", "overageCalculationOption", "overageUnusedUnitsCreditOption", "productCategory", "productClass", "productFamily", "productLine", "productRatePlanChargeId", "productRatePlanChargeNumber", "ratingGroup", "smoothingModel", "specificBillingPeriod", "specificListPriceBase", "type", "unusedUnitsCreditRates", "uom", "usageRecordRatingOption", "version", "amendedByOrderOn", "applyDiscountTo", "chargeFunction", "chargeModelConfiguration", "chargedThroughDate", "commitmentType", "prepaidCommittedAmount", "productChargeDefinitionId", "isStackedDiscount", "reflectDiscountInNetAmount", "centralizedPrice", "numberOfDeliveries", "creditOption", "currency", "deliverySchedule", "description", "discountAmount", "discountApplyDetails", "discountClass", "discountLevel", "discountPercentage", "applyToBillingPeriodPartially", "dmrc", "done", "drawdownRate", "drawdownUom", "dtcv", "effectiveEndDate", "effectiveStartDate", "endDateCondition", "id", "includedUnits", "overagePrice", "inputArgumentId", "isCommitted", "isPrepaid", "isRollover", "mrr", "originalOrderDate", "prepaidOperationType", "prepaidQuantity", "prepaidTotalQuantity", "prepaidUOM", "quantity", "price", "originalListPrice", "priceChangeOption", "priceIncreasePercentage", "pricingSummary", "processedThroughDate", "rolloverApply", "rolloverPeriodLength", "rolloverPeriods", "prorationOption", "segment", "specificEndDate", "subscriptionChargeIntervalPricing", "tcv", "tiers", "triggerDate", "triggerEvent", "upsellOriginChargeNumber", "upToPeriods", "upToPeriodsType", "validityPeriodType", "priceUpsellQuantityStacked", "pobPolicy", "salesPrice", "estimatedEndDate", "estimatedStartDate", "taxable", "taxCode", "taxMode", "pricingAttributes", "isDimensionalPrice", "isPriceNegotiated"]

    @field_validator('credit_option')
    def credit_option_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['TimeBased', 'ConsumptionBased', 'FullCreditBack']):
            raise ValueError("must be one of enum values ('TimeBased', 'ConsumptionBased', 'FullCreditBack')")
        return value

    @field_validator('prepaid_operation_type')
    def prepaid_operation_type_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['topup', 'drawdown']):
            raise ValueError("must be one of enum values ('topup', 'drawdown')")
        return value

    @field_validator('rollover_apply')
    def rollover_apply_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ApplyFirst', 'ApplyLast']):
            raise ValueError("must be one of enum values ('ApplyFirst', 'ApplyLast')")
        return value

    @field_validator('pob_policy')
    def pob_policy_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['Placeholder']):
            raise ValueError("must be one of enum values ('Placeholder')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of GetSubscriptionRatePlanChargesWithAllSegments from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in charge_segments (list)
        _items = []
        if self.charge_segments:
            for _item_charge_segments in self.charge_segments:
                if _item_charge_segments:
                    _items.append(_item_charge_segments.to_dict())
            _dict['chargeSegments'] = _items
        # override the default output from pydantic by calling `to_dict()` of charge_model_configuration
        if self.charge_model_configuration:
            _dict['chargeModelConfiguration'] = self.charge_model_configuration.to_dict()
        # override the default output from pydantic by calling `to_dict()` of delivery_schedule
        if self.delivery_schedule:
            _dict['deliverySchedule'] = self.delivery_schedule.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in discount_apply_details (list)
        _items = []
        if self.discount_apply_details:
            for _item_discount_apply_details in self.discount_apply_details:
                if _item_discount_apply_details:
                    _items.append(_item_discount_apply_details.to_dict())
            _dict['discountApplyDetails'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in subscription_charge_interval_pricing (list)
        _items = []
        if self.subscription_charge_interval_pricing:
            for _item_subscription_charge_interval_pricing in self.subscription_charge_interval_pricing:
                if _item_subscription_charge_interval_pricing:
                    _items.append(_item_subscription_charge_interval_pricing.to_dict())
            _dict['subscriptionChargeIntervalPricing'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in tiers (list)
        _items = []
        if self.tiers:
            for _item_tiers in self.tiers:
                if _item_tiers:
                    _items.append(_item_tiers.to_dict())
            _dict['tiers'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of GetSubscriptionRatePlanChargesWithAllSegments from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        obj = convert_snake_dict_to_camel(obj, cls.model_fields, cls.__properties)

        _obj = cls.model_validate(cls.to_alias_dict(obj))
        return cls.update_additional_properties(_obj, obj)

    @classmethod
    def update_additional_properties(cls, obj, _dict: Optional[Dict[str, Any]]):
        # store additional fields in additional_properties

        # store additional fields in additional_properties
        for _key in _dict.keys():
            if _key not in cls.__properties:
                obj.additional_properties[_key] = _dict.get(_key)


        return obj
        pass

    @classmethod
    def to_alias_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        return {
            "billingDay": obj.get("billingDay"),
            "billingPeriod": obj.get("billingPeriod"),
            "billingPeriodAlignment": obj.get("billingPeriodAlignment"),
            "billingTiming": obj.get("billingTiming"),
            "chargeSegments": [RatePlanChargeSegment.from_dict(_item) for _item in obj["chargeSegments"]] if obj.get("chargeSegments") is not None else None,
            "excludeItemBillingFromRevenueAccounting": obj.get("excludeItemBillingFromRevenueAccounting"),
            "excludeItemBookingFromRevenueAccounting": obj.get("excludeItemBookingFromRevenueAccounting"),
            "invoiceScheduleId": obj.get("invoiceScheduleId"),
            "isAllocationEligible": obj.get("isAllocationEligible"),
            "isUnbilled": obj.get("isUnbilled"),
            "listPriceBase": obj.get("listPriceBase"),
            "model": obj.get("model"),
            "name": obj.get("name"),
            "number": obj.get("number"),
            "numberOfPeriods": obj.get("numberOfPeriods"),
            "originalChargeId": obj.get("originalChargeId"),
            "overageCalculationOption": obj.get("overageCalculationOption"),
            "overageUnusedUnitsCreditOption": obj.get("overageUnusedUnitsCreditOption"),
            "productCategory": obj.get("productCategory"),
            "productClass": obj.get("productClass"),
            "productFamily": obj.get("productFamily"),
            "productLine": obj.get("productLine"),
            "productRatePlanChargeId": obj.get("productRatePlanChargeId"),
            "productRatePlanChargeNumber": obj.get("productRatePlanChargeNumber"),
            "ratingGroup": obj.get("ratingGroup"),
            "smoothingModel": obj.get("smoothingModel"),
            "specificBillingPeriod": obj.get("specificBillingPeriod"),
            "specificListPriceBase": obj.get("specificListPriceBase"),
            "type": obj.get("type"),
            "unusedUnitsCreditRates": obj.get("unusedUnitsCreditRates"),
            "uom": obj.get("uom"),
            "usageRecordRatingOption": obj.get("usageRecordRatingOption"),
            "version": obj.get("version"),
            "amendedByOrderOn": obj.get("amendedByOrderOn"),
            "applyDiscountTo": obj.get("applyDiscountTo"),
            "chargeFunction": obj.get("chargeFunction"),
            "chargeModelConfiguration": ChargeModelConfigurationForSubscription.from_dict(obj["chargeModelConfiguration"]) if obj.get("chargeModelConfiguration") is not None else None,
            "chargedThroughDate": obj.get("chargedThroughDate"),
            "commitmentType": obj.get("commitmentType"),
            "prepaidCommittedAmount": obj.get("prepaidCommittedAmount"),
            "productChargeDefinitionId": obj.get("productChargeDefinitionId"),
            "isStackedDiscount": obj.get("isStackedDiscount"),
            "reflectDiscountInNetAmount": obj.get("reflectDiscountInNetAmount"),
            "centralizedPrice": obj.get("centralizedPrice"),
            "numberOfDeliveries": obj.get("numberOfDeliveries"),
            "creditOption": obj.get("creditOption"),
            "currency": obj.get("currency"),
            "deliverySchedule": DeliverySchedule.from_dict(obj["deliverySchedule"]) if obj.get("deliverySchedule") is not None else None,
            "description": obj.get("description"),
            "discountAmount": obj.get("discountAmount"),
            "discountApplyDetails": [DiscountApplyDetail.from_dict(_item) for _item in obj["discountApplyDetails"]] if obj.get("discountApplyDetails") is not None else None,
            "discountClass": obj.get("discountClass"),
            "discountLevel": obj.get("discountLevel"),
            "discountPercentage": obj.get("discountPercentage"),
            "applyToBillingPeriodPartially": obj.get("applyToBillingPeriodPartially"),
            "dmrc": obj.get("dmrc"),
            "done": obj.get("done"),
            "drawdownRate": obj.get("drawdownRate"),
            "drawdownUom": obj.get("drawdownUom"),
            "dtcv": obj.get("dtcv"),
            "effectiveEndDate": obj.get("effectiveEndDate"),
            "effectiveStartDate": obj.get("effectiveStartDate"),
            "endDateCondition": obj.get("endDateCondition"),
            "id": obj.get("id"),
            "includedUnits": obj.get("includedUnits"),
            "overagePrice": obj.get("overagePrice"),
            "inputArgumentId": obj.get("inputArgumentId"),
            "isCommitted": obj.get("isCommitted"),
            "isPrepaid": obj.get("isPrepaid"),
            "isRollover": obj.get("isRollover"),
            "mrr": obj.get("mrr"),
            "originalOrderDate": obj.get("originalOrderDate"),
            "prepaidOperationType": obj.get("prepaidOperationType"),
            "prepaidQuantity": obj.get("prepaidQuantity"),
            "prepaidTotalQuantity": obj.get("prepaidTotalQuantity"),
            "prepaidUOM": obj.get("prepaidUOM"),
            "quantity": obj.get("quantity"),
            "price": obj.get("price"),
            "originalListPrice": obj.get("originalListPrice"),
            "priceChangeOption": obj.get("priceChangeOption") if obj.get("priceChangeOption") is not None else PriceChangeOption.NOCHANGE,
            "priceIncreasePercentage": obj.get("priceIncreasePercentage"),
            "pricingSummary": obj.get("pricingSummary"),
            "processedThroughDate": obj.get("processedThroughDate"),
            "rolloverApply": obj.get("rolloverApply"),
            "rolloverPeriodLength": obj.get("rolloverPeriodLength"),
            "rolloverPeriods": obj.get("rolloverPeriods"),
            "prorationOption": obj.get("prorationOption"),
            "segment": obj.get("segment"),
            "specificEndDate": obj.get("specificEndDate"),
            "subscriptionChargeIntervalPricing": [IntervalPricing.from_dict(_item) for _item in obj["subscriptionChargeIntervalPricing"]] if obj.get("subscriptionChargeIntervalPricing") is not None else None,
            "tcv": obj.get("tcv"),
            "tiers": [RatePlanChargeTier.from_dict(_item) for _item in obj["tiers"]] if obj.get("tiers") is not None else None,
            "triggerDate": obj.get("triggerDate"),
            "triggerEvent": obj.get("triggerEvent"),
            "upsellOriginChargeNumber": obj.get("upsellOriginChargeNumber"),
            "upToPeriods": obj.get("upToPeriods"),
            "upToPeriodsType": obj.get("upToPeriodsType"),
            "validityPeriodType": obj.get("validityPeriodType"),
            "priceUpsellQuantityStacked": obj.get("priceUpsellQuantityStacked"),
            "pobPolicy": obj.get("pobPolicy"),
            "salesPrice": obj.get("salesPrice"),
            "estimatedEndDate": obj.get("estimatedEndDate"),
            "estimatedStartDate": obj.get("estimatedStartDate"),
            "taxable": obj.get("taxable"),
            "taxCode": obj.get("taxCode"),
            "taxMode": obj.get("taxMode"),
            "pricingAttributes": obj.get("pricingAttributes"),
            "isDimensionalPrice": obj.get("isDimensionalPrice"),
            "isPriceNegotiated": obj.get("isPriceNegotiated")
        }
        return _obj


def convert_snake_dict_to_camel(_dict: dict, model_fields, properties):
    if not isinstance(_dict, dict):
        return _dict
    new_dict = {}
    for k, v in _dict.items():
        if k in model_fields:
            # model_fields: key is attribute name like bill_to_contact,
            alias = model_fields.get(k).alias or k
            new_dict[alias] = v
            pass
        else:
            new_key = snake_to_camel(k)
            if properties is not None and isinstance(properties, list) and new_key in properties:
                new_dict[new_key] = v
            else:
                new_dict[k] = v
    return new_dict
    pass


def snake_to_camel(name):
    if name is None or '_' not in name:
        return name
    components = name.split('_')
    return components[0] + ''.join(x.title() for x in components[1:])
