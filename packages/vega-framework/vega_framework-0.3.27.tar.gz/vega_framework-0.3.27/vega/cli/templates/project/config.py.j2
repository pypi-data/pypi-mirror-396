"""Dependency Injection configuration for {{ project_name }}"""
import logging
import sys
from pathlib import Path

from vega.di import Container, set_container
from vega.discovery import discover_beans

# Configure logging for bean discovery debugging
logger = logging.getLogger(__name__)

# Domain interfaces (Abstract)
# Example:
# from {{ project_package }}.domain.repositories.user_repository import UserRepository

# Infrastructure implementations (Concrete)
# Example:
# from {{ project_package }}.infrastructure.repositories.memory_user_repository import MemoryUserRepository

# Uncomment and configure database manager if using SQLAlchemy

# from settings import settings
# from infrastructure.database_manager import DatabaseManager
# db_manager = DatabaseManager(url=settings.database_url)

# DI Registry: Manual registration (optional - for instances or explicit mappings)
SERVICES = {
    # Example - Manual registration:
    # UserRepository: MemoryUserRepository,
    # DatabaseManager: lambda: db_manager,

    # Note: Classes decorated with @bean are auto-discovered and don't need manual registration
}

# Ensure project root is on sys.path for imports/discovery (works even without __init__.py)
project_root = Path(__file__).resolve().parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

# Create and set container
container = Container(SERVICES)
set_container(container)

# Auto-discover @bean decorated classes
# DDD Structure (lib/): Automatically scans all bounded contexts in lib/
# Legacy Structure: Scans domain/, application/, infrastructure/
try:
    logger.debug(f"Starting bean auto-discovery for package: {{ project_package }}")
    logger.debug(f"Current sys.path: {sys.path}")

    # Auto-discovery works with both structures:
    # - DDD: lib/{context}/domain, lib/{context}/application, lib/{context}/infrastructure
    # - Legacy: domain/, application/, infrastructure/
    discovered = discover_beans("{{ project_package }}")

    logger.info(f"Successfully discovered {discovered} bean(s) for {{ project_package }}")
except Exception as e:
    # Fallback to manual registration if auto-discovery fails
    # This ensures backward compatibility with older project structures
    logger.warning(
        f"Bean auto-discovery failed for {{ project_name }}: {type(e).__name__}: {e}\n"
        f"Current working directory: {__import__('pathlib').Path.cwd()}\n"
        f"sys.path: {sys.path}\n"
        f"Falling back to manual bean registration in SERVICES dict"
    )

# Customization examples:
# - Scan specific bounded context: discover_beans("{{ project_name }}", subpackages=["{{ project_name }}.sales.domain"])
# - Scan multiple contexts: discover_beans("{{ project_name }}", subpackages=["{{ project_name }}.sales.domain", "{{ project_name }}.billing.domain"])
# - Scan shared kernel only: discover_beans("{{ project_name }}", subpackages=["{{ project_name }}.shared.domain"])
# - Disable auto-discovery: Comment out discover_beans() and use manual SERVICES dict
