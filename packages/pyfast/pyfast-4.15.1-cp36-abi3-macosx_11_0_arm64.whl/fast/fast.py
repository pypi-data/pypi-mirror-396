# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")


from typing import *
import _fast


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

SHARED_PTR_DISOWN = _fast.SHARED_PTR_DISOWN
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fast.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _fast.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _fast.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _fast.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _fast.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _fast.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _fast.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _fast.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _fast.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _fast.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _fast.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _fast.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _fast.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _fast.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _fast.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _fast.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _fast.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _fast:
_fast.SwigPyIterator_swigregister(SwigPyIterator)

TYPE_FLOAT = _fast.TYPE_FLOAT
TYPE_UINT8 = _fast.TYPE_UINT8
TYPE_INT8 = _fast.TYPE_INT8
TYPE_UINT16 = _fast.TYPE_UINT16
TYPE_INT16 = _fast.TYPE_INT16
TYPE_UNORM_INT16 = _fast.TYPE_UNORM_INT16
TYPE_SNORM_INT16 = _fast.TYPE_SNORM_INT16
TYPE_UINT32 = _fast.TYPE_UINT32
TYPE_INT32 = _fast.TYPE_INT32
PLANE_X = _fast.PLANE_X
PLANE_Y = _fast.PLANE_Y
PLANE_Z = _fast.PLANE_Z

def getCTypeAsString(type: "fast::DataType") -> "std::string":
    return _fast.getCTypeAsString(type)

def getOpenCLImageFormat(arg1: "OpenCLDevice::pointer", imageType: "cl_mem_object_type", type: "fast::DataType", channels: "unsigned int") -> "cl::ImageFormat":
    return _fast.getOpenCLImageFormat(arg1, imageType, type, channels)

def getSizeOfDataType(type: "fast::DataType", nrOfChannels: "unsigned int") -> "size_t":
    return _fast.getSizeOfDataType(type, nrOfChannels)

def getDefaultIntensityLevel(type: "fast::DataType") -> "float":
    return _fast.getDefaultIntensityLevel(type)

def getDefaultIntensityWindow(type: "fast::DataType") -> "float":
    return _fast.getDefaultIntensityWindow(type)

def deleteArray(data: "void *", type: "fast::DataType") -> "void":
    return _fast.deleteArray(data, type)
PixelConnectivity_Closests = _fast.PixelConnectivity_Closests
PixelConnectivity_All = _fast.PixelConnectivity_All
class vectori(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectori_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectori___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectori___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _fast.vectori___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _fast.vectori___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectori___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _fast.vectori___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectori___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _fast.vectori___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectori___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _fast.vectori_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _fast.vectori_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectori_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _fast.vectori_size(self)

    def swap(self, v: "vectori") -> "void":
        return _fast.vectori_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _fast.vectori_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _fast.vectori_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _fast.vectori_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _fast.vectori_rend(self)

    def clear(self) -> "void":
        return _fast.vectori_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _fast.vectori_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectori_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _fast.vectori_erase(self, *args)

    def __init__(self, *args):
        _fast.vectori_swiginit(self, _fast.new_vectori(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _fast.vectori_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _fast.vectori_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _fast.vectori_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _fast.vectori_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectori_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectori_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _fast.vectori_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _fast.vectori_capacity(self)
    __swig_destroy__ = _fast.delete_vectori

# Register vectori in _fast:
_fast.vectori_swigregister(vectori)

class vectorf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectorf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectorf___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectorf___bool__(self)

    def __len__(self) -> "std::vector< float >::size_type":
        return _fast.vectorf___len__(self)

    def __getslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "std::vector< float,std::allocator< float > > *":
        return _fast.vectorf___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectorf___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< float >::difference_type", j: "std::vector< float >::difference_type") -> "void":
        return _fast.vectorf___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectorf___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< float >::value_type const &":
        return _fast.vectorf___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectorf___setitem__(self, *args)

    def pop(self) -> "std::vector< float >::value_type":
        return _fast.vectorf_pop(self)

    def append(self, x: "std::vector< float >::value_type const &") -> "void":
        return _fast.vectorf_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectorf_empty(self)

    def size(self) -> "std::vector< float >::size_type":
        return _fast.vectorf_size(self)

    def swap(self, v: "vectorf") -> "void":
        return _fast.vectorf_swap(self, v)

    def begin(self) -> "std::vector< float >::iterator":
        return _fast.vectorf_begin(self)

    def end(self) -> "std::vector< float >::iterator":
        return _fast.vectorf_end(self)

    def rbegin(self) -> "std::vector< float >::reverse_iterator":
        return _fast.vectorf_rbegin(self)

    def rend(self) -> "std::vector< float >::reverse_iterator":
        return _fast.vectorf_rend(self)

    def clear(self) -> "void":
        return _fast.vectorf_clear(self)

    def get_allocator(self) -> "std::vector< float >::allocator_type":
        return _fast.vectorf_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectorf_pop_back(self)

    def erase(self, *args) -> "std::vector< float >::iterator":
        return _fast.vectorf_erase(self, *args)

    def __init__(self, *args):
        _fast.vectorf_swiginit(self, _fast.new_vectorf(*args))

    def push_back(self, x: "std::vector< float >::value_type const &") -> "void":
        return _fast.vectorf_push_back(self, x)

    def front(self) -> "std::vector< float >::value_type const &":
        return _fast.vectorf_front(self)

    def back(self) -> "std::vector< float >::value_type const &":
        return _fast.vectorf_back(self)

    def assign(self, n: "std::vector< float >::size_type", x: "std::vector< float >::value_type const &") -> "void":
        return _fast.vectorf_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectorf_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectorf_insert(self, *args)

    def reserve(self, n: "std::vector< float >::size_type") -> "void":
        return _fast.vectorf_reserve(self, n)

    def capacity(self) -> "std::vector< float >::size_type":
        return _fast.vectorf_capacity(self)
    __swig_destroy__ = _fast.delete_vectorf

# Register vectorf in _fast:
_fast.vectorf_swigregister(vectorf)

class vectorui(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectorui_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectorui___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectorui___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _fast.vectorui___len__(self)

    def __getslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _fast.vectorui___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectorui___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned int >::difference_type", j: "std::vector< unsigned int >::difference_type") -> "void":
        return _fast.vectorui___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectorui___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _fast.vectorui___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectorui___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _fast.vectorui_pop(self)

    def append(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _fast.vectorui_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectorui_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _fast.vectorui_size(self)

    def swap(self, v: "vectorui") -> "void":
        return _fast.vectorui_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _fast.vectorui_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _fast.vectorui_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _fast.vectorui_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _fast.vectorui_rend(self)

    def clear(self) -> "void":
        return _fast.vectorui_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _fast.vectorui_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectorui_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _fast.vectorui_erase(self, *args)

    def __init__(self, *args):
        _fast.vectorui_swiginit(self, _fast.new_vectorui(*args))

    def push_back(self, x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _fast.vectorui_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _fast.vectorui_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _fast.vectorui_back(self)

    def assign(self, n: "std::vector< unsigned int >::size_type", x: "std::vector< unsigned int >::value_type const &") -> "void":
        return _fast.vectorui_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectorui_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectorui_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned int >::size_type") -> "void":
        return _fast.vectorui_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _fast.vectorui_capacity(self)
    __swig_destroy__ = _fast.delete_vectorui

# Register vectorui in _fast:
_fast.vectorui_swigregister(vectorui)

class vectorc(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectorc_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectorc___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectorc___bool__(self)

    def __len__(self) -> "std::vector< char >::size_type":
        return _fast.vectorc___len__(self)

    def __getslice__(self, i: "std::vector< char >::difference_type", j: "std::vector< char >::difference_type") -> "std::vector< char,std::allocator< char > > *":
        return _fast.vectorc___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectorc___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< char >::difference_type", j: "std::vector< char >::difference_type") -> "void":
        return _fast.vectorc___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectorc___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< char >::value_type const &":
        return _fast.vectorc___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectorc___setitem__(self, *args)

    def pop(self) -> "std::vector< char >::value_type":
        return _fast.vectorc_pop(self)

    def append(self, x: "std::vector< char >::value_type const &") -> "void":
        return _fast.vectorc_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectorc_empty(self)

    def size(self) -> "std::vector< char >::size_type":
        return _fast.vectorc_size(self)

    def swap(self, v: "vectorc") -> "void":
        return _fast.vectorc_swap(self, v)

    def begin(self) -> "std::vector< char >::iterator":
        return _fast.vectorc_begin(self)

    def end(self) -> "std::vector< char >::iterator":
        return _fast.vectorc_end(self)

    def rbegin(self) -> "std::vector< char >::reverse_iterator":
        return _fast.vectorc_rbegin(self)

    def rend(self) -> "std::vector< char >::reverse_iterator":
        return _fast.vectorc_rend(self)

    def clear(self) -> "void":
        return _fast.vectorc_clear(self)

    def get_allocator(self) -> "std::vector< char >::allocator_type":
        return _fast.vectorc_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectorc_pop_back(self)

    def erase(self, *args) -> "std::vector< char >::iterator":
        return _fast.vectorc_erase(self, *args)

    def __init__(self, *args):
        _fast.vectorc_swiginit(self, _fast.new_vectorc(*args))

    def push_back(self, x: "std::vector< char >::value_type const &") -> "void":
        return _fast.vectorc_push_back(self, x)

    def front(self) -> "std::vector< char >::value_type const &":
        return _fast.vectorc_front(self)

    def back(self) -> "std::vector< char >::value_type const &":
        return _fast.vectorc_back(self)

    def assign(self, n: "std::vector< char >::size_type", x: "std::vector< char >::value_type const &") -> "void":
        return _fast.vectorc_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectorc_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectorc_insert(self, *args)

    def reserve(self, n: "std::vector< char >::size_type") -> "void":
        return _fast.vectorc_reserve(self, n)

    def capacity(self) -> "std::vector< char >::size_type":
        return _fast.vectorc_capacity(self)
    __swig_destroy__ = _fast.delete_vectorc

# Register vectorc in _fast:
_fast.vectorc_swigregister(vectorc)

class vectoruc(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectoruc_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectoruc___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectoruc___bool__(self)

    def __len__(self) -> "std::vector< unsigned char >::size_type":
        return _fast.vectoruc___len__(self)

    def __getslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "std::vector< unsigned char,std::allocator< unsigned char > > *":
        return _fast.vectoruc___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectoruc___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< unsigned char >::difference_type", j: "std::vector< unsigned char >::difference_type") -> "void":
        return _fast.vectoruc___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectoruc___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned char >::value_type const &":
        return _fast.vectoruc___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectoruc___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned char >::value_type":
        return _fast.vectoruc_pop(self)

    def append(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _fast.vectoruc_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectoruc_empty(self)

    def size(self) -> "std::vector< unsigned char >::size_type":
        return _fast.vectoruc_size(self)

    def swap(self, v: "vectoruc") -> "void":
        return _fast.vectoruc_swap(self, v)

    def begin(self) -> "std::vector< unsigned char >::iterator":
        return _fast.vectoruc_begin(self)

    def end(self) -> "std::vector< unsigned char >::iterator":
        return _fast.vectoruc_end(self)

    def rbegin(self) -> "std::vector< unsigned char >::reverse_iterator":
        return _fast.vectoruc_rbegin(self)

    def rend(self) -> "std::vector< unsigned char >::reverse_iterator":
        return _fast.vectoruc_rend(self)

    def clear(self) -> "void":
        return _fast.vectoruc_clear(self)

    def get_allocator(self) -> "std::vector< unsigned char >::allocator_type":
        return _fast.vectoruc_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectoruc_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned char >::iterator":
        return _fast.vectoruc_erase(self, *args)

    def __init__(self, *args):
        _fast.vectoruc_swiginit(self, _fast.new_vectoruc(*args))

    def push_back(self, x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _fast.vectoruc_push_back(self, x)

    def front(self) -> "std::vector< unsigned char >::value_type const &":
        return _fast.vectoruc_front(self)

    def back(self) -> "std::vector< unsigned char >::value_type const &":
        return _fast.vectoruc_back(self)

    def assign(self, n: "std::vector< unsigned char >::size_type", x: "std::vector< unsigned char >::value_type const &") -> "void":
        return _fast.vectoruc_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectoruc_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectoruc_insert(self, *args)

    def reserve(self, n: "std::vector< unsigned char >::size_type") -> "void":
        return _fast.vectoruc_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned char >::size_type":
        return _fast.vectoruc_capacity(self)
    __swig_destroy__ = _fast.delete_vectoruc

# Register vectoruc in _fast:
_fast.vectoruc_swigregister(vectoruc)

class vectors(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectors_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectors___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectors___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _fast.vectors___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _fast.vectors___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectors___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _fast.vectors___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectors___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _fast.vectors___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectors___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _fast.vectors_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _fast.vectors_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectors_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _fast.vectors_size(self)

    def swap(self, v: "vectors") -> "void":
        return _fast.vectors_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _fast.vectors_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _fast.vectors_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _fast.vectors_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _fast.vectors_rend(self)

    def clear(self) -> "void":
        return _fast.vectors_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _fast.vectors_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectors_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _fast.vectors_erase(self, *args)

    def __init__(self, *args):
        _fast.vectors_swiginit(self, _fast.new_vectors(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _fast.vectors_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _fast.vectors_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _fast.vectors_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _fast.vectors_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectors_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectors_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _fast.vectors_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _fast.vectors_capacity(self)
    __swig_destroy__ = _fast.delete_vectors

# Register vectors in _fast:
_fast.vectors_swigregister(vectors)

class vectorqwidget(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectorqwidget_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectorqwidget___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectorqwidget___bool__(self)

    def __len__(self) -> "std::vector< QWidget * >::size_type":
        return _fast.vectorqwidget___len__(self)

    def __getslice__(self, i: "std::vector< QWidget * >::difference_type", j: "std::vector< QWidget * >::difference_type") -> "std::vector< QWidget *,std::allocator< QWidget * > > *":
        return _fast.vectorqwidget___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectorqwidget___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< QWidget * >::difference_type", j: "std::vector< QWidget * >::difference_type") -> "void":
        return _fast.vectorqwidget___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectorqwidget___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< QWidget * >::value_type":
        return _fast.vectorqwidget___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectorqwidget___setitem__(self, *args)

    def pop(self) -> "std::vector< QWidget * >::value_type":
        return _fast.vectorqwidget_pop(self)

    def append(self, x: "std::vector< QWidget * >::value_type") -> "void":
        return _fast.vectorqwidget_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectorqwidget_empty(self)

    def size(self) -> "std::vector< QWidget * >::size_type":
        return _fast.vectorqwidget_size(self)

    def swap(self, v: "vectorqwidget") -> "void":
        return _fast.vectorqwidget_swap(self, v)

    def begin(self) -> "std::vector< QWidget * >::iterator":
        return _fast.vectorqwidget_begin(self)

    def end(self) -> "std::vector< QWidget * >::iterator":
        return _fast.vectorqwidget_end(self)

    def rbegin(self) -> "std::vector< QWidget * >::reverse_iterator":
        return _fast.vectorqwidget_rbegin(self)

    def rend(self) -> "std::vector< QWidget * >::reverse_iterator":
        return _fast.vectorqwidget_rend(self)

    def clear(self) -> "void":
        return _fast.vectorqwidget_clear(self)

    def get_allocator(self) -> "std::vector< QWidget * >::allocator_type":
        return _fast.vectorqwidget_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectorqwidget_pop_back(self)

    def erase(self, *args) -> "std::vector< QWidget * >::iterator":
        return _fast.vectorqwidget_erase(self, *args)

    def __init__(self, *args):
        _fast.vectorqwidget_swiginit(self, _fast.new_vectorqwidget(*args))

    def push_back(self, x: "std::vector< QWidget * >::value_type") -> "void":
        return _fast.vectorqwidget_push_back(self, x)

    def front(self) -> "std::vector< QWidget * >::value_type":
        return _fast.vectorqwidget_front(self)

    def back(self) -> "std::vector< QWidget * >::value_type":
        return _fast.vectorqwidget_back(self)

    def assign(self, n: "std::vector< QWidget * >::size_type", x: "std::vector< QWidget * >::value_type") -> "void":
        return _fast.vectorqwidget_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectorqwidget_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectorqwidget_insert(self, *args)

    def reserve(self, n: "std::vector< QWidget * >::size_type") -> "void":
        return _fast.vectorqwidget_reserve(self, n)

    def capacity(self) -> "std::vector< QWidget * >::size_type":
        return _fast.vectorqwidget_capacity(self)
    __swig_destroy__ = _fast.delete_vectorqwidget

# Register vectorqwidget in _fast:
_fast.vectorqwidget_swigregister(vectorqwidget)

class NeuralNetworkNodes(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.NeuralNetworkNodes_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.NeuralNetworkNodes___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.NeuralNetworkNodes___bool__(self)

    def __len__(self) -> "std::vector< fast::NeuralNetworkNode >::size_type":
        return _fast.NeuralNetworkNodes___len__(self)

    def __getslice__(self, i: "std::vector< fast::NeuralNetworkNode >::difference_type", j: "std::vector< fast::NeuralNetworkNode >::difference_type") -> "std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > > *":
        return _fast.NeuralNetworkNodes___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.NeuralNetworkNodes___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< fast::NeuralNetworkNode >::difference_type", j: "std::vector< fast::NeuralNetworkNode >::difference_type") -> "void":
        return _fast.NeuralNetworkNodes___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.NeuralNetworkNodes___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< fast::NeuralNetworkNode >::value_type const &":
        return _fast.NeuralNetworkNodes___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.NeuralNetworkNodes___setitem__(self, *args)

    def append(self, x: "NeuralNetworkNode") -> "void":
        return _fast.NeuralNetworkNodes_append(self, x)

    def empty(self) -> "bool":
        return _fast.NeuralNetworkNodes_empty(self)

    def size(self) -> "std::vector< fast::NeuralNetworkNode >::size_type":
        return _fast.NeuralNetworkNodes_size(self)

    def swap(self, v: "NeuralNetworkNodes") -> "void":
        return _fast.NeuralNetworkNodes_swap(self, v)

    def begin(self) -> "std::vector< fast::NeuralNetworkNode >::iterator":
        return _fast.NeuralNetworkNodes_begin(self)

    def end(self) -> "std::vector< fast::NeuralNetworkNode >::iterator":
        return _fast.NeuralNetworkNodes_end(self)

    def rbegin(self) -> "std::vector< fast::NeuralNetworkNode >::reverse_iterator":
        return _fast.NeuralNetworkNodes_rbegin(self)

    def rend(self) -> "std::vector< fast::NeuralNetworkNode >::reverse_iterator":
        return _fast.NeuralNetworkNodes_rend(self)

    def clear(self) -> "void":
        return _fast.NeuralNetworkNodes_clear(self)

    def get_allocator(self) -> "std::vector< fast::NeuralNetworkNode >::allocator_type":
        return _fast.NeuralNetworkNodes_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.NeuralNetworkNodes_pop_back(self)

    def erase(self, *args) -> "std::vector< fast::NeuralNetworkNode >::iterator":
        return _fast.NeuralNetworkNodes_erase(self, *args)

    def __init__(self, *args):
        _fast.NeuralNetworkNodes_swiginit(self, _fast.new_NeuralNetworkNodes(*args))

    def push_back(self, x: "NeuralNetworkNode") -> "void":
        return _fast.NeuralNetworkNodes_push_back(self, x)

    def front(self) -> "std::vector< fast::NeuralNetworkNode >::value_type const &":
        return _fast.NeuralNetworkNodes_front(self)

    def back(self) -> "std::vector< fast::NeuralNetworkNode >::value_type const &":
        return _fast.NeuralNetworkNodes_back(self)

    def assign(self, n: "std::vector< fast::NeuralNetworkNode >::size_type", x: "NeuralNetworkNode") -> "void":
        return _fast.NeuralNetworkNodes_assign(self, n, x)

    def insert(self, *args) -> "void":
        return _fast.NeuralNetworkNodes_insert(self, *args)

    def reserve(self, n: "std::vector< fast::NeuralNetworkNode >::size_type") -> "void":
        return _fast.NeuralNetworkNodes_reserve(self, n)

    def capacity(self) -> "std::vector< fast::NeuralNetworkNode >::size_type":
        return _fast.NeuralNetworkNodes_capacity(self)
    __swig_destroy__ = _fast.delete_NeuralNetworkNodes

# Register NeuralNetworkNodes in _fast:
_fast.NeuralNetworkNodes_swigregister(NeuralNetworkNodes)

class NeuralNetworkNodeMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.NeuralNetworkNodeMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.NeuralNetworkNodeMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.NeuralNetworkNodeMap___bool__(self)

    def __len__(self) -> "std::map< std::string,fast::NeuralNetworkNode >::size_type":
        return _fast.NeuralNetworkNodeMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,fast::NeuralNetworkNode >::key_type const &") -> "std::map< std::string,fast::NeuralNetworkNode >::mapped_type const &":
        return _fast.NeuralNetworkNodeMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,fast::NeuralNetworkNode >::key_type const &") -> "void":
        return _fast.NeuralNetworkNodeMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,fast::NeuralNetworkNode >::key_type const &") -> "bool":
        return _fast.NeuralNetworkNodeMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _fast.NeuralNetworkNodeMap_keys(self)

    def values(self) -> "PyObject *":
        return _fast.NeuralNetworkNodeMap_values(self)

    def items(self) -> "PyObject *":
        return _fast.NeuralNetworkNodeMap_items(self)

    def __contains__(self, key: "std::map< std::string,fast::NeuralNetworkNode >::key_type const &") -> "bool":
        return _fast.NeuralNetworkNodeMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.NeuralNetworkNodeMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.NeuralNetworkNodeMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _fast.NeuralNetworkNodeMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _fast.NeuralNetworkNodeMap_asdict(self)

    def __init__(self, *args):
        _fast.NeuralNetworkNodeMap_swiginit(self, _fast.new_NeuralNetworkNodeMap(*args))

    def empty(self) -> "bool":
        return _fast.NeuralNetworkNodeMap_empty(self)

    def size(self) -> "std::map< std::string,fast::NeuralNetworkNode >::size_type":
        return _fast.NeuralNetworkNodeMap_size(self)

    def swap(self, v: "NeuralNetworkNodeMap") -> "void":
        return _fast.NeuralNetworkNodeMap_swap(self, v)

    def begin(self) -> "std::map< std::string,fast::NeuralNetworkNode >::iterator":
        return _fast.NeuralNetworkNodeMap_begin(self)

    def end(self) -> "std::map< std::string,fast::NeuralNetworkNode >::iterator":
        return _fast.NeuralNetworkNodeMap_end(self)

    def rbegin(self) -> "std::map< std::string,fast::NeuralNetworkNode >::reverse_iterator":
        return _fast.NeuralNetworkNodeMap_rbegin(self)

    def rend(self) -> "std::map< std::string,fast::NeuralNetworkNode >::reverse_iterator":
        return _fast.NeuralNetworkNodeMap_rend(self)

    def clear(self) -> "void":
        return _fast.NeuralNetworkNodeMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,fast::NeuralNetworkNode >::allocator_type":
        return _fast.NeuralNetworkNodeMap_get_allocator(self)

    def count(self, x: "std::map< std::string,fast::NeuralNetworkNode >::key_type const &") -> "std::map< std::string,fast::NeuralNetworkNode >::size_type":
        return _fast.NeuralNetworkNodeMap_count(self, x)

    def erase(self, *args) -> "void":
        return _fast.NeuralNetworkNodeMap_erase(self, *args)

    def find(self, x: "std::map< std::string,fast::NeuralNetworkNode >::key_type const &") -> "std::map< std::string,fast::NeuralNetworkNode >::iterator":
        return _fast.NeuralNetworkNodeMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,fast::NeuralNetworkNode >::key_type const &") -> "std::map< std::string,fast::NeuralNetworkNode >::iterator":
        return _fast.NeuralNetworkNodeMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,fast::NeuralNetworkNode >::key_type const &") -> "std::map< std::string,fast::NeuralNetworkNode >::iterator":
        return _fast.NeuralNetworkNodeMap_upper_bound(self, x)
    __swig_destroy__ = _fast.delete_NeuralNetworkNodeMap

# Register NeuralNetworkNodeMap in _fast:
_fast.NeuralNetworkNodeMap_swigregister(NeuralNetworkNodeMap)

class LabelColors(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.LabelColors_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.LabelColors___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.LabelColors___bool__(self)

    def __len__(self) -> "std::map< unsigned int,fast::Color >::size_type":
        return _fast.LabelColors___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< unsigned int,fast::Color >::key_type const &") -> "std::map< unsigned int,fast::Color >::mapped_type const &":
        return _fast.LabelColors___getitem__(self, key)

    def __delitem__(self, key: "std::map< unsigned int,fast::Color >::key_type const &") -> "void":
        return _fast.LabelColors___delitem__(self, key)

    def has_key(self, key: "std::map< unsigned int,fast::Color >::key_type const &") -> "bool":
        return _fast.LabelColors_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _fast.LabelColors_keys(self)

    def values(self) -> "PyObject *":
        return _fast.LabelColors_values(self)

    def items(self) -> "PyObject *":
        return _fast.LabelColors_items(self)

    def __contains__(self, key: "std::map< unsigned int,fast::Color >::key_type const &") -> "bool":
        return _fast.LabelColors___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.LabelColors_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.LabelColors_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _fast.LabelColors___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _fast.LabelColors_asdict(self)

    def __init__(self, *args):
        _fast.LabelColors_swiginit(self, _fast.new_LabelColors(*args))

    def empty(self) -> "bool":
        return _fast.LabelColors_empty(self)

    def size(self) -> "std::map< unsigned int,fast::Color >::size_type":
        return _fast.LabelColors_size(self)

    def swap(self, v: "LabelColors") -> "void":
        return _fast.LabelColors_swap(self, v)

    def begin(self) -> "std::map< unsigned int,fast::Color >::iterator":
        return _fast.LabelColors_begin(self)

    def end(self) -> "std::map< unsigned int,fast::Color >::iterator":
        return _fast.LabelColors_end(self)

    def rbegin(self) -> "std::map< unsigned int,fast::Color >::reverse_iterator":
        return _fast.LabelColors_rbegin(self)

    def rend(self) -> "std::map< unsigned int,fast::Color >::reverse_iterator":
        return _fast.LabelColors_rend(self)

    def clear(self) -> "void":
        return _fast.LabelColors_clear(self)

    def get_allocator(self) -> "std::map< unsigned int,fast::Color >::allocator_type":
        return _fast.LabelColors_get_allocator(self)

    def count(self, x: "std::map< unsigned int,fast::Color >::key_type const &") -> "std::map< unsigned int,fast::Color >::size_type":
        return _fast.LabelColors_count(self, x)

    def erase(self, *args) -> "void":
        return _fast.LabelColors_erase(self, *args)

    def find(self, x: "std::map< unsigned int,fast::Color >::key_type const &") -> "std::map< unsigned int,fast::Color >::iterator":
        return _fast.LabelColors_find(self, x)

    def lower_bound(self, x: "std::map< unsigned int,fast::Color >::key_type const &") -> "std::map< unsigned int,fast::Color >::iterator":
        return _fast.LabelColors_lower_bound(self, x)

    def upper_bound(self, x: "std::map< unsigned int,fast::Color >::key_type const &") -> "std::map< unsigned int,fast::Color >::iterator":
        return _fast.LabelColors_upper_bound(self, x)
    __swig_destroy__ = _fast.delete_LabelColors

# Register LabelColors in _fast:
_fast.LabelColors_swigregister(LabelColors)

class LabelNames(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.LabelNames_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.LabelNames___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.LabelNames___bool__(self)

    def __len__(self) -> "std::map< unsigned int,std::string >::size_type":
        return _fast.LabelNames___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< unsigned int,std::string >::key_type const &") -> "std::map< unsigned int,std::string >::mapped_type const &":
        return _fast.LabelNames___getitem__(self, key)

    def __delitem__(self, key: "std::map< unsigned int,std::string >::key_type const &") -> "void":
        return _fast.LabelNames___delitem__(self, key)

    def has_key(self, key: "std::map< unsigned int,std::string >::key_type const &") -> "bool":
        return _fast.LabelNames_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _fast.LabelNames_keys(self)

    def values(self) -> "PyObject *":
        return _fast.LabelNames_values(self)

    def items(self) -> "PyObject *":
        return _fast.LabelNames_items(self)

    def __contains__(self, key: "std::map< unsigned int,std::string >::key_type const &") -> "bool":
        return _fast.LabelNames___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.LabelNames_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.LabelNames_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _fast.LabelNames___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _fast.LabelNames_asdict(self)

    def __init__(self, *args):
        _fast.LabelNames_swiginit(self, _fast.new_LabelNames(*args))

    def empty(self) -> "bool":
        return _fast.LabelNames_empty(self)

    def size(self) -> "std::map< unsigned int,std::string >::size_type":
        return _fast.LabelNames_size(self)

    def swap(self, v: "LabelNames") -> "void":
        return _fast.LabelNames_swap(self, v)

    def begin(self) -> "std::map< unsigned int,std::string >::iterator":
        return _fast.LabelNames_begin(self)

    def end(self) -> "std::map< unsigned int,std::string >::iterator":
        return _fast.LabelNames_end(self)

    def rbegin(self) -> "std::map< unsigned int,std::string >::reverse_iterator":
        return _fast.LabelNames_rbegin(self)

    def rend(self) -> "std::map< unsigned int,std::string >::reverse_iterator":
        return _fast.LabelNames_rend(self)

    def clear(self) -> "void":
        return _fast.LabelNames_clear(self)

    def get_allocator(self) -> "std::map< unsigned int,std::string >::allocator_type":
        return _fast.LabelNames_get_allocator(self)

    def count(self, x: "std::map< unsigned int,std::string >::key_type const &") -> "std::map< unsigned int,std::string >::size_type":
        return _fast.LabelNames_count(self, x)

    def erase(self, *args) -> "void":
        return _fast.LabelNames_erase(self, *args)

    def find(self, x: "std::map< unsigned int,std::string >::key_type const &") -> "std::map< unsigned int,std::string >::iterator":
        return _fast.LabelNames_find(self, x)

    def lower_bound(self, x: "std::map< unsigned int,std::string >::key_type const &") -> "std::map< unsigned int,std::string >::iterator":
        return _fast.LabelNames_lower_bound(self, x)

    def upper_bound(self, x: "std::map< unsigned int,std::string >::key_type const &") -> "std::map< unsigned int,std::string >::iterator":
        return _fast.LabelNames_upper_bound(self, x)
    __swig_destroy__ = _fast.delete_LabelNames

# Register LabelNames in _fast:
_fast.LabelNames_swigregister(LabelNames)

class StringMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.StringMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.StringMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.StringMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::string >::size_type":
        return _fast.StringMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::mapped_type const &":
        return _fast.StringMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::string >::key_type const &") -> "void":
        return _fast.StringMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        return _fast.StringMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _fast.StringMap_keys(self)

    def values(self) -> "PyObject *":
        return _fast.StringMap_values(self)

    def items(self) -> "PyObject *":
        return _fast.StringMap_items(self)

    def __contains__(self, key: "std::map< std::string,std::string >::key_type const &") -> "bool":
        return _fast.StringMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.StringMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.StringMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _fast.StringMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _fast.StringMap_asdict(self)

    def __init__(self, *args):
        _fast.StringMap_swiginit(self, _fast.new_StringMap(*args))

    def empty(self) -> "bool":
        return _fast.StringMap_empty(self)

    def size(self) -> "std::map< std::string,std::string >::size_type":
        return _fast.StringMap_size(self)

    def swap(self, v: "StringMap") -> "void":
        return _fast.StringMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::string >::iterator":
        return _fast.StringMap_begin(self)

    def end(self) -> "std::map< std::string,std::string >::iterator":
        return _fast.StringMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::string >::reverse_iterator":
        return _fast.StringMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::string >::reverse_iterator":
        return _fast.StringMap_rend(self)

    def clear(self) -> "void":
        return _fast.StringMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::string >::allocator_type":
        return _fast.StringMap_get_allocator(self)

    def count(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::size_type":
        return _fast.StringMap_count(self, x)

    def erase(self, *args) -> "void":
        return _fast.StringMap_erase(self, *args)

    def find(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _fast.StringMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _fast.StringMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::string >::key_type const &") -> "std::map< std::string,std::string >::iterator":
        return _fast.StringMap_upper_bound(self, x)
    __swig_destroy__ = _fast.delete_StringMap

# Register StringMap in _fast:
_fast.StringMap_swigregister(StringMap)

class StringFloatMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.StringFloatMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.StringFloatMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.StringFloatMap___bool__(self)

    def __len__(self) -> "std::map< std::string,float >::size_type":
        return _fast.StringFloatMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,float >::key_type const &") -> "std::map< std::string,float >::mapped_type const &":
        return _fast.StringFloatMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,float >::key_type const &") -> "void":
        return _fast.StringFloatMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,float >::key_type const &") -> "bool":
        return _fast.StringFloatMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _fast.StringFloatMap_keys(self)

    def values(self) -> "PyObject *":
        return _fast.StringFloatMap_values(self)

    def items(self) -> "PyObject *":
        return _fast.StringFloatMap_items(self)

    def __contains__(self, key: "std::map< std::string,float >::key_type const &") -> "bool":
        return _fast.StringFloatMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.StringFloatMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.StringFloatMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _fast.StringFloatMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _fast.StringFloatMap_asdict(self)

    def __init__(self, *args):
        _fast.StringFloatMap_swiginit(self, _fast.new_StringFloatMap(*args))

    def empty(self) -> "bool":
        return _fast.StringFloatMap_empty(self)

    def size(self) -> "std::map< std::string,float >::size_type":
        return _fast.StringFloatMap_size(self)

    def swap(self, v: "StringFloatMap") -> "void":
        return _fast.StringFloatMap_swap(self, v)

    def begin(self) -> "std::map< std::string,float >::iterator":
        return _fast.StringFloatMap_begin(self)

    def end(self) -> "std::map< std::string,float >::iterator":
        return _fast.StringFloatMap_end(self)

    def rbegin(self) -> "std::map< std::string,float >::reverse_iterator":
        return _fast.StringFloatMap_rbegin(self)

    def rend(self) -> "std::map< std::string,float >::reverse_iterator":
        return _fast.StringFloatMap_rend(self)

    def clear(self) -> "void":
        return _fast.StringFloatMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,float >::allocator_type":
        return _fast.StringFloatMap_get_allocator(self)

    def count(self, x: "std::map< std::string,float >::key_type const &") -> "std::map< std::string,float >::size_type":
        return _fast.StringFloatMap_count(self, x)

    def erase(self, *args) -> "void":
        return _fast.StringFloatMap_erase(self, *args)

    def find(self, x: "std::map< std::string,float >::key_type const &") -> "std::map< std::string,float >::iterator":
        return _fast.StringFloatMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,float >::key_type const &") -> "std::map< std::string,float >::iterator":
        return _fast.StringFloatMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,float >::key_type const &") -> "std::map< std::string,float >::iterator":
        return _fast.StringFloatMap_upper_bound(self, x)
    __swig_destroy__ = _fast.delete_StringFloatMap

# Register StringFloatMap in _fast:
_fast.StringFloatMap_swigregister(StringFloatMap)

class StringFloatPair(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _fast.StringFloatPair_swiginit(self, _fast.new_StringFloatPair(*args))
    first = property(_fast.StringFloatPair_first_get, _fast.StringFloatPair_first_set)
    second = property(_fast.StringFloatPair_second_get, _fast.StringFloatPair_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _fast.delete_StringFloatPair

# Register StringFloatPair in _fast:
_fast.StringFloatPair_swigregister(StringFloatPair)

class vectormeshvertex(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectormeshvertex_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectormeshvertex___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectormeshvertex___bool__(self)

    def __len__(self) -> "std::vector< fast::MeshVertex >::size_type":
        return _fast.vectormeshvertex___len__(self)

    def __getslice__(self, i: "std::vector< fast::MeshVertex >::difference_type", j: "std::vector< fast::MeshVertex >::difference_type") -> "std::vector< fast::MeshVertex,std::allocator< fast::MeshVertex > > *":
        return _fast.vectormeshvertex___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectormeshvertex___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< fast::MeshVertex >::difference_type", j: "std::vector< fast::MeshVertex >::difference_type") -> "void":
        return _fast.vectormeshvertex___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectormeshvertex___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< fast::MeshVertex >::value_type const &":
        return _fast.vectormeshvertex___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectormeshvertex___setitem__(self, *args)

    def append(self, x: "MeshVertex") -> "void":
        return _fast.vectormeshvertex_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectormeshvertex_empty(self)

    def size(self) -> "std::vector< fast::MeshVertex >::size_type":
        return _fast.vectormeshvertex_size(self)

    def swap(self, v: "vectormeshvertex") -> "void":
        return _fast.vectormeshvertex_swap(self, v)

    def begin(self) -> "std::vector< fast::MeshVertex >::iterator":
        return _fast.vectormeshvertex_begin(self)

    def end(self) -> "std::vector< fast::MeshVertex >::iterator":
        return _fast.vectormeshvertex_end(self)

    def rbegin(self) -> "std::vector< fast::MeshVertex >::reverse_iterator":
        return _fast.vectormeshvertex_rbegin(self)

    def rend(self) -> "std::vector< fast::MeshVertex >::reverse_iterator":
        return _fast.vectormeshvertex_rend(self)

    def clear(self) -> "void":
        return _fast.vectormeshvertex_clear(self)

    def get_allocator(self) -> "std::vector< fast::MeshVertex >::allocator_type":
        return _fast.vectormeshvertex_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectormeshvertex_pop_back(self)

    def erase(self, *args) -> "std::vector< fast::MeshVertex >::iterator":
        return _fast.vectormeshvertex_erase(self, *args)

    def __init__(self, *args):
        _fast.vectormeshvertex_swiginit(self, _fast.new_vectormeshvertex(*args))

    def push_back(self, x: "MeshVertex") -> "void":
        return _fast.vectormeshvertex_push_back(self, x)

    def front(self) -> "std::vector< fast::MeshVertex >::value_type const &":
        return _fast.vectormeshvertex_front(self)

    def back(self) -> "std::vector< fast::MeshVertex >::value_type const &":
        return _fast.vectormeshvertex_back(self)

    def assign(self, n: "std::vector< fast::MeshVertex >::size_type", x: "MeshVertex") -> "void":
        return _fast.vectormeshvertex_assign(self, n, x)

    def insert(self, *args) -> "void":
        return _fast.vectormeshvertex_insert(self, *args)

    def reserve(self, n: "std::vector< fast::MeshVertex >::size_type") -> "void":
        return _fast.vectormeshvertex_reserve(self, n)

    def capacity(self) -> "std::vector< fast::MeshVertex >::size_type":
        return _fast.vectormeshvertex_capacity(self)
    __swig_destroy__ = _fast.delete_vectormeshvertex

# Register vectormeshvertex in _fast:
_fast.vectormeshvertex_swigregister(vectormeshvertex)

class vectormeshline(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectormeshline_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectormeshline___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectormeshline___bool__(self)

    def __len__(self) -> "std::vector< fast::MeshLine >::size_type":
        return _fast.vectormeshline___len__(self)

    def __getslice__(self, i: "std::vector< fast::MeshLine >::difference_type", j: "std::vector< fast::MeshLine >::difference_type") -> "std::vector< fast::MeshLine,std::allocator< fast::MeshLine > > *":
        return _fast.vectormeshline___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectormeshline___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< fast::MeshLine >::difference_type", j: "std::vector< fast::MeshLine >::difference_type") -> "void":
        return _fast.vectormeshline___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectormeshline___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< fast::MeshLine >::value_type const &":
        return _fast.vectormeshline___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectormeshline___setitem__(self, *args)

    def append(self, x: "MeshLine") -> "void":
        return _fast.vectormeshline_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectormeshline_empty(self)

    def size(self) -> "std::vector< fast::MeshLine >::size_type":
        return _fast.vectormeshline_size(self)

    def swap(self, v: "vectormeshline") -> "void":
        return _fast.vectormeshline_swap(self, v)

    def begin(self) -> "std::vector< fast::MeshLine >::iterator":
        return _fast.vectormeshline_begin(self)

    def end(self) -> "std::vector< fast::MeshLine >::iterator":
        return _fast.vectormeshline_end(self)

    def rbegin(self) -> "std::vector< fast::MeshLine >::reverse_iterator":
        return _fast.vectormeshline_rbegin(self)

    def rend(self) -> "std::vector< fast::MeshLine >::reverse_iterator":
        return _fast.vectormeshline_rend(self)

    def clear(self) -> "void":
        return _fast.vectormeshline_clear(self)

    def get_allocator(self) -> "std::vector< fast::MeshLine >::allocator_type":
        return _fast.vectormeshline_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectormeshline_pop_back(self)

    def erase(self, *args) -> "std::vector< fast::MeshLine >::iterator":
        return _fast.vectormeshline_erase(self, *args)

    def __init__(self, *args):
        _fast.vectormeshline_swiginit(self, _fast.new_vectormeshline(*args))

    def push_back(self, x: "MeshLine") -> "void":
        return _fast.vectormeshline_push_back(self, x)

    def front(self) -> "std::vector< fast::MeshLine >::value_type const &":
        return _fast.vectormeshline_front(self)

    def back(self) -> "std::vector< fast::MeshLine >::value_type const &":
        return _fast.vectormeshline_back(self)

    def assign(self, n: "std::vector< fast::MeshLine >::size_type", x: "MeshLine") -> "void":
        return _fast.vectormeshline_assign(self, n, x)

    def insert(self, *args) -> "void":
        return _fast.vectormeshline_insert(self, *args)

    def reserve(self, n: "std::vector< fast::MeshLine >::size_type") -> "void":
        return _fast.vectormeshline_reserve(self, n)

    def capacity(self) -> "std::vector< fast::MeshLine >::size_type":
        return _fast.vectormeshline_capacity(self)
    __swig_destroy__ = _fast.delete_vectormeshline

# Register vectormeshline in _fast:
_fast.vectormeshline_swigregister(vectormeshline)

class vectormeshtriangle(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectormeshtriangle_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectormeshtriangle___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectormeshtriangle___bool__(self)

    def __len__(self) -> "std::vector< fast::MeshTriangle >::size_type":
        return _fast.vectormeshtriangle___len__(self)

    def __getslice__(self, i: "std::vector< fast::MeshTriangle >::difference_type", j: "std::vector< fast::MeshTriangle >::difference_type") -> "std::vector< fast::MeshTriangle,std::allocator< fast::MeshTriangle > > *":
        return _fast.vectormeshtriangle___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectormeshtriangle___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< fast::MeshTriangle >::difference_type", j: "std::vector< fast::MeshTriangle >::difference_type") -> "void":
        return _fast.vectormeshtriangle___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectormeshtriangle___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< fast::MeshTriangle >::value_type const &":
        return _fast.vectormeshtriangle___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectormeshtriangle___setitem__(self, *args)

    def append(self, x: "MeshTriangle") -> "void":
        return _fast.vectormeshtriangle_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectormeshtriangle_empty(self)

    def size(self) -> "std::vector< fast::MeshTriangle >::size_type":
        return _fast.vectormeshtriangle_size(self)

    def swap(self, v: "vectormeshtriangle") -> "void":
        return _fast.vectormeshtriangle_swap(self, v)

    def begin(self) -> "std::vector< fast::MeshTriangle >::iterator":
        return _fast.vectormeshtriangle_begin(self)

    def end(self) -> "std::vector< fast::MeshTriangle >::iterator":
        return _fast.vectormeshtriangle_end(self)

    def rbegin(self) -> "std::vector< fast::MeshTriangle >::reverse_iterator":
        return _fast.vectormeshtriangle_rbegin(self)

    def rend(self) -> "std::vector< fast::MeshTriangle >::reverse_iterator":
        return _fast.vectormeshtriangle_rend(self)

    def clear(self) -> "void":
        return _fast.vectormeshtriangle_clear(self)

    def get_allocator(self) -> "std::vector< fast::MeshTriangle >::allocator_type":
        return _fast.vectormeshtriangle_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectormeshtriangle_pop_back(self)

    def erase(self, *args) -> "std::vector< fast::MeshTriangle >::iterator":
        return _fast.vectormeshtriangle_erase(self, *args)

    def __init__(self, *args):
        _fast.vectormeshtriangle_swiginit(self, _fast.new_vectormeshtriangle(*args))

    def push_back(self, x: "MeshTriangle") -> "void":
        return _fast.vectormeshtriangle_push_back(self, x)

    def front(self) -> "std::vector< fast::MeshTriangle >::value_type const &":
        return _fast.vectormeshtriangle_front(self)

    def back(self) -> "std::vector< fast::MeshTriangle >::value_type const &":
        return _fast.vectormeshtriangle_back(self)

    def assign(self, n: "std::vector< fast::MeshTriangle >::size_type", x: "MeshTriangle") -> "void":
        return _fast.vectormeshtriangle_assign(self, n, x)

    def insert(self, *args) -> "void":
        return _fast.vectormeshtriangle_insert(self, *args)

    def reserve(self, n: "std::vector< fast::MeshTriangle >::size_type") -> "void":
        return _fast.vectormeshtriangle_reserve(self, n)

    def capacity(self) -> "std::vector< fast::MeshTriangle >::size_type":
        return _fast.vectormeshtriangle_capacity(self)
    __swig_destroy__ = _fast.delete_vectormeshtriangle

# Register vectormeshtriangle in _fast:
_fast.vectormeshtriangle_swigregister(vectormeshtriangle)

class Connections(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.Connections_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.Connections___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.Connections___bool__(self)

    def __len__(self) -> "std::vector< std::vector< fast::MeshLine > >::size_type":
        return _fast.Connections___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< fast::MeshLine > >::difference_type", j: "std::vector< std::vector< fast::MeshLine > >::difference_type") -> "std::vector< std::vector< fast::MeshLine,std::allocator< fast::MeshLine > >,std::allocator< std::vector< fast::MeshLine,std::allocator< fast::MeshLine > > > > *":
        return _fast.Connections___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.Connections___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< fast::MeshLine > >::difference_type", j: "std::vector< std::vector< fast::MeshLine > >::difference_type") -> "void":
        return _fast.Connections___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.Connections___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< fast::MeshLine > >::value_type const &":
        return _fast.Connections___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.Connections___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< fast::MeshLine > >::value_type":
        return _fast.Connections_pop(self)

    def append(self, x: "vectormeshline") -> "void":
        return _fast.Connections_append(self, x)

    def empty(self) -> "bool":
        return _fast.Connections_empty(self)

    def size(self) -> "std::vector< std::vector< fast::MeshLine > >::size_type":
        return _fast.Connections_size(self)

    def swap(self, v: "Connections") -> "void":
        return _fast.Connections_swap(self, v)

    def begin(self) -> "std::vector< std::vector< fast::MeshLine > >::iterator":
        return _fast.Connections_begin(self)

    def end(self) -> "std::vector< std::vector< fast::MeshLine > >::iterator":
        return _fast.Connections_end(self)

    def rbegin(self) -> "std::vector< std::vector< fast::MeshLine > >::reverse_iterator":
        return _fast.Connections_rbegin(self)

    def rend(self) -> "std::vector< std::vector< fast::MeshLine > >::reverse_iterator":
        return _fast.Connections_rend(self)

    def clear(self) -> "void":
        return _fast.Connections_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< fast::MeshLine > >::allocator_type":
        return _fast.Connections_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.Connections_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< fast::MeshLine > >::iterator":
        return _fast.Connections_erase(self, *args)

    def __init__(self, *args):
        _fast.Connections_swiginit(self, _fast.new_Connections(*args))

    def push_back(self, x: "vectormeshline") -> "void":
        return _fast.Connections_push_back(self, x)

    def front(self) -> "std::vector< std::vector< fast::MeshLine > >::value_type const &":
        return _fast.Connections_front(self)

    def back(self) -> "std::vector< std::vector< fast::MeshLine > >::value_type const &":
        return _fast.Connections_back(self)

    def assign(self, n: "std::vector< std::vector< fast::MeshLine > >::size_type", x: "vectormeshline") -> "void":
        return _fast.Connections_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.Connections_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.Connections_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< fast::MeshLine > >::size_type") -> "void":
        return _fast.Connections_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< fast::MeshLine > >::size_type":
        return _fast.Connections_capacity(self)
    __swig_destroy__ = _fast.delete_Connections

# Register Connections in _fast:
_fast.Connections_swigregister(Connections)

class Regions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.Regions_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.Regions___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.Regions___bool__(self)

    def __len__(self) -> "std::vector< fast::Region >::size_type":
        return _fast.Regions___len__(self)

    def __getslice__(self, i: "std::vector< fast::Region >::difference_type", j: "std::vector< fast::Region >::difference_type") -> "std::vector< fast::Region,std::allocator< fast::Region > > *":
        return _fast.Regions___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.Regions___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< fast::Region >::difference_type", j: "std::vector< fast::Region >::difference_type") -> "void":
        return _fast.Regions___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.Regions___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< fast::Region >::value_type const &":
        return _fast.Regions___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.Regions___setitem__(self, *args)

    def pop(self) -> "std::vector< fast::Region >::value_type":
        return _fast.Regions_pop(self)

    def append(self, x: "Region") -> "void":
        return _fast.Regions_append(self, x)

    def empty(self) -> "bool":
        return _fast.Regions_empty(self)

    def size(self) -> "std::vector< fast::Region >::size_type":
        return _fast.Regions_size(self)

    def swap(self, v: "Regions") -> "void":
        return _fast.Regions_swap(self, v)

    def begin(self) -> "std::vector< fast::Region >::iterator":
        return _fast.Regions_begin(self)

    def end(self) -> "std::vector< fast::Region >::iterator":
        return _fast.Regions_end(self)

    def rbegin(self) -> "std::vector< fast::Region >::reverse_iterator":
        return _fast.Regions_rbegin(self)

    def rend(self) -> "std::vector< fast::Region >::reverse_iterator":
        return _fast.Regions_rend(self)

    def clear(self) -> "void":
        return _fast.Regions_clear(self)

    def get_allocator(self) -> "std::vector< fast::Region >::allocator_type":
        return _fast.Regions_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.Regions_pop_back(self)

    def erase(self, *args) -> "std::vector< fast::Region >::iterator":
        return _fast.Regions_erase(self, *args)

    def __init__(self, *args):
        _fast.Regions_swiginit(self, _fast.new_Regions(*args))

    def push_back(self, x: "Region") -> "void":
        return _fast.Regions_push_back(self, x)

    def front(self) -> "std::vector< fast::Region >::value_type const &":
        return _fast.Regions_front(self)

    def back(self) -> "std::vector< fast::Region >::value_type const &":
        return _fast.Regions_back(self)

    def assign(self, n: "std::vector< fast::Region >::size_type", x: "Region") -> "void":
        return _fast.Regions_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.Regions_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.Regions_insert(self, *args)

    def reserve(self, n: "std::vector< fast::Region >::size_type") -> "void":
        return _fast.Regions_reserve(self, n)

    def capacity(self) -> "std::vector< fast::Region >::size_type":
        return _fast.Regions_capacity(self)
    __swig_destroy__ = _fast.delete_Regions

# Register Regions in _fast:
_fast.Regions_swigregister(Regions)

class vectorrenderer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectorrenderer_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectorrenderer___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectorrenderer___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::size_type":
        return _fast.vectorrenderer___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< fast::Renderer > >::difference_type", j: "std::vector< std::shared_ptr< fast::Renderer > >::difference_type") -> "std::vector< std::shared_ptr< fast::Renderer >,std::allocator< std::shared_ptr< fast::Renderer > > > *":
        return _fast.vectorrenderer___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectorrenderer___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< fast::Renderer > >::difference_type", j: "std::vector< std::shared_ptr< fast::Renderer > >::difference_type") -> "void":
        return _fast.vectorrenderer___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectorrenderer___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< fast::Renderer > >::value_type const &":
        return _fast.vectorrenderer___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectorrenderer___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::value_type":
        return _fast.vectorrenderer_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< fast::Renderer > >::value_type const &") -> "void":
        return _fast.vectorrenderer_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectorrenderer_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::size_type":
        return _fast.vectorrenderer_size(self)

    def swap(self, v: "vectorrenderer") -> "void":
        return _fast.vectorrenderer_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::iterator":
        return _fast.vectorrenderer_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::iterator":
        return _fast.vectorrenderer_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::reverse_iterator":
        return _fast.vectorrenderer_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::reverse_iterator":
        return _fast.vectorrenderer_rend(self)

    def clear(self) -> "void":
        return _fast.vectorrenderer_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::allocator_type":
        return _fast.vectorrenderer_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectorrenderer_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< fast::Renderer > >::iterator":
        return _fast.vectorrenderer_erase(self, *args)

    def __init__(self, *args):
        _fast.vectorrenderer_swiginit(self, _fast.new_vectorrenderer(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< fast::Renderer > >::value_type const &") -> "void":
        return _fast.vectorrenderer_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::value_type const &":
        return _fast.vectorrenderer_front(self)

    def back(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::value_type const &":
        return _fast.vectorrenderer_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< fast::Renderer > >::size_type", x: "std::vector< std::shared_ptr< fast::Renderer > >::value_type const &") -> "void":
        return _fast.vectorrenderer_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectorrenderer_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectorrenderer_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< fast::Renderer > >::size_type") -> "void":
        return _fast.vectorrenderer_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< fast::Renderer > >::size_type":
        return _fast.vectorrenderer_capacity(self)
    __swig_destroy__ = _fast.delete_vectorrenderer

# Register vectorrenderer in _fast:
_fast.vectorrenderer_swigregister(vectorrenderer)

class vectorpo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectorpo_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectorpo___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectorpo___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::size_type":
        return _fast.vectorpo___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< fast::ProcessObject > >::difference_type", j: "std::vector< std::shared_ptr< fast::ProcessObject > >::difference_type") -> "std::vector< std::shared_ptr< fast::ProcessObject >,std::allocator< std::shared_ptr< fast::ProcessObject > > > *":
        return _fast.vectorpo___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectorpo___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< fast::ProcessObject > >::difference_type", j: "std::vector< std::shared_ptr< fast::ProcessObject > >::difference_type") -> "void":
        return _fast.vectorpo___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectorpo___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::value_type const &":
        return _fast.vectorpo___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectorpo___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::value_type":
        return _fast.vectorpo_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< fast::ProcessObject > >::value_type const &") -> "void":
        return _fast.vectorpo_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectorpo_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::size_type":
        return _fast.vectorpo_size(self)

    def swap(self, v: "vectorpo") -> "void":
        return _fast.vectorpo_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::iterator":
        return _fast.vectorpo_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::iterator":
        return _fast.vectorpo_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::reverse_iterator":
        return _fast.vectorpo_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::reverse_iterator":
        return _fast.vectorpo_rend(self)

    def clear(self) -> "void":
        return _fast.vectorpo_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::allocator_type":
        return _fast.vectorpo_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectorpo_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::iterator":
        return _fast.vectorpo_erase(self, *args)

    def __init__(self, *args):
        _fast.vectorpo_swiginit(self, _fast.new_vectorpo(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< fast::ProcessObject > >::value_type const &") -> "void":
        return _fast.vectorpo_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::value_type const &":
        return _fast.vectorpo_front(self)

    def back(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::value_type const &":
        return _fast.vectorpo_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< fast::ProcessObject > >::size_type", x: "std::vector< std::shared_ptr< fast::ProcessObject > >::value_type const &") -> "void":
        return _fast.vectorpo_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectorpo_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectorpo_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< fast::ProcessObject > >::size_type") -> "void":
        return _fast.vectorpo_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< fast::ProcessObject > >::size_type":
        return _fast.vectorpo_capacity(self)
    __swig_destroy__ = _fast.delete_vectorpo

# Register vectorpo in _fast:
_fast.vectorpo_swigregister(vectorpo)

class vectorimage(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectorimage_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectorimage___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectorimage___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< fast::Image > >::size_type":
        return _fast.vectorimage___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< fast::Image > >::difference_type", j: "std::vector< std::shared_ptr< fast::Image > >::difference_type") -> "std::vector< std::shared_ptr< fast::Image >,std::allocator< std::shared_ptr< fast::Image > > > *":
        return _fast.vectorimage___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectorimage___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< fast::Image > >::difference_type", j: "std::vector< std::shared_ptr< fast::Image > >::difference_type") -> "void":
        return _fast.vectorimage___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectorimage___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< fast::Image > >::value_type const &":
        return _fast.vectorimage___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectorimage___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< fast::Image > >::value_type":
        return _fast.vectorimage_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< fast::Image > >::value_type const &") -> "void":
        return _fast.vectorimage_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectorimage_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< fast::Image > >::size_type":
        return _fast.vectorimage_size(self)

    def swap(self, v: "vectorimage") -> "void":
        return _fast.vectorimage_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< fast::Image > >::iterator":
        return _fast.vectorimage_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< fast::Image > >::iterator":
        return _fast.vectorimage_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< fast::Image > >::reverse_iterator":
        return _fast.vectorimage_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< fast::Image > >::reverse_iterator":
        return _fast.vectorimage_rend(self)

    def clear(self) -> "void":
        return _fast.vectorimage_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< fast::Image > >::allocator_type":
        return _fast.vectorimage_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectorimage_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< fast::Image > >::iterator":
        return _fast.vectorimage_erase(self, *args)

    def __init__(self, *args):
        _fast.vectorimage_swiginit(self, _fast.new_vectorimage(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< fast::Image > >::value_type const &") -> "void":
        return _fast.vectorimage_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< fast::Image > >::value_type const &":
        return _fast.vectorimage_front(self)

    def back(self) -> "std::vector< std::shared_ptr< fast::Image > >::value_type const &":
        return _fast.vectorimage_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< fast::Image > >::size_type", x: "std::vector< std::shared_ptr< fast::Image > >::value_type const &") -> "void":
        return _fast.vectorimage_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectorimage_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectorimage_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< fast::Image > >::size_type") -> "void":
        return _fast.vectorimage_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< fast::Image > >::size_type":
        return _fast.vectorimage_capacity(self)
    __swig_destroy__ = _fast.delete_vectorimage

# Register vectorimage in _fast:
_fast.vectorimage_swigregister(vectorimage)

class vectortensor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.vectortensor_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.vectortensor___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.vectortensor___bool__(self)

    def __len__(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::size_type":
        return _fast.vectortensor___len__(self)

    def __getslice__(self, i: "std::vector< std::shared_ptr< fast::Tensor > >::difference_type", j: "std::vector< std::shared_ptr< fast::Tensor > >::difference_type") -> "std::vector< std::shared_ptr< fast::Tensor >,std::allocator< std::shared_ptr< fast::Tensor > > > *":
        return _fast.vectortensor___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.vectortensor___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::shared_ptr< fast::Tensor > >::difference_type", j: "std::vector< std::shared_ptr< fast::Tensor > >::difference_type") -> "void":
        return _fast.vectortensor___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.vectortensor___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::shared_ptr< fast::Tensor > >::value_type const &":
        return _fast.vectortensor___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.vectortensor___setitem__(self, *args)

    def pop(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::value_type":
        return _fast.vectortensor_pop(self)

    def append(self, x: "std::vector< std::shared_ptr< fast::Tensor > >::value_type const &") -> "void":
        return _fast.vectortensor_append(self, x)

    def empty(self) -> "bool":
        return _fast.vectortensor_empty(self)

    def size(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::size_type":
        return _fast.vectortensor_size(self)

    def swap(self, v: "vectortensor") -> "void":
        return _fast.vectortensor_swap(self, v)

    def begin(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::iterator":
        return _fast.vectortensor_begin(self)

    def end(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::iterator":
        return _fast.vectortensor_end(self)

    def rbegin(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::reverse_iterator":
        return _fast.vectortensor_rbegin(self)

    def rend(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::reverse_iterator":
        return _fast.vectortensor_rend(self)

    def clear(self) -> "void":
        return _fast.vectortensor_clear(self)

    def get_allocator(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::allocator_type":
        return _fast.vectortensor_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.vectortensor_pop_back(self)

    def erase(self, *args) -> "std::vector< std::shared_ptr< fast::Tensor > >::iterator":
        return _fast.vectortensor_erase(self, *args)

    def __init__(self, *args):
        _fast.vectortensor_swiginit(self, _fast.new_vectortensor(*args))

    def push_back(self, x: "std::vector< std::shared_ptr< fast::Tensor > >::value_type const &") -> "void":
        return _fast.vectortensor_push_back(self, x)

    def front(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::value_type const &":
        return _fast.vectortensor_front(self)

    def back(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::value_type const &":
        return _fast.vectortensor_back(self)

    def assign(self, n: "std::vector< std::shared_ptr< fast::Tensor > >::size_type", x: "std::vector< std::shared_ptr< fast::Tensor > >::value_type const &") -> "void":
        return _fast.vectortensor_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _fast.vectortensor_resize(self, *args)

    def insert(self, *args) -> "void":
        return _fast.vectortensor_insert(self, *args)

    def reserve(self, n: "std::vector< std::shared_ptr< fast::Tensor > >::size_type") -> "void":
        return _fast.vectortensor_reserve(self, n)

    def capacity(self) -> "std::vector< std::shared_ptr< fast::Tensor > >::size_type":
        return _fast.vectortensor_capacity(self)
    __swig_destroy__ = _fast.delete_vectortensor

# Register vectortensor in _fast:
_fast.vectortensor_swigregister(vectortensor)

class DataMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.DataMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.DataMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.DataMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::size_type":
        return _fast.DataMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::shared_ptr< fast::DataObject > >::key_type const &") -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::mapped_type const &":
        return _fast.DataMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::shared_ptr< fast::DataObject > >::key_type const &") -> "void":
        return _fast.DataMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::shared_ptr< fast::DataObject > >::key_type const &") -> "bool":
        return _fast.DataMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _fast.DataMap_keys(self)

    def values(self) -> "PyObject *":
        return _fast.DataMap_values(self)

    def items(self) -> "PyObject *":
        return _fast.DataMap_items(self)

    def __contains__(self, key: "std::map< std::string,std::shared_ptr< fast::DataObject > >::key_type const &") -> "bool":
        return _fast.DataMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.DataMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.DataMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _fast.DataMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _fast.DataMap_asdict(self)

    def __init__(self, *args):
        _fast.DataMap_swiginit(self, _fast.new_DataMap(*args))

    def empty(self) -> "bool":
        return _fast.DataMap_empty(self)

    def size(self) -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::size_type":
        return _fast.DataMap_size(self)

    def swap(self, v: "DataMap") -> "void":
        return _fast.DataMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::iterator":
        return _fast.DataMap_begin(self)

    def end(self) -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::iterator":
        return _fast.DataMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::reverse_iterator":
        return _fast.DataMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::reverse_iterator":
        return _fast.DataMap_rend(self)

    def clear(self) -> "void":
        return _fast.DataMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::allocator_type":
        return _fast.DataMap_get_allocator(self)

    def count(self, x: "std::map< std::string,std::shared_ptr< fast::DataObject > >::key_type const &") -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::size_type":
        return _fast.DataMap_count(self, x)

    def erase(self, *args) -> "void":
        return _fast.DataMap_erase(self, *args)

    def find(self, x: "std::map< std::string,std::shared_ptr< fast::DataObject > >::key_type const &") -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::iterator":
        return _fast.DataMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::shared_ptr< fast::DataObject > >::key_type const &") -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::iterator":
        return _fast.DataMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::shared_ptr< fast::DataObject > >::key_type const &") -> "std::map< std::string,std::shared_ptr< fast::DataObject > >::iterator":
        return _fast.DataMap_upper_bound(self, x)
    __swig_destroy__ = _fast.delete_DataMap

# Register DataMap in _fast:
_fast.DataMap_swigregister(DataMap)

class ProcessObjectMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.ProcessObjectMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.ProcessObjectMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.ProcessObjectMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::size_type":
        return _fast.ProcessObjectMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::key_type const &") -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::mapped_type const &":
        return _fast.ProcessObjectMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::key_type const &") -> "void":
        return _fast.ProcessObjectMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::key_type const &") -> "bool":
        return _fast.ProcessObjectMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _fast.ProcessObjectMap_keys(self)

    def values(self) -> "PyObject *":
        return _fast.ProcessObjectMap_values(self)

    def items(self) -> "PyObject *":
        return _fast.ProcessObjectMap_items(self)

    def __contains__(self, key: "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::key_type const &") -> "bool":
        return _fast.ProcessObjectMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.ProcessObjectMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _fast.ProcessObjectMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _fast.ProcessObjectMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _fast.ProcessObjectMap_asdict(self)

    def __init__(self, *args):
        _fast.ProcessObjectMap_swiginit(self, _fast.new_ProcessObjectMap(*args))

    def empty(self) -> "bool":
        return _fast.ProcessObjectMap_empty(self)

    def size(self) -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::size_type":
        return _fast.ProcessObjectMap_size(self)

    def swap(self, v: "ProcessObjectMap") -> "void":
        return _fast.ProcessObjectMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::iterator":
        return _fast.ProcessObjectMap_begin(self)

    def end(self) -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::iterator":
        return _fast.ProcessObjectMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::reverse_iterator":
        return _fast.ProcessObjectMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::reverse_iterator":
        return _fast.ProcessObjectMap_rend(self)

    def clear(self) -> "void":
        return _fast.ProcessObjectMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::allocator_type":
        return _fast.ProcessObjectMap_get_allocator(self)

    def count(self, x: "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::key_type const &") -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::size_type":
        return _fast.ProcessObjectMap_count(self, x)

    def erase(self, *args) -> "void":
        return _fast.ProcessObjectMap_erase(self, *args)

    def find(self, x: "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::key_type const &") -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::iterator":
        return _fast.ProcessObjectMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::key_type const &") -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::iterator":
        return _fast.ProcessObjectMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::key_type const &") -> "std::map< std::string,std::shared_ptr< fast::ProcessObject > >::iterator":
        return _fast.ProcessObjectMap_upper_bound(self, x)
    __swig_destroy__ = _fast.delete_ProcessObjectMap

# Register ProcessObjectMap in _fast:
_fast.ProcessObjectMap_swigregister(ProcessObjectMap)


def _convertToCContiguous(pointer: "std::size_t", shape: "vectori", type: "fast::DataType") -> "std::size_t":
    return _fast._convertToCContiguous(pointer, shape, type)

def _convertToCContiguousFloat(pointer: "std::size_t", shape: "vectori", type: "std::string") -> "std::size_t":
    return _fast._convertToCContiguousFloat(pointer, shape, type)

def _convertToFloat(pointer: "std::size_t", shape: "vectori", type: "std::string") -> "std::size_t":
    return _fast._convertToFloat(pointer, shape, type)

def _freePointer(pointer: "std::size_t", type: "fast::DataType") -> "void":
    return _fast._freePointer(pointer, type)

_data_type_to_str = {
  TYPE_UINT8: 'u1',
  TYPE_INT8: 'i1',
  TYPE_UINT16: 'u2',
  TYPE_INT16: 'i2',
  TYPE_UINT32: 'u4',
  TYPE_INT32: 'i4',
  TYPE_FLOAT: 'f4',
}
_str_to_data_type = {value : key for (key, value) in _data_type_to_str.items()}

class RuntimeMeasurement(object):
    r"""
    A class for runtime measurement

    Collect multiple runtimes over time, and calculates running average, running standard deviation,
    sum, max, min etc.

    All measurements are in milliseconds
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string", warmupRounds: "int"=0, maximumSamples: "int"=-1):
        _fast.RuntimeMeasurement_swiginit(self, _fast.new_RuntimeMeasurement(name, warmupRounds, maximumSamples))

    def addSample(self, runtime: "double") -> "void":
        return _fast.RuntimeMeasurement_addSample(self, runtime)

    def getSum(self) -> "double":
        return _fast.RuntimeMeasurement_getSum(self)

    def getAverage(self) -> "double":
        return _fast.RuntimeMeasurement_getAverage(self)

    def getSamples(self) -> "unsigned int":
        return _fast.RuntimeMeasurement_getSamples(self)

    def getMax(self) -> "double":
        return _fast.RuntimeMeasurement_getMax(self)

    def getMin(self) -> "double":
        return _fast.RuntimeMeasurement_getMin(self)

    def getStdDeviation(self) -> "double":
        return _fast.RuntimeMeasurement_getStdDeviation(self)

    def _print(self) -> "std::string":
        return _fast.RuntimeMeasurement__print(self)

    def reset(self) -> "void":
        return _fast.RuntimeMeasurement_reset(self)
    __swig_destroy__ = _fast.delete_RuntimeMeasurement

# Register RuntimeMeasurement in _fast:
_fast.RuntimeMeasurement_swigregister(RuntimeMeasurement)

class RuntimeMeasurementsManager(object):
    r"""
    Manages multiple runtime measurements

    See also: RuntimeMeasurement
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::RuntimeMeasurementsManager >":
        return _fast.RuntimeMeasurementsManager_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.RuntimeMeasurementsManager_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RuntimeMeasurementsManager_getStaticNameOfClass()

    def setWarmupRounds(self, rounds: "int") -> "void":
        return _fast.RuntimeMeasurementsManager_setWarmupRounds(self, rounds)

    def getWarmupRounds(self) -> "int":
        return _fast.RuntimeMeasurementsManager_getWarmupRounds(self)

    def enable(self) -> "void":
        return _fast.RuntimeMeasurementsManager_enable(self)

    def disable(self) -> "void":
        return _fast.RuntimeMeasurementsManager_disable(self)

    def isEnabled(self) -> "bool":
        return _fast.RuntimeMeasurementsManager_isEnabled(self)

    def startCLTimer(self, name: "std::string", queue: "cl::CommandQueue") -> "void":
        return _fast.RuntimeMeasurementsManager_startCLTimer(self, name, queue)

    def stopCLTimer(self, name: "std::string", queue: "cl::CommandQueue") -> "void":
        return _fast.RuntimeMeasurementsManager_stopCLTimer(self, name, queue)

    def startRegularTimer(self, name: "std::string") -> "void":
        return _fast.RuntimeMeasurementsManager_startRegularTimer(self, name)

    def stopRegularTimer(self, name: "std::string") -> "void":
        return _fast.RuntimeMeasurementsManager_stopRegularTimer(self, name)

    def startNumberedCLTimer(self, name: "std::string", queue: "cl::CommandQueue") -> "void":
        return _fast.RuntimeMeasurementsManager_startNumberedCLTimer(self, name, queue)

    def stopNumberedCLTimer(self, name: "std::string", queue: "cl::CommandQueue") -> "void":
        return _fast.RuntimeMeasurementsManager_stopNumberedCLTimer(self, name, queue)

    def startNumberedRegularTimer(self, name: "std::string") -> "void":
        return _fast.RuntimeMeasurementsManager_startNumberedRegularTimer(self, name)

    def stopNumberedRegularTimer(self, name: "std::string") -> "void":
        return _fast.RuntimeMeasurementsManager_stopNumberedRegularTimer(self, name)

    def getTiming(self, name: "std::string") -> "fast::RuntimeMeasurement::pointer":
        return _fast.RuntimeMeasurementsManager_getTiming(self, name)

    def _print(self, name: "std::string") -> "void":
        return _fast.RuntimeMeasurementsManager__print(self, name)

    def printAll(self) -> "void":
        return _fast.RuntimeMeasurementsManager_printAll(self)
    __swig_destroy__ = _fast.delete_RuntimeMeasurementsManager

# Register RuntimeMeasurementsManager in _fast:
_fast.RuntimeMeasurementsManager_swigregister(RuntimeMeasurementsManager)

def RuntimeMeasurementsManager_New() -> "std::shared_ptr< fast::RuntimeMeasurementsManager >":
    return _fast.RuntimeMeasurementsManager_New()

def RuntimeMeasurementsManager_getStaticNameOfClass() -> "std::string":
    return _fast.RuntimeMeasurementsManager_getStaticNameOfClass()

class ReporterEnd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _fast.ReporterEnd_swiginit(self, _fast.new_ReporterEnd())
    __swig_destroy__ = _fast.delete_ReporterEnd

# Register ReporterEnd in _fast:
_fast.ReporterEnd_swigregister(ReporterEnd)

class Reporter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def end() -> "fast::ReporterEnd":
        return _fast.Reporter_end()

    @staticmethod
    def info() -> "fast::Reporter":
        return _fast.Reporter_info()

    @staticmethod
    def warning() -> "fast::Reporter":
        return _fast.Reporter_warning()

    @staticmethod
    def error() -> "fast::Reporter":
        return _fast.Reporter_error()
    INFO = _fast.Reporter_INFO
    WARNING = _fast.Reporter_WARNING
    ERROR = _fast.Reporter_ERROR
    NONE = _fast.Reporter_NONE
    COUT = _fast.Reporter_COUT
    LOG = _fast.Reporter_LOG

    def setType(self, arg2: "fast::Reporter::Type") -> "void":
        return _fast.Reporter_setType(self, arg2)

    def __init__(self, *args):
        _fast.Reporter_swiginit(self, _fast.new_Reporter(*args))

    def processEnd(self) -> "void":
        return _fast.Reporter_processEnd(self)

    def setReportMethod(self, *args) -> "void":
        return _fast.Reporter_setReportMethod(self, *args)

    @staticmethod
    def setGlobalReportMethod(*args) -> "void":
        return _fast.Reporter_setGlobalReportMethod(*args)

    @staticmethod
    def getGlobalReportMethod(type: "fast::Reporter::Type") -> "fast::Reporter::Method":
        return _fast.Reporter_getGlobalReportMethod(type)
    __swig_destroy__ = _fast.delete_Reporter

# Register Reporter in _fast:
_fast.Reporter_swigregister(Reporter)

def Reporter_end() -> "fast::ReporterEnd":
    return _fast.Reporter_end()

def Reporter_info() -> "fast::Reporter":
    return _fast.Reporter_info()

def Reporter_warning() -> "fast::Reporter":
    return _fast.Reporter_warning()

def Reporter_error() -> "fast::Reporter":
    return _fast.Reporter_error()

def Reporter_setGlobalReportMethod(*args) -> "void":
    return _fast.Reporter_setGlobalReportMethod(*args)

def Reporter_getGlobalReportMethod(type: "fast::Reporter::Type") -> "fast::Reporter::Method":
    return _fast.Reporter_getGlobalReportMethod(type)

class Object(object):
    r"""
    Base class for all FAST objects.

    This class has some functionality common to all FAST objects.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _fast.Object_swiginit(self, _fast.new_Object())
    __swig_destroy__ = _fast.delete_Object

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Object_getStaticNameOfClass()

    def getReporter(self) -> "fast::Reporter &":
        return _fast.Object_getReporter(self)

    def getRuntime(self, *args) -> "fast::RuntimeMeasurement::pointer":
        return _fast.Object_getRuntime(self, *args)

    def getAllRuntimes(self) -> "fast::RuntimeMeasurementsManager::pointer":
        return _fast.Object_getAllRuntimes(self)

    def getRuntimeManager(self) -> "fast::RuntimeMeasurementsManager::pointer":
        return _fast.Object_getRuntimeManager(self)

    def enableRuntimeMeasurements(self) -> "void":
        return _fast.Object_enableRuntimeMeasurements(self)

    def disableRuntimeMeasurements(self) -> "void":
        return _fast.Object_disableRuntimeMeasurements(self)

# Register Object in _fast:
_fast.Object_swigregister(Object)

def Object_getStaticNameOfClass() -> "std::string":
    return _fast.Object_getStaticNameOfClass()

class AttributeObject(Object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def loadAttributes(self) -> "void":
        return _fast.AttributeObject_loadAttributes(self)

    def getAttribute(self, id: "std::string") -> "std::shared_ptr< Attribute >":
        return _fast.AttributeObject_getAttribute(self, id)

    def getAttributes(self) -> "std::unordered_map< std::string,std::shared_ptr< Attribute > >":
        return _fast.AttributeObject_getAttributes(self)

    def setAttributes(self, attributes: "std::vector< std::shared_ptr< Attribute >,std::allocator< std::shared_ptr< fast::Attribute > > >") -> "void":
        return _fast.AttributeObject_setAttributes(self, attributes)

    def getNameOfClass(self) -> "std::string":
        return _fast.AttributeObject_getNameOfClass(self)
    __swig_destroy__ = _fast.delete_AttributeObject

# Register AttributeObject in _fast:
_fast.AttributeObject_swigregister(AttributeObject)

class DataObject(Object):
    r"""
    Abstract data object class.

    All data which should flow between process objects should derive from this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setMetadata(self, *args) -> "void":
        return _fast.DataObject_setMetadata(self, *args)

    def getMetadata(self, *args) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        return _fast.DataObject_getMetadata(self, *args)

    def deleteMetadata(self, name: "std::string") -> "void":
        return _fast.DataObject_deleteMetadata(self, name)

    def getTimestamp(self) -> "uint64_t":
        return _fast.DataObject_getTimestamp(self)

    def updateModifiedTimestamp(self) -> "void":
        return _fast.DataObject_updateModifiedTimestamp(self)
    __swig_destroy__ = _fast.delete_DataObject

    def getNameOfClass(self) -> "std::string":
        return _fast.DataObject_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DataObject_getStaticNameOfClass()

    def getCreationTimestamp(self) -> "uint64_t":
        return _fast.DataObject_getCreationTimestamp(self)

    def setCreationTimestamp(self, timestamp: "uint64_t") -> "void":
        return _fast.DataObject_setCreationTimestamp(self, timestamp)

    def setLastFrame(self, streamer: "std::string") -> "void":
        return _fast.DataObject_setLastFrame(self, streamer)

    def isLastFrame(self, *args) -> "bool":
        return _fast.DataObject_isLastFrame(self, *args)

    def removeLastFrame(self, streamer: "std::string") -> "void":
        return _fast.DataObject_removeLastFrame(self, streamer)

    def clearLastFrame(self) -> "void":
        return _fast.DataObject_clearLastFrame(self)

    def getLastFrame(self) -> "std::set< std::string >":
        return _fast.DataObject_getLastFrame(self)

    def setFrameData(self, *args) -> "void":
        return _fast.DataObject_setFrameData(self, *args)

    def hasFrameData(self, name: "std::string") -> "bool":
        return _fast.DataObject_hasFrameData(self, name)

    def getFrameData(self, *args) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        return _fast.DataObject_getFrameData(self, *args)

    def accessFinished(self) -> "void":
        return _fast.DataObject_accessFinished(self)

# Register DataObject in _fast:
_fast.DataObject_swigregister(DataObject)

def DataObject_getStaticNameOfClass() -> "std::string":
    return _fast.DataObject_getStaticNameOfClass()

class DataChannel(Object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def addFrame(self, data: "fast::DataObject::pointer") -> "void":
        r"""
        Add frame to the data channel. This call may block
        if the buffer is full.
        """
        return _fast.DataChannel_addFrame(self, data)

    def getSize(self) -> "int":
        r"""
        :rtype: int
        :return: the number of frames stored in this DataChannel
        """
        return _fast.DataChannel_getSize(self)

    def setMaximumNumberOfFrames(self, frames: "uint") -> "void":
        r"""Set the maximum nr of frames that can be stored in this data channel"""
        return _fast.DataChannel_setMaximumNumberOfFrames(self, frames)

    def getMaximumNumberOfFrames(self) -> "int":
        return _fast.DataChannel_getMaximumNumberOfFrames(self)

    def stop(self, *args, **kwargs) -> "void":
        r"""
        This will unblock if this DataChannel is currently blocking. Used to stop a pipeline.
        :param Error: message to supply.
        """
        return _fast.DataChannel_stop(self, *args, **kwargs)

    def hasCurrentData(self) -> "bool":
        return _fast.DataChannel_hasCurrentData(self)

    def getFrame(self) -> "fast::DataObject::pointer":
        r"""Get current frame, throws if current frame is not available."""
        return _fast.DataChannel_getFrame(self)

    def getProcessObject(self) -> "std::shared_ptr< fast::ProcessObject >":
        return _fast.DataChannel_getProcessObject(self)

    def setProcessObject(self, po: "std::shared_ptr< fast::ProcessObject >") -> "void":
        return _fast.DataChannel_setProcessObject(self, po)

    def getNextFrame(self) -> "std::shared_ptr< fast::DataObject >":
        r"""
        Get next frame in the data channel.
        It will block until the frame is available.
        """
        val = _fast.DataChannel_getNextFrame(self)

        className = val.getNameOfClass()
        val = eval(className + '.fromDataObject')(val)


        return val

    __swig_destroy__ = _fast.delete_DataChannel

# Register DataChannel in _fast:
_fast.DataChannel_swigregister(DataChannel)

DEVICE_TYPE_ANY = _fast.DEVICE_TYPE_ANY
DEVICE_TYPE_GPU = _fast.DEVICE_TYPE_GPU
DEVICE_TYPE_CPU = _fast.DEVICE_TYPE_CPU
DEVICE_PLATFORM_ANY = _fast.DEVICE_PLATFORM_ANY
DEVICE_PLATFORM_AMD = _fast.DEVICE_PLATFORM_AMD
DEVICE_PLATFORM_NVIDIA = _fast.DEVICE_PLATFORM_NVIDIA
DEVICE_PLATFORM_INTEL = _fast.DEVICE_PLATFORM_INTEL
DEVICE_PLATFORM_APPLE = _fast.DEVICE_PLATFORM_APPLE
DEVICE_PLATFORM_POCL = _fast.DEVICE_PLATFORM_POCL
DEVICE_PLATFORM_UNKNOWN = _fast.DEVICE_PLATFORM_UNKNOWN
DEVICE_CAPABILITY_OPENGL_INTEROP = _fast.DEVICE_CAPABILITY_OPENGL_INTEROP
DEVICE_PREFERENCE_NONE = _fast.DEVICE_PREFERENCE_NONE
DEVICE_PREFERENCE_NOT_CONNECTED_TO_SCREEN = _fast.DEVICE_PREFERENCE_NOT_CONNECTED_TO_SCREEN
DEVICE_PREFERENCE_COMPUTE_UNITS = _fast.DEVICE_PREFERENCE_COMPUTE_UNITS
DEVICE_PREFERENCE_GLOBAL_MEMORY = _fast.DEVICE_PREFERENCE_GLOBAL_MEMORY
class DeviceCriteria(object):
    r"""Class used to set up a set of criteria for choosing devices"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _fast.DeviceCriteria_swiginit(self, _fast.new_DeviceCriteria())

    def setPlatformCriteria(self, platform: "fast::DevicePlatform") -> "void":
        return _fast.DeviceCriteria_setPlatformCriteria(self, platform)

    def setCapabilityCriteria(self, capability: "fast::DeviceCapability") -> "void":
        return _fast.DeviceCriteria_setCapabilityCriteria(self, capability)

    def setTypeCriteria(self, typeCriteria: "fast::DeviceType") -> "void":
        return _fast.DeviceCriteria_setTypeCriteria(self, typeCriteria)

    def setDevicePreference(self, preference: "fast::DevicePreference") -> "void":
        return _fast.DeviceCriteria_setDevicePreference(self, preference)

    def setDeviceCountCriteria(self, *args) -> "void":
        return _fast.DeviceCriteria_setDeviceCountCriteria(self, *args)

    def getCapabilityCriteria(self) -> "std::vector< fast::DeviceCapability,std::allocator< fast::DeviceCapability > > const &":
        return _fast.DeviceCriteria_getCapabilityCriteria(self)

    def getPlatformCriteria(self) -> "fast::DevicePlatform":
        return _fast.DeviceCriteria_getPlatformCriteria(self)

    def getTypeCriteria(self) -> "fast::DeviceType":
        return _fast.DeviceCriteria_getTypeCriteria(self)

    def getDevicePreference(self) -> "fast::DevicePreference":
        return _fast.DeviceCriteria_getDevicePreference(self)

    def getDeviceCountMinCriteria(self) -> "unsigned int":
        return _fast.DeviceCriteria_getDeviceCountMinCriteria(self)

    def getDeviceCountMaxCriteria(self) -> "unsigned int":
        return _fast.DeviceCriteria_getDeviceCountMaxCriteria(self)

    def hasCapabilityCriteria(self, capability: "fast::DeviceCapability") -> "bool":
        return _fast.DeviceCriteria_hasCapabilityCriteria(self, capability)
    __swig_destroy__ = _fast.delete_DeviceCriteria

# Register DeviceCriteria in _fast:
_fast.DeviceCriteria_swigregister(DeviceCriteria)

class ExecutionDevice(Object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def isHost(self) -> "bool":
        return _fast.ExecutionDevice_isHost(self)
    __swig_destroy__ = _fast.delete_ExecutionDevice

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ExecutionDevice_getStaticNameOfClass()

    def __init__(self):
        _fast.ExecutionDevice_swiginit(self, _fast.new_ExecutionDevice())

# Register ExecutionDevice in _fast:
_fast.ExecutionDevice_swigregister(ExecutionDevice)

def ExecutionDevice_getStaticNameOfClass() -> "std::string":
    return _fast.ExecutionDevice_getStaticNameOfClass()

class Host(ExecutionDevice):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def getInstance() -> "fast::Host::pointer":
        return _fast.Host_getInstance()

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Host_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_Host

# Register Host in _fast:
_fast.Host_swigregister(Host)

def Host_getInstance() -> "fast::Host::pointer":
    return _fast.Host_getInstance()

def Host_getStaticNameOfClass() -> "std::string":
    return _fast.Host_getStaticNameOfClass()

PLATFORM_VENDOR_APPLE = _fast.PLATFORM_VENDOR_APPLE
PLATFORM_VENDOR_AMD = _fast.PLATFORM_VENDOR_AMD
PLATFORM_VENDOR_INTEL = _fast.PLATFORM_VENDOR_INTEL
PLATFORM_VENDOR_NVIDIA = _fast.PLATFORM_VENDOR_NVIDIA
PLATFORM_VENDOR_POCL = _fast.PLATFORM_VENDOR_POCL
PLATFORM_VENDOR_UNKNOWN = _fast.PLATFORM_VENDOR_UNKNOWN
DEVICE_VENDOR_AMD = _fast.DEVICE_VENDOR_AMD
DEVICE_VENDOR_INTEL = _fast.DEVICE_VENDOR_INTEL
DEVICE_VENDOR_NVIDIA = _fast.DEVICE_VENDOR_NVIDIA
DEVICE_VENDOR_UKNOWN = _fast.DEVICE_VENDOR_UKNOWN
class OpenCLDevice(ExecutionDevice):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::OpenCLDevice >":
        return _fast.OpenCLDevice_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.OpenCLDevice_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.OpenCLDevice_getStaticNameOfClass()

    def getCommandQueue(self) -> "cl::CommandQueue":
        return _fast.OpenCLDevice_getCommandQueue(self)

    def createProgramFromSource(self, *args) -> "int":
        return _fast.OpenCLDevice_createProgramFromSource(self, *args)

    def createProgramFromString(self, *args, **kwargs) -> "int":
        return _fast.OpenCLDevice_createProgramFromString(self, *args, **kwargs)

    def createProgramFromSourceWithName(self, *args) -> "int":
        return _fast.OpenCLDevice_createProgramFromSourceWithName(self, *args)

    def createProgramFromStringWithName(self, *args, **kwargs) -> "int":
        return _fast.OpenCLDevice_createProgramFromStringWithName(self, *args, **kwargs)

    def getProgram(self, *args) -> "cl::Program":
        return _fast.OpenCLDevice_getProgram(self, *args)

    def hasProgram(self, name: "std::string") -> "bool":
        return _fast.OpenCLDevice_hasProgram(self, name)

    def isImageFormatSupported(self, order: "cl_channel_order", type: "cl_channel_type", imageType: "cl_mem_object_type") -> "bool":
        return _fast.OpenCLDevice_isImageFormatSupported(self, order, type, imageType)

    def isOpenGLInteropSupported(self) -> "bool":
        return _fast.OpenCLDevice_isOpenGLInteropSupported(self)

    def getQueue(self, i: "unsigned int") -> "cl::CommandQueue":
        return _fast.OpenCLDevice_getQueue(self, i)

    def getContext(self) -> "cl::Context":
        return _fast.OpenCLDevice_getContext(self)

    def getPlatform(self) -> "cl::Platform":
        return _fast.OpenCLDevice_getPlatform(self)

    def __init__(self, devices: "std::vector< cl::Device,std::allocator< cl::Device > >", glContext: "unsigned long *"=None):
        _fast.OpenCLDevice_swiginit(self, _fast.new_OpenCLDevice(devices, glContext))

    def getGLContext(self) -> "unsigned long *":
        return _fast.OpenCLDevice_getGLContext(self)

    def getName(self) -> "std::string":
        return _fast.OpenCLDevice_getName(self)

    def getPlatformVendor(self) -> "fast::OpenCLPlatformVendor":
        return _fast.OpenCLDevice_getPlatformVendor(self)

    def isWritingTo3DTexturesSupported(self) -> "bool":
        return _fast.OpenCLDevice_isWritingTo3DTexturesSupported(self)

    def getRunTimeMeasurementManager(self) -> "fast::RuntimeMeasurementsManager::pointer":
        return _fast.OpenCLDevice_getRunTimeMeasurementManager(self)
    __swig_destroy__ = _fast.delete_OpenCLDevice

# Register OpenCLDevice in _fast:
_fast.OpenCLDevice_swigregister(OpenCLDevice)

def OpenCLDevice_New() -> "std::shared_ptr< fast::OpenCLDevice >":
    return _fast.OpenCLDevice_New()

def OpenCLDevice_getStaticNameOfClass() -> "std::string":
    return _fast.OpenCLDevice_getStaticNameOfClass()

ATTRIBUTE_TYPE_STRING = _fast.ATTRIBUTE_TYPE_STRING
ATTRIBUTE_TYPE_FLOAT = _fast.ATTRIBUTE_TYPE_FLOAT
ATTRIBUTE_TYPE_INTEGER = _fast.ATTRIBUTE_TYPE_INTEGER
ATTRIBUTE_TYPE_BOOLEAN = _fast.ATTRIBUTE_TYPE_BOOLEAN
class AttributeValue(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _fast.delete_AttributeValue

    def __init__(self):
        _fast.AttributeValue_swiginit(self, _fast.new_AttributeValue())

# Register AttributeValue in _fast:
_fast.AttributeValue_swigregister(AttributeValue)

class AttributeValueString(AttributeValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, value: "std::string"):
        _fast.AttributeValueString_swiginit(self, _fast.new_AttributeValueString(value))

    def get(self) -> "std::string":
        return _fast.AttributeValueString_get(self)
    __swig_destroy__ = _fast.delete_AttributeValueString

# Register AttributeValueString in _fast:
_fast.AttributeValueString_swigregister(AttributeValueString)

class AttributeValueFloat(AttributeValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, value: "float"):
        _fast.AttributeValueFloat_swiginit(self, _fast.new_AttributeValueFloat(value))

    def get(self) -> "float":
        return _fast.AttributeValueFloat_get(self)
    __swig_destroy__ = _fast.delete_AttributeValueFloat

# Register AttributeValueFloat in _fast:
_fast.AttributeValueFloat_swigregister(AttributeValueFloat)

class AttributeValueInteger(AttributeValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, value: "int"):
        _fast.AttributeValueInteger_swiginit(self, _fast.new_AttributeValueInteger(value))

    def get(self) -> "int":
        return _fast.AttributeValueInteger_get(self)
    __swig_destroy__ = _fast.delete_AttributeValueInteger

# Register AttributeValueInteger in _fast:
_fast.AttributeValueInteger_swigregister(AttributeValueInteger)

class AttributeValueBoolean(AttributeValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, value: "bool"):
        _fast.AttributeValueBoolean_swiginit(self, _fast.new_AttributeValueBoolean(value))

    def get(self) -> "bool":
        return _fast.AttributeValueBoolean_get(self)
    __swig_destroy__ = _fast.delete_AttributeValueBoolean

# Register AttributeValueBoolean in _fast:
_fast.AttributeValueBoolean_swigregister(AttributeValueBoolean)

class Attribute(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, id: "std::string", name: "std::string", description: "std::string", type: "fast::AttributeType"):
        _fast.Attribute_swiginit(self, _fast.new_Attribute(id, name, description, type))

    def setValue(self, value: "std::shared_ptr< fast::AttributeValue >") -> "void":
        return _fast.Attribute_setValue(self, value)

    def getValue(self) -> "std::shared_ptr< fast::AttributeValue >":
        return _fast.Attribute_getValue(self)

    def setValues(self, values: "std::vector< std::shared_ptr< fast::AttributeValue >,std::allocator< std::shared_ptr< fast::AttributeValue > > >") -> "void":
        return _fast.Attribute_setValues(self, values)

    def getValues(self) -> "std::vector< std::shared_ptr< fast::AttributeValue >,std::allocator< std::shared_ptr< fast::AttributeValue > > >":
        return _fast.Attribute_getValues(self)

    def getName(self) -> "std::string":
        return _fast.Attribute_getName(self)

    def getID(self) -> "std::string":
        return _fast.Attribute_getID(self)

    def getType(self) -> "fast::AttributeType":
        return _fast.Attribute_getType(self)

    def parseInput(self, input: "std::string") -> "void":
        return _fast.Attribute_parseInput(self, input)
    __swig_destroy__ = _fast.delete_Attribute

# Register Attribute in _fast:
_fast.Attribute_swigregister(Attribute)

class ProcessObject(AttributeObject):
    r"""Abstract base class for all process objects"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def update(self, executeToken: "int"=-1) -> "void":
        r"""
        Update/Run the pipeline up to this process object.

        Do update on this PO, which will trigger update on all connected POs
        thus running the entire pipeline.

        An optional executeToken can be used to synchronize updating to avoid
        duplicate execution for the same frames when using streaming.
        Increment the token for every timestep with a positive value.

        :type executeToken: int
        :param executeToken: Negative value means that the execute token is disabled.
        """
        return _fast.ProcessObject_update(self, executeToken)

    def setMainDevice(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.ProcessObject_setMainDevice(self, device)

    def setMainDeviceCriteria(self, citeria: "DeviceCriteria") -> "void":
        return _fast.ProcessObject_setMainDeviceCriteria(self, citeria)

    def getMainDevice(self) -> "fast::ExecutionDevice::pointer":
        return _fast.ProcessObject_getMainDevice(self)

    def setDevice(self, deviceNumber: "uint", device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.ProcessObject_setDevice(self, deviceNumber, device)

    def setDeviceCriteria(self, deviceNumber: "uint", criteria: "DeviceCriteria") -> "void":
        return _fast.ProcessObject_setDeviceCriteria(self, deviceNumber, criteria)

    def getOutputPort(self, portID: "uint"=0) -> "fast::DataChannel::pointer":
        return _fast.ProcessObject_getOutputPort(self, portID)

    def getInputPort(self, portID: "uint"=0) -> "fast::DataChannel::pointer":
        return _fast.ProcessObject_getInputPort(self, portID)

    def setInputConnection(self, *args) -> "void":
        return _fast.ProcessObject_setInputConnection(self, *args)

    def setInputData(self, *args) -> "void":
        return _fast.ProcessObject_setInputData(self, *args)

    def getOutputData(self, portID: "uint"=0) -> "fast::DataObject::pointer":
        r"""
        Get current output data for a given port
        :type portID: int
        :param portID:
        :rtype: :py:class:`DataObject`
        :return: 
        """
        val = _fast.ProcessObject_getOutputData(self, portID)

        className = val.getNameOfClass()
        val = eval(className + '.fromDataObject')(val)


        return val


    def getNrOfInputConnections(self) -> "int":
        return _fast.ProcessObject_getNrOfInputConnections(self)

    def getNrOfOutputPorts(self) -> "int":
        return _fast.ProcessObject_getNrOfOutputPorts(self)

    def getNrOfInputPorts(self) -> "int":
        return _fast.ProcessObject_getNrOfInputPorts(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ProcessObject_getStaticNameOfClass()

    def stopPipeline(self) -> "void":
        r"""Stop a pipeline."""
        return _fast.ProcessObject_stopPipeline(self)

    def setModified(self, modified: "bool") -> "void":
        r"""
        Mark this process object as modified or not.
        A modified PO will execute next time it is updated.

        :type modified: boolean
        :param modified:
        """
        return _fast.ProcessObject_setModified(self, modified)

    def runAndGetOutputData(self, portID: "uint"=0, executeToken: "int64_t"=-1) -> "std::shared_ptr< fast::DataObject >":
        val = _fast.ProcessObject_runAndGetOutputData(self, portID, executeToken)

        className = val.getNameOfClass()
        val = eval(className + '.fromDataObject')(val)


        return val


    def run(self, executeToken: "int64_t"=-1) -> "void":
        return _fast.ProcessObject_run(self, executeToken)

    def connect(self, *args) -> "std::shared_ptr< fast::ProcessObject >":
        return _fast.ProcessObject_connect(self, *args)

    def getLastExecuteToken(self) -> "int":
        return _fast.ProcessObject_getLastExecuteToken(self)

    def setExecuteOnLastFrameOnly(self, executeOnLastFrameOnly: "bool") -> "void":
        r"""
        If set to true, this will only trigger this PO to execute if one of its inputs is marked as being "last frame".
        This is useful if one want to export the results of a PatchStitcher, but only when it is complete.

        :type executeOnLastFrameOnly: boolean
        :param executeOnLastFrameOnly:
        """
        return _fast.ProcessObject_setExecuteOnLastFrameOnly(self, executeOnLastFrameOnly)

    def getExecuteOnLastFrameOnly(self) -> "bool":
        return _fast.ProcessObject_getExecuteOnLastFrameOnly(self)

    def attributesToString(self) -> "std::string":
        r"""
        Convert attributes to string
        :rtype: string
        :return: 
        """
        return _fast.ProcessObject_attributesToString(self)

    def hasReceivedLastFrameFlag(self) -> "bool":
        r"""
        Whether this PO has received input data with last frame flag set
        :rtype: boolean
        :return: 
        """
        return _fast.ProcessObject_hasReceivedLastFrameFlag(self)

    def getDataStream(self):
        return DataStream(self)

    __swig_destroy__ = _fast.delete_ProcessObject

# Register ProcessObject in _fast:
_fast.ProcessObject_swigregister(ProcessObject)

def ProcessObject_getStaticNameOfClass() -> "std::string":
    return _fast.ProcessObject_getStaticNameOfClass()


def downloadTestDataIfNotExists(*args, **kwargs) -> "void":
    return _fast.downloadTestDataIfNotExists(*args, **kwargs)
class Config(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def getTestDataPath() -> "std::string":
        return _fast.Config_getTestDataPath()

    @staticmethod
    def getKernelSourcePath() -> "std::string":
        return _fast.Config_getKernelSourcePath()

    @staticmethod
    def getKernelBinaryPath() -> "std::string":
        return _fast.Config_getKernelBinaryPath()

    @staticmethod
    def getDocumentationPath() -> "std::string":
        return _fast.Config_getDocumentationPath()

    @staticmethod
    def getPipelinePath() -> "std::string":
        return _fast.Config_getPipelinePath()

    @staticmethod
    def getLibraryPath() -> "std::string":
        return _fast.Config_getLibraryPath()

    @staticmethod
    def getQtPluginsPath() -> "std::string":
        return _fast.Config_getQtPluginsPath()

    @staticmethod
    def getVisualization() -> "bool":
        return _fast.Config_getVisualization()

    @staticmethod
    def setTestDataPath(path: "std::string") -> "void":
        return _fast.Config_setTestDataPath(path)

    @staticmethod
    def setKernelSourcePath(path: "std::string") -> "void":
        return _fast.Config_setKernelSourcePath(path)

    @staticmethod
    def setKernelBinaryPath(path: "std::string") -> "void":
        return _fast.Config_setKernelBinaryPath(path)

    @staticmethod
    def setDocumentationPath(path: "std::string") -> "void":
        return _fast.Config_setDocumentationPath(path)

    @staticmethod
    def setPipelinePath(path: "std::string") -> "void":
        return _fast.Config_setPipelinePath(path)

    @staticmethod
    def setConfigFilename(filename: "std::string") -> "void":
        return _fast.Config_setConfigFilename(filename)

    @staticmethod
    def setBasePath(path: "std::string") -> "void":
        return _fast.Config_setBasePath(path)

    @staticmethod
    def setVisualization(visualization: "bool") -> "void":
        return _fast.Config_setVisualization(visualization)

    @staticmethod
    def setTerminateHandlerDisabled(disabled: "bool") -> "void":
        return _fast.Config_setTerminateHandlerDisabled(disabled)

    @staticmethod
    def getTerminateHandlerDisabled() -> "bool":
        return _fast.Config_getTerminateHandlerDisabled()

    def __init__(self):
        _fast.Config_swiginit(self, _fast.new_Config())

# Register Config in _fast:
_fast.Config_swigregister(Config)

def Config_getTestDataPath() -> "std::string":
    return _fast.Config_getTestDataPath()

def Config_getKernelSourcePath() -> "std::string":
    return _fast.Config_getKernelSourcePath()

def Config_getKernelBinaryPath() -> "std::string":
    return _fast.Config_getKernelBinaryPath()

def Config_getDocumentationPath() -> "std::string":
    return _fast.Config_getDocumentationPath()

def Config_getPipelinePath() -> "std::string":
    return _fast.Config_getPipelinePath()

def Config_getLibraryPath() -> "std::string":
    return _fast.Config_getLibraryPath()

def Config_getQtPluginsPath() -> "std::string":
    return _fast.Config_getQtPluginsPath()

def Config_getVisualization() -> "bool":
    return _fast.Config_getVisualization()

def Config_setTestDataPath(path: "std::string") -> "void":
    return _fast.Config_setTestDataPath(path)

def Config_setKernelSourcePath(path: "std::string") -> "void":
    return _fast.Config_setKernelSourcePath(path)

def Config_setKernelBinaryPath(path: "std::string") -> "void":
    return _fast.Config_setKernelBinaryPath(path)

def Config_setDocumentationPath(path: "std::string") -> "void":
    return _fast.Config_setDocumentationPath(path)

def Config_setPipelinePath(path: "std::string") -> "void":
    return _fast.Config_setPipelinePath(path)

def Config_setConfigFilename(filename: "std::string") -> "void":
    return _fast.Config_setConfigFilename(filename)

def Config_setBasePath(path: "std::string") -> "void":
    return _fast.Config_setBasePath(path)

def Config_setVisualization(visualization: "bool") -> "void":
    return _fast.Config_setVisualization(visualization)

def Config_setTerminateHandlerDisabled(disabled: "bool") -> "void":
    return _fast.Config_setTerminateHandlerDisabled(disabled)

def Config_getTerminateHandlerDisabled() -> "bool":
    return _fast.Config_getTerminateHandlerDisabled()

ACCESS_READ = _fast.ACCESS_READ
ACCESS_READ_WRITE = _fast.ACCESS_READ_WRITE
class Color(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _fast.Color_swiginit(self, _fast.new_Color(*args))

    def isNull(self) -> "bool":
        r"""
        Whether the color is set or not
        :rtype: boolean
        :return: 
        """
        return _fast.Color_isNull(self)

    def hasOpacity(self) -> "bool":
        return _fast.Color_hasOpacity(self)

    @staticmethod
    def fromString(str: "std::string") -> "fast::Color":
        return _fast.Color_fromString(str)

    def asVector(self) -> "Vector3f":
        return _fast.Color_asVector(self)

    def getRedValue(self) -> "float":
        return _fast.Color_getRedValue(self)

    def getGreenValue(self) -> "float":
        return _fast.Color_getGreenValue(self)

    def getBlueValue(self) -> "float":
        return _fast.Color_getBlueValue(self)

    def getOpacity(self) -> "float":
        return _fast.Color_getOpacity(self)

    def getName(self) -> "std::string":
        return _fast.Color_getName(self)

    @staticmethod
    def Null() -> "fast::Color":
        r"""
        The color Null means NO COLOR, or not set, resulting in isNull() returning true
        :rtype: :py:class:`Color`
        :return: 
        """
        return _fast.Color_Null()

    @staticmethod
    def Red() -> "fast::Color":
        return _fast.Color_Red()

    @staticmethod
    def Green() -> "fast::Color":
        return _fast.Color_Green()

    @staticmethod
    def Blue() -> "fast::Color":
        return _fast.Color_Blue()

    @staticmethod
    def White() -> "fast::Color":
        return _fast.Color_White()

    @staticmethod
    def Black() -> "fast::Color":
        return _fast.Color_Black()

    @staticmethod
    def Yellow() -> "fast::Color":
        return _fast.Color_Yellow()

    @staticmethod
    def Magenta() -> "fast::Color":
        return _fast.Color_Magenta()

    @staticmethod
    def Cyan() -> "fast::Color":
        return _fast.Color_Cyan()

    @staticmethod
    def Brown() -> "fast::Color":
        return _fast.Color_Brown()
    __swig_destroy__ = _fast.delete_Color

# Register Color in _fast:
_fast.Color_swigregister(Color)

def Color_fromString(str: "std::string") -> "fast::Color":
    return _fast.Color_fromString(str)

def Color_Null() -> "fast::Color":
    r"""
    The color Null means NO COLOR, or not set, resulting in isNull() returning true
    :rtype: :py:class:`Color`
    :return: 
    """
    return _fast.Color_Null()

def Color_Red() -> "fast::Color":
    return _fast.Color_Red()

def Color_Green() -> "fast::Color":
    return _fast.Color_Green()

def Color_Blue() -> "fast::Color":
    return _fast.Color_Blue()

def Color_White() -> "fast::Color":
    return _fast.Color_White()

def Color_Black() -> "fast::Color":
    return _fast.Color_Black()

def Color_Yellow() -> "fast::Color":
    return _fast.Color_Yellow()

def Color_Magenta() -> "fast::Color":
    return _fast.Color_Magenta()

def Color_Cyan() -> "fast::Color":
    return _fast.Color_Cyan()

def Color_Brown() -> "fast::Color":
    return _fast.Color_Brown()

class Transform(DataObject):
    r"""
    Data object for a 3D affine transform.

    The 3D transform is stored as an Eigen Affine3f object (4x4 32 bit float matrix)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.Transform_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Transform_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Transform >":
        return _fast.Transform_fromDataObject(object)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::Transform >":
        return _fast.Transform_create(*args, **kwargs)

    def get(self) -> "Affine3f":
        return _fast.Transform_get(self)

    def set(self, transform: "Affine3f") -> "void":
        return _fast.Transform_set(self, transform)

    def getMatrix(self) -> "Matrix4f":
        return _fast.Transform_getMatrix(self)

    def setMatrix(self, matrix: "Matrix4f") -> "void":
        return _fast.Transform_setMatrix(self, matrix)

    def setTranslation(self, translation: "Vector3f") -> "void":
        return _fast.Transform_setTranslation(self, translation)

    def getTranslation(self) -> "Vector3f":
        return _fast.Transform_getTranslation(self)

    def addTranslation(self, translation: "Vector3f") -> "void":
        return _fast.Transform_addTranslation(self, translation)

    def setRotation(self, angles: "float", axis: "Vector3f") -> "void":
        return _fast.Transform_setRotation(self, angles, axis)

    def addRotation(self, angles: "float", axis: "Vector3f") -> "void":
        return _fast.Transform_addRotation(self, angles, axis)

    def getRotation(self) -> "AngleAxisf":
        return _fast.Transform_getRotation(self)

    def setScaling(self, scaling: "Vector3f") -> "void":
        return _fast.Transform_setScaling(self, scaling)

    def addScaling(self, scaling: "Vector3f") -> "void":
        return _fast.Transform_addScaling(self, scaling)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.Transform_free(self, device)

    def freeAll(self) -> "void":
        return _fast.Transform_freeAll(self)
    __swig_destroy__ = _fast.delete_Transform

# Register Transform in _fast:
_fast.Transform_swigregister(Transform)

def Transform_getStaticNameOfClass() -> "std::string":
    return _fast.Transform_getStaticNameOfClass()

def Transform_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Transform >":
    return _fast.Transform_fromDataObject(object)

def Transform_create(*args, **kwargs) -> "std::shared_ptr< fast::Transform >":
    return _fast.Transform_create(*args, **kwargs)

class SpatialDataObject(DataObject):
    r"""
    Abstract base class for all spatial data objects

    Spatial data objects are data which have a location in 2D/3D space.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setTransform(self, transform: "fast::Transform::pointer", disconnectParentSceneGraphNode: "bool"=False) -> "void":
        return _fast.SpatialDataObject_setTransform(self, transform, disconnectParentSceneGraphNode)

    def getTransform(self, getFullTransform: "bool"=True) -> "fast::Transform::pointer":
        return _fast.SpatialDataObject_getTransform(self, getFullTransform)

    def getBoundingBox(self) -> "DataBoundingBox":
        return _fast.SpatialDataObject_getBoundingBox(self)

    def getTransformedBoundingBox(self) -> "DataBoundingBox":
        return _fast.SpatialDataObject_getTransformedBoundingBox(self)

    def getSceneGraphNode(self) -> "SceneGraphNode::pointer":
        return _fast.SpatialDataObject_getSceneGraphNode(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SpatialDataObject_getStaticNameOfClass()
    __swig_destroy__ = _fast.delete_SpatialDataObject

# Register SpatialDataObject in _fast:
_fast.SpatialDataObject_swigregister(SpatialDataObject)

def SpatialDataObject_getStaticNameOfClass() -> "std::string":
    return _fast.SpatialDataObject_getStaticNameOfClass()

class OpenCLImageAccess(object):
    r"""OpenCL image access to Image"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get(self) -> "cl::Image *":
        return _fast.OpenCLImageAccess_get(self)

    def get2DImage(self) -> "cl::Image2D *":
        return _fast.OpenCLImageAccess_get2DImage(self)

    def get3DImage(self) -> "cl::Image3D *":
        return _fast.OpenCLImageAccess_get3DImage(self)

    def __init__(self, *args):
        _fast.OpenCLImageAccess_swiginit(self, _fast.new_OpenCLImageAccess(*args))

    def release(self) -> "void":
        return _fast.OpenCLImageAccess_release(self)
    __swig_destroy__ = _fast.delete_OpenCLImageAccess

# Register OpenCLImageAccess in _fast:
_fast.OpenCLImageAccess_swigregister(OpenCLImageAccess)

class OpenCLBufferAccess(object):
    r"""OpenCL buffer access to Image"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get(self) -> "cl::Buffer *":
        return _fast.OpenCLBufferAccess_get(self)

    def __init__(self, buffer: "cl::Buffer *", dataObject: "std::shared_ptr< fast::DataObject >"):
        _fast.OpenCLBufferAccess_swiginit(self, _fast.new_OpenCLBufferAccess(buffer, dataObject))

    def release(self) -> "void":
        return _fast.OpenCLBufferAccess_release(self)
    __swig_destroy__ = _fast.delete_OpenCLBufferAccess

# Register OpenCLBufferAccess in _fast:
_fast.OpenCLBufferAccess_swigregister(OpenCLBufferAccess)

class ImageAccess(object):
    r"""CPU access to Image data"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, data: "void *", image: "std::shared_ptr< fast::Image >"):
        _fast.ImageAccess_swiginit(self, _fast.new_ImageAccess(data, image))

    def get(self) -> "void *":
        return _fast.ImageAccess_get(self)

    def getScalar(self, *args) -> "float":
        return _fast.ImageAccess_getScalar(self, *args)

    def getVector(self, position: "VectorXi") -> "Vector4f":
        return _fast.ImageAccess_getVector(self, position)

    def setScalar(self, *args) -> "void":
        return _fast.ImageAccess_setScalar(self, *args)

    def setVector(self, *args) -> "void":
        return _fast.ImageAccess_setVector(self, *args)

    def release(self) -> "void":
        return _fast.ImageAccess_release(self)
    __swig_destroy__ = _fast.delete_ImageAccess

# Register ImageAccess in _fast:
_fast.ImageAccess_swigregister(ImageAccess)

class BoundingBoxSetAccess(object):
    r"""CPU access to BoundingBoxSet"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, coordinates: "vectorf", lines: "vectorui", labels: "vectoruc", scores: "vectorf", m_minimumSize: "float *", bbset: "std::shared_ptr< fast::BoundingBoxSet >"):
        _fast.BoundingBoxSetAccess_swiginit(self, _fast.new_BoundingBoxSetAccess(coordinates, lines, labels, scores, m_minimumSize, bbset))

    def addBoundingBox(self, *args) -> "void":
        return _fast.BoundingBoxSetAccess_addBoundingBox(self, *args)

    def getCoordinates(self) -> "std::vector< float,std::allocator< float > >":
        return _fast.BoundingBoxSetAccess_getCoordinates(self)

    def getLines(self) -> "std::vector< uint,std::allocator< uint > >":
        return _fast.BoundingBoxSetAccess_getLines(self)

    def getLabels(self) -> "std::vector< uchar,std::allocator< uchar > >":
        return _fast.BoundingBoxSetAccess_getLabels(self)

    def getScores(self) -> "std::vector< float,std::allocator< float > >":
        return _fast.BoundingBoxSetAccess_getScores(self)

    def addBoundingBoxes(self, coordinates: "vectorf", lines: "vectorui", labels: "vectoruc", scores: "vectorf", minimumSize: "float") -> "void":
        return _fast.BoundingBoxSetAccess_addBoundingBoxes(self, coordinates, lines, labels, scores, minimumSize)

    def release(self) -> "void":
        return _fast.BoundingBoxSetAccess_release(self)
    __swig_destroy__ = _fast.delete_BoundingBoxSetAccess

# Register BoundingBoxSetAccess in _fast:
_fast.BoundingBoxSetAccess_swigregister(BoundingBoxSetAccess)

class BoundingBoxSetOpenGLAccess(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, m_coordinatesVBO: "GLuint", m_linesEBO: "GLuint", m_labels: "GLuint", bbset: "std::shared_ptr< fast::BoundingBoxSet >"):
        _fast.BoundingBoxSetOpenGLAccess_swiginit(self, _fast.new_BoundingBoxSetOpenGLAccess(m_coordinatesVBO, m_linesEBO, m_labels, bbset))

    def getCoordinateVBO(self) -> "GLuint":
        return _fast.BoundingBoxSetOpenGLAccess_getCoordinateVBO(self)

    def getLinesEBO(self) -> "GLuint":
        return _fast.BoundingBoxSetOpenGLAccess_getLinesEBO(self)

    def getLabelVBO(self) -> "GLuint":
        return _fast.BoundingBoxSetOpenGLAccess_getLabelVBO(self)

    def release(self) -> "void":
        return _fast.BoundingBoxSetOpenGLAccess_release(self)
    __swig_destroy__ = _fast.delete_BoundingBoxSetOpenGLAccess

# Register BoundingBoxSetOpenGLAccess in _fast:
_fast.BoundingBoxSetOpenGLAccess_swigregister(BoundingBoxSetOpenGLAccess)

class OpenGLTextureAccess(object):
    r"""OpenGL texture access to Image"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get(self) -> "uint":
        return _fast.OpenGLTextureAccess_get(self)

    def __init__(self, textureID: "uint", object: "std::shared_ptr< fast::Image >"):
        _fast.OpenGLTextureAccess_swiginit(self, _fast.new_OpenGLTextureAccess(textureID, object))

    def release(self) -> "void":
        return _fast.OpenGLTextureAccess_release(self)
    __swig_destroy__ = _fast.delete_OpenGLTextureAccess

# Register OpenGLTextureAccess in _fast:
_fast.OpenGLTextureAccess_swigregister(OpenGLTextureAccess)

class Plane(object):
    r"""
    Class for a 3D plane

    A plane is defined by a 3D position and a 3D normal
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _fast.Plane_swiginit(self, _fast.new_Plane(*args))

    def setPosition(self, position: "Vector3f") -> "void":
        return _fast.Plane_setPosition(self, position)

    def setNormal(self, normal: "Vector3f") -> "void":
        return _fast.Plane_setNormal(self, normal)

    def getPosition(self) -> "Vector3f":
        return _fast.Plane_getPosition(self)

    def getNormal(self) -> "Vector3f":
        return _fast.Plane_getNormal(self)

    def getIntersectionPoint(self, pointA: "Vector3f", pointB: "Vector3f") -> "Vector3f":
        return _fast.Plane_getIntersectionPoint(self, pointA, pointB)

    def hasPosition(self) -> "bool":
        return _fast.Plane_hasPosition(self)

    @staticmethod
    def Sagittal() -> "fast::Plane":
        return _fast.Plane_Sagittal()

    @staticmethod
    def Coronal() -> "fast::Plane":
        return _fast.Plane_Coronal()

    @staticmethod
    def Axial() -> "fast::Plane":
        return _fast.Plane_Axial()
    __swig_destroy__ = _fast.delete_Plane

# Register Plane in _fast:
_fast.Plane_swigregister(Plane)

def Plane_Sagittal() -> "fast::Plane":
    return _fast.Plane_Sagittal()

def Plane_Coronal() -> "fast::Plane":
    return _fast.Plane_Coronal()

def Plane_Axial() -> "fast::Plane":
    return _fast.Plane_Axial()

class BatchT(DataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get(self) -> "fast::InferenceDataList":
        return _fast.BatchT_get(self)

    def set(self, data: "InferenceDataList") -> "void":
        return _fast.BatchT_set(self, data)
    __swig_destroy__ = _fast.delete_BatchT

# Register BatchT in _fast:
_fast.BatchT_swigregister(BatchT)

class SequenceT(DataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get(self) -> "fast::InferenceDataList":
        return _fast.SequenceT_get(self)

    def set(self, data: "InferenceDataList") -> "void":
        return _fast.SequenceT_set(self, data)
    __swig_destroy__ = _fast.delete_SequenceT

# Register SequenceT in _fast:
_fast.SequenceT_swigregister(SequenceT)

class FloatScalarT(DataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get(self) -> "float":
        return _fast.FloatScalarT_get(self)

    def set(self, data: "float") -> "void":
        return _fast.FloatScalarT_set(self, data)
    __swig_destroy__ = _fast.delete_FloatScalarT

# Register FloatScalarT in _fast:
_fast.FloatScalarT_swigregister(FloatScalarT)

class FloatPointT(DataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get(self) -> "Vector2f":
        return _fast.FloatPointT_get(self)

    def set(self, data: "Vector2f") -> "void":
        return _fast.FloatPointT_set(self, data)
    __swig_destroy__ = _fast.delete_FloatPointT

# Register FloatPointT in _fast:
_fast.FloatPointT_swigregister(FloatPointT)

class StringT(DataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get(self) -> "std::string":
        return _fast.StringT_get(self)

    def set(self, data: "std::string") -> "void":
        return _fast.StringT_set(self, data)
    __swig_destroy__ = _fast.delete_StringT

# Register StringT in _fast:
_fast.StringT_swigregister(StringT)

class ClassificationSimpleDataType(DataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get(self) -> "std::map< std::string,float,std::less< std::string >,std::allocator< std::pair< std::string const,float > > >":
        return _fast.ClassificationSimpleDataType_get(self)

    def set(self, data: "StringFloatMap") -> "void":
        return _fast.ClassificationSimpleDataType_set(self, data)
    __swig_destroy__ = _fast.delete_ClassificationSimpleDataType

# Register ClassificationSimpleDataType in _fast:
_fast.ClassificationSimpleDataType_swigregister(ClassificationSimpleDataType)

class RegionListT(DataObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get(self) -> "std::vector< fast::Region,std::allocator< fast::Region > >":
        return _fast.RegionListT_get(self)

    def set(self, data: "Regions") -> "void":
        return _fast.RegionListT_set(self, data)
    __swig_destroy__ = _fast.delete_RegionListT

# Register RegionListT in _fast:
_fast.RegionListT_swigregister(RegionListT)

StreamingMode_NewestFrameOnly = _fast.StreamingMode_NewestFrameOnly
StreamingMode_ProcessAllFrames = _fast.StreamingMode_ProcessAllFrames
StreamingMode_StoreAllFrames = _fast.StreamingMode_StoreAllFrames
class NoMoreFramesException(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message: "std::string"):
        _fast.NoMoreFramesException_swiginit(self, _fast.new_NoMoreFramesException(message))
    __swig_destroy__ = _fast.delete_NoMoreFramesException

# Register NoMoreFramesException in _fast:
_fast.NoMoreFramesException_swigregister(NoMoreFramesException)

class Streamer(ProcessObject):
    r"""
    Abstract base class for all 'streamers'

    All 'streamers' must inherit from this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fast.delete_Streamer

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Streamer_getStaticNameOfClass()

    def getNameOfClass(self) -> "std::string":
        return _fast.Streamer_getNameOfClass(self)

    def stop(self) -> "void":
        r"""
        Stop the stream

        The streaming thread has finished when this method returns.
        This method should not be called from the streaming thread.
        """
        return _fast.Streamer_stop(self)

    def stopWithError(self, message: "std::string", outputPort: "int"=-1) -> "void":
        return _fast.Streamer_stopWithError(self, message, outputPort)

    def isStopped(self) -> "bool":
        return _fast.Streamer_isStopped(self)

    def setStreamingMode(self, mode: "fast::StreamingMode") -> "void":
        return _fast.Streamer_setStreamingMode(self, mode)

    def getStreamingMode(self) -> "fast::StreamingMode":
        return _fast.Streamer_getStreamingMode(self)

    def getOutputPort(self, portID: "uint"=0) -> "fast::DataChannel::pointer":
        return _fast.Streamer_getOutputPort(self, portID)

# Register Streamer in _fast:
_fast.Streamer_swigregister(Streamer)

def Streamer_getStaticNameOfClass() -> "std::string":
    return _fast.Streamer_getStaticNameOfClass()

class RandomAccessStreamer(Streamer):
    r"""
    Abstract class of streamer in which any frame can be accessed at any time through an integer index and playbacked can be paused.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setPause(self, pause: "bool") -> "void":
        return _fast.RandomAccessStreamer_setPause(self, pause)

    def getPause(self) -> "bool":
        return _fast.RandomAccessStreamer_getPause(self)

    def getCurrentFrameIndex(self) -> "int":
        return _fast.RandomAccessStreamer_getCurrentFrameIndex(self)

    def setCurrentFrameIndex(self, index: "int") -> "void":
        return _fast.RandomAccessStreamer_setCurrentFrameIndex(self, index)

    def getCurrentFrameIndexAndUpdate(self) -> "int":
        return _fast.RandomAccessStreamer_getCurrentFrameIndexAndUpdate(self)

    def getFramerate(self) -> "int":
        return _fast.RandomAccessStreamer_getFramerate(self)

    def setFramerate(self, framerate: "int") -> "void":
        return _fast.RandomAccessStreamer_setFramerate(self, framerate)

    def getNrOfFrames(self) -> "int":
        return _fast.RandomAccessStreamer_getNrOfFrames(self)

    def stop(self) -> "void":
        return _fast.RandomAccessStreamer_stop(self)

    def setLooping(self, loop: "bool") -> "void":
        return _fast.RandomAccessStreamer_setLooping(self, loop)

    def getLooping(self) -> "bool":
        return _fast.RandomAccessStreamer_getLooping(self)

    def frameAdded(self) -> "void":
        return _fast.RandomAccessStreamer_frameAdded(self)

    def waitForUnpause(self) -> "void":
        return _fast.RandomAccessStreamer_waitForUnpause(self)
    __swig_destroy__ = _fast.delete_RandomAccessStreamer

# Register RandomAccessStreamer in _fast:
_fast.RandomAccessStreamer_swigregister(RandomAccessStreamer)

class FileStreamer(RandomAccessStreamer):
    r"""
    Abstract file streamer class

    ### Output ports
    - 0: Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setFilenameFormat(self, str: "std::string") -> "void":
        return _fast.FileStreamer_setFilenameFormat(self, str)

    def setFilenameFormats(self, strings: "vectors") -> "void":
        return _fast.FileStreamer_setFilenameFormats(self, strings)

    def setStartNumber(self, startNumber: "uint") -> "void":
        return _fast.FileStreamer_setStartNumber(self, startNumber)

    def setStepSize(self, step: "uint") -> "void":
        return _fast.FileStreamer_setStepSize(self, step)

    def setZeroFilling(self, digits: "uint") -> "void":
        return _fast.FileStreamer_setZeroFilling(self, digits)

    def setNumberOfReplays(self, replays: "uint") -> "void":
        return _fast.FileStreamer_setNumberOfReplays(self, replays)

    def setMaximumNumberOfFrames(self, nrOfFrames: "uint") -> "void":
        return _fast.FileStreamer_setMaximumNumberOfFrames(self, nrOfFrames)

    def setTimestampFilename(self, filepath: "std::string") -> "void":
        return _fast.FileStreamer_setTimestampFilename(self, filepath)

    def enableLooping(self) -> "void":
        return _fast.FileStreamer_enableLooping(self)

    def disableLooping(self) -> "void":
        return _fast.FileStreamer_disableLooping(self)

    def setSleepTime(self, milliseconds: "uint") -> "void":
        r"""Set a sleep time after each frame is read"""
        return _fast.FileStreamer_setSleepTime(self, milliseconds)

    def getNrOfFrames(self) -> "int":
        return _fast.FileStreamer_getNrOfFrames(self)

    def setUseTimestamp(self, use: "bool") -> "void":
        r"""
        Enable or disable the use of timestamps when streaming files.

        :type use: boolean
        :param use:
        """
        return _fast.FileStreamer_setUseTimestamp(self, use)
    __swig_destroy__ = _fast.delete_FileStreamer

    def getNameOfClass(self) -> "std::string":
        return _fast.FileStreamer_getNameOfClass(self)

    def loadAttributes(self) -> "void":
        return _fast.FileStreamer_loadAttributes(self)

# Register FileStreamer in _fast:
_fast.FileStreamer_swigregister(FileStreamer)

class MeshFileStreamer(FileStreamer):
    r"""
    Stream a sequence of Mesh stored in VTK polydata files

    This streamer uses the VTKMeshFileImporter

    ### Output ports
    - 0: Mesh

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MeshFileStreamer >":
        return _fast.MeshFileStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MeshFileStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MeshFileStreamer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::MeshFileStreamer >":
        return _fast.MeshFileStreamer_connect(self, *args)

    @staticmethod
    def create(filenameFormat: "std::string", loop: "bool"=False) -> "std::shared_ptr< fast::MeshFileStreamer >":
        r"""
        Create instance
        :type filenameFormat: string
        :param filenameFormat: String of path and format of images. E.g. /path/to/files/frame_#.mhd. The hash sign #
            will be replaced by an index
        :type loop: boolean
        :param loop: Whether to loop the recording or not
        :rtype: :py:class:`MeshFileStreamer`
        :return: instance
        """
        return _fast.MeshFileStreamer_create(filenameFormat, loop)
    __swig_destroy__ = _fast.delete_MeshFileStreamer

# Register MeshFileStreamer in _fast:
_fast.MeshFileStreamer_swigregister(MeshFileStreamer)

def MeshFileStreamer_New() -> "std::shared_ptr< fast::MeshFileStreamer >":
    return _fast.MeshFileStreamer_New()

def MeshFileStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.MeshFileStreamer_getStaticNameOfClass()

def MeshFileStreamer_create(filenameFormat: "std::string", loop: "bool"=False) -> "std::shared_ptr< fast::MeshFileStreamer >":
    r"""
    Create instance
    :type filenameFormat: string
    :param filenameFormat: String of path and format of images. E.g. /path/to/files/frame_#.mhd. The hash sign #
        will be replaced by an index
    :type loop: boolean
    :param loop: Whether to loop the recording or not
    :rtype: :py:class:`MeshFileStreamer`
    :return: instance
    """
    return _fast.MeshFileStreamer_create(filenameFormat, loop)

class ImageFileStreamer(FileStreamer):
    r"""
    Stream a sequence of image files from disk

    Images has to be stored with an index before the file extension.
    E.g. some_name_0.mhd, some_name_1.mhd, some_name_2.mhd ...
    or some_name_0.png, some_name_1.png, some_name_2.png ...

    This streamer uses the ImageFileImporter to read the images from disk.

    ### Output ports
    - 0: Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageFileStreamer >":
        return _fast.ImageFileStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageFileStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageFileStreamer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageFileStreamer >":
        return _fast.ImageFileStreamer_connect(self, *args)

    @staticmethod
    def create(filenameFormat: "std::string", loop: "bool"=False, useTimestamps: "bool"=True, framerate: "int"=-1, grayscale: "bool"=False) -> "std::shared_ptr< fast::ImageFileStreamer >":
        r"""
        Create a ImageFileStreamer instance

        :type filenameFormat: string
        :param filenameFormat: String of path and format of images. E.g. /path/to/files/frame_#.mhd. The hash sign #
            will be replaced by an index
        :type loop: boolean
        :param loop: Whether to loop the recording or not
        :type useTimestamps: boolean
        :param useTimestamps: Whether to use timestamps in image files (if available) when streaming, or just stream as fast as possible
        :type framerate: int
        :param framerate: If framerate is > 0, this framerate will be used for streaming the images
        :type grayscale: boolean
        :param grayscale: Convert images to grayscale if the source image is in color.
        :rtype: :py:class:`ImageFileStreamer`
        :return: instance
        """
        return _fast.ImageFileStreamer_create(filenameFormat, loop, useTimestamps, framerate, grayscale)

    def setGrayscale(self, grayscale: "bool") -> "void":
        r"""
        Convert images to grayscale if the source image is in color
        :type grayscale: boolean
        :param grayscale: Convert or not
        """
        return _fast.ImageFileStreamer_setGrayscale(self, grayscale)

    def loadAttributes(self) -> "void":
        return _fast.ImageFileStreamer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageFileStreamer

# Register ImageFileStreamer in _fast:
_fast.ImageFileStreamer_swigregister(ImageFileStreamer)

def ImageFileStreamer_New() -> "std::shared_ptr< fast::ImageFileStreamer >":
    return _fast.ImageFileStreamer_New()

def ImageFileStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.ImageFileStreamer_getStaticNameOfClass()

def ImageFileStreamer_create(filenameFormat: "std::string", loop: "bool"=False, useTimestamps: "bool"=True, framerate: "int"=-1, grayscale: "bool"=False) -> "std::shared_ptr< fast::ImageFileStreamer >":
    r"""
    Create a ImageFileStreamer instance

    :type filenameFormat: string
    :param filenameFormat: String of path and format of images. E.g. /path/to/files/frame_#.mhd. The hash sign #
        will be replaced by an index
    :type loop: boolean
    :param loop: Whether to loop the recording or not
    :type useTimestamps: boolean
    :param useTimestamps: Whether to use timestamps in image files (if available) when streaming, or just stream as fast as possible
    :type framerate: int
    :param framerate: If framerate is > 0, this framerate will be used for streaming the images
    :type grayscale: boolean
    :param grayscale: Convert images to grayscale if the source image is in color.
    :rtype: :py:class:`ImageFileStreamer`
    :return: instance
    """
    return _fast.ImageFileStreamer_create(filenameFormat, loop, useTimestamps, framerate, grayscale)

class DICOMMultiFrameStreamer(RandomAccessStreamer):
    r"""
    Stream images from a DICOM multi-frame image

    ### Output ports
    - 0: Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::DICOMMultiFrameStreamer >":
        return _fast.DICOMMultiFrameStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.DICOMMultiFrameStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DICOMMultiFrameStreamer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::DICOMMultiFrameStreamer >":
        return _fast.DICOMMultiFrameStreamer_connect(self, *args)

    @staticmethod
    def create(filename: "std::string", loop: "bool"=False, useFramerate: "bool"=True, framerate: "int"=-1, grayscale: "bool"=False, cropToROI: "bool"=False) -> "std::shared_ptr< fast::DICOMMultiFrameStreamer >":
        r"""
        Create instance
        :type filename: string
        :param filename: DICOM file to open
        :type loop: boolean
        :param loop: Whether to loop or not
        :type useFramerate: boolean
        :param useFramerate: Whether to use framerate from DICOM file or not. If this is set to false, images will be streamed as fast as possible
        :type framerate: int
        :param framerate: If framerate is > 0, this framerate will be used for streaming the images
        :type grayscale: boolean
        :param grayscale: Convert images to grayscale
        :type cropToROI: boolean
        :param cropToROI: Try to extract ROI from dicom and crop the images to this ROI
        :rtype: :py:class:`DICOMMultiFrameStreamer`
        :return: instance
        """
        return _fast.DICOMMultiFrameStreamer_create(filename, loop, useFramerate, framerate, grayscale, cropToROI)

    def getNrOfFrames(self) -> "int":
        return _fast.DICOMMultiFrameStreamer_getNrOfFrames(self)
    __swig_destroy__ = _fast.delete_DICOMMultiFrameStreamer

# Register DICOMMultiFrameStreamer in _fast:
_fast.DICOMMultiFrameStreamer_swigregister(DICOMMultiFrameStreamer)

def DICOMMultiFrameStreamer_New() -> "std::shared_ptr< fast::DICOMMultiFrameStreamer >":
    return _fast.DICOMMultiFrameStreamer_New()

def DICOMMultiFrameStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.DICOMMultiFrameStreamer_getStaticNameOfClass()

def DICOMMultiFrameStreamer_create(filename: "std::string", loop: "bool"=False, useFramerate: "bool"=True, framerate: "int"=-1, grayscale: "bool"=False, cropToROI: "bool"=False) -> "std::shared_ptr< fast::DICOMMultiFrameStreamer >":
    r"""
    Create instance
    :type filename: string
    :param filename: DICOM file to open
    :type loop: boolean
    :param loop: Whether to loop or not
    :type useFramerate: boolean
    :param useFramerate: Whether to use framerate from DICOM file or not. If this is set to false, images will be streamed as fast as possible
    :type framerate: int
    :param framerate: If framerate is > 0, this framerate will be used for streaming the images
    :type grayscale: boolean
    :param grayscale: Convert images to grayscale
    :type cropToROI: boolean
    :param cropToROI: Try to extract ROI from dicom and crop the images to this ROI
    :rtype: :py:class:`DICOMMultiFrameStreamer`
    :return: instance
    """
    return _fast.DICOMMultiFrameStreamer_create(filename, loop, useFramerate, framerate, grayscale, cropToROI)

class String(StringT):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.String_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.String_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::String >":
        return _fast.String_fromDataObject(object)

    @staticmethod
    def create(data: "std::string") -> "std::shared_ptr< fast::String >":
        return _fast.String_create(data)
    __swig_destroy__ = _fast.delete_String

# Register String in _fast:
_fast.String_swigregister(String)

def String_getStaticNameOfClass() -> "std::string":
    return _fast.String_getStaticNameOfClass()

def String_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::String >":
    return _fast.String_fromDataObject(object)

def String_create(data: "std::string") -> "std::shared_ptr< fast::String >":
    return _fast.String_create(data)

class OpenIGTLinkStreamer(Streamer):
    r"""
    Stream image or transforms from an OpenIGTLink server

    This streamer uses the OpenIGTLink protocol and library to stream data such as images and transforms from a server

    Default streaming mode is StreamingMode::NewestFrameOnly

    ### Output ports
    Multiple ports possible dependeing on number of streams from OpenIGTLink server

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::OpenIGTLinkStreamer >":
        return _fast.OpenIGTLinkStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.OpenIGTLinkStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.OpenIGTLinkStreamer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::OpenIGTLinkStreamer >":
        return _fast.OpenIGTLinkStreamer_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::OpenIGTLinkStreamer >":
        r"""
        Create instance
        :type ipAddress: string
        :param ipAddress: IP address of server to connect to. Default is localhost
        :type port: int
        :param port: Port of server to connect to. Default is 18944
        :rtype: :py:class:`OpenIGTLinkStreamer`
        :return: instance
        """
        return _fast.OpenIGTLinkStreamer_create(*args, **kwargs)

    def getImageStreamNames(self) -> "std::set< std::string >":
        return _fast.OpenIGTLinkStreamer_getImageStreamNames(self)

    def getTransformStreamNames(self) -> "std::set< std::string >":
        return _fast.OpenIGTLinkStreamer_getTransformStreamNames(self)

    def getActiveImageStreamNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _fast.OpenIGTLinkStreamer_getActiveImageStreamNames(self)

    def getActiveTransformStreamNames(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _fast.OpenIGTLinkStreamer_getActiveTransformStreamNames(self)

    def getStreamDescription(self, streamName: "std::string") -> "std::string":
        return _fast.OpenIGTLinkStreamer_getStreamDescription(self, streamName)

    def setConnectionAddress(self, address: "std::string") -> "void":
        return _fast.OpenIGTLinkStreamer_setConnectionAddress(self, address)

    def setConnectionPort(self, port: "uint") -> "void":
        return _fast.OpenIGTLinkStreamer_setConnectionPort(self, port)

    def getNrOfFrames(self) -> "uint":
        return _fast.OpenIGTLinkStreamer_getNrOfFrames(self)

    def getOutputPortNumber(self, deviceName: "std::string") -> "uint":
        r"""
        Get output port number for specific device
        :type deviceName: string
        :param deviceName:
        :rtype: int
        :return: output port number
        """
        return _fast.OpenIGTLinkStreamer_getOutputPortNumber(self, deviceName)

    def getOutputPort(self, *args) -> "fast::DataChannel::pointer":
        return _fast.OpenIGTLinkStreamer_getOutputPort(self, *args)

    def createOutputPortForDevice(self, deviceName: "std::string") -> "uint":
        return _fast.OpenIGTLinkStreamer_createOutputPortForDevice(self, deviceName)

    def generateStream(self) -> "void":
        r"""
        This method runs in a separate thread and adds frames to the
        output object
        """
        return _fast.OpenIGTLinkStreamer_generateStream(self)
    __swig_destroy__ = _fast.delete_OpenIGTLinkStreamer

    def loadAttributes(self) -> "void":
        return _fast.OpenIGTLinkStreamer_loadAttributes(self)

    def getCurrentFramerate(self) -> "float":
        return _fast.OpenIGTLinkStreamer_getCurrentFramerate(self)

# Register OpenIGTLinkStreamer in _fast:
_fast.OpenIGTLinkStreamer_swigregister(OpenIGTLinkStreamer)

def OpenIGTLinkStreamer_New() -> "std::shared_ptr< fast::OpenIGTLinkStreamer >":
    return _fast.OpenIGTLinkStreamer_New()

def OpenIGTLinkStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.OpenIGTLinkStreamer_getStaticNameOfClass()

def OpenIGTLinkStreamer_create(*args, **kwargs) -> "std::shared_ptr< fast::OpenIGTLinkStreamer >":
    r"""
    Create instance
    :type ipAddress: string
    :param ipAddress: IP address of server to connect to. Default is localhost
    :type port: int
    :param port: Port of server to connect to. Default is 18944
    :rtype: :py:class:`OpenIGTLinkStreamer`
    :return: instance
    """
    return _fast.OpenIGTLinkStreamer_create(*args, **kwargs)

class MovieStreamer(Streamer):
    r"""
    Stream movie files

    This streamer uses Qt 5 to streams every frame in a movie as an Image.

    ### Output ports
    - 0: Image - Movie frame

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MovieStreamer >":
        return _fast.MovieStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MovieStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MovieStreamer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::MovieStreamer >":
        return _fast.MovieStreamer_connect(self, *args)

    @staticmethod
    def create(filename: "std::string", grayscale: "bool"=True, loop: "bool"=False) -> "std::shared_ptr< fast::MovieStreamer >":
        r"""
        Create instance
        :type filename: string
        :param filename: Movie file to stream from
        :type grayscale: boolean
        :param grayscale: Whether to convert to grayscale or not
        :type loop: boolean
        :param loop: Whether to loop the video or not
        :rtype: :py:class:`MovieStreamer`
        :return: instance
        """
        return _fast.MovieStreamer_create(filename, grayscale, loop)

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.MovieStreamer_setFilename(self, filename)

    def getFilename(self) -> "std::string":
        return _fast.MovieStreamer_getFilename(self)

    def hasReachedEnd(self) -> "bool":
        return _fast.MovieStreamer_hasReachedEnd(self)

    def addNewImageFrame(self, data: "uchar const *", width: "int", height: "int") -> "void":
        return _fast.MovieStreamer_addNewImageFrame(self, data, width, height)

    def setGrayscale(self, grayscale: "bool") -> "void":
        return _fast.MovieStreamer_setGrayscale(self, grayscale)

    def getGrayscale(self) -> "bool":
        return _fast.MovieStreamer_getGrayscale(self)

    def setFinished(self, finished: "bool") -> "void":
        return _fast.MovieStreamer_setFinished(self, finished)

    def setLoop(self, loop: "bool") -> "void":
        return _fast.MovieStreamer_setLoop(self, loop)

    def getLoop(self) -> "bool":
        return _fast.MovieStreamer_getLoop(self)

    def getFramesAdded(self) -> "int":
        return _fast.MovieStreamer_getFramesAdded(self)
    __swig_destroy__ = _fast.delete_MovieStreamer

    def loadAttributes(self) -> "void":
        return _fast.MovieStreamer_loadAttributes(self)

    def addLastFrame(self) -> "void":
        return _fast.MovieStreamer_addLastFrame(self)

# Register MovieStreamer in _fast:
_fast.MovieStreamer_swigregister(MovieStreamer)

def MovieStreamer_New() -> "std::shared_ptr< fast::MovieStreamer >":
    return _fast.MovieStreamer_New()

def MovieStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.MovieStreamer_getStaticNameOfClass()

def MovieStreamer_create(filename: "std::string", grayscale: "bool"=True, loop: "bool"=False) -> "std::shared_ptr< fast::MovieStreamer >":
    r"""
    Create instance
    :type filename: string
    :param filename: Movie file to stream from
    :type grayscale: boolean
    :param grayscale: Whether to convert to grayscale or not
    :type loop: boolean
    :param loop: Whether to loop the video or not
    :rtype: :py:class:`MovieStreamer`
    :return: instance
    """
    return _fast.MovieStreamer_create(filename, grayscale, loop)

class CameraStreamer(Streamer):
    r"""
    Stream images from a (web)camera

    This streamer uses Qt 5 to connect a (web)camera and creates
    a stream of FAST images from it.

    Default streaming mode is StreamingMode::NewestFrameOnly

    ### Output ports
    - 0: Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::CameraStreamer >":
        return _fast.CameraStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.CameraStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.CameraStreamer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::CameraStreamer >":
        return _fast.CameraStreamer_connect(self, *args)

    @staticmethod
    def create(grayscale: "bool"=False, cameraIndex: "uchar"=0) -> "std::shared_ptr< fast::CameraStreamer >":
        r"""
        Create instance
        :type grayscale: boolean
        :param grayscale: Whether to convert to grayscale or not
        :type cameraIndex: uchar
        :param cameraIndex: index of camera to use
        :rtype: :py:class:`CameraStreamer`
        :return: instance
        """
        return _fast.CameraStreamer_create(grayscale, cameraIndex)

    def setFinished(self, finished: "bool") -> "void":
        return _fast.CameraStreamer_setFinished(self, finished)

    def addNewImageFrame(self, data: "uchar const *", width: "int", height: "int") -> "void":
        return _fast.CameraStreamer_addNewImageFrame(self, data, width, height)

    def getGrayscale(self) -> "bool":
        return _fast.CameraStreamer_getGrayscale(self)

    def setGrayscale(self, grayscale: "bool") -> "void":
        return _fast.CameraStreamer_setGrayscale(self, grayscale)

    def loadAttributes(self) -> "void":
        return _fast.CameraStreamer_loadAttributes(self)

    def setCamera(self, index: "uchar") -> "void":
        return _fast.CameraStreamer_setCamera(self, index)
    __swig_destroy__ = _fast.delete_CameraStreamer

# Register CameraStreamer in _fast:
_fast.CameraStreamer_swigregister(CameraStreamer)

def CameraStreamer_New() -> "std::shared_ptr< fast::CameraStreamer >":
    return _fast.CameraStreamer_New()

def CameraStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.CameraStreamer_getStaticNameOfClass()

def CameraStreamer_create(grayscale: "bool"=False, cameraIndex: "uchar"=0) -> "std::shared_ptr< fast::CameraStreamer >":
    r"""
    Create instance
    :type grayscale: boolean
    :param grayscale: Whether to convert to grayscale or not
    :type cameraIndex: uchar
    :param cameraIndex: index of camera to use
    :rtype: :py:class:`CameraStreamer`
    :return: instance
    """
    return _fast.CameraStreamer_create(grayscale, cameraIndex)

class UFFStreamer(RandomAccessStreamer):
    r"""
    Stream ultrasound file format (UFF) data

    A streamer for reading data stored in the ultrasound file format (UFF)
    which is essentially and HDF5 file with ultrasound image/beam data.

    There is GUI tool called the 'UFFviewer' which uses the UFF streamer,
    enabling you to load and play with UFF data without programming.
    Type UFFviewer in your terminal to access it.

    ### Output ports
    - 0: Image

    Examples using the UFF streamer:
    - 'stream_uff_ultrasound_file_format_data.py'
    - 'display_ultrasound_file_format_data_with_matplotlib.py'
    - 'streamUFFData.cpp'


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::UFFStreamer >":
        return _fast.UFFStreamer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.UFFStreamer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.UFFStreamer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::UFFStreamer >":
        return _fast.UFFStreamer_connect(self, *args)

    @staticmethod
    def create(filename: "std::string", loop: "bool"=False, framerate: "uint"=30, gain: "float"=10, dynamicRange: "float"=60, scanConversionWidth: "int"=1024, scanConversionHeight: "int"=1024, doScanConversion: "bool"=True, convertToGrayscale: "bool"=True) -> "std::shared_ptr< fast::UFFStreamer >":
        r"""
        Create instance
        :type filename: string
        :param filename: UFF file to stream from
        :type loop: boolean
        :param loop: Whether to loop or not
        :type framerate: int
        :param framerate: Max framerate (FPS) to output frames
        :type gain: float
        :param gain: Gain
        :type dynamicRange: float
        :param dynamicRange: Dynamic range
        :type scanConversionWidth: int
        :param scanConversionWidth: Width of scan converted image
        :type scanConversionHeight: int
        :param scanConversionHeight: Height of scan converted image
        :type doScanConversion: boolean
        :param doScanConversion: Whether to perform scan conversion or not
        :param toGrayscale: Whether to convert from dB to grayscale using the gain and dynamicRange if scan conversion is OFF.
                 When scan conversion is ON, the image is always converted to grayscale.
        :rtype: :py:class:`UFFStreamer`
        :return: instance
        """
        return _fast.UFFStreamer_create(filename, loop, framerate, gain, dynamicRange, scanConversionWidth, scanConversionHeight, doScanConversion, convertToGrayscale)

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.UFFStreamer_setFilename(self, filename)

    def setGain(self, gain: "float") -> "void":
        return _fast.UFFStreamer_setGain(self, gain)

    def setDynamicRange(self, dynamicRange: "float") -> "void":
        return _fast.UFFStreamer_setDynamicRange(self, dynamicRange)

    def execute(self) -> "void":
        return _fast.UFFStreamer_execute(self)

    def getNrOfFrames(self) -> "int":
        r"""
        Nr of frames in UFF file
        :rtype: int
        :return: nr of frames
        """
        return _fast.UFFStreamer_getNrOfFrames(self)

    def setName(self, name: "std::string") -> "void":
        r"""Set name of which HDF5 group to stream."""
        return _fast.UFFStreamer_setName(self, name)

    def loadAttributes(self) -> "void":
        return _fast.UFFStreamer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_UFFStreamer

# Register UFFStreamer in _fast:
_fast.UFFStreamer_swigregister(UFFStreamer)

def UFFStreamer_New() -> "std::shared_ptr< fast::UFFStreamer >":
    return _fast.UFFStreamer_New()

def UFFStreamer_getStaticNameOfClass() -> "std::string":
    return _fast.UFFStreamer_getStaticNameOfClass()

def UFFStreamer_create(filename: "std::string", loop: "bool"=False, framerate: "uint"=30, gain: "float"=10, dynamicRange: "float"=60, scanConversionWidth: "int"=1024, scanConversionHeight: "int"=1024, doScanConversion: "bool"=True, convertToGrayscale: "bool"=True) -> "std::shared_ptr< fast::UFFStreamer >":
    r"""
    Create instance
    :type filename: string
    :param filename: UFF file to stream from
    :type loop: boolean
    :param loop: Whether to loop or not
    :type framerate: int
    :param framerate: Max framerate (FPS) to output frames
    :type gain: float
    :param gain: Gain
    :type dynamicRange: float
    :param dynamicRange: Dynamic range
    :type scanConversionWidth: int
    :param scanConversionWidth: Width of scan converted image
    :type scanConversionHeight: int
    :param scanConversionHeight: Height of scan converted image
    :type doScanConversion: boolean
    :param doScanConversion: Whether to perform scan conversion or not
    :param toGrayscale: Whether to convert from dB to grayscale using the gain and dynamicRange if scan conversion is OFF.
             When scan conversion is ON, the image is always converted to grayscale.
    :rtype: :py:class:`UFFStreamer`
    :return: instance
    """
    return _fast.UFFStreamer_create(filename, loop, framerate, gain, dynamicRange, scanConversionWidth, scanConversionHeight, doScanConversion, convertToGrayscale)

class AddTransformation(ProcessObject):
    r"""
    Add transformations to spatial data objects

    This class will add new scene graph node before the root node of the input data object.
    This node will get the transformation supplied to the transformation input connection

    Inputs:
    - 0: SpatialDataObject - Object to add transform to
    - 1: AffineTransformation - Transform to add

    Outputs:
    - 0: SpatialDataObject - Same as input 0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::AddTransformation >":
        return _fast.AddTransformation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.AddTransformation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.AddTransformation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::AddTransformation >":
        return _fast.AddTransformation_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::AddTransformation >":
        r"""
        Create instance
        :rtype: :py:class:`AddTransformation`
        :return: instance
        """
        return _fast.AddTransformation_create()
    __swig_destroy__ = _fast.delete_AddTransformation

# Register AddTransformation in _fast:
_fast.AddTransformation_swigregister(AddTransformation)

def AddTransformation_New() -> "std::shared_ptr< fast::AddTransformation >":
    return _fast.AddTransformation_New()

def AddTransformation_getStaticNameOfClass() -> "std::string":
    return _fast.AddTransformation_getStaticNameOfClass()

def AddTransformation_create() -> "std::shared_ptr< fast::AddTransformation >":
    r"""
    Create instance
    :rtype: :py:class:`AddTransformation`
    :return: instance
    """
    return _fast.AddTransformation_create()

class SetTransformation(ProcessObject):
    r"""
    Set transformations to spatial data objects

    This class will set the transform for spatial data object.

    Inputs:
    - 0: SpatialDataObject - Object to set transform to
    - 1: AffineTransformation - Transform to set

    Outputs:
    - 0: SpatialDataObject - Same as input 0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SetTransformation >":
        return _fast.SetTransformation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SetTransformation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SetTransformation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::SetTransformation >":
        return _fast.SetTransformation_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::SetTransformation >":
        r"""
        Create instance
        :rtype: :py:class:`SetTransformation`
        :return: instance
        """
        return _fast.SetTransformation_create()
    __swig_destroy__ = _fast.delete_SetTransformation

# Register SetTransformation in _fast:
_fast.SetTransformation_swigregister(SetTransformation)

def SetTransformation_New() -> "std::shared_ptr< fast::SetTransformation >":
    return _fast.SetTransformation_New()

def SetTransformation_getStaticNameOfClass() -> "std::string":
    return _fast.SetTransformation_getStaticNameOfClass()

def SetTransformation_create() -> "std::shared_ptr< fast::SetTransformation >":
    r"""
    Create instance
    :rtype: :py:class:`SetTransformation`
    :return: instance
    """
    return _fast.SetTransformation_create()

class AirwaySegmentation(ProcessObject):
    r"""
    Segment airways from CT using seeded region growing with explosion control

    An example of this can be found in 'airwaySegmentation.cpp'

    Inputs:
    - 0: Image - CT thorax 3D image

    Outputs:
    - 0: Image - Segmentation image

    See also: CenterlineExtraction
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::AirwaySegmentation >":
        return _fast.AirwaySegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.AirwaySegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.AirwaySegmentation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::AirwaySegmentation >":
        return _fast.AirwaySegmentation_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::AirwaySegmentation >":
        r"""
        Create AirwaySegmentation instance

        :type smoothing: float
        :param smoothing: Standard deviation of Gaussian smoothing to apply before segmentation.
            A higher value can be used for low dose CT.
        :type seed: Vector3i
        :param seed: Manually set seed point. If set to (-1,-1,-1), it will try to find seed point automatically.
        :rtype: :py:class:`AirwaySegmentation`
        :return: instance
        """
        return _fast.AirwaySegmentation_create(*args, **kwargs)

    def setSeedPoint(self, *args) -> "void":
        r"""
        *Overload 1:*

        Set manual seed point for region growing
        :type x: int
        :param x:
        :type y: int
        :param y:
        :type z: int
        :param z:

        |

        *Overload 2:*

        Set manual seed point for region growing
        :type seed: Vector3i
        :param seed:
        """
        return _fast.AirwaySegmentation_setSeedPoint(self, *args)

    def setSmoothing(self, sigma: "float") -> "void":
        r"""
        Standard deviation of Gaussian smoothing for preprocessing

        Set the standard deviation value of the GaussianSmoothing performed before segmentation.
        Default is 0.5. A higher value can be used for low dose CT.
        :type sigma: float
        :param sigma: standard deviation
        """
        return _fast.AirwaySegmentation_setSmoothing(self, sigma)

    def loadAttributes(self) -> "void":
        return _fast.AirwaySegmentation_loadAttributes(self)
    __swig_destroy__ = _fast.delete_AirwaySegmentation

# Register AirwaySegmentation in _fast:
_fast.AirwaySegmentation_swigregister(AirwaySegmentation)

def AirwaySegmentation_New() -> "std::shared_ptr< fast::AirwaySegmentation >":
    return _fast.AirwaySegmentation_New()

def AirwaySegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.AirwaySegmentation_getStaticNameOfClass()

def AirwaySegmentation_create(*args, **kwargs) -> "std::shared_ptr< fast::AirwaySegmentation >":
    r"""
    Create AirwaySegmentation instance

    :type smoothing: float
    :param smoothing: Standard deviation of Gaussian smoothing to apply before segmentation.
        A higher value can be used for low dose CT.
    :type seed: Vector3i
    :param seed: Manually set seed point. If set to (-1,-1,-1), it will try to find seed point automatically.
    :rtype: :py:class:`AirwaySegmentation`
    :return: instance
    """
    return _fast.AirwaySegmentation_create(*args, **kwargs)

class Colormap(object):
    r"""
    Colormap data structure

    The colormap can be both in grayscale and in RGB color.
    The colormap can be linearly interpolated between points or just use nearest neighbor interpolation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Create empty uninitialized colormap

        |

        *Overload 2:*

        Create a grayscale colormap

        :type colormap: std::map< float,float,std::less< float >,std::allocator< std::pair< float const,float > > >
        :param colormap:
        :type interpolate: boolean
        :param interpolate:
        :type diverging: boolean
        :param diverging:

        |

        *Overload 3:*

        Creates an RGB colormap
        :type colormap: std::map< float,fast::Color,std::less< float >,std::allocator< std::pair< float const,fast::Color > > >
        :param colormap:
        :type interpolate: boolean
        :param interpolate:
        :type diverging: boolean
        :param diverging:

        |

        *Overload 4:*

        Creates a colormap directly from a list of floats.

        The floats must be intensity_source1, intensity_output1, intensity_source2, intensity_output2, ... N if you
        have a grayscale colormap.
        If you have a RGB colormap it should be: intensity_source1, red1, green1, blue1, intensity_source2, red2, green2, blue2, .... N

        :type values: std::vector< float,std::allocator< float > >
        :param values:
        :type grayscale: boolean
        :param grayscale:
        :type interpolate: boolean
        :param interpolate:
        :type diverging: boolean
        :param diverging:
        """
        _fast.Colormap_swiginit(self, _fast.new_Colormap(*args))

    def getAsOpenCLBuffer(self, device: "fast::OpenCLDevice::pointer", opacity: "float"=1.0) -> "cl::Buffer":
        r"""
        Create an OpenCL buffer from the colormap data.
        :type device: :py:class:`OpenCLDevice`
        :param device: OpenCL device to transfer data to
        :type opacity: float
        :param opacity: Opacity to apply to colormap. If lower than 1 opacity will be added to the colormap.
                 If the colormap already has opacity, this opacity will be multiplied with the existing opacity.
        :rtype: cl::Buffer
        :return: OpenCL buffer
        """
        return _fast.Colormap_getAsOpenCLBuffer(self, device, opacity)

    def hasOpacity(self) -> "bool":
        r"""
        Has this colormap opacity defined
        :rtype: boolean
        :return: 
        """
        return _fast.Colormap_hasOpacity(self)

    def isGrayscale(self) -> "bool":
        r"""
        Is this colormap grayscale
        :rtype: boolean
        :return: 
        """
        return _fast.Colormap_isGrayscale(self)

    def isInterpolated(self) -> "bool":
        r"""
        Is this colormap grayscale
        :rtype: boolean
        :return: 
        """
        return _fast.Colormap_isInterpolated(self)

    def isIntensityInvariant(self) -> "bool":
        r"""
        Is this colormap intensity invariant
        :rtype: boolean
        :return: 
        """
        return _fast.Colormap_isIntensityInvariant(self)

    def isDiverging(self) -> "bool":
        r"""
        Is this colormap diverging
        :rtype: boolean
        :return: 
        """
        return _fast.Colormap_isDiverging(self)

    def getSteps(self) -> "int":
        r"""
        Get nr of steps (defined points) in colormap
        :rtype: int
        :return: 
        """
        return _fast.Colormap_getSteps(self)

    def getData(self) -> "std::vector< float,std::allocator< float > >":
        r"""
        Get data values of the colormap as a list of floats
        :rtype: std::vector< float,std::allocator< float > >
        :return: list of floats
        """
        return _fast.Colormap_getData(self)

    @staticmethod
    def Ultrasound(grayscale: "bool"=False) -> "fast::Colormap":
        r"""
        Ultrasound S-curve colormap (grayscale and color (with a hint of blue))
        :type grayscale: boolean
        :param grayscale:
        :rtype: :py:class:`Colormap`
        :return: ultrasound colormap
        """
        return _fast.Colormap_Ultrasound(grayscale)

    @staticmethod
    def Inferno(withOpacity: "bool"=False) -> "fast::Colormap":
        r"""
        Inferno heatmap (like fire, but with some blue and purple in it)
        :type withOpacity: boolean
        :param withOpacity: Create inferno heatmap with custom opacity.
                 If you will use this heatmap as an overlay you should enable this.
        :rtype: :py:class:`Colormap`
        :return: inferno heatmap
        """
        return _fast.Colormap_Inferno(withOpacity)

    @staticmethod
    def Fire(withOpacity: "bool"=False) -> "fast::Colormap":
        r"""
        Fire heatmap (no blue/purple)
        :type withOpacity: boolean
        :param withOpacity: Create fire heatmap with custom opacity.
                 If you will use this heatmap as an overlay you should enable this.
        :rtype: :py:class:`Colormap`
        :return: fire heatmap
        """
        return _fast.Colormap_Fire(withOpacity)

    @staticmethod
    def CoolWarm() -> "fast::Colormap":
        r"""
        Cool-Warm (Blue-Red) diverging colormap
        :rtype: :py:class:`Colormap`
        :return: 
        """
        return _fast.Colormap_CoolWarm()
    __swig_destroy__ = _fast.delete_Colormap

# Register Colormap in _fast:
_fast.Colormap_swigregister(Colormap)

def Colormap_Ultrasound(grayscale: "bool"=False) -> "fast::Colormap":
    r"""
    Ultrasound S-curve colormap (grayscale and color (with a hint of blue))
    :type grayscale: boolean
    :param grayscale:
    :rtype: :py:class:`Colormap`
    :return: ultrasound colormap
    """
    return _fast.Colormap_Ultrasound(grayscale)

def Colormap_Inferno(withOpacity: "bool"=False) -> "fast::Colormap":
    r"""
    Inferno heatmap (like fire, but with some blue and purple in it)
    :type withOpacity: boolean
    :param withOpacity: Create inferno heatmap with custom opacity.
             If you will use this heatmap as an overlay you should enable this.
    :rtype: :py:class:`Colormap`
    :return: inferno heatmap
    """
    return _fast.Colormap_Inferno(withOpacity)

def Colormap_Fire(withOpacity: "bool"=False) -> "fast::Colormap":
    r"""
    Fire heatmap (no blue/purple)
    :type withOpacity: boolean
    :param withOpacity: Create fire heatmap with custom opacity.
             If you will use this heatmap as an overlay you should enable this.
    :rtype: :py:class:`Colormap`
    :return: fire heatmap
    """
    return _fast.Colormap_Fire(withOpacity)

def Colormap_CoolWarm() -> "fast::Colormap":
    r"""
    Cool-Warm (Blue-Red) diverging colormap
    :rtype: :py:class:`Colormap`
    :return: 
    """
    return _fast.Colormap_CoolWarm()

class ApplyColormap(ProcessObject):
    r"""
    Applies a colormap on an image to create a new image.

    Current limitations are: Input and output images can only be 2D. Output image is always of TYPE_UINT8

    Inputs:
    - 0: Image

    Outputs:
    - 0: Image

    See also: Colormap
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ApplyColormap >":
        return _fast.ApplyColormap_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ApplyColormap_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ApplyColormap_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ApplyColormap >":
        return _fast.ApplyColormap_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::ApplyColormap >":
        r"""
        Create instance
        :type colormap: :py:class:`Colormap`
        :param colormap: Colormap to apply
        :type opacity: float
        :param opacity: Apply colormap with an opacity.
                 If the colormap already has opacity, this opacity will be multiplied with the existing opacity.
        :type minValue: float
        :param minValue: Set the minimum value of the input data to scale the colormap to. This is only used
                 on intensity invariant colormaps. If not set, the true minimum value of the input data is used.
        :type maxValue: float
        :param maxValue: Set the maximum value of the input data to scale the colormap to. This is only used
                 on intensity invariant colormaps. If not set, the true maximum value of the input data is used.
        :rtype: :py:class:`ApplyColormap`
        :return: instance
        """
        return _fast.ApplyColormap_create(*args, **kwargs)

    def setColormap(self, colormap: "Colormap") -> "void":
        return _fast.ApplyColormap_setColormap(self, colormap)

    def getColormap(self) -> "fast::Colormap":
        return _fast.ApplyColormap_getColormap(self)

    def setMinValue(self, minValue: "float") -> "void":
        return _fast.ApplyColormap_setMinValue(self, minValue)

    def setMaxValue(self, maxValue: "float") -> "void":
        return _fast.ApplyColormap_setMaxValue(self, maxValue)

    def setOpacity(self, opacity: "float") -> "void":
        return _fast.ApplyColormap_setOpacity(self, opacity)
    __swig_destroy__ = _fast.delete_ApplyColormap

# Register ApplyColormap in _fast:
_fast.ApplyColormap_swigregister(ApplyColormap)

def ApplyColormap_New() -> "std::shared_ptr< fast::ApplyColormap >":
    return _fast.ApplyColormap_New()

def ApplyColormap_getStaticNameOfClass() -> "std::string":
    return _fast.ApplyColormap_getStaticNameOfClass()

def ApplyColormap_create(*args, **kwargs) -> "std::shared_ptr< fast::ApplyColormap >":
    r"""
    Create instance
    :type colormap: :py:class:`Colormap`
    :param colormap: Colormap to apply
    :type opacity: float
    :param opacity: Apply colormap with an opacity.
             If the colormap already has opacity, this opacity will be multiplied with the existing opacity.
    :type minValue: float
    :param minValue: Set the minimum value of the input data to scale the colormap to. This is only used
             on intensity invariant colormaps. If not set, the true minimum value of the input data is used.
    :type maxValue: float
    :param maxValue: Set the maximum value of the input data to scale the colormap to. This is only used
             on intensity invariant colormaps. If not set, the true maximum value of the input data is used.
    :rtype: :py:class:`ApplyColormap`
    :return: instance
    """
    return _fast.ApplyColormap_create(*args, **kwargs)

class BinaryThresholding(ProcessObject):
    r"""
    Segmentation using a threshold value

    Any pixel with intensity between lower and upper threshold is labeled as 1, the rest is background 0.

    Inputs:
    - 0: Image

    Outputs:
    - 0: Image segmentation

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BinaryThresholding >":
        return _fast.BinaryThresholding_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BinaryThresholding_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BinaryThresholding_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::BinaryThresholding >":
        return _fast.BinaryThresholding_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::BinaryThresholding >":
        r"""
        Create instance
        :type lowerThreshold: float
        :param lowerThreshold: All pixels with an intensity above this threshold will be segmented
        :type upperThreshold: float
        :param upperThreshold: All pixels with intensity below this threshold will be segmented
        :rtype: :py:class:`BinaryThresholding`
        :return: instance
        """
        return _fast.BinaryThresholding_create(*args, **kwargs)

    def setLowerThreshold(self, threshold: "float") -> "void":
        return _fast.BinaryThresholding_setLowerThreshold(self, threshold)

    def setUpperThreshold(self, threshold: "float") -> "void":
        return _fast.BinaryThresholding_setUpperThreshold(self, threshold)

    def loadAttributes(self) -> "void":
        return _fast.BinaryThresholding_loadAttributes(self)
    __swig_destroy__ = _fast.delete_BinaryThresholding

# Register BinaryThresholding in _fast:
_fast.BinaryThresholding_swigregister(BinaryThresholding)

def BinaryThresholding_New() -> "std::shared_ptr< fast::BinaryThresholding >":
    return _fast.BinaryThresholding_New()

def BinaryThresholding_getStaticNameOfClass() -> "std::string":
    return _fast.BinaryThresholding_getStaticNameOfClass()

def BinaryThresholding_create(*args, **kwargs) -> "std::shared_ptr< fast::BinaryThresholding >":
    r"""
    Create instance
    :type lowerThreshold: float
    :param lowerThreshold: All pixels with an intensity above this threshold will be segmented
    :type upperThreshold: float
    :param upperThreshold: All pixels with intensity below this threshold will be segmented
    :rtype: :py:class:`BinaryThresholding`
    :return: instance
    """
    return _fast.BinaryThresholding_create(*args, **kwargs)

MatchingMetric_NORMALIZED_CROSS_CORRELATION = _fast.MatchingMetric_NORMALIZED_CROSS_CORRELATION
MatchingMetric_SUM_OF_SQUARED_DIFFERENCES = _fast.MatchingMetric_SUM_OF_SQUARED_DIFFERENCES
MatchingMetric_SUM_OF_ABSOLUTE_DIFFERENCES = _fast.MatchingMetric_SUM_OF_ABSOLUTE_DIFFERENCES
class BlockMatching(ProcessObject):
    r"""
    Block matching tracking of an image stream.

    2D block matching on the GPU. Input is a stream of input images, output is a stream of images
    with 2 channels giving the x,y motion of each pixel.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BlockMatching >":
        return _fast.BlockMatching_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BlockMatching_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BlockMatching_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::BlockMatching >":
        return _fast.BlockMatching_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::BlockMatching >":
        r"""
        Create instance
        :type blockSize: int
        :param blockSize: Must be odd.
        :type searchSize: int
        :param searchSize: Must be odd.
        :type metric: int
        :param metric: Similarity metric to use
        :type forwardBackwardTracking: boolean
        :param forwardBackwardTracking: Do forward-backward tracking and take average of the two. Will be slover.
        :type timeLag: int
        :param timeLag: How many frames to skip when comparing. Default is 1, comarping frame t vs frame t-1.
        :rtype: :py:class:`BlockMatching`
        :return: instance
        """
        return _fast.BlockMatching_create(*args, **kwargs)

    @staticmethod
    def stringToMetric(name: "std::string") -> "fast::MatchingMetric":
        r"""
        Convert string of metric to type
        :type name: string
        :param name:
        :rtype: int
        :return: MatchingMetric
        """
        return _fast.BlockMatching_stringToMetric(name)

    def setMatchingMetric(self, type: "fast::MatchingMetric") -> "void":
        r"""
        Select which matching metric to use
        :type type: int
        :param type:
        """
        return _fast.BlockMatching_setMatchingMetric(self, type)

    def setBlockSize(self, size: "int") -> "void":
        r"""
        Set size of the blocks to match. Has to be odd
        :type size: int
        :param size:
        """
        return _fast.BlockMatching_setBlockSize(self, size)

    def setSearchSize(self, size: "int") -> "void":
        r"""
        Set size of search grid around x,y. Has to be odd
        :type size: int
        :param size:
        """
        return _fast.BlockMatching_setSearchSize(self, size)

    def setIntensityThreshold(self, value: "float") -> "void":
        r"""
        Set an intensity threshold, do not do block matching on pixels where the mean of the block is below this threhsold.
        :type value: float
        :param value:
        """
        return _fast.BlockMatching_setIntensityThreshold(self, value)

    def setTimeLag(self, timeLag: "int") -> "void":
        r"""
        Set time lag of block matching. A time lag of 2 will use frame t, and t-2 for block matching. Default is 1
        :type timeLag: int
        :param timeLag:
        """
        return _fast.BlockMatching_setTimeLag(self, timeLag)

    def setForwardBackwardTracking(self, forwardBackward: "bool") -> "void":
        r"""
        Set whether to use forward-backward tracking or not. Disabled by default.
        :type forwardBackward: boolean
        :param forwardBackward:
        """
        return _fast.BlockMatching_setForwardBackwardTracking(self, forwardBackward)

    def setRegionOfInterest(self, offset: "Vector2i", size: "Vector2i") -> "void":
        r"""
        Set a region of interest (ROI) to run the block matching in.
        :type offset: Vector2i
        :param offset: from origin to start the ROI in pixels
        :type size: Vector2i
        :param size: of the ROI in pixels
        """
        return _fast.BlockMatching_setRegionOfInterest(self, offset, size)

    def loadAttributes(self) -> "void":
        return _fast.BlockMatching_loadAttributes(self)
    __swig_destroy__ = _fast.delete_BlockMatching

# Register BlockMatching in _fast:
_fast.BlockMatching_swigregister(BlockMatching)

def BlockMatching_New() -> "std::shared_ptr< fast::BlockMatching >":
    return _fast.BlockMatching_New()

def BlockMatching_getStaticNameOfClass() -> "std::string":
    return _fast.BlockMatching_getStaticNameOfClass()

def BlockMatching_create(*args, **kwargs) -> "std::shared_ptr< fast::BlockMatching >":
    r"""
    Create instance
    :type blockSize: int
    :param blockSize: Must be odd.
    :type searchSize: int
    :param searchSize: Must be odd.
    :type metric: int
    :param metric: Similarity metric to use
    :type forwardBackwardTracking: boolean
    :param forwardBackwardTracking: Do forward-backward tracking and take average of the two. Will be slover.
    :type timeLag: int
    :param timeLag: How many frames to skip when comparing. Default is 1, comarping frame t vs frame t-1.
    :rtype: :py:class:`BlockMatching`
    :return: instance
    """
    return _fast.BlockMatching_create(*args, **kwargs)

def BlockMatching_stringToMetric(name: "std::string") -> "fast::MatchingMetric":
    r"""
    Convert string of metric to type
    :type name: string
    :param name:
    :rtype: int
    :return: MatchingMetric
    """
    return _fast.BlockMatching_stringToMetric(name)

class CenterlineExtraction(ProcessObject):
    r"""
    Extract centerline from 3D image segmentation

    Uses fast marching algorithm for centerline extraction.
    Based on the algorithm described in the article
    "FAST 3D CENTERLINE COMPUTATION FOR TUBULAR STRUCTURES BY FRONT COLLAPSING AND FAST MARCHING" by Crdenes et al. 2010.

    Inputs:
    - 0: Image 3D segmentation

    Outputs:
    - 0: Mesh centerlines

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::CenterlineExtraction >":
        return _fast.CenterlineExtraction_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.CenterlineExtraction_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.CenterlineExtraction_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::CenterlineExtraction >":
        return _fast.CenterlineExtraction_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::CenterlineExtraction >":
        r"""
        Create instance
        :rtype: :py:class:`CenterlineExtraction`
        :return: instance
        """
        return _fast.CenterlineExtraction_create()
    __swig_destroy__ = _fast.delete_CenterlineExtraction

# Register CenterlineExtraction in _fast:
_fast.CenterlineExtraction_swigregister(CenterlineExtraction)

def CenterlineExtraction_New() -> "std::shared_ptr< fast::CenterlineExtraction >":
    return _fast.CenterlineExtraction_New()

def CenterlineExtraction_getStaticNameOfClass() -> "std::string":
    return _fast.CenterlineExtraction_getStaticNameOfClass()

def CenterlineExtraction_create() -> "std::shared_ptr< fast::CenterlineExtraction >":
    r"""
    Create instance
    :rtype: :py:class:`CenterlineExtraction`
    :return: instance
    """
    return _fast.CenterlineExtraction_create()

class CoherentPointDrift(ProcessObject):
    r"""Abstract base class for Coherent Point Drift (CPD) registration"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    RIGID = _fast.CoherentPointDrift_RIGID
    AFFINE = _fast.CoherentPointDrift_AFFINE
    NONRIGID = _fast.CoherentPointDrift_NONRIGID

    def setFixedMeshPort(self, port: "fast::DataChannel::pointer") -> "void":
        return _fast.CoherentPointDrift_setFixedMeshPort(self, port)

    def setFixedMesh(self, data: "Mesh::pointer") -> "void":
        return _fast.CoherentPointDrift_setFixedMesh(self, data)

    def setMovingMeshPort(self, port: "fast::DataChannel::pointer") -> "void":
        return _fast.CoherentPointDrift_setMovingMeshPort(self, port)

    def setMovingMesh(self, data: "Mesh::pointer") -> "void":
        return _fast.CoherentPointDrift_setMovingMesh(self, data)

    def setMaximumIterations(self, maxIterations: "unsigned char") -> "void":
        return _fast.CoherentPointDrift_setMaximumIterations(self, maxIterations)

    def setUniformWeight(self, uniformWeight: "float") -> "void":
        return _fast.CoherentPointDrift_setUniformWeight(self, uniformWeight)

    def setTolerance(self, tolerance: "double") -> "void":
        return _fast.CoherentPointDrift_setTolerance(self, tolerance)

    def getOutputTransformation(self) -> "fast::Transform::pointer":
        return _fast.CoherentPointDrift_getOutputTransformation(self)

    def initializeVarianceAndMore(self) -> "void":
        return _fast.CoherentPointDrift_initializeVarianceAndMore(self)

    def expectation(self, fixedPoints: "MatrixXf &", movingPoints: "MatrixXf &") -> "void":
        return _fast.CoherentPointDrift_expectation(self, fixedPoints, movingPoints)

    def maximization(self, fixedPoints: "MatrixXf &", movingPoints: "MatrixXf &") -> "void":
        return _fast.CoherentPointDrift_maximization(self, fixedPoints, movingPoints)
    __swig_destroy__ = _fast.delete_CoherentPointDrift

# Register CoherentPointDrift in _fast:
_fast.CoherentPointDrift_swigregister(CoherentPointDrift)

class CoherentPointDriftAffine(CoherentPointDrift):
    r"""
    Affine coherent point drift registration


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::CoherentPointDriftAffine >":
        return _fast.CoherentPointDriftAffine_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.CoherentPointDriftAffine_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.CoherentPointDriftAffine_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::CoherentPointDriftAffine >":
        return _fast.CoherentPointDriftAffine_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::CoherentPointDriftAffine >":
        return _fast.CoherentPointDriftAffine_create()

    def connectFixed(self, *args) -> "std::shared_ptr< fast::CoherentPointDriftAffine >":
        return _fast.CoherentPointDriftAffine_connectFixed(self, *args)

    def connectMoving(self, *args) -> "std::shared_ptr< fast::CoherentPointDriftAffine >":
        return _fast.CoherentPointDriftAffine_connectMoving(self, *args)

    def initializeVarianceAndMore(self) -> "void":
        return _fast.CoherentPointDriftAffine_initializeVarianceAndMore(self)

    def maximization(self, fixedPoints: "MatrixXf &", movingPoints: "MatrixXf &") -> "void":
        return _fast.CoherentPointDriftAffine_maximization(self, fixedPoints, movingPoints)
    __swig_destroy__ = _fast.delete_CoherentPointDriftAffine

# Register CoherentPointDriftAffine in _fast:
_fast.CoherentPointDriftAffine_swigregister(CoherentPointDriftAffine)

def CoherentPointDriftAffine_New() -> "std::shared_ptr< fast::CoherentPointDriftAffine >":
    return _fast.CoherentPointDriftAffine_New()

def CoherentPointDriftAffine_getStaticNameOfClass() -> "std::string":
    return _fast.CoherentPointDriftAffine_getStaticNameOfClass()

def CoherentPointDriftAffine_create() -> "std::shared_ptr< fast::CoherentPointDriftAffine >":
    return _fast.CoherentPointDriftAffine_create()

class CoherentPointDriftRigid(CoherentPointDrift):
    r"""
    Rigid coherent point drift registration


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::CoherentPointDriftRigid >":
        return _fast.CoherentPointDriftRigid_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.CoherentPointDriftRigid_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.CoherentPointDriftRigid_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::CoherentPointDriftRigid >":
        return _fast.CoherentPointDriftRigid_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::CoherentPointDriftRigid >":
        return _fast.CoherentPointDriftRigid_create()

    def connectFixed(self, *args) -> "std::shared_ptr< fast::CoherentPointDriftRigid >":
        return _fast.CoherentPointDriftRigid_connectFixed(self, *args)

    def connectMoving(self, *args) -> "std::shared_ptr< fast::CoherentPointDriftRigid >":
        return _fast.CoherentPointDriftRigid_connectMoving(self, *args)

    def maximization(self, fixedPoints: "MatrixXf &", movingPoints: "MatrixXf &") -> "void":
        return _fast.CoherentPointDriftRigid_maximization(self, fixedPoints, movingPoints)

    def initializeVarianceAndMore(self) -> "void":
        return _fast.CoherentPointDriftRigid_initializeVarianceAndMore(self)
    __swig_destroy__ = _fast.delete_CoherentPointDriftRigid

# Register CoherentPointDriftRigid in _fast:
_fast.CoherentPointDriftRigid_swigregister(CoherentPointDriftRigid)

def CoherentPointDriftRigid_New() -> "std::shared_ptr< fast::CoherentPointDriftRigid >":
    return _fast.CoherentPointDriftRigid_New()

def CoherentPointDriftRigid_getStaticNameOfClass() -> "std::string":
    return _fast.CoherentPointDriftRigid_getStaticNameOfClass()

def CoherentPointDriftRigid_create() -> "std::shared_ptr< fast::CoherentPointDriftRigid >":
    return _fast.CoherentPointDriftRigid_create()

class GrayscaleToColor(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::GrayscaleToColor >":
        return _fast.GrayscaleToColor_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.GrayscaleToColor_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.GrayscaleToColor_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::GrayscaleToColor >":
        return _fast.GrayscaleToColor_connect(self, *args)

    @staticmethod
    def create(addAlphaChannel: "bool"=False) -> "std::shared_ptr< fast::GrayscaleToColor >":
        return _fast.GrayscaleToColor_create(addAlphaChannel)
    __swig_destroy__ = _fast.delete_GrayscaleToColor

# Register GrayscaleToColor in _fast:
_fast.GrayscaleToColor_swigregister(GrayscaleToColor)

def GrayscaleToColor_New() -> "std::shared_ptr< fast::GrayscaleToColor >":
    return _fast.GrayscaleToColor_New()

def GrayscaleToColor_getStaticNameOfClass() -> "std::string":
    return _fast.GrayscaleToColor_getStaticNameOfClass()

def GrayscaleToColor_create(addAlphaChannel: "bool"=False) -> "std::shared_ptr< fast::GrayscaleToColor >":
    return _fast.GrayscaleToColor_create(addAlphaChannel)

class ColorToGrayscale(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ColorToGrayscale >":
        return _fast.ColorToGrayscale_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ColorToGrayscale_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ColorToGrayscale_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ColorToGrayscale >":
        return _fast.ColorToGrayscale_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::ColorToGrayscale >":
        return _fast.ColorToGrayscale_create()
    __swig_destroy__ = _fast.delete_ColorToGrayscale

# Register ColorToGrayscale in _fast:
_fast.ColorToGrayscale_swigregister(ColorToGrayscale)

def ColorToGrayscale_New() -> "std::shared_ptr< fast::ColorToGrayscale >":
    return _fast.ColorToGrayscale_New()

def ColorToGrayscale_getStaticNameOfClass() -> "std::string":
    return _fast.ColorToGrayscale_getStaticNameOfClass()

def ColorToGrayscale_create() -> "std::shared_ptr< fast::ColorToGrayscale >":
    return _fast.ColorToGrayscale_create()

class DrawCubicHermiteSpline(ProcessObject):
    r"""
    Draw cubic hermite splines on an input Image

    Inputs:
    - 0: Image

    Outputs
    - 0: Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::DrawCubicHermiteSpline >":
        return _fast.DrawCubicHermiteSpline_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.DrawCubicHermiteSpline_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DrawCubicHermiteSpline_getStaticNameOfClass()
    CloseSpline_No = _fast.DrawCubicHermiteSpline_CloseSpline_No
    CloseSpline_Smooth = _fast.DrawCubicHermiteSpline_CloseSpline_Smooth
    CloseSpline_Straight = _fast.DrawCubicHermiteSpline_CloseSpline_Straight

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::DrawCubicHermiteSpline >":
        r"""
        Create instance

        :type controlPoints: std::vector< Vector2f,std::allocator< Vector2f > >
        :param controlPoints:
        :type close: int
        :param close:
        :type value: float
        :param value:
        :type color: :py:class:`Color`
        :param color:
        :type fill: boolean
        :param fill:
        :type controlPointsInPixels: boolean
        :param controlPointsInPixels:
        :rtype: :py:class:`DrawCubicHermiteSpline`
        :return: instance
        """
        return _fast.DrawCubicHermiteSpline_create(*args, **kwargs)

    def setControlPoints(self, controlPoints: "std::vector< Vector2f,std::allocator< Vector2f > >") -> "void":
        return _fast.DrawCubicHermiteSpline_setControlPoints(self, controlPoints)
    __swig_destroy__ = _fast.delete_DrawCubicHermiteSpline

# Register DrawCubicHermiteSpline in _fast:
_fast.DrawCubicHermiteSpline_swigregister(DrawCubicHermiteSpline)

def DrawCubicHermiteSpline_New() -> "std::shared_ptr< fast::DrawCubicHermiteSpline >":
    return _fast.DrawCubicHermiteSpline_New()

def DrawCubicHermiteSpline_getStaticNameOfClass() -> "std::string":
    return _fast.DrawCubicHermiteSpline_getStaticNameOfClass()

def DrawCubicHermiteSpline_create(*args, **kwargs) -> "std::shared_ptr< fast::DrawCubicHermiteSpline >":
    r"""
    Create instance

    :type controlPoints: std::vector< Vector2f,std::allocator< Vector2f > >
    :param controlPoints:
    :type close: int
    :param close:
    :type value: float
    :param value:
    :type color: :py:class:`Color`
    :param color:
    :type fill: boolean
    :param fill:
    :type controlPointsInPixels: boolean
    :param controlPointsInPixels:
    :rtype: :py:class:`DrawCubicHermiteSpline`
    :return: instance
    """
    return _fast.DrawCubicHermiteSpline_create(*args, **kwargs)

class FillHoles(ProcessObject):
    r"""
    Fill holes in image/segmentation

    Inputs:
    - 0: Image

    Outputs
    - 0: Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::FillHoles >":
        return _fast.FillHoles_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.FillHoles_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.FillHoles_getStaticNameOfClass()

    @staticmethod
    def create() -> "std::shared_ptr< fast::FillHoles >":
        return _fast.FillHoles_create()
    __swig_destroy__ = _fast.delete_FillHoles

# Register FillHoles in _fast:
_fast.FillHoles_swigregister(FillHoles)

def FillHoles_New() -> "std::shared_ptr< fast::FillHoles >":
    return _fast.FillHoles_New()

def FillHoles_getStaticNameOfClass() -> "std::string":
    return _fast.FillHoles_getStaticNameOfClass()

def FillHoles_create() -> "std::shared_ptr< fast::FillHoles >":
    return _fast.FillHoles_create()

class DrawCircle(ProcessObject):
    r"""
    Draw circles on an input Image

    Inputs:
    - 0: Image

    Outputs
    - 0: Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::DrawCircle >":
        return _fast.DrawCircle_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.DrawCircle_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DrawCircle_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::DrawCircle >":
        r"""
        Create instance

        :type centroids: std::vector< Vector2f,std::allocator< Vector2f > >
        :param centroids: List of centroid coordinates.
        :type radii: std::vector< float,std::allocator< float > >
        :param radii: Radius for each circle/centroid. If only one radius is given, it will be used for all circles.
        :type value: float
        :param value: Value to use to draw circles
        :type color: :py:class:`Color`
        :param color: Color to use to draw circles
        :type fill: boolean
        :param fill: Whether to fill the circle or not
        :type inPixels: boolean
        :param inPixels: Whether the centroids and radii are given in pixels or in millimeters
        :rtype: :py:class:`DrawCircle`
        :return: instance
        """
        return _fast.DrawCircle_create(*args, **kwargs)
    __swig_destroy__ = _fast.delete_DrawCircle

# Register DrawCircle in _fast:
_fast.DrawCircle_swigregister(DrawCircle)

def DrawCircle_New() -> "std::shared_ptr< fast::DrawCircle >":
    return _fast.DrawCircle_New()

def DrawCircle_getStaticNameOfClass() -> "std::string":
    return _fast.DrawCircle_getStaticNameOfClass()

def DrawCircle_create(*args, **kwargs) -> "std::shared_ptr< fast::DrawCircle >":
    r"""
    Create instance

    :type centroids: std::vector< Vector2f,std::allocator< Vector2f > >
    :param centroids: List of centroid coordinates.
    :type radii: std::vector< float,std::allocator< float > >
    :param radii: Radius for each circle/centroid. If only one radius is given, it will be used for all circles.
    :type value: float
    :param value: Value to use to draw circles
    :type color: :py:class:`Color`
    :param color: Color to use to draw circles
    :type fill: boolean
    :param fill: Whether to fill the circle or not
    :type inPixels: boolean
    :param inPixels: Whether the centroids and radii are given in pixels or in millimeters
    :rtype: :py:class:`DrawCircle`
    :return: instance
    """
    return _fast.DrawCircle_create(*args, **kwargs)

class GaussianSmoothing(ProcessObject):
    r"""
    Smoothing by convolution with a Gaussian mask

    Inputs:
    - 0: Image, 2D or 3D

    Outputs:
    - 0: Image, 2D or 3D

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::GaussianSmoothing >":
        return _fast.GaussianSmoothing_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.GaussianSmoothing_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.GaussianSmoothing_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::GaussianSmoothing >":
        return _fast.GaussianSmoothing_connect(self, *args)

    @staticmethod
    def create(stdDev: "float"=0.5, maskSize: "uchar"=0) -> "std::shared_ptr< fast::GaussianSmoothing >":
        r"""
        Create instance
        :type stdDev: float
        :param stdDev: Standard deviation of convolution kernel
        :type maskSize: uchar
        :param maskSize: Size of convolution filter/mask. Must be odd.
                 If 0 filter size is determined automatically from standard deviation
        :rtype: :py:class:`GaussianSmoothing`
        :return: instance
        """
        return _fast.GaussianSmoothing_create(stdDev, maskSize)

    def setMaskSize(self, maskSize: "unsigned char") -> "void":
        return _fast.GaussianSmoothing_setMaskSize(self, maskSize)

    def setStandardDeviation(self, stdDev: "float") -> "void":
        return _fast.GaussianSmoothing_setStandardDeviation(self, stdDev)

    def setOutputType(self, type: "fast::DataType") -> "void":
        return _fast.GaussianSmoothing_setOutputType(self, type)

    def loadAttributes(self) -> "void":
        return _fast.GaussianSmoothing_loadAttributes(self)
    __swig_destroy__ = _fast.delete_GaussianSmoothing

# Register GaussianSmoothing in _fast:
_fast.GaussianSmoothing_swigregister(GaussianSmoothing)

def GaussianSmoothing_New() -> "std::shared_ptr< fast::GaussianSmoothing >":
    return _fast.GaussianSmoothing_New()

def GaussianSmoothing_getStaticNameOfClass() -> "std::string":
    return _fast.GaussianSmoothing_getStaticNameOfClass()

def GaussianSmoothing_create(stdDev: "float"=0.5, maskSize: "uchar"=0) -> "std::shared_ptr< fast::GaussianSmoothing >":
    r"""
    Create instance
    :type stdDev: float
    :param stdDev: Standard deviation of convolution kernel
    :type maskSize: uchar
    :param maskSize: Size of convolution filter/mask. Must be odd.
             If 0 filter size is determined automatically from standard deviation
    :rtype: :py:class:`GaussianSmoothing`
    :return: instance
    """
    return _fast.GaussianSmoothing_create(stdDev, maskSize)

class EulerGradientVectorFlow(ProcessObject):
    r"""
    Gradient vector flow using Euler method

    Gradient vector flow is a spatial diffusion of vectors often used for segmentation.
    This 2D/3D GPU implementation is described in the article "Real-time gradient vector flow on GPUs using OpenCL"
    by Smistad et. al 2015: https://www.eriksmistad.no/wp-content/uploads/gpu_gradient_vector_flow_opencl.pdf

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::EulerGradientVectorFlow >":
        return _fast.EulerGradientVectorFlow_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.EulerGradientVectorFlow_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.EulerGradientVectorFlow_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::EulerGradientVectorFlow >":
        return _fast.EulerGradientVectorFlow_connect(self, *args)

    @staticmethod
    def create(mu: "float"=0.05, iterations: "uint"=0, use16bitStorage: "bool"=True) -> "std::shared_ptr< fast::EulerGradientVectorFlow >":
        r"""
        Create instance
        :type mu: float
        :param mu:
        :type iterations: int
        :param iterations:
        :type use16bitStorage: boolean
        :param use16bitStorage:
        :rtype: :py:class:`EulerGradientVectorFlow`
        :return: 
        """
        return _fast.EulerGradientVectorFlow_create(mu, iterations, use16bitStorage)

    def setIterations(self, iterations: "uint") -> "void":
        return _fast.EulerGradientVectorFlow_setIterations(self, iterations)

    def setMuConstant(self, mu: "float") -> "void":
        return _fast.EulerGradientVectorFlow_setMuConstant(self, mu)

    def getMuConstant(self) -> "float":
        return _fast.EulerGradientVectorFlow_getMuConstant(self)

    def set16bitStorageFormat(self) -> "void":
        r"""
        Use 16 bit format internally to reduce memory usage and
        increase performance.
        This will slightly reduce accuracy/convergence.
        """
        return _fast.EulerGradientVectorFlow_set16bitStorageFormat(self)

    def set32bitStorageFormat(self) -> "void":
        r"""Use 32 bit format internally instead of 16 bit."""
        return _fast.EulerGradientVectorFlow_set32bitStorageFormat(self)
    __swig_destroy__ = _fast.delete_EulerGradientVectorFlow

# Register EulerGradientVectorFlow in _fast:
_fast.EulerGradientVectorFlow_swigregister(EulerGradientVectorFlow)

def EulerGradientVectorFlow_New() -> "std::shared_ptr< fast::EulerGradientVectorFlow >":
    return _fast.EulerGradientVectorFlow_New()

def EulerGradientVectorFlow_getStaticNameOfClass() -> "std::string":
    return _fast.EulerGradientVectorFlow_getStaticNameOfClass()

def EulerGradientVectorFlow_create(mu: "float"=0.05, iterations: "uint"=0, use16bitStorage: "bool"=True) -> "std::shared_ptr< fast::EulerGradientVectorFlow >":
    r"""
    Create instance
    :type mu: float
    :param mu:
    :type iterations: int
    :param iterations:
    :type use16bitStorage: boolean
    :param use16bitStorage:
    :rtype: :py:class:`EulerGradientVectorFlow`
    :return: 
    """
    return _fast.EulerGradientVectorFlow_create(mu, iterations, use16bitStorage)

class MultigridGradientVectorFlow(ProcessObject):
    r"""
    Gradient vector flow using the multigrid method

    This is only implemented for 3D.
    Gradient vector flow is a spatial diffusion of vectors often used for segmentation.
    This 3D GPU implementation is described in the article "Multigrid gradient vector flow computation on the GPU"
    by Smistad et. al 2014: https://www.eriksmistad.no/wp-content/uploads/multigrid_gradient_vector_flow_computation_on_the_gpu.pdf

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MultigridGradientVectorFlow >":
        return _fast.MultigridGradientVectorFlow_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MultigridGradientVectorFlow_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MultigridGradientVectorFlow_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::MultigridGradientVectorFlow >":
        return _fast.MultigridGradientVectorFlow_connect(self, *args)

    @staticmethod
    def create(mu: "float"=0.1, iterations: "uint"=10, use16BitStorage: "bool"=True) -> "std::shared_ptr< fast::MultigridGradientVectorFlow >":
        r"""
        Create instance
        :type mu: float
        :param mu:
        :type iterations: int
        :param iterations:
        :type use16BitStorage: boolean
        :param use16BitStorage:
        :rtype: :py:class:`MultigridGradientVectorFlow`
        :return: instance
        """
        return _fast.MultigridGradientVectorFlow_create(mu, iterations, use16BitStorage)

    def setIterations(self, iterations: "uint") -> "void":
        return _fast.MultigridGradientVectorFlow_setIterations(self, iterations)

    def setMuConstant(self, mu: "float") -> "void":
        return _fast.MultigridGradientVectorFlow_setMuConstant(self, mu)

    def getMuConstant(self) -> "float":
        return _fast.MultigridGradientVectorFlow_getMuConstant(self)

    def set16bitStorageFormat(self) -> "void":
        r"""
        Use 16 bit format internally to reduce memory usage and
        increase performance.
        This will slightly reduce accuracy/convergence.
        """
        return _fast.MultigridGradientVectorFlow_set16bitStorageFormat(self)

    def set32bitStorageFormat(self) -> "void":
        r"""Use 32 bit format internally instead of 16 bit."""
        return _fast.MultigridGradientVectorFlow_set32bitStorageFormat(self)
    __swig_destroy__ = _fast.delete_MultigridGradientVectorFlow

# Register MultigridGradientVectorFlow in _fast:
_fast.MultigridGradientVectorFlow_swigregister(MultigridGradientVectorFlow)

def MultigridGradientVectorFlow_New() -> "std::shared_ptr< fast::MultigridGradientVectorFlow >":
    return _fast.MultigridGradientVectorFlow_New()

def MultigridGradientVectorFlow_getStaticNameOfClass() -> "std::string":
    return _fast.MultigridGradientVectorFlow_getStaticNameOfClass()

def MultigridGradientVectorFlow_create(mu: "float"=0.1, iterations: "uint"=10, use16BitStorage: "bool"=True) -> "std::shared_ptr< fast::MultigridGradientVectorFlow >":
    r"""
    Create instance
    :type mu: float
    :param mu:
    :type iterations: int
    :param iterations:
    :type use16BitStorage: boolean
    :param use16BitStorage:
    :rtype: :py:class:`MultigridGradientVectorFlow`
    :return: instance
    """
    return _fast.MultigridGradientVectorFlow_create(mu, iterations, use16BitStorage)

class HounsefieldConverter(ProcessObject):
    r"""
    Converts input image to Hounsefield units (if needed)

    Hounsefield units used in CT are defined as signed 16 bit integers from -1024 and up.
    This PO simply converts UINT16 input images to INT16 and subtracts 1024 from each voxel.
    If the input image already is INT16, it will only pass to input to the output.

    Inputs:
    - 0: Image 3D INT16 or UINT16

    Outputs:
    - 0: Image 3D INT16
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::HounsefieldConverter >":
        return _fast.HounsefieldConverter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.HounsefieldConverter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.HounsefieldConverter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::HounsefieldConverter >":
        return _fast.HounsefieldConverter_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::HounsefieldConverter >":
        r"""
        Create instance
        :rtype: :py:class:`HounsefieldConverter`
        :return: instance
        """
        return _fast.HounsefieldConverter_create()
    __swig_destroy__ = _fast.delete_HounsefieldConverter

# Register HounsefieldConverter in _fast:
_fast.HounsefieldConverter_swigregister(HounsefieldConverter)

def HounsefieldConverter_New() -> "std::shared_ptr< fast::HounsefieldConverter >":
    return _fast.HounsefieldConverter_New()

def HounsefieldConverter_getStaticNameOfClass() -> "std::string":
    return _fast.HounsefieldConverter_getStaticNameOfClass()

def HounsefieldConverter_create() -> "std::shared_ptr< fast::HounsefieldConverter >":
    r"""
    Create instance
    :rtype: :py:class:`HounsefieldConverter`
    :return: instance
    """
    return _fast.HounsefieldConverter_create()

class ImageAdd(ProcessObject):
    r"""Add two images"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageAdd >":
        return _fast.ImageAdd_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageAdd_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageAdd_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageAdd >":
        return _fast.ImageAdd_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::ImageAdd >":
        r"""
        Create instance
        :rtype: :py:class:`ImageAdd`
        :return: instance
        """
        return _fast.ImageAdd_create()
    __swig_destroy__ = _fast.delete_ImageAdd

# Register ImageAdd in _fast:
_fast.ImageAdd_swigregister(ImageAdd)

def ImageAdd_New() -> "std::shared_ptr< fast::ImageAdd >":
    return _fast.ImageAdd_New()

def ImageAdd_getStaticNameOfClass() -> "std::string":
    return _fast.ImageAdd_getStaticNameOfClass()

def ImageAdd_create() -> "std::shared_ptr< fast::ImageAdd >":
    r"""
    Create instance
    :rtype: :py:class:`ImageAdd`
    :return: instance
    """
    return _fast.ImageAdd_create()

class ImageCaster(ProcessObject):
    r"""
    Cast image to another data type

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageCaster >":
        return _fast.ImageCaster_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageCaster_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageCaster_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageCaster >":
        return _fast.ImageCaster_connect(self, *args)

    @staticmethod
    def create(outputType: "fast::DataType", scaleFactor: "float"=1.0) -> "std::shared_ptr< fast::ImageCaster >":
        r"""
        Create instance
        :type outputType: int
        :param outputType: The data type to cast the input image to
        :type scaleFactor: float
        :param scaleFactor: Value to multiply each pixel with when casting to other type
        :rtype: :py:class:`ImageCaster`
        :return: instance
        """
        return _fast.ImageCaster_create(outputType, scaleFactor)
    __swig_destroy__ = _fast.delete_ImageCaster

# Register ImageCaster in _fast:
_fast.ImageCaster_swigregister(ImageCaster)

def ImageCaster_New() -> "std::shared_ptr< fast::ImageCaster >":
    return _fast.ImageCaster_New()

def ImageCaster_getStaticNameOfClass() -> "std::string":
    return _fast.ImageCaster_getStaticNameOfClass()

def ImageCaster_create(outputType: "fast::DataType", scaleFactor: "float"=1.0) -> "std::shared_ptr< fast::ImageCaster >":
    r"""
    Create instance
    :type outputType: int
    :param outputType: The data type to cast the input image to
    :type scaleFactor: float
    :param scaleFactor: Value to multiply each pixel with when casting to other type
    :rtype: :py:class:`ImageCaster`
    :return: instance
    """
    return _fast.ImageCaster_create(outputType, scaleFactor)

class ImageChannelConverter(ProcessObject):
    r"""
    Remove and/or reverse channels from an image

    Inputs:
    - 0: Image

    Outputs:
    - 0: Image
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageChannelConverter >":
        return _fast.ImageChannelConverter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageChannelConverter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageChannelConverter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageChannelConverter >":
        return _fast.ImageChannelConverter_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::ImageChannelConverter >":
        r"""
        Create instance
        :type channelsToRemove: std::vector< int,std::allocator< int > >
        :param channelsToRemove: List of image channels to remove
        :type reverse: boolean
        :param reverse: Whether to reverse image channels or not. E.g. converting BGR to RGB.
        :rtype: :py:class:`ImageChannelConverter`
        :return: instance
        """
        return _fast.ImageChannelConverter_create(*args, **kwargs)

    def setChannelsToRemove(self, channel1: "bool", channel2: "bool", channel3: "bool", channel4: "bool") -> "void":
        return _fast.ImageChannelConverter_setChannelsToRemove(self, channel1, channel2, channel3, channel4)

    def setReverseChannels(self, reverse: "bool") -> "void":
        return _fast.ImageChannelConverter_setReverseChannels(self, reverse)

    def execute(self) -> "void":
        return _fast.ImageChannelConverter_execute(self)
    __swig_destroy__ = _fast.delete_ImageChannelConverter

# Register ImageChannelConverter in _fast:
_fast.ImageChannelConverter_swigregister(ImageChannelConverter)

def ImageChannelConverter_New() -> "std::shared_ptr< fast::ImageChannelConverter >":
    return _fast.ImageChannelConverter_New()

def ImageChannelConverter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageChannelConverter_getStaticNameOfClass()

def ImageChannelConverter_create(*args, **kwargs) -> "std::shared_ptr< fast::ImageChannelConverter >":
    r"""
    Create instance
    :type channelsToRemove: std::vector< int,std::allocator< int > >
    :param channelsToRemove: List of image channels to remove
    :type reverse: boolean
    :param reverse: Whether to reverse image channels or not. E.g. converting BGR to RGB.
    :rtype: :py:class:`ImageChannelConverter`
    :return: instance
    """
    return _fast.ImageChannelConverter_create(*args, **kwargs)

class ImageCropper(ProcessObject):
    r"""
    Process object from cropping an image

    Uses Image::crop
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageCropper >":
        return _fast.ImageCropper_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageCropper_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageCropper_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageCropper >":
        return _fast.ImageCropper_connect(self, *args)

    def setOffset(self, offset: "VectorXi") -> "void":
        return _fast.ImageCropper_setOffset(self, offset)

    def setSize(self, size: "VectorXi") -> "void":
        return _fast.ImageCropper_setSize(self, size)

    def allowOutOfBoundsCropping(self, allow: "bool") -> "void":
        r"""
        If out of bounds cropping is allowed, offset can be negative and size can be larger than image.
        Any pixels outside of image will be replaced with 0.
        """
        return _fast.ImageCropper_allowOutOfBoundsCropping(self, allow)

    def setCropBottom(self, fraction: "float") -> "void":
        return _fast.ImageCropper_setCropBottom(self, fraction)

    def setCropTop(self, fraction: "float") -> "void":
        return _fast.ImageCropper_setCropTop(self, fraction)


    @classmethod
    def create(cls, size=None, offset=None, cropBottom: Optional[float]=None, cropTop: Optional[float]=None):
        instance = cls()
        if cropBottom is not None:
            instance.setCropBottom(cropBottom)
        elif cropTop is not None:
            instance.setCropTop(cropTop)
        else:
            instance.setSize(size)
            instance.setOffset(offset)

        return instance


    __swig_destroy__ = _fast.delete_ImageCropper

# Register ImageCropper in _fast:
_fast.ImageCropper_swigregister(ImageCropper)

def ImageCropper_New() -> "std::shared_ptr< fast::ImageCropper >":
    return _fast.ImageCropper_New()

def ImageCropper_getStaticNameOfClass() -> "std::string":
    return _fast.ImageCropper_getStaticNameOfClass()

class ImageFlipper(ProcessObject):
    r"""
    Flip images

    Inputs:
    - 0: Image

    Outputs:
    - 0: Image flipped

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageFlipper >":
        return _fast.ImageFlipper_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageFlipper_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageFlipper_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageFlipper >":
        return _fast.ImageFlipper_connect(self, *args)

    @staticmethod
    def create(flipHorizontal: "bool", flipVertical: "bool", flipDepth: "bool"=False) -> "std::shared_ptr< fast::ImageFlipper >":
        r"""
        Create instance
        :type flipHorizontal: boolean
        :param flipHorizontal: Whether to flip horizontally or not
        :type flipVertical: boolean
        :param flipVertical: Whether to flip vertically or not
        :type flipDepth: boolean
        :param flipDepth: Whether to flip depthwise or not (3D only)
        :rtype: :py:class:`ImageFlipper`
        :return: instance
        """
        return _fast.ImageFlipper_create(flipHorizontal, flipVertical, flipDepth)

    def setFlipHorizontal(self, flip: "bool") -> "void":
        return _fast.ImageFlipper_setFlipHorizontal(self, flip)

    def setFlipVertical(self, flip: "bool") -> "void":
        return _fast.ImageFlipper_setFlipVertical(self, flip)

    def setFlipDepth(self, flip: "bool") -> "void":
        return _fast.ImageFlipper_setFlipDepth(self, flip)

    def loadAttributes(self) -> "void":
        return _fast.ImageFlipper_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageFlipper

# Register ImageFlipper in _fast:
_fast.ImageFlipper_swigregister(ImageFlipper)

def ImageFlipper_New() -> "std::shared_ptr< fast::ImageFlipper >":
    return _fast.ImageFlipper_New()

def ImageFlipper_getStaticNameOfClass() -> "std::string":
    return _fast.ImageFlipper_getStaticNameOfClass()

def ImageFlipper_create(flipHorizontal: "bool", flipVertical: "bool", flipDepth: "bool"=False) -> "std::shared_ptr< fast::ImageFlipper >":
    r"""
    Create instance
    :type flipHorizontal: boolean
    :param flipHorizontal: Whether to flip horizontally or not
    :type flipVertical: boolean
    :param flipVertical: Whether to flip vertically or not
    :type flipDepth: boolean
    :param flipDepth: Whether to flip depthwise or not (3D only)
    :rtype: :py:class:`ImageFlipper`
    :return: instance
    """
    return _fast.ImageFlipper_create(flipHorizontal, flipVertical, flipDepth)

class ImageGradient(ProcessObject):
    r"""
    Calculate image gradient using central finite difference method

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageGradient >":
        return _fast.ImageGradient_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageGradient_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageGradient_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageGradient >":
        return _fast.ImageGradient_connect(self, *args)

    @staticmethod
    def create(use16BitFormat: "bool"=False) -> "std::shared_ptr< fast::ImageGradient >":
        r"""
        Create instance
        :type use16BitFormat: boolean
        :param use16BitFormat: Use normalized 16 bit float representation instead of regular 32 bit
        :rtype: :py:class:`ImageGradient`
        :return: instance
        """
        return _fast.ImageGradient_create(use16BitFormat)

    def set16bitStorageFormat(self) -> "void":
        r"""Use 16 bit format to reduce memory usage"""
        return _fast.ImageGradient_set16bitStorageFormat(self)

    def set32bitStorageFormat(self) -> "void":
        r"""Use regular 32 bit float format (default)"""
        return _fast.ImageGradient_set32bitStorageFormat(self)
    __swig_destroy__ = _fast.delete_ImageGradient

# Register ImageGradient in _fast:
_fast.ImageGradient_swigregister(ImageGradient)

def ImageGradient_New() -> "std::shared_ptr< fast::ImageGradient >":
    return _fast.ImageGradient_New()

def ImageGradient_getStaticNameOfClass() -> "std::string":
    return _fast.ImageGradient_getStaticNameOfClass()

def ImageGradient_create(use16BitFormat: "bool"=False) -> "std::shared_ptr< fast::ImageGradient >":
    r"""
    Create instance
    :type use16BitFormat: boolean
    :param use16BitFormat: Use normalized 16 bit float representation instead of regular 32 bit
    :rtype: :py:class:`ImageGradient`
    :return: instance
    """
    return _fast.ImageGradient_create(use16BitFormat)

class ImageInverter(ProcessObject):
    r"""Invert the intensity of an image"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageInverter >":
        return _fast.ImageInverter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageInverter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageInverter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageInverter >":
        return _fast.ImageInverter_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::ImageInverter >":
        r"""
        Create instance
        :rtype: :py:class:`ImageInverter`
        :return: instance
        """
        return _fast.ImageInverter_create()
    __swig_destroy__ = _fast.delete_ImageInverter

# Register ImageInverter in _fast:
_fast.ImageInverter_swigregister(ImageInverter)

def ImageInverter_New() -> "std::shared_ptr< fast::ImageInverter >":
    return _fast.ImageInverter_New()

def ImageInverter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageInverter_getStaticNameOfClass()

def ImageInverter_create() -> "std::shared_ptr< fast::ImageInverter >":
    r"""
    Create instance
    :rtype: :py:class:`ImageInverter`
    :return: instance
    """
    return _fast.ImageInverter_create()

class ImageMultiply(ProcessObject):
    r"""Multiply two images"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageMultiply >":
        return _fast.ImageMultiply_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageMultiply_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageMultiply_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageMultiply >":
        return _fast.ImageMultiply_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::ImageMultiply >":
        r"""
        Create instance
        :rtype: :py:class:`ImageMultiply`
        :return: instance
        """
        return _fast.ImageMultiply_create()
    __swig_destroy__ = _fast.delete_ImageMultiply

# Register ImageMultiply in _fast:
_fast.ImageMultiply_swigregister(ImageMultiply)

def ImageMultiply_New() -> "std::shared_ptr< fast::ImageMultiply >":
    return _fast.ImageMultiply_New()

def ImageMultiply_getStaticNameOfClass() -> "std::string":
    return _fast.ImageMultiply_getStaticNameOfClass()

def ImageMultiply_create() -> "std::shared_ptr< fast::ImageMultiply >":
    r"""
    Create instance
    :rtype: :py:class:`ImageMultiply`
    :return: instance
    """
    return _fast.ImageMultiply_create()

class PatchGenerator(Streamer):
    r"""
    Generates a stream of patches from an ImagePyramid or 3D Image

    The patch generator tiles an ImagePyramid or 3D image into equal sized patches.
    Although the patches can be smaller at the edges if the image size is not dividable by the patch size.
    The result of the processed patches can be stitched together again to form a full
    ImagePyramid/3D Image/Tensor by using the PatchStitcher.


    See also: PatchStitcher
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::PatchGenerator >":
        return _fast.PatchGenerator_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.PatchGenerator_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.PatchGenerator_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::PatchGenerator >":
        return _fast.PatchGenerator_connect(self, *args)

    @staticmethod
    def create(width: "int", height: "int", depth: "int"=1, level: "int"=0, magnification: "float"=-1, overlapPercent: "float"=0.0, maskThreshold: "float"=0.5, paddingValue: "int"=-1) -> "std::shared_ptr< fast::PatchGenerator >":
        r"""
        Creates a PatchGenerator instance
        :type width: int
        :param width: Width of patch (Note: patches can be smaller at boundaries and will be padded)
        :type height: int
        :param height: Height of patch (Note: patches can be smaller at boundaries and will be padded)
        :type depth: int
        :param depth: Depth of patch (Note: patches can be smaller at boundaries and will be padded)
        :type level: int
        :param level: Which level of an ImagePyramid to generate patches from.
        :type magnification: float
        :param magnification: Which magnification to extract patches from.
                 Setting this value for instance to 20, will trigger a search through all levels
                 to find an image pyramid level which is close to 20X magnification (0.0005 mm pixel spacing).
                 If such a level doesn't exist, FAST will look for a higher magnification level (e.g. 40X) and then
                 resize 40X patches to create 20X patches. This will off course come at an increased runtime cost.
                 This parameter overrides the level parameter.
        :type overlapPercent: float
        :param overlapPercent: Amount of patch overlap in percent.
        :type maskThreshold: float
        :param maskThreshold: Threshold to accept a patch if the additional mask is provided.
        :type paddingValue: int
        :param paddingValue: Value to pad patches with when out-of-bounds. Default is negative, meaning it will use
             (white)255 for color images, and (black)0 for grayscale images
        :rtype: :py:class:`PatchGenerator`
        :return: instance
        """
        return _fast.PatchGenerator_create(width, height, depth, level, magnification, overlapPercent, maskThreshold, paddingValue)

    def setPatchSize(self, width: "int", height: "int", depth: "int"=1) -> "void":
        return _fast.PatchGenerator_setPatchSize(self, width, height, depth)

    def setOverlap(self, percent: "float") -> "void":
        r"""
        Set overlap of generated patches, in percent of patch size.
        :type percent: float
        :param percent:
        """
        return _fast.PatchGenerator_setOverlap(self, percent)

    def setPatchLevel(self, level: "int") -> "void":
        return _fast.PatchGenerator_setPatchLevel(self, level)

    def setPatchMagnification(self, magnification: "float") -> "void":
        return _fast.PatchGenerator_setPatchMagnification(self, magnification)

    def setMaskThreshold(self, percent: "float") -> "void":
        return _fast.PatchGenerator_setMaskThreshold(self, percent)

    def setPaddingValue(self, paddingValue: "int") -> "void":
        return _fast.PatchGenerator_setPaddingValue(self, paddingValue)

    def loadAttributes(self) -> "void":
        return _fast.PatchGenerator_loadAttributes(self)

    def getProgress(self) -> "float":
        r"""
        Get progress of this patch generator in percent.
        :rtype: float
        :return: progress in percent 0.0-1.0
        """
        return _fast.PatchGenerator_getProgress(self)
    __swig_destroy__ = _fast.delete_PatchGenerator

# Register PatchGenerator in _fast:
_fast.PatchGenerator_swigregister(PatchGenerator)

def PatchGenerator_New() -> "std::shared_ptr< fast::PatchGenerator >":
    return _fast.PatchGenerator_New()

def PatchGenerator_getStaticNameOfClass() -> "std::string":
    return _fast.PatchGenerator_getStaticNameOfClass()

def PatchGenerator_create(width: "int", height: "int", depth: "int"=1, level: "int"=0, magnification: "float"=-1, overlapPercent: "float"=0.0, maskThreshold: "float"=0.5, paddingValue: "int"=-1) -> "std::shared_ptr< fast::PatchGenerator >":
    r"""
    Creates a PatchGenerator instance
    :type width: int
    :param width: Width of patch (Note: patches can be smaller at boundaries and will be padded)
    :type height: int
    :param height: Height of patch (Note: patches can be smaller at boundaries and will be padded)
    :type depth: int
    :param depth: Depth of patch (Note: patches can be smaller at boundaries and will be padded)
    :type level: int
    :param level: Which level of an ImagePyramid to generate patches from.
    :type magnification: float
    :param magnification: Which magnification to extract patches from.
             Setting this value for instance to 20, will trigger a search through all levels
             to find an image pyramid level which is close to 20X magnification (0.0005 mm pixel spacing).
             If such a level doesn't exist, FAST will look for a higher magnification level (e.g. 40X) and then
             resize 40X patches to create 20X patches. This will off course come at an increased runtime cost.
             This parameter overrides the level parameter.
    :type overlapPercent: float
    :param overlapPercent: Amount of patch overlap in percent.
    :type maskThreshold: float
    :param maskThreshold: Threshold to accept a patch if the additional mask is provided.
    :type paddingValue: int
    :param paddingValue: Value to pad patches with when out-of-bounds. Default is negative, meaning it will use
         (white)255 for color images, and (black)0 for grayscale images
    :rtype: :py:class:`PatchGenerator`
    :return: instance
    """
    return _fast.PatchGenerator_create(width, height, depth, level, magnification, overlapPercent, maskThreshold, paddingValue)

class PatchStitcher(ProcessObject):
    r"""
    Stitch a stream of processed patches from the PatchGenerator

    This process object stitches a stream of processed Image/Tensor patches into an
    ImagePyramid, 2D or 3D Image or Tensor depending on the patch source.

    Inputs:
    0 - Image/Tensor: A stream of processed patches from PatchGenerator
    Outputs:
    0 - ImagePyramid/Image/Tensor: The stitched image/image pyramid.


    See also: PatchGenerator
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::PatchStitcher >":
        return _fast.PatchStitcher_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.PatchStitcher_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.PatchStitcher_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::PatchStitcher >":
        return _fast.PatchStitcher_connect(self, *args)

    @staticmethod
    def create(patchesAreCropped: "bool"=False, forceImagePyramidOutput: "bool"=False) -> "std::shared_ptr< fast::PatchStitcher >":
        r"""
        Create instance
        :type patchesAreCropped: boolean
        :param patchesAreCropped:
        :type forceImagePyramidOutput: boolean
        :param forceImagePyramidOutput: Force output to always be an image pyramid, if source was an image pyramid,
                 even if output is small.
        :rtype: :py:class:`PatchStitcher`
        :return: instance
        """
        return _fast.PatchStitcher_create(patchesAreCropped, forceImagePyramidOutput)

    def loadAttributes(self) -> "void":
        return _fast.PatchStitcher_loadAttributes(self)

    def setPatchesAreCropped(self, cropped: "bool") -> "void":
        r"""
        Set whether incoming patches are cropped or not
        :type cropped: boolean
        :param cropped:
        """
        return _fast.PatchStitcher_setPatchesAreCropped(self, cropped)

    def getPatchesAreCropped(self) -> "bool":
        r"""
        Get whether incoming patches are cropped or not
        :param cropped:
        """
        return _fast.PatchStitcher_getPatchesAreCropped(self)

    def setForceImagePyramidOutput(self, force: "bool") -> "void":
        r"""
        Force output to always be an image pyramid, if source was an image pyramid,
             even if output is small.
        :type force: boolean
        :param force:
        """
        return _fast.PatchStitcher_setForceImagePyramidOutput(self, force)

    def getForceImagePyramidOutput(self) -> "bool":
        r"""
        Get whether output should be forced to be image pyramid
        :rtype: boolean
        :return: 
        """
        return _fast.PatchStitcher_getForceImagePyramidOutput(self)
    __swig_destroy__ = _fast.delete_PatchStitcher

# Register PatchStitcher in _fast:
_fast.PatchStitcher_swigregister(PatchStitcher)

def PatchStitcher_New() -> "std::shared_ptr< fast::PatchStitcher >":
    return _fast.PatchStitcher_New()

def PatchStitcher_getStaticNameOfClass() -> "std::string":
    return _fast.PatchStitcher_getStaticNameOfClass()

def PatchStitcher_create(patchesAreCropped: "bool"=False, forceImagePyramidOutput: "bool"=False) -> "std::shared_ptr< fast::PatchStitcher >":
    r"""
    Create instance
    :type patchesAreCropped: boolean
    :param patchesAreCropped:
    :type forceImagePyramidOutput: boolean
    :param forceImagePyramidOutput: Force output to always be an image pyramid, if source was an image pyramid,
             even if output is small.
    :rtype: :py:class:`PatchStitcher`
    :return: instance
    """
    return _fast.PatchStitcher_create(patchesAreCropped, forceImagePyramidOutput)

class ImageToBatchGenerator(Streamer):
    r"""
    Converts a stream of images into stream of Batch data objects

    This is used for doing batch processing on a stream of images.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageToBatchGenerator >":
        return _fast.ImageToBatchGenerator_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageToBatchGenerator_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageToBatchGenerator_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageToBatchGenerator >":
        return _fast.ImageToBatchGenerator_connect(self, *args)

    @staticmethod
    def create(maxBatchSize: "int") -> "std::shared_ptr< fast::ImageToBatchGenerator >":
        r"""
        Create instance
        :type maxBatchSize: int
        :param maxBatchSize: Maximum batch size
        :rtype: :py:class:`ImageToBatchGenerator`
        :return: instance
        """
        return _fast.ImageToBatchGenerator_create(maxBatchSize)

    def setMaxBatchSize(self, size: "int") -> "void":
        return _fast.ImageToBatchGenerator_setMaxBatchSize(self, size)

    def loadAttributes(self) -> "void":
        return _fast.ImageToBatchGenerator_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageToBatchGenerator

# Register ImageToBatchGenerator in _fast:
_fast.ImageToBatchGenerator_swigregister(ImageToBatchGenerator)

def ImageToBatchGenerator_New() -> "std::shared_ptr< fast::ImageToBatchGenerator >":
    return _fast.ImageToBatchGenerator_New()

def ImageToBatchGenerator_getStaticNameOfClass() -> "std::string":
    return _fast.ImageToBatchGenerator_getStaticNameOfClass()

def ImageToBatchGenerator_create(maxBatchSize: "int") -> "std::shared_ptr< fast::ImageToBatchGenerator >":
    r"""
    Create instance
    :type maxBatchSize: int
    :param maxBatchSize: Maximum batch size
    :rtype: :py:class:`ImageToBatchGenerator`
    :return: instance
    """
    return _fast.ImageToBatchGenerator_create(maxBatchSize)

class ImagePyramidLevelExtractor(ProcessObject):
    r"""
    Extract a level of an image pyramid as an image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImagePyramidLevelExtractor >":
        return _fast.ImagePyramidLevelExtractor_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImagePyramidLevelExtractor_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImagePyramidLevelExtractor_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImagePyramidLevelExtractor >":
        return _fast.ImagePyramidLevelExtractor_connect(self, *args)

    @staticmethod
    def create(level: "int"=-1, magnification: "int"=-1) -> "std::shared_ptr< fast::ImagePyramidLevelExtractor >":
        r"""
        Create instance
        :type level: int
        :param level: Specify which level to extract from image pyramid. Negative level means last level,
                 e.g. lowest resolution(default).
        :type magnification: int
        :param magnification: Which magnification to extract patches from.
                 Setting this value for instance to 20, will trigger a search through all levels
                 to find the image pyramid level which is closest to 20X magnification, 0.0005 mm pixel spacing.
                 If no such level exist an exception is thrown.
                 This parameter overrides the level parameter
        :rtype: :py:class:`ImagePyramidLevelExtractor`
        :return: instance
        """
        return _fast.ImagePyramidLevelExtractor_create(level, magnification)

    def setLevel(self, level: "int") -> "void":
        return _fast.ImagePyramidLevelExtractor_setLevel(self, level)

    def setMagnification(self, magnification: "int") -> "void":
        return _fast.ImagePyramidLevelExtractor_setMagnification(self, magnification)

    def loadAttributes(self) -> "void":
        return _fast.ImagePyramidLevelExtractor_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImagePyramidLevelExtractor

# Register ImagePyramidLevelExtractor in _fast:
_fast.ImagePyramidLevelExtractor_swigregister(ImagePyramidLevelExtractor)

def ImagePyramidLevelExtractor_New() -> "std::shared_ptr< fast::ImagePyramidLevelExtractor >":
    return _fast.ImagePyramidLevelExtractor_New()

def ImagePyramidLevelExtractor_getStaticNameOfClass() -> "std::string":
    return _fast.ImagePyramidLevelExtractor_getStaticNameOfClass()

def ImagePyramidLevelExtractor_create(level: "int"=-1, magnification: "int"=-1) -> "std::shared_ptr< fast::ImagePyramidLevelExtractor >":
    r"""
    Create instance
    :type level: int
    :param level: Specify which level to extract from image pyramid. Negative level means last level,
             e.g. lowest resolution(default).
    :type magnification: int
    :param magnification: Which magnification to extract patches from.
             Setting this value for instance to 20, will trigger a search through all levels
             to find the image pyramid level which is closest to 20X magnification, 0.0005 mm pixel spacing.
             If no such level exist an exception is thrown.
             This parameter overrides the level parameter
    :rtype: :py:class:`ImagePyramidLevelExtractor`
    :return: instance
    """
    return _fast.ImagePyramidLevelExtractor_create(level, magnification)

class ImageResampler(ProcessObject):
    r"""Resample an image to a given spatial resolution"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageResampler >":
        return _fast.ImageResampler_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageResampler_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageResampler_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageResampler >":
        return _fast.ImageResampler_connect(self, *args)

    @staticmethod
    def create(spacingX: "float", spacingY: "float", spacingZ: "float"=-1.0, useInterpolation: "bool"=True) -> "std::shared_ptr< fast::ImageResampler >":
        r"""
        Create instance
        :type spacingX: float
        :param spacingX: Pixel spacing in x direction
        :type spacingY: float
        :param spacingY: Pixel spacing in y direction
        :type spacingZ: float
        :param spacingZ: Pixel spacing in z direction
        :type useInterpolation: boolean
        :param useInterpolation: Whether to use linear interpolation, or just nearest neighbor.
        :rtype: :py:class:`ImageResampler`
        :return: instance
        """
        return _fast.ImageResampler_create(spacingX, spacingY, spacingZ, useInterpolation)

    def setOutputSpacing(self, *args) -> "void":
        return _fast.ImageResampler_setOutputSpacing(self, *args)

    def setInterpolation(self, useInterpolation: "bool") -> "void":
        return _fast.ImageResampler_setInterpolation(self, useInterpolation)

    def loadAttributes(self) -> "void":
        return _fast.ImageResampler_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageResampler

# Register ImageResampler in _fast:
_fast.ImageResampler_swigregister(ImageResampler)

def ImageResampler_New() -> "std::shared_ptr< fast::ImageResampler >":
    return _fast.ImageResampler_New()

def ImageResampler_getStaticNameOfClass() -> "std::string":
    return _fast.ImageResampler_getStaticNameOfClass()

def ImageResampler_create(spacingX: "float", spacingY: "float", spacingZ: "float"=-1.0, useInterpolation: "bool"=True) -> "std::shared_ptr< fast::ImageResampler >":
    r"""
    Create instance
    :type spacingX: float
    :param spacingX: Pixel spacing in x direction
    :type spacingY: float
    :param spacingY: Pixel spacing in y direction
    :type spacingZ: float
    :param spacingZ: Pixel spacing in z direction
    :type useInterpolation: boolean
    :param useInterpolation: Whether to use linear interpolation, or just nearest neighbor.
    :rtype: :py:class:`ImageResampler`
    :return: instance
    """
    return _fast.ImageResampler_create(spacingX, spacingY, spacingZ, useInterpolation)

class IsotropicResampler(ImageResampler):
    r"""
    Resample an image so that the the pixel spacing is equal in both directions

    This image resampler will resample the image so it has the same spacing in both directions, resulting
    in an isotropic image. This resampler will select the target spacing from the input image.

    If you want to specify exactly which spacing to use, you should use ImageResampler instead.

    Inputs:
    - 0: Image

    Outputs:
    - 0: Image

    See also: ImageResampler
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::IsotropicResampler >":
        return _fast.IsotropicResampler_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.IsotropicResampler_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.IsotropicResampler_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::IsotropicResampler >":
        return _fast.IsotropicResampler_connect(self, *args)
    SpacingSelector_SMALLEST = _fast.IsotropicResampler_SpacingSelector_SMALLEST
    r""" Select smallest spacing"""
    SpacingSelector_LARGEST = _fast.IsotropicResampler_SpacingSelector_LARGEST
    r""" Select largest spacing"""
    SpacingSelector_X = _fast.IsotropicResampler_SpacingSelector_X
    r""" Select X spacing always"""
    SpacingSelector_Y = _fast.IsotropicResampler_SpacingSelector_Y
    r""" Select Y spacing always"""
    SpacingSelector_Z = _fast.IsotropicResampler_SpacingSelector_Z
    r""" Select Z spacing always"""

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::IsotropicResampler >":
        r"""
        Create instance
        :type spacingSelector: int
        :param spacingSelector: Which spacing to select from image to use for resampling. Default is smallest.
        :type useInterpolation: boolean
        :param useInterpolation: Whether to use linear interpolation, or just nearest neighbor.
        :rtype: :py:class:`IsotropicResampler`
        :return: instance
        """
        return _fast.IsotropicResampler_create(*args, **kwargs)

    def setSpacingSelector(self, spacingSelector: "fast::IsotropicResampler::SpacingSelector") -> "void":
        return _fast.IsotropicResampler_setSpacingSelector(self, spacingSelector)
    __swig_destroy__ = _fast.delete_IsotropicResampler

# Register IsotropicResampler in _fast:
_fast.IsotropicResampler_swigregister(IsotropicResampler)

def IsotropicResampler_New() -> "std::shared_ptr< fast::IsotropicResampler >":
    return _fast.IsotropicResampler_New()

def IsotropicResampler_getStaticNameOfClass() -> "std::string":
    return _fast.IsotropicResampler_getStaticNameOfClass()

def IsotropicResampler_create(*args, **kwargs) -> "std::shared_ptr< fast::IsotropicResampler >":
    r"""
    Create instance
    :type spacingSelector: int
    :param spacingSelector: Which spacing to select from image to use for resampling. Default is smallest.
    :type useInterpolation: boolean
    :param useInterpolation: Whether to use linear interpolation, or just nearest neighbor.
    :rtype: :py:class:`IsotropicResampler`
    :return: instance
    """
    return _fast.IsotropicResampler_create(*args, **kwargs)

class ImageResizer(ProcessObject):
    r"""Process object for resizing an image"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageResizer >":
        return _fast.ImageResizer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageResizer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageResizer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageResizer >":
        return _fast.ImageResizer_connect(self, *args)

    @staticmethod
    def create(width: "int", height: "int", depth: "int"=0, useInterpolation: "bool"=True, preserveAspectRatio: "bool"=False) -> "std::shared_ptr< fast::ImageResizer >":
        r"""
        Create instnace
        :type width: int
        :param width:
        :type height: int
        :param height:
        :type depth: int
        :param depth:
        :type useInterpolation: boolean
        :param useInterpolation: Whether to use linear interpolation or not
        :type preserveAspectRatio: boolean
        :param preserveAspectRatio:
        :rtype: :py:class:`ImageResizer`
        :return: instance
        """
        return _fast.ImageResizer_create(width, height, depth, useInterpolation, preserveAspectRatio)

    def setWidth(self, width: "int") -> "void":
        return _fast.ImageResizer_setWidth(self, width)

    def setHeight(self, height: "int") -> "void":
        return _fast.ImageResizer_setHeight(self, height)

    def setDepth(self, depth: "int") -> "void":
        return _fast.ImageResizer_setDepth(self, depth)

    def setSize(self, size: "VectorXi") -> "void":
        return _fast.ImageResizer_setSize(self, size)

    def setPreserveAspectRatio(self, preserve: "bool") -> "void":
        return _fast.ImageResizer_setPreserveAspectRatio(self, preserve)

    def setInterpolation(self, useInterpolation: "bool") -> "void":
        return _fast.ImageResizer_setInterpolation(self, useInterpolation)

    def loadAttributes(self) -> "void":
        return _fast.ImageResizer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageResizer

# Register ImageResizer in _fast:
_fast.ImageResizer_swigregister(ImageResizer)

def ImageResizer_New() -> "std::shared_ptr< fast::ImageResizer >":
    return _fast.ImageResizer_New()

def ImageResizer_getStaticNameOfClass() -> "std::string":
    return _fast.ImageResizer_getStaticNameOfClass()

def ImageResizer_create(width: "int", height: "int", depth: "int"=0, useInterpolation: "bool"=True, preserveAspectRatio: "bool"=False) -> "std::shared_ptr< fast::ImageResizer >":
    r"""
    Create instnace
    :type width: int
    :param width:
    :type height: int
    :param height:
    :type depth: int
    :param depth:
    :type useInterpolation: boolean
    :param useInterpolation: Whether to use linear interpolation or not
    :type preserveAspectRatio: boolean
    :param preserveAspectRatio:
    :rtype: :py:class:`ImageResizer`
    :return: instance
    """
    return _fast.ImageResizer_create(width, height, depth, useInterpolation, preserveAspectRatio)

class ImageSharpening(GaussianSmoothing):
    r"""
    Image sharpening by the unsharp masking method.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageSharpening >":
        return _fast.ImageSharpening_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageSharpening_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageSharpening_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageSharpening >":
        return _fast.ImageSharpening_connect(self, *args)

    @staticmethod
    def create(gain: "float"=1.0, stddev: "float"=0.5, maskSize: "uchar"=0) -> "std::shared_ptr< fast::ImageSharpening >":
        r"""
        Create instance
        :type gain: float
        :param gain:
        :param stdDev: Standard deviation of convolution kernel
        :type maskSize: uchar
        :param maskSize: Size of convolution filter/mask. Must be odd.
                 If 0 filter size is determined automatically from standard deviation
        :rtype: :py:class:`ImageSharpening`
        :return: instance
        """
        return _fast.ImageSharpening_create(gain, stddev, maskSize)

    def setGain(self, gain: "float") -> "void":
        return _fast.ImageSharpening_setGain(self, gain)

    def loadAttributes(self) -> "void":
        return _fast.ImageSharpening_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageSharpening

# Register ImageSharpening in _fast:
_fast.ImageSharpening_swigregister(ImageSharpening)

def ImageSharpening_New() -> "std::shared_ptr< fast::ImageSharpening >":
    return _fast.ImageSharpening_New()

def ImageSharpening_getStaticNameOfClass() -> "std::string":
    return _fast.ImageSharpening_getStaticNameOfClass()

def ImageSharpening_create(gain: "float"=1.0, stddev: "float"=0.5, maskSize: "uchar"=0) -> "std::shared_ptr< fast::ImageSharpening >":
    r"""
    Create instance
    :type gain: float
    :param gain:
    :param stdDev: Standard deviation of convolution kernel
    :type maskSize: uchar
    :param maskSize: Size of convolution filter/mask. Must be odd.
             If 0 filter size is determined automatically from standard deviation
    :rtype: :py:class:`ImageSharpening`
    :return: instance
    """
    return _fast.ImageSharpening_create(gain, stddev, maskSize)

class ImageSlicer(ProcessObject):
    r"""
    Slice a 3D image using a defined plane

    See also: Plane PlaneType
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageSlicer >":
        return _fast.ImageSlicer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageSlicer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageSlicer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageSlicer >":
        return _fast.ImageSlicer_connect(self, *args)

    @staticmethod
    def create(*args) -> "std::shared_ptr< fast::ImageSlicer >":
        r"""
        *Overload 1:*

        Create instance

        Slice a 3D image with an orthogonal slice plane. Default slice nr is the center slice.

        :param orthogonalSlicePlane: Which orthogonal slice plane to use X/Y/Z
        :type sliceNr: int
        :param sliceNr: Which slice nr to extract, must be smaller than size of the slicing dimension.
                 If negative center slice will be used
        :rtype: :py:class:`ImageSlicer`
        :return: instance

        |

        *Overload 2:*

        Create instance

        Slice a volume with an arbitrary slice plane defined by Plane.

        :param arbitrarySlicePlane:
        :rtype: :py:class:`ImageSlicer`
        :return: instance
        """
        return _fast.ImageSlicer_create(*args)

    def setOrthogonalSlicePlane(self, orthogonalSlicePlane: "fast::PlaneType", sliceNr: "int"=-1) -> "void":
        return _fast.ImageSlicer_setOrthogonalSlicePlane(self, orthogonalSlicePlane, sliceNr)

    def setArbitrarySlicePlane(self, slicePlane: "Plane") -> "void":
        return _fast.ImageSlicer_setArbitrarySlicePlane(self, slicePlane)

    def loadAttributes(self) -> "void":
        return _fast.ImageSlicer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageSlicer

# Register ImageSlicer in _fast:
_fast.ImageSlicer_swigregister(ImageSlicer)

def ImageSlicer_New() -> "std::shared_ptr< fast::ImageSlicer >":
    return _fast.ImageSlicer_New()

def ImageSlicer_getStaticNameOfClass() -> "std::string":
    return _fast.ImageSlicer_getStaticNameOfClass()

def ImageSlicer_create(*args) -> "std::shared_ptr< fast::ImageSlicer >":
    r"""
    *Overload 1:*

    Create instance

    Slice a 3D image with an orthogonal slice plane. Default slice nr is the center slice.

    :param orthogonalSlicePlane: Which orthogonal slice plane to use X/Y/Z
    :type sliceNr: int
    :param sliceNr: Which slice nr to extract, must be smaller than size of the slicing dimension.
             If negative center slice will be used
    :rtype: :py:class:`ImageSlicer`
    :return: instance

    |

    *Overload 2:*

    Create instance

    Slice a volume with an arbitrary slice plane defined by Plane.

    :param arbitrarySlicePlane:
    :rtype: :py:class:`ImageSlicer`
    :return: instance
    """
    return _fast.ImageSlicer_create(*args)

class ImageTransposer(ProcessObject):
    r"""
    Transpose images

    Inputs:
    - 0: Image

    Outputs:
    - 0: Image transposed

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageTransposer >":
        return _fast.ImageTransposer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageTransposer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageTransposer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageTransposer >":
        return _fast.ImageTransposer_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::ImageTransposer >":
        r"""
        Create instance
        :type axes: std::vector< int,std::allocator< int > >
        :param axes: Specify axes to swap for 3D images. If not supplied, X and Y will be transposed.
        :rtype: :py:class:`ImageTransposer`
        :return: instance
        """
        return _fast.ImageTransposer_create(*args, **kwargs)

    def setAxes(self, axes: "vectori") -> "void":
        return _fast.ImageTransposer_setAxes(self, axes)

    def loadAttributes(self) -> "void":
        return _fast.ImageTransposer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageTransposer

# Register ImageTransposer in _fast:
_fast.ImageTransposer_swigregister(ImageTransposer)

def ImageTransposer_New() -> "std::shared_ptr< fast::ImageTransposer >":
    return _fast.ImageTransposer_New()

def ImageTransposer_getStaticNameOfClass() -> "std::string":
    return _fast.ImageTransposer_getStaticNameOfClass()

def ImageTransposer_create(*args, **kwargs) -> "std::shared_ptr< fast::ImageTransposer >":
    r"""
    Create instance
    :type axes: std::vector< int,std::allocator< int > >
    :param axes: Specify axes to swap for 3D images. If not supplied, X and Y will be transposed.
    :rtype: :py:class:`ImageTransposer`
    :return: instance
    """
    return _fast.ImageTransposer_create(*args, **kwargs)

class IntensityClipping(ProcessObject):
    r"""
    Clips the pixel intensities of an image to specific values

    Inputs:
    - 0: Image

    Outputs:
    - 0: Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::IntensityClipping >":
        return _fast.IntensityClipping_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.IntensityClipping_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.IntensityClipping_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::IntensityClipping >":
        return _fast.IntensityClipping_connect(self, *args)

    @staticmethod
    def create(minValue: "float"=0.0, maxValue: "float"=1.0) -> "std::shared_ptr< fast::IntensityClipping >":
        r"""
        Create instance

        Clips the pixel intensities to the provided min and max values.

        :type minValue: float
        :param minValue:
        :type maxValue: float
        :param maxValue:
        :rtype: :py:class:`IntensityClipping`
        :return: instance
        """
        return _fast.IntensityClipping_create(minValue, maxValue)

    def setMinValue(self, value: "float") -> "void":
        return _fast.IntensityClipping_setMinValue(self, value)

    def setMaxValue(self, value: "float") -> "void":
        return _fast.IntensityClipping_setMaxValue(self, value)

    def loadAttributes(self) -> "void":
        return _fast.IntensityClipping_loadAttributes(self)
    __swig_destroy__ = _fast.delete_IntensityClipping

# Register IntensityClipping in _fast:
_fast.IntensityClipping_swigregister(IntensityClipping)

def IntensityClipping_New() -> "std::shared_ptr< fast::IntensityClipping >":
    return _fast.IntensityClipping_New()

def IntensityClipping_getStaticNameOfClass() -> "std::string":
    return _fast.IntensityClipping_getStaticNameOfClass()

def IntensityClipping_create(minValue: "float"=0.0, maxValue: "float"=1.0) -> "std::shared_ptr< fast::IntensityClipping >":
    r"""
    Create instance

    Clips the pixel intensities to the provided min and max values.

    :type minValue: float
    :param minValue:
    :type maxValue: float
    :param maxValue:
    :rtype: :py:class:`IntensityClipping`
    :return: instance
    """
    return _fast.IntensityClipping_create(minValue, maxValue)

class IntensityNormalization(ProcessObject):
    r"""
    Normalize intensities of an image to a 0-1 or custom range.

    This process object will scale the pixel values of an
    image to a value between 0 and 1 (default) or other
    values if set.

    Inputs:
    - 0: Image

    Outputs:
    - 0: Image float

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::IntensityNormalization >":
        return _fast.IntensityNormalization_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.IntensityNormalization_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.IntensityNormalization_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::IntensityNormalization >":
        return _fast.IntensityNormalization_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::IntensityNormalization >":
        r"""
        Create instance
        Every pixel value is scaled so that:
        value = (value - minimumIntensity) / (maximumIntensity - minimumIntensity);
        value = value*(valueHigh - valueLow) + valueLow;

        :type valueLow: float
        :param valueLow: minimum value after normalization
        :type valueHigh: float
        :param valueHigh: maximum value after normalization
        :type minimumIntensity: float
        :param minimumIntensity: set fixed minimum intensity, if not set it is calculated for each image
        :type maximumIntensity: float
        :param maximumIntensity: set fixed maxiumum intensity, if not set it is calculated for each image
        :rtype: :py:class:`IntensityNormalization`
        :return: instance
        """
        return _fast.IntensityNormalization_create(*args, **kwargs)

    def setMinimumIntensity(self, intensity: "float") -> "void":
        return _fast.IntensityNormalization_setMinimumIntensity(self, intensity)

    def setMaximumIntensity(self, intensity: "float") -> "void":
        return _fast.IntensityNormalization_setMaximumIntensity(self, intensity)

    def setLowestValue(self, value: "float") -> "void":
        return _fast.IntensityNormalization_setLowestValue(self, value)

    def setHighestValue(self, value: "float") -> "void":
        return _fast.IntensityNormalization_setHighestValue(self, value)
    __swig_destroy__ = _fast.delete_IntensityNormalization

# Register IntensityNormalization in _fast:
_fast.IntensityNormalization_swigregister(IntensityNormalization)

def IntensityNormalization_New() -> "std::shared_ptr< fast::IntensityNormalization >":
    return _fast.IntensityNormalization_New()

def IntensityNormalization_getStaticNameOfClass() -> "std::string":
    return _fast.IntensityNormalization_getStaticNameOfClass()

def IntensityNormalization_create(*args, **kwargs) -> "std::shared_ptr< fast::IntensityNormalization >":
    r"""
    Create instance
    Every pixel value is scaled so that:
    value = (value - minimumIntensity) / (maximumIntensity - minimumIntensity);
    value = value*(valueHigh - valueLow) + valueLow;

    :type valueLow: float
    :param valueLow: minimum value after normalization
    :type valueHigh: float
    :param valueHigh: maximum value after normalization
    :type minimumIntensity: float
    :param minimumIntensity: set fixed minimum intensity, if not set it is calculated for each image
    :type maximumIntensity: float
    :param maximumIntensity: set fixed maxiumum intensity, if not set it is calculated for each image
    :rtype: :py:class:`IntensityNormalization`
    :return: instance
    """
    return _fast.IntensityNormalization_create(*args, **kwargs)

class ZeroMeanUnitVariance(ProcessObject):
    r"""
    Normalize intensities of an image to have zero mean and unit variance

    This process object will scale the pixel values so that the resulting image
    has a zero mean and unit variance.
    This achieved by doing (image - mean(image)) / std(image)

    Inputs:
    - 0: Image

    Outputs:
    - 0: Image float

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ZeroMeanUnitVariance >":
        return _fast.ZeroMeanUnitVariance_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ZeroMeanUnitVariance_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ZeroMeanUnitVariance_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ZeroMeanUnitVariance >":
        return _fast.ZeroMeanUnitVariance_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::ZeroMeanUnitVariance >":
        r"""
        Create instance
        :rtype: :py:class:`ZeroMeanUnitVariance`
        :return: instance
        """
        return _fast.ZeroMeanUnitVariance_create()
    __swig_destroy__ = _fast.delete_ZeroMeanUnitVariance

# Register ZeroMeanUnitVariance in _fast:
_fast.ZeroMeanUnitVariance_swigregister(ZeroMeanUnitVariance)

def ZeroMeanUnitVariance_New() -> "std::shared_ptr< fast::ZeroMeanUnitVariance >":
    return _fast.ZeroMeanUnitVariance_New()

def ZeroMeanUnitVariance_getStaticNameOfClass() -> "std::string":
    return _fast.ZeroMeanUnitVariance_getStaticNameOfClass()

def ZeroMeanUnitVariance_create() -> "std::shared_ptr< fast::ZeroMeanUnitVariance >":
    r"""
    Create instance
    :rtype: :py:class:`ZeroMeanUnitVariance`
    :return: instance
    """
    return _fast.ZeroMeanUnitVariance_create()

class Interleave(Streamer):
    r"""
    Interleaves input data streams into one output stream

    This process object interleaves multiple input data streams into one output stream
    by alternating data objects from the input data streams.
    This is useful for instance for comparing image quality of two or more data streams.
    The speed in which they are interleaved can be controlled by the framerate parameter.

    Inputs:
    - 0-N: Any types of data

    Outputs:
    - 0: Same as input data
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Interleave >":
        return _fast.Interleave_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Interleave_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Interleave_getStaticNameOfClass()

    @staticmethod
    def create(framerate: "int"=-1) -> "std::shared_ptr< fast::Interleave >":
        r"""
        Create instance
        :type framerate: int
        :param framerate: Framerate to switch between input data
        :rtype: :py:class:`Interleave`
        :return: instance
        """
        return _fast.Interleave_create(framerate)

    def setFramerate(self, framerate: "int") -> "void":
        return _fast.Interleave_setFramerate(self, framerate)

    def loadAttributes(self) -> "void":
        return _fast.Interleave_loadAttributes(self)

    def generateStream(self) -> "void":
        return _fast.Interleave_generateStream(self)
    __swig_destroy__ = _fast.delete_Interleave

# Register Interleave in _fast:
_fast.Interleave_swigregister(Interleave)

def Interleave_New() -> "std::shared_ptr< fast::Interleave >":
    return _fast.Interleave_New()

def Interleave_getStaticNameOfClass() -> "std::string":
    return _fast.Interleave_getStaticNameOfClass()

def Interleave_create(framerate: "int"=-1) -> "std::shared_ptr< fast::Interleave >":
    r"""
    Create instance
    :type framerate: int
    :param framerate: Framerate to switch between input data
    :rtype: :py:class:`Interleave`
    :return: instance
    """
    return _fast.Interleave_create(framerate)

class InterleavePlayback(RandomAccessStreamer):
    r"""
    Interleaves input data streams into one output stream with playback control

    The difference between this InterleavePlayback and Interleave, is that this PO can be used with PlaybackWidget.

    Inputs:
    - 0-N: Any types of data

    Outputs:
    - 0: Same as input data
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::InterleavePlayback >":
        return _fast.InterleavePlayback_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.InterleavePlayback_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.InterleavePlayback_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::InterleavePlayback >":
        return _fast.InterleavePlayback_connect(self, *args)

    @staticmethod
    def create(sourceStreamer: "std::shared_ptr< fast::RandomAccessStreamer >", framerate: "int"=-1) -> "std::shared_ptr< fast::InterleavePlayback >":
        r"""
        Create instance
        :type sourceStreamer: :py:class:`RandomAccessStreamer`
        :param sourceStreamer: The RandomAccessStreamer which is the source of this stream
        :type framerate: int
        :param framerate: Framerate to switch between input data
        :rtype: :py:class:`InterleavePlayback`
        :return: instance
        """
        return _fast.InterleavePlayback_create(sourceStreamer, framerate)

    def getNrOfFrames(self) -> "int":
        return _fast.InterleavePlayback_getNrOfFrames(self)

    def generateStream(self) -> "void":
        return _fast.InterleavePlayback_generateStream(self)

    def setCurrentFrameIndex(self, index: "int") -> "void":
        return _fast.InterleavePlayback_setCurrentFrameIndex(self, index)

    def getCurrentFrameIndex(self) -> "int":
        return _fast.InterleavePlayback_getCurrentFrameIndex(self)

    def setFramerate(self, framerate: "int") -> "void":
        return _fast.InterleavePlayback_setFramerate(self, framerate)

    def getFramerate(self) -> "int":
        return _fast.InterleavePlayback_getFramerate(self)

    def setPause(self, pause: "bool") -> "void":
        return _fast.InterleavePlayback_setPause(self, pause)

    def setLooping(self, loop: "bool") -> "void":
        return _fast.InterleavePlayback_setLooping(self, loop)
    __swig_destroy__ = _fast.delete_InterleavePlayback

# Register InterleavePlayback in _fast:
_fast.InterleavePlayback_swigregister(InterleavePlayback)

def InterleavePlayback_New() -> "std::shared_ptr< fast::InterleavePlayback >":
    return _fast.InterleavePlayback_New()

def InterleavePlayback_getStaticNameOfClass() -> "std::string":
    return _fast.InterleavePlayback_getStaticNameOfClass()

def InterleavePlayback_create(sourceStreamer: "std::shared_ptr< fast::RandomAccessStreamer >", framerate: "int"=-1) -> "std::shared_ptr< fast::InterleavePlayback >":
    r"""
    Create instance
    :type sourceStreamer: :py:class:`RandomAccessStreamer`
    :param sourceStreamer: The RandomAccessStreamer which is the source of this stream
    :type framerate: int
    :param framerate: Framerate to switch between input data
    :rtype: :py:class:`InterleavePlayback`
    :return: instance
    """
    return _fast.InterleavePlayback_create(sourceStreamer, framerate)

class IterativeClosestPoint(ProcessObject):
    r"""
    Registration of two meshes using ICP algorithm

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::IterativeClosestPoint >":
        return _fast.IterativeClosestPoint_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.IterativeClosestPoint_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.IterativeClosestPoint_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::IterativeClosestPoint >":
        return _fast.IterativeClosestPoint_connect(self, *args)
    RIGID = _fast.IterativeClosestPoint_RIGID
    TRANSLATION = _fast.IterativeClosestPoint_TRANSLATION

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::IterativeClosestPoint >":
        r"""
        Create instance

        :type type: int
        :param type: The type of transformation
        :type maxIterations: int
        :param maxIterations: Maximum nr of iterations to run
        :type minErrorChange: float
        :param minErrorChange: Stopping criterion. If change in error is less than this number for an iteration, ICP will stop.
        :type distanceThreshold: float
        :param distanceThreshold: If specified, do not accept points that are further away than this threshold.
        :type randomSamplingPoints: int
        :param randomSamplingPoints: If specified, ICP will sample this many points at random to match instead of all points.
        :rtype: :py:class:`IterativeClosestPoint`
        :return: instance
        """
        return _fast.IterativeClosestPoint_create(*args, **kwargs)

    def connectFixed(self, *args) -> "std::shared_ptr< fast::IterativeClosestPoint >":
        return _fast.IterativeClosestPoint_connectFixed(self, *args)

    def connectMoving(self, *args) -> "std::shared_ptr< fast::IterativeClosestPoint >":
        return _fast.IterativeClosestPoint_connectMoving(self, *args)

    def setFixedMeshPort(self, port: "fast::DataChannel::pointer") -> "void":
        return _fast.IterativeClosestPoint_setFixedMeshPort(self, port)

    def setFixedMesh(self, data: "Mesh::pointer") -> "void":
        return _fast.IterativeClosestPoint_setFixedMesh(self, data)

    def setMovingMeshPort(self, port: "fast::DataChannel::pointer") -> "void":
        return _fast.IterativeClosestPoint_setMovingMeshPort(self, port)

    def setMovingMesh(self, data: "Mesh::pointer") -> "void":
        return _fast.IterativeClosestPoint_setMovingMesh(self, data)

    def setTransformationType(self, type: "fast::IterativeClosestPoint::TransformationType const") -> "void":
        return _fast.IterativeClosestPoint_setTransformationType(self, type)

    def getOutputTransformation(self) -> "fast::Transform::pointer":
        return _fast.IterativeClosestPoint_getOutputTransformation(self)

    def getError(self) -> "float":
        return _fast.IterativeClosestPoint_getError(self)

    def setMinimumErrorChange(self, errorChange: "float") -> "void":
        return _fast.IterativeClosestPoint_setMinimumErrorChange(self, errorChange)

    def setMaximumNrOfIterations(self, iterations: "uint") -> "void":
        return _fast.IterativeClosestPoint_setMaximumNrOfIterations(self, iterations)

    def setRandomPointSampling(self, nrOfPointsToSample: "uint") -> "void":
        return _fast.IterativeClosestPoint_setRandomPointSampling(self, nrOfPointsToSample)

    def setDistanceThreshold(self, distance: "float") -> "void":
        return _fast.IterativeClosestPoint_setDistanceThreshold(self, distance)
    __swig_destroy__ = _fast.delete_IterativeClosestPoint

# Register IterativeClosestPoint in _fast:
_fast.IterativeClosestPoint_swigregister(IterativeClosestPoint)

def IterativeClosestPoint_New() -> "std::shared_ptr< fast::IterativeClosestPoint >":
    return _fast.IterativeClosestPoint_New()

def IterativeClosestPoint_getStaticNameOfClass() -> "std::string":
    return _fast.IterativeClosestPoint_getStaticNameOfClass()

def IterativeClosestPoint_create(*args, **kwargs) -> "std::shared_ptr< fast::IterativeClosestPoint >":
    r"""
    Create instance

    :type type: int
    :param type: The type of transformation
    :type maxIterations: int
    :param maxIterations: Maximum nr of iterations to run
    :type minErrorChange: float
    :param minErrorChange: Stopping criterion. If change in error is less than this number for an iteration, ICP will stop.
    :type distanceThreshold: float
    :param distanceThreshold: If specified, do not accept points that are further away than this threshold.
    :type randomSamplingPoints: int
    :param randomSamplingPoints: If specified, ICP will sample this many points at random to match instead of all points.
    :rtype: :py:class:`IterativeClosestPoint`
    :return: instance
    """
    return _fast.IterativeClosestPoint_create(*args, **kwargs)

class KalmanFilterModelSegmentation(ProcessObject):
    r"""
    Kalman filter deformable model segmentation

    Temporal deformable model segmentation using Kalman filter state estimation
    Supports multiple shape and appearance models

    Inputs:
    - 0: Image to segment

    Outputs:
    - 0: Mesh segmentation
    - 1: Mesh displacement

    See also: ShapeModel AppearanceModel
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::KalmanFilterModelSegmentation >":
        return _fast.KalmanFilterModelSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.KalmanFilterModelSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.KalmanFilterModelSegmentation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::KalmanFilterModelSegmentation >":
        return _fast.KalmanFilterModelSegmentation_connect(self, *args)

    @staticmethod
    def create(shapeModel: "ShapeModel::pointer", appearanceModel: "AppearanceModel::pointer", iterations: "int"=5, startIterations: "int"=20) -> "std::shared_ptr< fast::KalmanFilterModelSegmentation >":
        r"""
        Create instance
        :type shapeModel: ShapeModel::pointer
        :param shapeModel: Shape model to use
        :type appearanceModel: AppearanceModel::pointer
        :param appearanceModel: Apperrance model to use
        :type iterations: int
        :param iterations: Iterations per frame
        :type startIterations: int
        :param startIterations: Iterations for first frame
        :rtype: :py:class:`KalmanFilterModelSegmentation`
        :return: instance
        """
        return _fast.KalmanFilterModelSegmentation_create(shapeModel, appearanceModel, iterations, startIterations)

    def setShapeModel(self, shapeModel: "ShapeModel::pointer") -> "void":
        return _fast.KalmanFilterModelSegmentation_setShapeModel(self, shapeModel)

    def setAppearanceModel(self, appearanceModel: "AppearanceModel::pointer") -> "void":
        return _fast.KalmanFilterModelSegmentation_setAppearanceModel(self, appearanceModel)

    def setIterations(self, iterations: "int") -> "void":
        return _fast.KalmanFilterModelSegmentation_setIterations(self, iterations)

    def setStartIterations(self, iterations: "int") -> "void":
        return _fast.KalmanFilterModelSegmentation_setStartIterations(self, iterations)

    def getCurrentState(self) -> "VectorXf":
        return _fast.KalmanFilterModelSegmentation_getCurrentState(self)

    def getSegmentationOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.KalmanFilterModelSegmentation_getSegmentationOutputPort(self)

    def getDisplacementsOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.KalmanFilterModelSegmentation_getDisplacementsOutputPort(self)
    __swig_destroy__ = _fast.delete_KalmanFilterModelSegmentation

# Register KalmanFilterModelSegmentation in _fast:
_fast.KalmanFilterModelSegmentation_swigregister(KalmanFilterModelSegmentation)

def KalmanFilterModelSegmentation_New() -> "std::shared_ptr< fast::KalmanFilterModelSegmentation >":
    return _fast.KalmanFilterModelSegmentation_New()

def KalmanFilterModelSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.KalmanFilterModelSegmentation_getStaticNameOfClass()

def KalmanFilterModelSegmentation_create(shapeModel: "ShapeModel::pointer", appearanceModel: "AppearanceModel::pointer", iterations: "int"=5, startIterations: "int"=20) -> "std::shared_ptr< fast::KalmanFilterModelSegmentation >":
    r"""
    Create instance
    :type shapeModel: ShapeModel::pointer
    :param shapeModel: Shape model to use
    :type appearanceModel: AppearanceModel::pointer
    :param appearanceModel: Apperrance model to use
    :type iterations: int
    :param iterations: Iterations per frame
    :type startIterations: int
    :param startIterations: Iterations for first frame
    :rtype: :py:class:`KalmanFilterModelSegmentation`
    :return: instance
    """
    return _fast.KalmanFilterModelSegmentation_create(shapeModel, appearanceModel, iterations, startIterations)

class Measurement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    displacement = property(_fast.Measurement_displacement_get, _fast.Measurement_displacement_set)
    uncertainty = property(_fast.Measurement_uncertainty_get, _fast.Measurement_uncertainty_set)

    def __init__(self):
        _fast.Measurement_swiginit(self, _fast.new_Measurement())
    __swig_destroy__ = _fast.delete_Measurement

# Register Measurement in _fast:
_fast.Measurement_swigregister(Measurement)

class AppearanceModel(Object):
    r"""
    This is a base class for appearance models.
    These classes model of an object appears in an image.
    They are used by the Kalman filter to collect measurements.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getMeasurements(self, image: "std::shared_ptr< fast::Image >", shape: "std::shared_ptr< Shape >", device: "fast::ExecutionDevice::pointer") -> "std::vector< fast::Measurement,std::allocator< fast::Measurement > >":
        return _fast.AppearanceModel_getMeasurements(self, image, shape, device)
    __swig_destroy__ = _fast.delete_AppearanceModel

# Register AppearanceModel in _fast:
_fast.AppearanceModel_swigregister(AppearanceModel)

class ShapeModel(Object):
    r"""
    This is an abstract base class for all shape models.
    These objects describe a deformable shape, its parameters
    and how it is allowed to change in space and time.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getShape(self, state: "VectorXf") -> "Shape::pointer":
        return _fast.ShapeModel_getShape(self, state)

    def getStateTransitionMatrix1(self) -> "MatrixXf":
        return _fast.ShapeModel_getStateTransitionMatrix1(self)

    def getStateTransitionMatrix2(self) -> "MatrixXf":
        return _fast.ShapeModel_getStateTransitionMatrix2(self)

    def getStateTransitionMatrix3(self) -> "MatrixXf":
        return _fast.ShapeModel_getStateTransitionMatrix3(self)

    def getProcessErrorMatrix(self) -> "MatrixXf":
        return _fast.ShapeModel_getProcessErrorMatrix(self)

    def getInitialState(self, image: "std::shared_ptr< fast::Image >") -> "VectorXf":
        return _fast.ShapeModel_getInitialState(self, image)

    def getMeasurementVectors(self, state: "VectorXf", shape: "Shape::pointer") -> "std::vector< MatrixXf,std::allocator< MatrixXf > >":
        return _fast.ShapeModel_getMeasurementVectors(self, state, shape)

    def restrictState(self, state: "VectorXf") -> "VectorXf":
        return _fast.ShapeModel_restrictState(self, state)
    __swig_destroy__ = _fast.delete_ShapeModel

# Register ShapeModel in _fast:
_fast.ShapeModel_swigregister(ShapeModel)

class Shape(Object):
    r"""Class used to represent a mesh shape."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Shape >":
        return _fast.Shape_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Shape_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Shape_getStaticNameOfClass()

    def getMesh(self) -> "fast::Mesh::pointer":
        return _fast.Shape_getMesh(self)

    def setMesh(self, mesh: "fast::Mesh::pointer") -> "void":
        return _fast.Shape_setMesh(self, mesh)

    def getCentroid(self) -> "Vector3f":
        return _fast.Shape_getCentroid(self)
    __swig_destroy__ = _fast.delete_Shape

# Register Shape in _fast:
_fast.Shape_swigregister(Shape)

def Shape_New() -> "std::shared_ptr< fast::Shape >":
    return _fast.Shape_New()

def Shape_getStaticNameOfClass() -> "std::string":
    return _fast.Shape_getStaticNameOfClass()

class RidgeEdgeModel(AppearanceModel):
    r"""
    Ridge edge appearance model

    Used in Kalman filter deformable model segmentation

    See also: KalmanFilter StepEdgeModel
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.RidgeEdgeModel_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RidgeEdgeModel_getStaticNameOfClass()
    EDGE_TYPE_ANY = _fast.RidgeEdgeModel_EDGE_TYPE_ANY
    EDGE_TYPE_BLACK_INSIDE_WHITE_OUTSIDE = _fast.RidgeEdgeModel_EDGE_TYPE_BLACK_INSIDE_WHITE_OUTSIDE
    EDGE_TYPE_WHITE_INSIDE_BLACK_OUTSIDE = _fast.RidgeEdgeModel_EDGE_TYPE_WHITE_INSIDE_BLACK_OUTSIDE

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::RidgeEdgeModel >":
        return _fast.RidgeEdgeModel_create(*args, **kwargs)

    def setLineLength(self, lengthInMM: "float") -> "void":
        return _fast.RidgeEdgeModel_setLineLength(self, lengthInMM)

    def setLineSampleSpacing(self, spacingInMM: "float") -> "void":
        return _fast.RidgeEdgeModel_setLineSampleSpacing(self, spacingInMM)

    def setIntensityDifferenceThreshold(self, threshold: "float") -> "void":
        return _fast.RidgeEdgeModel_setIntensityDifferenceThreshold(self, threshold)

    def setMinimumDepth(self, depth: "float") -> "void":
        return _fast.RidgeEdgeModel_setMinimumDepth(self, depth)

    def setMinimumRidgeSize(self, sizeInMM: "float") -> "void":
        return _fast.RidgeEdgeModel_setMinimumRidgeSize(self, sizeInMM)

    def getMeasurements(self, image: "std::shared_ptr< fast::Image >", shape: "std::shared_ptr< fast::Shape >", device: "fast::ExecutionDevice::pointer") -> "std::vector< fast::Measurement,std::allocator< fast::Measurement > >":
        return _fast.RidgeEdgeModel_getMeasurements(self, image, shape, device)

    def setEdgeType(self, type: "fast::RidgeEdgeModel::EdgeType") -> "void":
        return _fast.RidgeEdgeModel_setEdgeType(self, type)
    __swig_destroy__ = _fast.delete_RidgeEdgeModel

# Register RidgeEdgeModel in _fast:
_fast.RidgeEdgeModel_swigregister(RidgeEdgeModel)

def RidgeEdgeModel_getStaticNameOfClass() -> "std::string":
    return _fast.RidgeEdgeModel_getStaticNameOfClass()

def RidgeEdgeModel_create(*args, **kwargs) -> "std::shared_ptr< fast::RidgeEdgeModel >":
    return _fast.RidgeEdgeModel_create(*args, **kwargs)

class StepEdgeModel(AppearanceModel):
    r"""
    Step edge appearance model

    Used in Kalman filter deformable model segmentation

    See also: KalmanFilter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.StepEdgeModel_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.StepEdgeModel_getStaticNameOfClass()
    EDGE_TYPE_ANY = _fast.StepEdgeModel_EDGE_TYPE_ANY
    EDGE_TYPE_BLACK_INSIDE_WHITE_OUTSIDE = _fast.StepEdgeModel_EDGE_TYPE_BLACK_INSIDE_WHITE_OUTSIDE
    EDGE_TYPE_WHITE_INSIDE_BLACK_OUTSIDE = _fast.StepEdgeModel_EDGE_TYPE_WHITE_INSIDE_BLACK_OUTSIDE

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::StepEdgeModel >":
        return _fast.StepEdgeModel_create(*args, **kwargs)

    def setLineLength(self, lengthInMM: "float") -> "void":
        return _fast.StepEdgeModel_setLineLength(self, lengthInMM)

    def setLineSampleSpacing(self, spacingInMM: "float") -> "void":
        return _fast.StepEdgeModel_setLineSampleSpacing(self, spacingInMM)

    def setIntensityDifferenceThreshold(self, threshold: "float") -> "void":
        return _fast.StepEdgeModel_setIntensityDifferenceThreshold(self, threshold)

    def setMinimumDepth(self, depth: "float") -> "void":
        return _fast.StepEdgeModel_setMinimumDepth(self, depth)

    def getMeasurements(self, image: "std::shared_ptr< fast::Image >", shape: "std::shared_ptr< fast::Shape >", device: "fast::ExecutionDevice::pointer") -> "std::vector< fast::Measurement,std::allocator< fast::Measurement > >":
        return _fast.StepEdgeModel_getMeasurements(self, image, shape, device)

    def setEdgeType(self, type: "fast::StepEdgeModel::EdgeType") -> "void":
        return _fast.StepEdgeModel_setEdgeType(self, type)
    __swig_destroy__ = _fast.delete_StepEdgeModel

# Register StepEdgeModel in _fast:
_fast.StepEdgeModel_swigregister(StepEdgeModel)

def StepEdgeModel_getStaticNameOfClass() -> "std::string":
    return _fast.StepEdgeModel_getStaticNameOfClass()

def StepEdgeModel_create(*args, **kwargs) -> "std::shared_ptr< fast::StepEdgeModel >":
    return _fast.StepEdgeModel_create(*args, **kwargs)

class CardinalSplineModel(ShapeModel):
    r"""
    Cardinal spline shape model

    Used in the Kalman filter deformable model segmentation algorithm

    See also: KalmanFilter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.CardinalSplineModel_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.CardinalSplineModel_getStaticNameOfClass()

    @staticmethod
    def create(controlPoints: "std::vector< Vector2f,std::allocator< Vector2f > >", globalProcessError: "float"=0.000001, localProcessError: "float"=0.0000001) -> "std::shared_ptr< fast::CardinalSplineModel >":
        r"""
        Create instance
        :type controlPoints: std::vector< Vector2f,std::allocator< Vector2f > >
        :param controlPoints: List of control points for the cardinal spline.
        :type globalProcessError: float
        :param globalProcessError:
        :type localProcessError: float
        :param localProcessError:
        :rtype: :py:class:`CardinalSplineModel`
        :return: instance
        """
        return _fast.CardinalSplineModel_create(controlPoints, globalProcessError, localProcessError)

    def getShape(self, state: "VectorXf") -> "fast::Shape::pointer":
        return _fast.CardinalSplineModel_getShape(self, state)

    def getStateTransitionMatrix1(self) -> "MatrixXf":
        return _fast.CardinalSplineModel_getStateTransitionMatrix1(self)

    def getStateTransitionMatrix2(self) -> "MatrixXf":
        return _fast.CardinalSplineModel_getStateTransitionMatrix2(self)

    def getStateTransitionMatrix3(self) -> "MatrixXf":
        return _fast.CardinalSplineModel_getStateTransitionMatrix3(self)

    def getProcessErrorMatrix(self) -> "MatrixXf":
        return _fast.CardinalSplineModel_getProcessErrorMatrix(self)

    def getInitialState(self, image: "std::shared_ptr< fast::Image >") -> "VectorXf":
        return _fast.CardinalSplineModel_getInitialState(self, image)

    def getMeasurementVectors(self, state: "VectorXf", shape: "fast::Shape::pointer") -> "std::vector< MatrixXf,std::allocator< MatrixXf > >":
        return _fast.CardinalSplineModel_getMeasurementVectors(self, state, shape)

    def initializeShapeToImageCenter(self) -> "void":
        return _fast.CardinalSplineModel_initializeShapeToImageCenter(self)

    def setControlPoints(self, controlPoints: "std::vector< Vector2f,std::allocator< Vector2f > >") -> "void":
        r"""
        Give a set of control points.
        The control points are assumed to be connected so that vector k,
        is connected to vector k-1 and k+1, and the last is connected to
        to the first to form a closed loop.
        """
        return _fast.CardinalSplineModel_setControlPoints(self, controlPoints)

    def setInitialScaling(self, x: "float", y: "float") -> "void":
        return _fast.CardinalSplineModel_setInitialScaling(self, x, y)

    def setInitialRotation(self, angleInRadians: "float") -> "void":
        return _fast.CardinalSplineModel_setInitialRotation(self, angleInRadians)

    def setInitialTranslation(self, x: "float", y: "float") -> "void":
        return _fast.CardinalSplineModel_setInitialTranslation(self, x, y)

    def setLocalProcessError(self, error: "float") -> "void":
        return _fast.CardinalSplineModel_setLocalProcessError(self, error)

    def setGlobalProcessError(self, error: "float") -> "void":
        return _fast.CardinalSplineModel_setGlobalProcessError(self, error)

    def setTension(self, *args) -> "void":
        return _fast.CardinalSplineModel_setTension(self, *args)

    def setResolution(self, resolution: "int") -> "void":
        return _fast.CardinalSplineModel_setResolution(self, resolution)

    def restrictState(self, state: "VectorXf") -> "VectorXf":
        return _fast.CardinalSplineModel_restrictState(self, state)

    def setScalingLimit(self, min: "float"=-1, max: "float"=-1) -> "void":
        return _fast.CardinalSplineModel_setScalingLimit(self, min, max)
    __swig_destroy__ = _fast.delete_CardinalSplineModel

# Register CardinalSplineModel in _fast:
_fast.CardinalSplineModel_swigregister(CardinalSplineModel)

def CardinalSplineModel_getStaticNameOfClass() -> "std::string":
    return _fast.CardinalSplineModel_getStaticNameOfClass()

def CardinalSplineModel_create(controlPoints: "std::vector< Vector2f,std::allocator< Vector2f > >", globalProcessError: "float"=0.000001, localProcessError: "float"=0.0000001) -> "std::shared_ptr< fast::CardinalSplineModel >":
    r"""
    Create instance
    :type controlPoints: std::vector< Vector2f,std::allocator< Vector2f > >
    :param controlPoints: List of control points for the cardinal spline.
    :type globalProcessError: float
    :param globalProcessError:
    :type localProcessError: float
    :param localProcessError:
    :rtype: :py:class:`CardinalSplineModel`
    :return: instance
    """
    return _fast.CardinalSplineModel_create(controlPoints, globalProcessError, localProcessError)

class EllipseModel(ShapeModel):
    r"""
    Ellipse shape model

    Used in the Kalman filter deformable model segmentation algorithm

    See also: KalmanFilter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.EllipseModel_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.EllipseModel_getStaticNameOfClass()

    @staticmethod
    def create(position: "Vector2f", majorRadius: "float", MinorRadius: "float") -> "std::shared_ptr< fast::EllipseModel >":
        r"""
        Create instance
        :type position: Vector2f
        :param position: center position of ellipse
        :type majorRadius: float
        :param majorRadius: major radius
        :type MinorRadius: float
        :param MinorRadius: minor radius
        :rtype: :py:class:`EllipseModel`
        :return: instance
        """
        return _fast.EllipseModel_create(position, majorRadius, MinorRadius)

    def getShape(self, state: "VectorXf") -> "fast::Shape::pointer":
        return _fast.EllipseModel_getShape(self, state)

    def getStateTransitionMatrix1(self) -> "MatrixXf":
        return _fast.EllipseModel_getStateTransitionMatrix1(self)

    def getStateTransitionMatrix2(self) -> "MatrixXf":
        return _fast.EllipseModel_getStateTransitionMatrix2(self)

    def getStateTransitionMatrix3(self) -> "MatrixXf":
        return _fast.EllipseModel_getStateTransitionMatrix3(self)

    def getProcessErrorMatrix(self) -> "MatrixXf":
        return _fast.EllipseModel_getProcessErrorMatrix(self)

    def getMeasurementVectors(self, state: "VectorXf", shape: "fast::Shape::pointer") -> "std::vector< MatrixXf,std::allocator< MatrixXf > >":
        return _fast.EllipseModel_getMeasurementVectors(self, state, shape)

    def setInitialState(self, position: "Vector2f", majorRadius: "float", minorRadius: "float") -> "void":
        r"""Set initial state in mm"""
        return _fast.EllipseModel_setInitialState(self, position, majorRadius, minorRadius)

    def getInitialState(self, image: "std::shared_ptr< fast::Image >") -> "VectorXf":
        return _fast.EllipseModel_getInitialState(self, image)

    def restrictState(self, state: "VectorXf") -> "VectorXf":
        return _fast.EllipseModel_restrictState(self, state)
    __swig_destroy__ = _fast.delete_EllipseModel

# Register EllipseModel in _fast:
_fast.EllipseModel_swigregister(EllipseModel)

def EllipseModel_getStaticNameOfClass() -> "std::string":
    return _fast.EllipseModel_getStaticNameOfClass()

def EllipseModel_create(position: "Vector2f", majorRadius: "float", MinorRadius: "float") -> "std::shared_ptr< fast::EllipseModel >":
    r"""
    Create instance
    :type position: Vector2f
    :param position: center position of ellipse
    :type majorRadius: float
    :param majorRadius: major radius
    :type MinorRadius: float
    :param MinorRadius: minor radius
    :rtype: :py:class:`EllipseModel`
    :return: instance
    """
    return _fast.EllipseModel_create(position, majorRadius, MinorRadius)

class MeanValueCoordinatesModel(ShapeModel):
    r"""
    Mean value coordinates shape model

    Used in Kalman filter deformable model segmentation

    See also: KalmanFilter CardianlSplineModel EllipseModel
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.MeanValueCoordinatesModel_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MeanValueCoordinatesModel_getStaticNameOfClass()

    @staticmethod
    def create(*args) -> "std::shared_ptr< fast::MeanValueCoordinatesModel >":
        return _fast.MeanValueCoordinatesModel_create(*args)

    def getShape(self, state: "VectorXf") -> "fast::Shape::pointer":
        return _fast.MeanValueCoordinatesModel_getShape(self, state)

    def getStateTransitionMatrix1(self) -> "MatrixXf":
        return _fast.MeanValueCoordinatesModel_getStateTransitionMatrix1(self)

    def getStateTransitionMatrix2(self) -> "MatrixXf":
        return _fast.MeanValueCoordinatesModel_getStateTransitionMatrix2(self)

    def getStateTransitionMatrix3(self) -> "MatrixXf":
        return _fast.MeanValueCoordinatesModel_getStateTransitionMatrix3(self)

    def getProcessErrorMatrix(self) -> "MatrixXf":
        return _fast.MeanValueCoordinatesModel_getProcessErrorMatrix(self)

    def getInitialState(self, image: "std::shared_ptr< fast::Image >") -> "VectorXf":
        return _fast.MeanValueCoordinatesModel_getInitialState(self, image)

    def getMeasurementVectors(self, state: "VectorXf", shape: "fast::Shape::pointer") -> "std::vector< MatrixXf,std::allocator< MatrixXf > >":
        return _fast.MeanValueCoordinatesModel_getMeasurementVectors(self, state, shape)

    def initializeShapeToImageCenter(self) -> "void":
        return _fast.MeanValueCoordinatesModel_initializeShapeToImageCenter(self)

    def setInitialScaling(self, x: "float", y: "float", z: "float") -> "void":
        return _fast.MeanValueCoordinatesModel_setInitialScaling(self, x, y, z)

    def setInitialTranslation(self, x: "float", y: "float", z: "float") -> "void":
        return _fast.MeanValueCoordinatesModel_setInitialTranslation(self, x, y, z)

    def setLocalProcessError(self, error: "float") -> "void":
        return _fast.MeanValueCoordinatesModel_setLocalProcessError(self, error)

    def setGlobalProcessError(self, error: "float") -> "void":
        return _fast.MeanValueCoordinatesModel_setGlobalProcessError(self, error)
    __swig_destroy__ = _fast.delete_MeanValueCoordinatesModel

# Register MeanValueCoordinatesModel in _fast:
_fast.MeanValueCoordinatesModel_swigregister(MeanValueCoordinatesModel)

def MeanValueCoordinatesModel_getStaticNameOfClass() -> "std::string":
    return _fast.MeanValueCoordinatesModel_getStaticNameOfClass()

def MeanValueCoordinatesModel_create(*args) -> "std::shared_ptr< fast::MeanValueCoordinatesModel >":
    return _fast.MeanValueCoordinatesModel_create(*args)

class LabelModifier(ProcessObject):
    r"""
    Change labels in a segmentation image

    Used to converting all pixels with label/intensity X to label/intensity Y

    TODO: Use std::map/dict in constructor instead of two vectors?

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::LabelModifier >":
        return _fast.LabelModifier_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.LabelModifier_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.LabelModifier_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::LabelModifier >":
        return _fast.LabelModifier_connect(self, *args)

    @staticmethod
    def create(oldLabels: "vectoruc", newLabels: "vectoruc") -> "std::shared_ptr< fast::LabelModifier >":
        r"""
        Create instance
        :type oldLabels: std::vector< uchar,std::allocator< uchar > >
        :param oldLabels: A list of labels to change
        :type newLabels: std::vector< uchar,std::allocator< uchar > >
        :param newLabels: A list of new labels for the labels specified in oldLabels
        :rtype: :py:class:`LabelModifier`
        :return: 
        """
        return _fast.LabelModifier_create(oldLabels, newLabels)

    def setLabelChange(self, oldLabel: "uchar", newLabel: "uchar") -> "void":
        return _fast.LabelModifier_setLabelChange(self, oldLabel, newLabel)

    def loadAttributes(self) -> "void":
        return _fast.LabelModifier_loadAttributes(self)
    __swig_destroy__ = _fast.delete_LabelModifier

# Register LabelModifier in _fast:
_fast.LabelModifier_swigregister(LabelModifier)

def LabelModifier_New() -> "std::shared_ptr< fast::LabelModifier >":
    return _fast.LabelModifier_New()

def LabelModifier_getStaticNameOfClass() -> "std::string":
    return _fast.LabelModifier_getStaticNameOfClass()

def LabelModifier_create(oldLabels: "vectoruc", newLabels: "vectoruc") -> "std::shared_ptr< fast::LabelModifier >":
    r"""
    Create instance
    :type oldLabels: std::vector< uchar,std::allocator< uchar > >
    :param oldLabels: A list of labels to change
    :type newLabels: std::vector< uchar,std::allocator< uchar > >
    :param newLabels: A list of new labels for the labels specified in oldLabels
    :rtype: :py:class:`LabelModifier`
    :return: 
    """
    return _fast.LabelModifier_create(oldLabels, newLabels)

class LaplacianOfGaussian(ProcessObject):
    r"""
    Calculate image gradient using Laplacian of Gaussian method

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::LaplacianOfGaussian >":
        return _fast.LaplacianOfGaussian_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.LaplacianOfGaussian_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.LaplacianOfGaussian_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::LaplacianOfGaussian >":
        return _fast.LaplacianOfGaussian_connect(self, *args)

    @staticmethod
    def create(stdDev: "float"=1.0, maskSize: "uchar"=0) -> "std::shared_ptr< fast::LaplacianOfGaussian >":
        r"""
        Create instance
        :type stdDev: float
        :param stdDev: Standard deviation of Gaussian, default: 1.0
        :type maskSize: uchar
        :param maskSize: Size of mask used for Gaussian, if zero mask size is calculated based on stdDev. Default: 0
        :rtype: :py:class:`LaplacianOfGaussian`
        :return: instance
        """
        return _fast.LaplacianOfGaussian_create(stdDev, maskSize)

    def setMaskSize(self, maskSize: "unsigned char") -> "void":
        return _fast.LaplacianOfGaussian_setMaskSize(self, maskSize)

    def setStandardDeviation(self, stdDev: "float") -> "void":
        return _fast.LaplacianOfGaussian_setStandardDeviation(self, stdDev)
    __swig_destroy__ = _fast.delete_LaplacianOfGaussian

# Register LaplacianOfGaussian in _fast:
_fast.LaplacianOfGaussian_swigregister(LaplacianOfGaussian)

def LaplacianOfGaussian_New() -> "std::shared_ptr< fast::LaplacianOfGaussian >":
    return _fast.LaplacianOfGaussian_New()

def LaplacianOfGaussian_getStaticNameOfClass() -> "std::string":
    return _fast.LaplacianOfGaussian_getStaticNameOfClass()

def LaplacianOfGaussian_create(stdDev: "float"=1.0, maskSize: "uchar"=0) -> "std::shared_ptr< fast::LaplacianOfGaussian >":
    r"""
    Create instance
    :type stdDev: float
    :param stdDev: Standard deviation of Gaussian, default: 1.0
    :type maskSize: uchar
    :param maskSize: Size of mask used for Gaussian, if zero mask size is calculated based on stdDev. Default: 0
    :rtype: :py:class:`LaplacianOfGaussian`
    :return: instance
    """
    return _fast.LaplacianOfGaussian_create(stdDev, maskSize)

class LevelSetSegmentation(ProcessObject):
    r"""
    Level set image segmentation

    GPU-based level set segmentation using spherical seed points.
    Only supports 3D images atm.

    Inputs:
    - 0: Image 3D

    Outputs:
    - 0: Image segmentation 3D

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::LevelSetSegmentation >":
        return _fast.LevelSetSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.LevelSetSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.LevelSetSegmentation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::LevelSetSegmentation >":
        return _fast.LevelSetSegmentation_connect(self, *args)

    @staticmethod
    def create(seedPoints: "std::vector< Vector3i,std::allocator< Vector3i > >", seedRadius: "float"=1.0, curvatureWeight: "float"=0.9, maxIterations: "int"=1000) -> "std::shared_ptr< fast::LevelSetSegmentation >":
        r"""
        Create instance
        :type seedPoints: std::vector< Vector3i,std::allocator< Vector3i > >
        :param seedPoints: List of 3D points to create seeds
        :type seedRadius: float
        :param seedRadius: Radius of seeds
        :type curvatureWeight: float
        :param curvatureWeight: Weight for curvature term
        :type maxIterations: int
        :param maxIterations: Maximum number of iterations
        :rtype: :py:class:`LevelSetSegmentation`
        :return: instance
        """
        return _fast.LevelSetSegmentation_create(seedPoints, seedRadius, curvatureWeight, maxIterations)

    def addSeedPoint(self, position: "Vector3i", radius: "float") -> "void":
        return _fast.LevelSetSegmentation_addSeedPoint(self, position, radius)

    def setCurvatureWeight(self, weight: "float") -> "void":
        return _fast.LevelSetSegmentation_setCurvatureWeight(self, weight)

    def setIntensityMean(self, intensity: "float") -> "void":
        return _fast.LevelSetSegmentation_setIntensityMean(self, intensity)

    def setIntensityVariance(self, variation: "float") -> "void":
        return _fast.LevelSetSegmentation_setIntensityVariance(self, variation)

    def setMaxIterations(self, iterations: "uint") -> "void":
        return _fast.LevelSetSegmentation_setMaxIterations(self, iterations)
    __swig_destroy__ = _fast.delete_LevelSetSegmentation

# Register LevelSetSegmentation in _fast:
_fast.LevelSetSegmentation_swigregister(LevelSetSegmentation)

def LevelSetSegmentation_New() -> "std::shared_ptr< fast::LevelSetSegmentation >":
    return _fast.LevelSetSegmentation_New()

def LevelSetSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.LevelSetSegmentation_getStaticNameOfClass()

def LevelSetSegmentation_create(seedPoints: "std::vector< Vector3i,std::allocator< Vector3i > >", seedRadius: "float"=1.0, curvatureWeight: "float"=0.9, maxIterations: "int"=1000) -> "std::shared_ptr< fast::LevelSetSegmentation >":
    r"""
    Create instance
    :type seedPoints: std::vector< Vector3i,std::allocator< Vector3i > >
    :param seedPoints: List of 3D points to create seeds
    :type seedRadius: float
    :param seedRadius: Radius of seeds
    :type curvatureWeight: float
    :param curvatureWeight: Weight for curvature term
    :type maxIterations: int
    :param maxIterations: Maximum number of iterations
    :rtype: :py:class:`LevelSetSegmentation`
    :return: instance
    """
    return _fast.LevelSetSegmentation_create(seedPoints, seedRadius, curvatureWeight, maxIterations)

class LungSegmentation(ProcessObject):
    r"""
    Segment the lung, airways and blood vessels from a CT using seeded region growing and morpohology

    Inputs:
    - 0: Image a 3D CT image

    Outputs:
    - 0: Image segmentation of lungs
    - 1: Image segmentation of airways
    - 2: Image segmentation of blood vessels (only if extractBloodVessels == true)

    See also: AirwaySegmentation
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::LungSegmentation >":
        return _fast.LungSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.LungSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.LungSegmentation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::LungSegmentation >":
        return _fast.LungSegmentation_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::LungSegmentation >":
        r"""
        Create instance
        :type airwaySeedPoint: Vector3i
        :param airwaySeedPoint: Manually specify seed point for airways. By default it will automatically try to find the seed point.
        :type lungSeedPoint: Vector3i
        :param lungSeedPoint: Manually specify seed point for lung. By default it will automatically try to find the seed point.
        :type extractBloodVessels: boolean
        :param extractBloodVessels: Whether to extract blood vessels as well or not, Default: false
        :rtype: :py:class:`LungSegmentation`
        :return: instance
        """
        return _fast.LungSegmentation_create(*args, **kwargs)

    def setAirwaySeedPoint(self, *args) -> "void":
        return _fast.LungSegmentation_setAirwaySeedPoint(self, *args)

    def setLungSeedPoint(self, *args) -> "void":
        return _fast.LungSegmentation_setLungSeedPoint(self, *args)
    __swig_destroy__ = _fast.delete_LungSegmentation

# Register LungSegmentation in _fast:
_fast.LungSegmentation_swigregister(LungSegmentation)

def LungSegmentation_New() -> "std::shared_ptr< fast::LungSegmentation >":
    return _fast.LungSegmentation_New()

def LungSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.LungSegmentation_getStaticNameOfClass()

def LungSegmentation_create(*args, **kwargs) -> "std::shared_ptr< fast::LungSegmentation >":
    r"""
    Create instance
    :type airwaySeedPoint: Vector3i
    :param airwaySeedPoint: Manually specify seed point for airways. By default it will automatically try to find the seed point.
    :type lungSeedPoint: Vector3i
    :param lungSeedPoint: Manually specify seed point for lung. By default it will automatically try to find the seed point.
    :type extractBloodVessels: boolean
    :param extractBloodVessels: Whether to extract blood vessels as well or not, Default: false
    :rtype: :py:class:`LungSegmentation`
    :return: instance
    """
    return _fast.LungSegmentation_create(*args, **kwargs)

class MeshToSegmentation(ProcessObject):
    r"""
    Converts a line (2D) or triangle (3D) mesh to a segmentation image

    To set the output size of segmentation image, either supply an image to input port 1, or manually specify the size.

    Inputs:
    - 0: Mesh to convert
    - 1: (Optional) Image to get size of output from

    Outputs:
    - 0: Image - Segmentation image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MeshToSegmentation >":
        return _fast.MeshToSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MeshToSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MeshToSegmentation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::MeshToSegmentation >":
        return _fast.MeshToSegmentation_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::MeshToSegmentation >":
        r"""
        Create instance
        :type size: Vector3i
        :param size: Size of segmentation image to output. If not set it will use the same size as the image given to input 1 (optional).
        :rtype: :py:class:`MeshToSegmentation`
        :return: instance
        """
        return _fast.MeshToSegmentation_create(*args, **kwargs)

    def setOutputImageResolution(self, x: "uint", y: "uint", z: "uint"=1) -> "void":
        r"""
        Set output image resolution in voxels
        :type x: int
        :param x:
        :type y: int
        :param y:
        :type z: int
        :param z:
        """
        return _fast.MeshToSegmentation_setOutputImageResolution(self, x, y, z)
    __swig_destroy__ = _fast.delete_MeshToSegmentation

# Register MeshToSegmentation in _fast:
_fast.MeshToSegmentation_swigregister(MeshToSegmentation)

def MeshToSegmentation_New() -> "std::shared_ptr< fast::MeshToSegmentation >":
    return _fast.MeshToSegmentation_New()

def MeshToSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.MeshToSegmentation_getStaticNameOfClass()

def MeshToSegmentation_create(*args, **kwargs) -> "std::shared_ptr< fast::MeshToSegmentation >":
    r"""
    Create instance
    :type size: Vector3i
    :param size: Size of segmentation image to output. If not set it will use the same size as the image given to input 1 (optional).
    :rtype: :py:class:`MeshToSegmentation`
    :return: instance
    """
    return _fast.MeshToSegmentation_create(*args, **kwargs)

class Dilation(ProcessObject):
    r"""
    Perform binary dilation with disk structuring element

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Dilation >":
        return _fast.Dilation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Dilation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Dilation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::Dilation >":
        return _fast.Dilation_connect(self, *args)

    @staticmethod
    def create(size: "int"=3) -> "std::shared_ptr< fast::Dilation >":
        r"""
        Create instance
        :type size: int
        :param size: Size of square dilation structuring element. Default 3: 3x3
        :rtype: :py:class:`Dilation`
        :return: instance
        """
        return _fast.Dilation_create(size)

    def setStructuringElementSize(self, size: "int") -> "void":
        r"""
        Set size of structuring element, must be odd
        :type size: int
        :param size:
        """
        return _fast.Dilation_setStructuringElementSize(self, size)

    def loadAttributes(self) -> "void":
        return _fast.Dilation_loadAttributes(self)
    __swig_destroy__ = _fast.delete_Dilation

# Register Dilation in _fast:
_fast.Dilation_swigregister(Dilation)

def Dilation_New() -> "std::shared_ptr< fast::Dilation >":
    return _fast.Dilation_New()

def Dilation_getStaticNameOfClass() -> "std::string":
    return _fast.Dilation_getStaticNameOfClass()

def Dilation_create(size: "int"=3) -> "std::shared_ptr< fast::Dilation >":
    r"""
    Create instance
    :type size: int
    :param size: Size of square dilation structuring element. Default 3: 3x3
    :rtype: :py:class:`Dilation`
    :return: instance
    """
    return _fast.Dilation_create(size)

class Erosion(ProcessObject):
    r"""
    Perform binary erosion with disk structuring element

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Erosion >":
        return _fast.Erosion_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Erosion_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Erosion_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::Erosion >":
        return _fast.Erosion_connect(self, *args)

    @staticmethod
    def create(size: "int"=3) -> "std::shared_ptr< fast::Erosion >":
        r"""
        Create instance
        :type size: int
        :param size: Size of square dilation structuring element. Default 3: 3x3
        :rtype: :py:class:`Erosion`
        :return: instance
        """
        return _fast.Erosion_create(size)

    def setStructuringElementSize(self, size: "int") -> "void":
        r"""
        Set size of structuring element, must be odd
        :type size: int
        :param size:
        """
        return _fast.Erosion_setStructuringElementSize(self, size)

    def loadAttributes(self) -> "void":
        return _fast.Erosion_loadAttributes(self)
    __swig_destroy__ = _fast.delete_Erosion

# Register Erosion in _fast:
_fast.Erosion_swigregister(Erosion)

def Erosion_New() -> "std::shared_ptr< fast::Erosion >":
    return _fast.Erosion_New()

def Erosion_getStaticNameOfClass() -> "std::string":
    return _fast.Erosion_getStaticNameOfClass()

def Erosion_create(size: "int"=3) -> "std::shared_ptr< fast::Erosion >":
    r"""
    Create instance
    :type size: int
    :param size: Size of square dilation structuring element. Default 3: 3x3
    :rtype: :py:class:`Erosion`
    :return: instance
    """
    return _fast.Erosion_create(size)

ImageOrdering_ChannelFirst = _fast.ImageOrdering_ChannelFirst
ImageOrdering_ChannelLast = _fast.ImageOrdering_ChannelLast
NodeType_UNSPECIFIED = _fast.NodeType_UNSPECIFIED
NodeType_IMAGE = _fast.NodeType_IMAGE
NodeType_TENSOR = _fast.NodeType_TENSOR
InferenceDeviceType_ANY = _fast.InferenceDeviceType_ANY
InferenceDeviceType_CPU = _fast.InferenceDeviceType_CPU
InferenceDeviceType_GPU = _fast.InferenceDeviceType_GPU
InferenceDeviceType_VPU = _fast.InferenceDeviceType_VPU
InferenceDeviceType_OTHER = _fast.InferenceDeviceType_OTHER
class InferenceDeviceInfo(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_fast.InferenceDeviceInfo_name_get, _fast.InferenceDeviceInfo_name_set)
    type = property(_fast.InferenceDeviceInfo_type_get, _fast.InferenceDeviceInfo_type_set)
    index = property(_fast.InferenceDeviceInfo_index_get, _fast.InferenceDeviceInfo_index_set)

    def __init__(self):
        _fast.InferenceDeviceInfo_swiginit(self, _fast.new_InferenceDeviceInfo())
    __swig_destroy__ = _fast.delete_InferenceDeviceInfo

# Register InferenceDeviceInfo in _fast:
_fast.InferenceDeviceInfo_swigregister(InferenceDeviceInfo)

class NeuralNetworkNode(object):
    r"""A struct/class representing a neural network input/output node"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Constructor

        :type name: string
        :param name: Name of node, must match name of node in network file
        :type type: int
        :param type:
        :type shape: :py:class:`TensorShape`
        :param shape:
        :type id: int
        :param id: Input/Output port id
        :type minShape: :py:class:`TensorShape`
        :param minShape: If node has dynamic shape, you can set the minimum shape for optimizations.
               Note that this is required for the TensorRT engine.
        :type maxShape: :py:class:`TensorShape`
        :param maxShape: If node has dynamic shape, you can set the maximum shape for optimizations.
               Note that this is required for the TensorRT engine.
        """
        _fast.NeuralNetworkNode_swiginit(self, _fast.new_NeuralNetworkNode(*args, **kwargs))
    id = property(_fast.NeuralNetworkNode_id_get, _fast.NeuralNetworkNode_id_set)
    name = property(_fast.NeuralNetworkNode_name_get, _fast.NeuralNetworkNode_name_set)
    type = property(_fast.NeuralNetworkNode_type_get, _fast.NeuralNetworkNode_type_set)
    shape = property(_fast.NeuralNetworkNode_shape_get, _fast.NeuralNetworkNode_shape_set)
    optShape = property(_fast.NeuralNetworkNode_optShape_get, _fast.NeuralNetworkNode_optShape_set)
    minShape = property(_fast.NeuralNetworkNode_minShape_get, _fast.NeuralNetworkNode_minShape_set)
    maxShape = property(_fast.NeuralNetworkNode_maxShape_get, _fast.NeuralNetworkNode_maxShape_set)
    data = property(_fast.NeuralNetworkNode_data_get, _fast.NeuralNetworkNode_data_set)
    __swig_destroy__ = _fast.delete_NeuralNetworkNode

# Register NeuralNetworkNode in _fast:
_fast.NeuralNetworkNode_swigregister(NeuralNetworkNode)

ModelFormat_PROTOBUF = _fast.ModelFormat_PROTOBUF
ModelFormat_SAVEDMODEL = _fast.ModelFormat_SAVEDMODEL
ModelFormat_ONNX = _fast.ModelFormat_ONNX
ModelFormat_OPENVINO = _fast.ModelFormat_OPENVINO
ModelFormat_UFF = _fast.ModelFormat_UFF

def getModelFileExtension(format: "fast::ModelFormat") -> "std::string":
    r"""Get model format file extension."""
    return _fast.getModelFileExtension(format)

def getModelFormat(filename: "std::string") -> "fast::ModelFormat":
    r"""Get model format of the given file."""
    return _fast.getModelFormat(filename)

def getModelFormatName(format: "fast::ModelFormat") -> "std::string":
    r"""
    Get name of model format as string
    :type format: int
    :param format:
    :rtype: string
    :return: 
    """
    return _fast.getModelFormatName(format)
class InferenceEngine(Object):
    r"""Abstract class for neural network inference engines (TensorFlow, TensorRT ++)"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.InferenceEngine_setFilename(self, filename)

    def setModelAndWeights(self, model: "vectoruc", weights: "vectoruc") -> "void":
        return _fast.InferenceEngine_setModelAndWeights(self, model, weights)

    def getFilename(self) -> "std::string":
        return _fast.InferenceEngine_getFilename(self)

    def run(self) -> "void":
        return _fast.InferenceEngine_run(self)

    def addInputNode(self, node: "NeuralNetworkNode") -> "void":
        return _fast.InferenceEngine_addInputNode(self, node)

    def addOutputNode(self, node: "NeuralNetworkNode") -> "void":
        return _fast.InferenceEngine_addOutputNode(self, node)

    def setInputNodeShape(self, name: "std::string", shape: "TensorShape") -> "void":
        return _fast.InferenceEngine_setInputNodeShape(self, name, shape)

    def setOutputNodeShape(self, name: "std::string", shape: "TensorShape") -> "void":
        return _fast.InferenceEngine_setOutputNodeShape(self, name, shape)

    def getInputNode(self, name: "std::string") -> "fast::NeuralNetworkNode":
        return _fast.InferenceEngine_getInputNode(self, name)

    def getOutputNode(self, name: "std::string") -> "fast::NeuralNetworkNode":
        return _fast.InferenceEngine_getOutputNode(self, name)

    def getOutputNodes(self) -> "std::map< std::string,fast::NeuralNetworkNode,std::less< std::string >,std::allocator< std::pair< std::string const,fast::NeuralNetworkNode > > >":
        return _fast.InferenceEngine_getOutputNodes(self)

    def getInputNodes(self) -> "std::map< std::string,fast::NeuralNetworkNode,std::less< std::string >,std::allocator< std::pair< std::string const,fast::NeuralNetworkNode > > >":
        return _fast.InferenceEngine_getInputNodes(self)

    def setInputData(self, inputNodeName: "std::string", tensor: "std::shared_ptr< fast::Tensor >") -> "void":
        return _fast.InferenceEngine_setInputData(self, inputNodeName, tensor)

    def getOutputData(self, inputNodeName: "std::string") -> "std::shared_ptr< fast::Tensor >":
        return _fast.InferenceEngine_getOutputData(self, inputNodeName)

    def load(self) -> "void":
        return _fast.InferenceEngine_load(self)

    def isLoaded(self) -> "bool":
        return _fast.InferenceEngine_isLoaded(self)

    def getPreferredImageOrdering(self) -> "fast::ImageOrdering":
        return _fast.InferenceEngine_getPreferredImageOrdering(self)

    def getName(self) -> "std::string":
        return _fast.InferenceEngine_getName(self)

    def getSupportedModelFormats(self) -> "std::vector< fast::ModelFormat,std::allocator< fast::ModelFormat > >":
        return _fast.InferenceEngine_getSupportedModelFormats(self)

    def getPreferredModelFormat(self) -> "fast::ModelFormat":
        return _fast.InferenceEngine_getPreferredModelFormat(self)

    def isModelFormatSupported(self, format: "fast::ModelFormat") -> "bool":
        return _fast.InferenceEngine_isModelFormatSupported(self, format)

    def setDeviceType(self, type: "fast::InferenceDeviceType") -> "void":
        r"""
        Set which device type the inference engine should use
        (assuming the IE supports multiple devices like OpenVINO)
        :type type: int
        :param type:
        """
        return _fast.InferenceEngine_setDeviceType(self, type)

    def setDevice(self, *args, **kwargs) -> "void":
        r"""
        Specify which device index and/or device type to use
        :type index: int
        :param index: Index of the device to use. -1 means any device can be used
        :type type: int
        :param type:
        """
        return _fast.InferenceEngine_setDevice(self, *args, **kwargs)

    def getDeviceList(self) -> "std::vector< fast::InferenceDeviceInfo,std::allocator< fast::InferenceDeviceInfo > >":
        r"""
        Get a list of devices available for this inference engine.

        :rtype: std::vector< fast::InferenceDeviceInfo,std::allocator< fast::InferenceDeviceInfo > >
        :return: vector with info on each device
        """
        return _fast.InferenceEngine_getDeviceList(self)

    def getMaxBatchSize(self) -> "int":
        return _fast.InferenceEngine_getMaxBatchSize(self)

    def setMaxBatchSize(self, size: "int") -> "void":
        return _fast.InferenceEngine_setMaxBatchSize(self, size)

    def loadCustomPlugins(self, filenames: "vectors") -> "void":
        r"""
        Load a custom operator (op), plugin. Must be called before load()

        :param filename: path to library (.so/.dll) or in the case of GPU/VPU OpenVINO .xml files.
        """
        return _fast.InferenceEngine_loadCustomPlugins(self, filenames)

    def setImageOrdering(self, ordering: "fast::ImageOrdering") -> "void":
        r"""
        Set dimension image ordering manually.
        E.g. channel last or channel-first.

        :type ordering: int
        :param ordering:
        """
        return _fast.InferenceEngine_setImageOrdering(self, ordering)

    @staticmethod
    def detectNodeType(shape: "TensorShape const &") -> "fast::NodeType":
        r"""
        Detect node type from shape
        :type shape: TensorShape
        :param shape:
        :rtype: int
        :return: 
        """
        return _fast.InferenceEngine_detectNodeType(shape)

    @staticmethod
    def detectImageOrdering(shape: "TensorShape const &", hasBatchDim: "bool"=True) -> "fast::ImageOrdering":
        r"""
        Detect image ordering from shape
        :type shape: TensorShape
        :param shape: shape to check
        :type hasBatchDim: boolean
        :param hasBatchDim: Whether first dimension is batch dimension
        :rtype: int
        :return: 
        """
        return _fast.InferenceEngine_detectImageOrdering(shape, hasBatchDim)
    __swig_destroy__ = _fast.delete_InferenceEngine

# Register InferenceEngine in _fast:
_fast.InferenceEngine_swigregister(InferenceEngine)

def InferenceEngine_detectNodeType(shape: "TensorShape const &") -> "fast::NodeType":
    r"""
    Detect node type from shape
    :type shape: TensorShape
    :param shape:
    :rtype: int
    :return: 
    """
    return _fast.InferenceEngine_detectNodeType(shape)

def InferenceEngine_detectImageOrdering(shape: "TensorShape const &", hasBatchDim: "bool"=True) -> "fast::ImageOrdering":
    r"""
    Detect image ordering from shape
    :type shape: TensorShape
    :param shape: shape to check
    :type hasBatchDim: boolean
    :param hasBatchDim: Whether first dimension is batch dimension
    :rtype: int
    :return: 
    """
    return _fast.InferenceEngine_detectImageOrdering(shape, hasBatchDim)

class InferenceEngineManager(object):
    r"""A purely static class to dynamically load inference engines at runtime"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def getEngineList() -> "std::vector< std::string,std::allocator< std::string > >":
        return _fast.InferenceEngineManager_getEngineList()

    @staticmethod
    def loadAll() -> "void":
        return _fast.InferenceEngineManager_loadAll()

    @staticmethod
    def loadEngine(name: "std::string") -> "std::shared_ptr< fast::InferenceEngine >":
        return _fast.InferenceEngineManager_loadEngine(name)

    @staticmethod
    def loadBestAvailableEngine(*args) -> "std::shared_ptr< fast::InferenceEngine >":
        return _fast.InferenceEngineManager_loadBestAvailableEngine(*args)

    @staticmethod
    def isEngineAvailable(name: "std::string") -> "bool":
        return _fast.InferenceEngineManager_isEngineAvailable(name)

    def __init__(self):
        _fast.InferenceEngineManager_swiginit(self, _fast.new_InferenceEngineManager())
    __swig_destroy__ = _fast.delete_InferenceEngineManager

# Register InferenceEngineManager in _fast:
_fast.InferenceEngineManager_swigregister(InferenceEngineManager)

def InferenceEngineManager_getEngineList() -> "std::vector< std::string,std::allocator< std::string > >":
    return _fast.InferenceEngineManager_getEngineList()

def InferenceEngineManager_loadAll() -> "void":
    return _fast.InferenceEngineManager_loadAll()

def InferenceEngineManager_loadEngine(name: "std::string") -> "std::shared_ptr< fast::InferenceEngine >":
    return _fast.InferenceEngineManager_loadEngine(name)

def InferenceEngineManager_loadBestAvailableEngine(*args) -> "std::shared_ptr< fast::InferenceEngine >":
    return _fast.InferenceEngineManager_loadBestAvailableEngine(*args)

def InferenceEngineManager_isEngineAvailable(name: "std::string") -> "bool":
    return _fast.InferenceEngineManager_isEngineAvailable(name)

class InferenceDataList(object):
    r"""
    A class containing a list of data objects for inference, either Image or Tensor objects.

    This is used as a container for Batch and Sequence data objects.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _fast.InferenceDataList_swiginit(self, _fast.new_InferenceDataList(*args))

    def getImages(self) -> "std::vector< std::shared_ptr< fast::Image >,std::allocator< std::shared_ptr< fast::Image > > >":
        return _fast.InferenceDataList_getImages(self)

    def getTensors(self) -> "std::vector< std::shared_ptr< fast::Tensor >,std::allocator< std::shared_ptr< fast::Tensor > > >":
        return _fast.InferenceDataList_getTensors(self)

    def isTensors(self) -> "bool":
        return _fast.InferenceDataList_isTensors(self)

    def isImages(self) -> "bool":
        return _fast.InferenceDataList_isImages(self)

    def getSize(self) -> "int":
        return _fast.InferenceDataList_getSize(self)
    __swig_destroy__ = _fast.delete_InferenceDataList

# Register InferenceDataList in _fast:
_fast.InferenceDataList_swigregister(InferenceDataList)

class Sequence(BatchT):
    r"""
    Sequence data object

    A data object used for neural network processing of a sequence of data.
    The sequence can consist of Image or Tensor objects.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.Sequence_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Sequence_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Sequence >":
        return _fast.Sequence_fromDataObject(object)

    @staticmethod
    def create(*args) -> "std::shared_ptr< fast::Sequence >":
        return _fast.Sequence_create(*args)
    __swig_destroy__ = _fast.delete_Sequence

# Register Sequence in _fast:
_fast.Sequence_swigregister(Sequence)

def Sequence_getStaticNameOfClass() -> "std::string":
    return _fast.Sequence_getStaticNameOfClass()

def Sequence_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Sequence >":
    return _fast.Sequence_fromDataObject(object)

def Sequence_create(*args) -> "std::shared_ptr< fast::Sequence >":
    return _fast.Sequence_create(*args)

class Batch(BatchT):
    r"""
    Batch data object

    A data object used for batch processing in neural networks.
    The batch consists of Image or Tensor objects.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.Batch_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Batch_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Batch >":
        return _fast.Batch_fromDataObject(object)

    @staticmethod
    def create(*args) -> "std::shared_ptr< fast::Batch >":
        return _fast.Batch_create(*args)
    __swig_destroy__ = _fast.delete_Batch

# Register Batch in _fast:
_fast.Batch_swigregister(Batch)

def Batch_getStaticNameOfClass() -> "std::string":
    return _fast.Batch_getStaticNameOfClass()

def Batch_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Batch >":
    return _fast.Batch_fromDataObject(object)

def Batch_create(*args) -> "std::shared_ptr< fast::Batch >":
    return _fast.Batch_create(*args)

class NeuralNetwork(ProcessObject):
    r"""
    Neural network process object

    This is the neural network process object base. All other neural network process objects should extend this class.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::NeuralNetwork >":
        return _fast.NeuralNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.NeuralNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.NeuralNetwork_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::NeuralNetwork >":
        return _fast.NeuralNetwork_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::NeuralNetwork >":
        r"""
        Create instance
        Python friendly constructor with almost all parameters.

        :type modelFilename: string
        :param modelFilename: Path to model to load
        :type scaleFactor: float
        :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
                 network. Use this to scale your pixels values. Default: 1.0
        :type meanIntensity: float
        :param meanIntensity: Mean intensity to subtract from each pixel of the input image
        :type standardDeviationIntensity: float
        :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
        :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param inputNodes: Specify names, and potentially shapes, of input nodes.
                 Not necessary unless you only want to use certain inputs or specify the input shape manually.
        :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
                 Not necessary unless you only want to use certain outputs or specify the output shape manually.
        :type inferenceEngine: string
        :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
                 By default, FAST will select the best inference engine available on your system.
        :type customPlugins: std::vector< std::string,std::allocator< std::string > >
        :param customPlugins: Specify path to any custom plugins/operators to load
        :rtype: :py:class:`NeuralNetwork`
        :return: instance
        """
        return _fast.NeuralNetwork_create(*args, **kwargs)

    def load(self, *args) -> "void":
        r"""
        *Overload 1:*

        Load a given network model file. This takes time. The second argument can be used
        to specify files for loading custom plugins/operators needed by the network model.

        :type filename: string
        :param filename: Path to network model file.
        :type customPlugins: std::vector< std::string,std::allocator< std::string > >
        :param customPlugins: Paths to custom plugins/operators which can be libraries (.so/.dll) or in the case of GPU/VPU OpenVINO: .xml files.

        |

        *Overload 2:*

        Load a network from memory provided as byte two byte vectors: model and weights
        The second argument can be used to specify files for loading custom plugins/operators
        needed by the network model.

        :type model: std::vector< uint8_t,std::allocator< uint8_t > >
        :param model:
        :type weights: std::vector< uint8_t,std::allocator< uint8_t > >
        :param weights:
        :type customPlugins: std::vector< std::string,std::allocator< std::string > >
        :param customPlugins: paths to custom plugins/operators which can be libraries (.so/.dll) or in the case of GPU/VPU OpenVINO: .xml files.
        """
        return _fast.NeuralNetwork_load(self, *args)

    def setInferenceEngine(self, *args) -> "void":
        r"""
        *Overload 1:*

        Specify which inference engine to use
        :type engine: :py:class:`InferenceEngine`
        :param engine:

        |

        *Overload 2:*

        Specify which inference engine to use
        :type engine: string
        :param engine:
        """
        return _fast.NeuralNetwork_setInferenceEngine(self, *args)

    def getInferenceEngine(self) -> "fast::InferenceEngine::pointer":
        r"""
        Retrieve current inference engine
        :rtype: :py:class:`InferenceEngine`
        :return: 
        """
        return _fast.NeuralNetwork_getInferenceEngine(self)

    def setInputNode(self, *args) -> "void":
        return _fast.NeuralNetwork_setInputNode(self, *args)

    def setOutputNode(self, *args) -> "void":
        return _fast.NeuralNetwork_setOutputNode(self, *args)

    def setScaleFactor(self, scale: "float") -> "void":
        r"""
        For each input value i: new_i = i*scale
        :type scale: float
        :param scale:
        """
        return _fast.NeuralNetwork_setScaleFactor(self, scale)

    def setMeanAndStandardDeviation(self, mean: "float", std: "float") -> "void":
        r"""
        For each input value i: new_i = (i - mean)/std, this is applied after the scale factor
        :type mean: float
        :param mean:
        :type std: float
        :param std:
        """
        return _fast.NeuralNetwork_setMeanAndStandardDeviation(self, mean, std)

    def setMinAndMaxIntensity(self, min: "float", max: "float") -> "void":
        r"""
        Intensities of input image will be clipped at these values
        :type min: float
        :param min:
        :type max: float
        :param max:
        """
        return _fast.NeuralNetwork_setMinAndMaxIntensity(self, min, max)

    def setSignedInputNormalization(self, signedInputNormalization: "bool") -> "void":
        return _fast.NeuralNetwork_setSignedInputNormalization(self, signedInputNormalization)

    def setPreserveAspectRatio(self, preserve: "bool") -> "void":
        return _fast.NeuralNetwork_setPreserveAspectRatio(self, preserve)

    def setHorizontalFlipping(self, flip: "bool") -> "void":
        r"""
        Setting this parameter to true will flip the input image horizontally.
        For pixel classification the output image will be flipped back.
        :type flip: boolean
        :param flip:
        """
        return _fast.NeuralNetwork_setHorizontalFlipping(self, flip)

    def getInputNodes(self) -> "std::map< std::string,fast::NeuralNetworkNode,std::less< std::string >,std::allocator< std::pair< std::string const,fast::NeuralNetworkNode > > >":
        return _fast.NeuralNetwork_getInputNodes(self)

    def getOutputNodes(self) -> "std::map< std::string,fast::NeuralNetworkNode,std::less< std::string >,std::allocator< std::pair< std::string const,fast::NeuralNetworkNode > > >":
        return _fast.NeuralNetwork_getOutputNodes(self)

    def getNode(self, name: "std::string") -> "fast::NeuralNetworkNode":
        return _fast.NeuralNetwork_getNode(self, name)

    def setTemporalWindow(self, window: "uint") -> "void":
        r"""
        Set the temporal window for dynamic mode.
        If window > 1, assume the second dimension of the input tensor is the number of timesteps.
        If the window is set to 4, the frames t-3, t-2, t-1 and t, where t is the current timestep,
        will be given as input to the network.

        :type window: int
        :param window:
        """
        return _fast.NeuralNetwork_setTemporalWindow(self, window)

    def addTemporalState(self, *args, **kwargs) -> "void":
        r"""
        Add a temporal state uses input and output nodes to remember state between runs

        Not all inference engines support stateful temporal neural networks directly.
        Stateful LSTM/GRU/ConvLSTM layers remembers it's internal state from one run to the next.
        Statefullness can still be enabled by having an additional input and output node for each
        temporal state in the neural network, and then copy the temporal state from the output node to the
        input node for the next run.
        The first run the input nodes for the temporal state are all zero.

        :type inputNodeName: string
        :param inputNodeName: Name of the input node for the given temporal state
        :type outputNodeName: string
        :param outputNodeName: Name of the output node for the given temporal state
        :type shape: TensorShape
        :param shape: Shape of the temporal state tensor. If empty, FAST will try to find the shape automatically.
        """
        return _fast.NeuralNetwork_addTemporalState(self, *args, **kwargs)

    def setInputSize(self, name: "std::string", size: "vectori") -> "void":
        return _fast.NeuralNetwork_setInputSize(self, name, size)

    def loadAttributes(self) -> "void":
        return _fast.NeuralNetwork_loadAttributes(self)
    __swig_destroy__ = _fast.delete_NeuralNetwork

# Register NeuralNetwork in _fast:
_fast.NeuralNetwork_swigregister(NeuralNetwork)

def NeuralNetwork_New() -> "std::shared_ptr< fast::NeuralNetwork >":
    return _fast.NeuralNetwork_New()

def NeuralNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.NeuralNetwork_getStaticNameOfClass()

def NeuralNetwork_create(*args, **kwargs) -> "std::shared_ptr< fast::NeuralNetwork >":
    r"""
    Create instance
    Python friendly constructor with almost all parameters.

    :type modelFilename: string
    :param modelFilename: Path to model to load
    :type scaleFactor: float
    :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
             network. Use this to scale your pixels values. Default: 1.0
    :type meanIntensity: float
    :param meanIntensity: Mean intensity to subtract from each pixel of the input image
    :type standardDeviationIntensity: float
    :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
    :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param inputNodes: Specify names, and potentially shapes, of input nodes.
             Not necessary unless you only want to use certain inputs or specify the input shape manually.
    :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
             Not necessary unless you only want to use certain outputs or specify the output shape manually.
    :type inferenceEngine: string
    :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
             By default, FAST will select the best inference engine available on your system.
    :type customPlugins: std::vector< std::string,std::allocator< std::string > >
    :param customPlugins: Specify path to any custom plugins/operators to load
    :rtype: :py:class:`NeuralNetwork`
    :return: instance
    """
    return _fast.NeuralNetwork_create(*args, **kwargs)

class ImageClassification(ClassificationSimpleDataType):
    r"""
    Image classification data object

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageClassification_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageClassification_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::ImageClassification >":
        return _fast.ImageClassification_fromDataObject(object)

    @staticmethod
    def create(data: "StringFloatMap") -> "std::shared_ptr< fast::ImageClassification >":
        return _fast.ImageClassification_create(data)

    def getTopClassification(self) -> "std::pair< std::string,float >":
        r"""
        Get classification with highest confidence score

        :rtype: std::pair< std::string,float >
        :return: pair of label name and confidence value
        """
        return _fast.ImageClassification_getTopClassification(self)
    __swig_destroy__ = _fast.delete_ImageClassification

# Register ImageClassification in _fast:
_fast.ImageClassification_swigregister(ImageClassification)

def ImageClassification_getStaticNameOfClass() -> "std::string":
    return _fast.ImageClassification_getStaticNameOfClass()

def ImageClassification_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::ImageClassification >":
    return _fast.ImageClassification_fromDataObject(object)

def ImageClassification_create(data: "StringFloatMap") -> "std::shared_ptr< fast::ImageClassification >":
    return _fast.ImageClassification_create(data)

class ImageClassificationNetwork(NeuralNetwork):
    r"""
    Image classification neural network

    This class is a convenience class for a neural network which performs image classification.
    Use setLabels method to define the class names. The output is then ImageClassification
    which is a map from class names to confidence values.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageClassificationNetwork >":
        return _fast.ImageClassificationNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageClassificationNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageClassificationNetwork_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageClassificationNetwork >":
        return _fast.ImageClassificationNetwork_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::ImageClassificationNetwork >":
        r"""
        Create instance
        Python friendly constructor with almost all parameters.

        :type modelFilename: string
        :param modelFilename: Path to model to load
        :type scaleFactor: float
        :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
                 network. Use this to scale your pixels values. Default: 1.0
        :type meanIntensity: float
        :param meanIntensity: Mean intensity to subtract from each pixel of the input image
        :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
        :type temporalWindow: int
        :param temporalWindow: Temporal window to average results over.
        :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param inputNodes: Specify names, and potentially shapes, of input nodes.
                 Not necessary unless you only want to use certain inputs or specify the input shape manually.
        :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
                 Not necessary unless you only want to use certain outputs or specify the output shape manually.
        :type inferenceEngine: string
        :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
                 By default, FAST will select the best inference engine available on your system.
        :type customPlugins: std::vector< std::string,std::allocator< std::string > >
        :param customPlugins: Specify path to any custom plugins/operators to load
        :rtype: :py:class:`ImageClassificationNetwork`
        :return: instance
        """
        return _fast.ImageClassificationNetwork_create(*args, **kwargs)

    def setTemporalWindow(self, window: "int") -> "void":
        return _fast.ImageClassificationNetwork_setTemporalWindow(self, window)

    def setLabels(self, labels: "vectors") -> "void":
        return _fast.ImageClassificationNetwork_setLabels(self, labels)

    def loadAttributes(self) -> "void":
        return _fast.ImageClassificationNetwork_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageClassificationNetwork

# Register ImageClassificationNetwork in _fast:
_fast.ImageClassificationNetwork_swigregister(ImageClassificationNetwork)

def ImageClassificationNetwork_New() -> "std::shared_ptr< fast::ImageClassificationNetwork >":
    return _fast.ImageClassificationNetwork_New()

def ImageClassificationNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.ImageClassificationNetwork_getStaticNameOfClass()

def ImageClassificationNetwork_create(*args, **kwargs) -> "std::shared_ptr< fast::ImageClassificationNetwork >":
    r"""
    Create instance
    Python friendly constructor with almost all parameters.

    :type modelFilename: string
    :param modelFilename: Path to model to load
    :type scaleFactor: float
    :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
             network. Use this to scale your pixels values. Default: 1.0
    :type meanIntensity: float
    :param meanIntensity: Mean intensity to subtract from each pixel of the input image
    :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
    :type temporalWindow: int
    :param temporalWindow: Temporal window to average results over.
    :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param inputNodes: Specify names, and potentially shapes, of input nodes.
             Not necessary unless you only want to use certain inputs or specify the input shape manually.
    :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
             Not necessary unless you only want to use certain outputs or specify the output shape manually.
    :type inferenceEngine: string
    :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
             By default, FAST will select the best inference engine available on your system.
    :type customPlugins: std::vector< std::string,std::allocator< std::string > >
    :param customPlugins: Specify path to any custom plugins/operators to load
    :rtype: :py:class:`ImageClassificationNetwork`
    :return: instance
    """
    return _fast.ImageClassificationNetwork_create(*args, **kwargs)

class ClassificationToText(ProcessObject):
    r"""ProcessObject to convert a classification into text"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ClassificationToText >":
        return _fast.ClassificationToText_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ClassificationToText_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ClassificationToText_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ClassificationToText >":
        return _fast.ClassificationToText_connect(self, *args)

    @staticmethod
    def create(bufferSize: "int"=1) -> "std::shared_ptr< fast::ClassificationToText >":
        return _fast.ClassificationToText_create(bufferSize)

    def setBufferSize(self, bufferSize: "int") -> "void":
        return _fast.ClassificationToText_setBufferSize(self, bufferSize)
    __swig_destroy__ = _fast.delete_ClassificationToText

# Register ClassificationToText in _fast:
_fast.ClassificationToText_swigregister(ClassificationToText)

def ClassificationToText_New() -> "std::shared_ptr< fast::ClassificationToText >":
    return _fast.ClassificationToText_New()

def ClassificationToText_getStaticNameOfClass() -> "std::string":
    return _fast.ClassificationToText_getStaticNameOfClass()

def ClassificationToText_create(bufferSize: "int"=1) -> "std::shared_ptr< fast::ClassificationToText >":
    return _fast.ClassificationToText_create(bufferSize)

class SegmentationNetwork(NeuralNetwork):
    r"""
    Segmentation neural network process object

    This class is a convenience class for a neural network which performs segmentation
    by having 1 input image, and outputs 1 segmentation image. Internally it uses TensorToSegmentation.
    If you need multi-input or multi-output support, use NeuralNetwork with TensorToSegmentation instead.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SegmentationNetwork >":
        return _fast.SegmentationNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SegmentationNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SegmentationNetwork_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::SegmentationNetwork >":
        return _fast.SegmentationNetwork_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::SegmentationNetwork >":
        r"""
        Create instance

        :type modelFilename: string
        :param modelFilename: path to model to load
        :type scaleFactor: float
        :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
                 network. Use this to scale your pixels values. Default: 1.0
        :type heatmapOutput: boolean
        :param heatmapOutput: If set to true, the output of this object will be a Tensor instead of a segmentation Image. Default: false
        :type threshold: float
        :param threshold: The minimum value of the class confidence value to be accepted. Default: 0.5
        :type hasBackgroundClass: boolean
        :param hasBackgroundClass: Whether the neural network has a channel 0 which represents the "background".
        :type meanIntensity: float
        :param meanIntensity: Mean intensity to subtract from each pixel of the input image
        :type standardDeviationIntensity: float
        :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
        :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param inputNodes: Specify names, and potentially shapes, of input nodes.
                 Not necessary unless you only want to use certain inputs or specify the input shape manually.
        :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
                 Not necessary unless you only want to use certain outputs or specify the output shape manually.
        :type inferenceEngine: string
        :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
                 By default, FAST will select the best inference engine available on your system.
        :type customPlugins: std::vector< std::string,std::allocator< std::string > >
        :param customPlugins: Specify path to any custom plugins/operators to load

        :rtype: :py:class:`SegmentationNetwork`
        :return: instance
        """
        return _fast.SegmentationNetwork_create(*args, **kwargs)

    def setHeatmapOutput(self) -> "void":
        return _fast.SegmentationNetwork_setHeatmapOutput(self)

    def setSegmentationOutput(self) -> "void":
        return _fast.SegmentationNetwork_setSegmentationOutput(self)

    def setThreshold(self, threshold: "float") -> "void":
        r"""
        Threshold to accept a channel X as being class X.

        :type threshold: float
        :param threshold:
        """
        return _fast.SegmentationNetwork_setThreshold(self, threshold)

    def getThreshold(self) -> "float":
        return _fast.SegmentationNetwork_getThreshold(self)

    def setBackgroundClass(self, hasBackgroundClass: "bool") -> "void":
        r"""
        Set whether channel 0 of segmentation tensor is the "background" class, thereby getting the label 0 in the
        resulting Segmentation.

        :type hasBackgroundClass: boolean
        :param hasBackgroundClass:
        """
        return _fast.SegmentationNetwork_setBackgroundClass(self, hasBackgroundClass)

    def loadAttributes(self) -> "void":
        return _fast.SegmentationNetwork_loadAttributes(self)

    def setResizeBackToOriginalSize(self, resize: "bool") -> "void":
        return _fast.SegmentationNetwork_setResizeBackToOriginalSize(self, resize)

    def setChannelsToIgnore(self, channels: "vectori") -> "void":
        r"""
        Specify list of output channels to ignore
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:
        """
        return _fast.SegmentationNetwork_setChannelsToIgnore(self, channels)
    __swig_destroy__ = _fast.delete_SegmentationNetwork

# Register SegmentationNetwork in _fast:
_fast.SegmentationNetwork_swigregister(SegmentationNetwork)

def SegmentationNetwork_New() -> "std::shared_ptr< fast::SegmentationNetwork >":
    return _fast.SegmentationNetwork_New()

def SegmentationNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.SegmentationNetwork_getStaticNameOfClass()

def SegmentationNetwork_create(*args, **kwargs) -> "std::shared_ptr< fast::SegmentationNetwork >":
    r"""
    Create instance

    :type modelFilename: string
    :param modelFilename: path to model to load
    :type scaleFactor: float
    :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
             network. Use this to scale your pixels values. Default: 1.0
    :type heatmapOutput: boolean
    :param heatmapOutput: If set to true, the output of this object will be a Tensor instead of a segmentation Image. Default: false
    :type threshold: float
    :param threshold: The minimum value of the class confidence value to be accepted. Default: 0.5
    :type hasBackgroundClass: boolean
    :param hasBackgroundClass: Whether the neural network has a channel 0 which represents the "background".
    :type meanIntensity: float
    :param meanIntensity: Mean intensity to subtract from each pixel of the input image
    :type standardDeviationIntensity: float
    :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
    :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param inputNodes: Specify names, and potentially shapes, of input nodes.
             Not necessary unless you only want to use certain inputs or specify the input shape manually.
    :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
             Not necessary unless you only want to use certain outputs or specify the output shape manually.
    :type inferenceEngine: string
    :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
             By default, FAST will select the best inference engine available on your system.
    :type customPlugins: std::vector< std::string,std::allocator< std::string > >
    :param customPlugins: Specify path to any custom plugins/operators to load

    :rtype: :py:class:`SegmentationNetwork`
    :return: instance
    """
    return _fast.SegmentationNetwork_create(*args, **kwargs)

class BoundingBoxNetwork(NeuralNetwork):
    r"""
    Neural network process object for bounding box detection

    This class is a convenience class for a neural network which performs bounding box prediction.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BoundingBoxNetwork >":
        return _fast.BoundingBoxNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BoundingBoxNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BoundingBoxNetwork_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::BoundingBoxNetwork >":
        return _fast.BoundingBoxNetwork_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::BoundingBoxNetwork >":
        r"""
        Create instance

        :type modelFilename: string
        :param modelFilename: Path to model to load
        :type scaleFactor: float
        :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
                 network. Use this to scale your pixels values. Default: 1.0
        :type threshold: float
        :param threshold: Threshold for how high score a bounding box need to be accepted.
        :type anchors: std::vector< std::vector< Vector2f,std::allocator< Vector2f > >,std::allocator< std::vector< Vector2f,std::allocator< Vector2f > > > >
        :param anchors: List of anchors to use when calculating bounding boxes from the output tensor.
        :type type: BoundingBoxNetworkType
        :param type: Type of bounding box detection network. Used to determine how the output tensor should be handled to create bounding boxes. Default: YOLOv3
        :type meanIntensity: float
        :param meanIntensity: Mean intensity to subtract from each pixel of the input image
        :type standardDeviationIntensity: float
        :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
        :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param inputNodes: Specify names, and potentially shapes, of input nodes.
                 Not necessary unless you only want to use certain inputs or specify the input shape manually.
        :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
                 Not necessary unless you only want to use certain outputs or specify the output shape manually.
        :type inferenceEngine: string
        :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
                 By default, FAST will select the best inference engine available on your system.
        :type customPlugins: std::vector< std::string,std::allocator< std::string > >
        :param customPlugins: Specify path to any custom plugins/operators to load
        :rtype: :py:class:`BoundingBoxNetwork`
        :return: instance
        """
        return _fast.BoundingBoxNetwork_create(*args, **kwargs)

    def setThreshold(self, threshold: "float") -> "void":
        return _fast.BoundingBoxNetwork_setThreshold(self, threshold)

    def loadAttributes(self) -> "void":
        return _fast.BoundingBoxNetwork_loadAttributes(self)

    def setAnchors(self, anchors: "std::vector< std::vector< Vector2f,std::allocator< Vector2f > >,std::allocator< std::vector< Vector2f,std::allocator< Vector2f > > > >") -> "void":
        return _fast.BoundingBoxNetwork_setAnchors(self, anchors)

    def setType(self, type: "BoundingBoxNetworkType") -> "void":
        return _fast.BoundingBoxNetwork_setType(self, type)
    __swig_destroy__ = _fast.delete_BoundingBoxNetwork

# Register BoundingBoxNetwork in _fast:
_fast.BoundingBoxNetwork_swigregister(BoundingBoxNetwork)

def BoundingBoxNetwork_New() -> "std::shared_ptr< fast::BoundingBoxNetwork >":
    return _fast.BoundingBoxNetwork_New()

def BoundingBoxNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.BoundingBoxNetwork_getStaticNameOfClass()

def BoundingBoxNetwork_create(*args, **kwargs) -> "std::shared_ptr< fast::BoundingBoxNetwork >":
    r"""
    Create instance

    :type modelFilename: string
    :param modelFilename: Path to model to load
    :type scaleFactor: float
    :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
             network. Use this to scale your pixels values. Default: 1.0
    :type threshold: float
    :param threshold: Threshold for how high score a bounding box need to be accepted.
    :type anchors: std::vector< std::vector< Vector2f,std::allocator< Vector2f > >,std::allocator< std::vector< Vector2f,std::allocator< Vector2f > > > >
    :param anchors: List of anchors to use when calculating bounding boxes from the output tensor.
    :type type: BoundingBoxNetworkType
    :param type: Type of bounding box detection network. Used to determine how the output tensor should be handled to create bounding boxes. Default: YOLOv3
    :type meanIntensity: float
    :param meanIntensity: Mean intensity to subtract from each pixel of the input image
    :type standardDeviationIntensity: float
    :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
    :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param inputNodes: Specify names, and potentially shapes, of input nodes.
             Not necessary unless you only want to use certain inputs or specify the input shape manually.
    :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
             Not necessary unless you only want to use certain outputs or specify the output shape manually.
    :type inferenceEngine: string
    :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
             By default, FAST will select the best inference engine available on your system.
    :type customPlugins: std::vector< std::string,std::allocator< std::string > >
    :param customPlugins: Specify path to any custom plugins/operators to load
    :rtype: :py:class:`BoundingBoxNetwork`
    :return: instance
    """
    return _fast.BoundingBoxNetwork_create(*args, **kwargs)

class ImagesToSequence(ProcessObject):
    r"""
    Process object for converting a stream of images to a Sequence data object

    This process object converts a stream of images to a stream of sequences of a given size.
    If the sequence size is X, for the first execute, the added item will be copied X times in the sequence.
    New images are added to the end/back of the sequence, while the first/oldest image, is removed.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImagesToSequence >":
        return _fast.ImagesToSequence_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImagesToSequence_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImagesToSequence_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImagesToSequence >":
        return _fast.ImagesToSequence_connect(self, *args)

    @staticmethod
    def create(sequenceSize: "int"=2) -> "std::shared_ptr< fast::ImagesToSequence >":
        r"""
        Create instance
        :type sequenceSize: int
        :param sequenceSize: Set size of sequence
        :rtype: :py:class:`ImagesToSequence`
        :return: instance
        """
        return _fast.ImagesToSequence_create(sequenceSize)

    def setSequenceSize(self, size: "int") -> "void":
        return _fast.ImagesToSequence_setSequenceSize(self, size)

    def loadAttributes(self) -> "void":
        return _fast.ImagesToSequence_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImagesToSequence

# Register ImagesToSequence in _fast:
_fast.ImagesToSequence_swigregister(ImagesToSequence)

def ImagesToSequence_New() -> "std::shared_ptr< fast::ImagesToSequence >":
    return _fast.ImagesToSequence_New()

def ImagesToSequence_getStaticNameOfClass() -> "std::string":
    return _fast.ImagesToSequence_getStaticNameOfClass()

def ImagesToSequence_create(sequenceSize: "int"=2) -> "std::shared_ptr< fast::ImagesToSequence >":
    r"""
    Create instance
    :type sequenceSize: int
    :param sequenceSize: Set size of sequence
    :rtype: :py:class:`ImagesToSequence`
    :return: instance
    """
    return _fast.ImagesToSequence_create(sequenceSize)

class FlowNetwork(NeuralNetwork):
    r"""
    A neural network for optical flow estimation

    A neural network which takes a sequence of images as input, and then
    outputs a flow/displacement vector field. This can be a flow network which
    estimates the motion between two frames.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::FlowNetwork >":
        return _fast.FlowNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.FlowNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.FlowNetwork_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::FlowNetwork >":
        return _fast.FlowNetwork_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::FlowNetwork >":
        r"""
        Create instance
        Python friendly constructor with almost all parameters.

        :type modelFilename: string
        :param modelFilename: Path to model to load
        :type scaleFactor: float
        :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
                 network. Use this to scale your pixels values. Default: 1.0
        :type meanIntensity: float
        :param meanIntensity: Mean intensity to subtract from each pixel of the input image
        :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
        :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param inputNodes: Specify names, and potentially shapes, of input nodes.
                 Not necessary unless you only want to use certain inputs or specify the input shape manually.
        :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
                 Not necessary unless you only want to use certain outputs or specify the output shape manually.
        :type inferenceEngine: string
        :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
                 By default, FAST will select the best inference engine available on your system.
        :type customPlugins: std::vector< std::string,std::allocator< std::string > >
        :param customPlugins: Specify path to any custom plugins/operators to load
        :rtype: :py:class:`FlowNetwork`
        :return: instance
        """
        return _fast.FlowNetwork_create(*args, **kwargs)
    __swig_destroy__ = _fast.delete_FlowNetwork

# Register FlowNetwork in _fast:
_fast.FlowNetwork_swigregister(FlowNetwork)

def FlowNetwork_New() -> "std::shared_ptr< fast::FlowNetwork >":
    return _fast.FlowNetwork_New()

def FlowNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.FlowNetwork_getStaticNameOfClass()

def FlowNetwork_create(*args, **kwargs) -> "std::shared_ptr< fast::FlowNetwork >":
    r"""
    Create instance
    Python friendly constructor with almost all parameters.

    :type modelFilename: string
    :param modelFilename: Path to model to load
    :type scaleFactor: float
    :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
             network. Use this to scale your pixels values. Default: 1.0
    :type meanIntensity: float
    :param meanIntensity: Mean intensity to subtract from each pixel of the input image
    :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
    :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param inputNodes: Specify names, and potentially shapes, of input nodes.
             Not necessary unless you only want to use certain inputs or specify the input shape manually.
    :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
             Not necessary unless you only want to use certain outputs or specify the output shape manually.
    :type inferenceEngine: string
    :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
             By default, FAST will select the best inference engine available on your system.
    :type customPlugins: std::vector< std::string,std::allocator< std::string > >
    :param customPlugins: Specify path to any custom plugins/operators to load
    :rtype: :py:class:`FlowNetwork`
    :return: instance
    """
    return _fast.FlowNetwork_create(*args, **kwargs)

class ImageToImageNetwork(NeuralNetwork):
    r"""
    Image-to-Image neural network process object

    This class is a convenience class for a neural network which performs image to image transformation
    by having 1 input image, and outputs 1 image. Internally it uses TensorToImage.
    If you need multi-input or multi-output support, use NeuralNetwork with TensorToImage instead.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageToImageNetwork >":
        return _fast.ImageToImageNetwork_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageToImageNetwork_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageToImageNetwork_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageToImageNetwork >":
        return _fast.ImageToImageNetwork_connect(self, *args)
    Normalization_CLIP_0_1 = _fast.ImageToImageNetwork_Normalization_CLIP_0_1
    r""" Clip image intensities at 0 and 1"""
    Normalization_CLIP_0_SQUEEZE = _fast.ImageToImageNetwork_Normalization_CLIP_0_SQUEEZE
    r""" Clip image intensities at 0 and squeeze intensity range if max is above 1.0"""
    Normalization_NONE = _fast.ImageToImageNetwork_Normalization_NONE
    r""" No normalization"""

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::ImageToImageNetwork >":
        r"""
        Create instance

        :type modelFilename: string
        :param modelFilename: path to model to load
        :type scaleFactor: float
        :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
                 network. Use this to scale your pixels values. Default: 1.0
        :type iterations: int
        :param iterations: Number of iterations to run the network
        :type residualNetwork: boolean
        :param residualNetwork: Whether this image-to-image network is a residual network.
                 If true, the output is added to the input image to create the final output image.
        :type resizeBackToOriginalSize: boolean
        :param resizeBackToOriginalSize: Whether to resize the output image to its original input image size
        :type castBackToOriginalType: boolean
        :param castBackToOriginalType: Whether to cast the output image to its input image type
        :type channelsToExtract: std::vector< int,std::allocator< int > >
        :param channelsToExtract: Which channels to extract from the output tensor.
                 Default (empty list) is to extract all channels.
        :param normalizationMethod: Specify normalization method to be applied to image after each iteration.
        :type meanIntensity: float
        :param meanIntensity: Mean intensity to subtract from each pixel of the input image
        :type standardDeviationIntensity: float
        :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
        :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param inputNodes: Specify names, and potentially shapes, of input nodes.
                 Not necessary unless you only want to use certain inputs or specify the input shape manually.
        :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
        :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
                 Not necessary unless you only want to use certain outputs or specify the output shape manually.
        :type inferenceEngine: string
        :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
                 By default, FAST will select the best inference engine available on your system.
        :type customPlugins: std::vector< std::string,std::allocator< std::string > >
        :param customPlugins: Specify path to any custom plugins/operators to load

        :rtype: :py:class:`ImageToImageNetwork`
        :return: instance
        """
        return _fast.ImageToImageNetwork_create(*args, **kwargs)

    def loadAttributes(self) -> "void":
        return _fast.ImageToImageNetwork_loadAttributes(self)

    def setIterations(self, iterations: "int") -> "void":
        return _fast.ImageToImageNetwork_setIterations(self, iterations)

    def getIterations(self) -> "int":
        return _fast.ImageToImageNetwork_getIterations(self)

    def setResidualNetwork(self, residual: "bool") -> "void":
        return _fast.ImageToImageNetwork_setResidualNetwork(self, residual)

    def setResizeOutput(self, resizeOutput: "bool") -> "void":
        return _fast.ImageToImageNetwork_setResizeOutput(self, resizeOutput)

    def setCastOutput(self, castOutput: "bool") -> "void":
        return _fast.ImageToImageNetwork_setCastOutput(self, castOutput)

    def setChannels(self, channels: "vectori") -> "void":
        return _fast.ImageToImageNetwork_setChannels(self, channels)

    def setNormalization(self, norm: "fast::ImageToImageNetwork::Normalization") -> "void":
        r"""
        Specify normalization to be performed after each iteration
        See also: ImageToImageNetwork::Normalization
        :type norm: int
        :param norm:
        """
        return _fast.ImageToImageNetwork_setNormalization(self, norm)

    def setDisabled(self, disabled: "bool") -> "void":
        r"""
        Set disabled state
        When disabled, this PO will just forward the input image instead of processing it
        :type disabled: boolean
        :param disabled:
        """
        return _fast.ImageToImageNetwork_setDisabled(self, disabled)

    def isDisabled(self) -> "bool":
        r"""
        Check if disabled
        See also: ImageToImageNetwork::setDisabled
        :rtype: boolean
        :return: 
        """
        return _fast.ImageToImageNetwork_isDisabled(self)
    __swig_destroy__ = _fast.delete_ImageToImageNetwork

# Register ImageToImageNetwork in _fast:
_fast.ImageToImageNetwork_swigregister(ImageToImageNetwork)

def ImageToImageNetwork_New() -> "std::shared_ptr< fast::ImageToImageNetwork >":
    return _fast.ImageToImageNetwork_New()

def ImageToImageNetwork_getStaticNameOfClass() -> "std::string":
    return _fast.ImageToImageNetwork_getStaticNameOfClass()

def ImageToImageNetwork_create(*args, **kwargs) -> "std::shared_ptr< fast::ImageToImageNetwork >":
    r"""
    Create instance

    :type modelFilename: string
    :param modelFilename: path to model to load
    :type scaleFactor: float
    :param scaleFactor: A value which is multiplied with each pixel of input image before it is sent to the neural
             network. Use this to scale your pixels values. Default: 1.0
    :type iterations: int
    :param iterations: Number of iterations to run the network
    :type residualNetwork: boolean
    :param residualNetwork: Whether this image-to-image network is a residual network.
             If true, the output is added to the input image to create the final output image.
    :type resizeBackToOriginalSize: boolean
    :param resizeBackToOriginalSize: Whether to resize the output image to its original input image size
    :type castBackToOriginalType: boolean
    :param castBackToOriginalType: Whether to cast the output image to its input image type
    :type channelsToExtract: std::vector< int,std::allocator< int > >
    :param channelsToExtract: Which channels to extract from the output tensor.
             Default (empty list) is to extract all channels.
    :param normalizationMethod: Specify normalization method to be applied to image after each iteration.
    :type meanIntensity: float
    :param meanIntensity: Mean intensity to subtract from each pixel of the input image
    :type standardDeviationIntensity: float
    :param standardDeviationIntensity: Standard deviation to divide each pixel of the input image by
    :type inputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param inputNodes: Specify names, and potentially shapes, of input nodes.
             Not necessary unless you only want to use certain inputs or specify the input shape manually.
    :type outputNodes: std::vector< fast::NeuralNetworkNode,std::allocator< fast::NeuralNetworkNode > >
    :param outputNodes: Specify names, and potentially shapes, of output nodes to use.
             Not necessary unless you only want to use certain outputs or specify the output shape manually.
    :type inferenceEngine: string
    :param inferenceEngine: Specify which inference engine to use (TensorFlow, TensorRT, OpenVINO).
             By default, FAST will select the best inference engine available on your system.
    :type customPlugins: std::vector< std::string,std::allocator< std::string > >
    :param customPlugins: Specify path to any custom plugins/operators to load

    :rtype: :py:class:`ImageToImageNetwork`
    :return: instance
    """
    return _fast.ImageToImageNetwork_create(*args, **kwargs)

class TensorToSegmentation(ProcessObject):
    r"""
    A process object which converts a Tensor to a Segmentation object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TensorToSegmentation >":
        return _fast.TensorToSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TensorToSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TensorToSegmentation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TensorToSegmentation >":
        return _fast.TensorToSegmentation_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::TensorToSegmentation >":
        r"""
        Create instance
        :type threshold: float
        :param threshold: The minimum value of the class confidence value to be accepted. Default: 0.5
        :type hasBackgroundClass: boolean
        :param hasBackgroundClass: Whether the neural network has a channel 0 which represents the "background". Default: true
        :type channelsToIgnore: std::vector< int,std::allocator< int > >
        :param channelsToIgnore: List of output channels to ignore
        :rtype: :py:class:`TensorToSegmentation`
        :return: instance
        """
        return _fast.TensorToSegmentation_create(*args, **kwargs)

    def setThreshold(self, threshold: "float") -> "void":
        r"""
        Threshold to accept a channel X as being class X.

        :type threshold: float
        :param threshold:
        """
        return _fast.TensorToSegmentation_setThreshold(self, threshold)

    def getThreshold(self) -> "float":
        return _fast.TensorToSegmentation_getThreshold(self)

    def setBackgroundClass(self, hasBackgroundClass: "bool") -> "void":
        r"""
        Set whether channel 0 of segmentation tensor is the "background" class, thereby getting the label 0 in the
        resulting Segmentation.

        :type hasBackgroundClass: boolean
        :param hasBackgroundClass:
        """
        return _fast.TensorToSegmentation_setBackgroundClass(self, hasBackgroundClass)

    def setChannelsToIgnore(self, channels: "vectori") -> "void":
        r"""
        Specify list of output channels to ignore
        :type channels: std::vector< int,std::allocator< int > >
        :param channels:
        """
        return _fast.TensorToSegmentation_setChannelsToIgnore(self, channels)

    def loadAttributes(self) -> "void":
        return _fast.TensorToSegmentation_loadAttributes(self)
    __swig_destroy__ = _fast.delete_TensorToSegmentation

# Register TensorToSegmentation in _fast:
_fast.TensorToSegmentation_swigregister(TensorToSegmentation)

def TensorToSegmentation_New() -> "std::shared_ptr< fast::TensorToSegmentation >":
    return _fast.TensorToSegmentation_New()

def TensorToSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.TensorToSegmentation_getStaticNameOfClass()

def TensorToSegmentation_create(*args, **kwargs) -> "std::shared_ptr< fast::TensorToSegmentation >":
    r"""
    Create instance
    :type threshold: float
    :param threshold: The minimum value of the class confidence value to be accepted. Default: 0.5
    :type hasBackgroundClass: boolean
    :param hasBackgroundClass: Whether the neural network has a channel 0 which represents the "background". Default: true
    :type channelsToIgnore: std::vector< int,std::allocator< int > >
    :param channelsToIgnore: List of output channels to ignore
    :rtype: :py:class:`TensorToSegmentation`
    :return: instance
    """
    return _fast.TensorToSegmentation_create(*args, **kwargs)

class TensorToImage(ProcessObject):
    r"""
    Converts a Tensor with shape HxWxC to a FAST Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TensorToImage >":
        return _fast.TensorToImage_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TensorToImage_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TensorToImage_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TensorToImage >":
        return _fast.TensorToImage_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::TensorToImage >":
        r"""
        Create instance
        :type channels: std::vector< int,std::allocator< int > >
        :param channels: which channels to extract from tensor.
                 If empty all channels are used. Nr of channels has to be <= 4
        :rtype: :py:class:`TensorToImage`
        :return: instance
        """
        return _fast.TensorToImage_create(*args, **kwargs)

    def setChannels(self, channels: "vectori") -> "void":
        return _fast.TensorToImage_setChannels(self, channels)

    def loadAttributes(self) -> "void":
        return _fast.TensorToImage_loadAttributes(self)
    __swig_destroy__ = _fast.delete_TensorToImage

# Register TensorToImage in _fast:
_fast.TensorToImage_swigregister(TensorToImage)

def TensorToImage_New() -> "std::shared_ptr< fast::TensorToImage >":
    return _fast.TensorToImage_New()

def TensorToImage_getStaticNameOfClass() -> "std::string":
    return _fast.TensorToImage_getStaticNameOfClass()

def TensorToImage_create(*args, **kwargs) -> "std::shared_ptr< fast::TensorToImage >":
    r"""
    Create instance
    :type channels: std::vector< int,std::allocator< int > >
    :param channels: which channels to extract from tensor.
             If empty all channels are used. Nr of channels has to be <= 4
    :rtype: :py:class:`TensorToImage`
    :return: instance
    """
    return _fast.TensorToImage_create(*args, **kwargs)

BoundingBoxNetworkType_YOLOv3 = _fast.BoundingBoxNetworkType_YOLOv3
class TensorToBoundingBoxSet(ProcessObject):
    r"""
    Convert a tensor to a set of bounding boxes

    Used in BoundingBoxNetwork to convert a tensor to a set of bounding boxes.

    See also: BoundingBoxNetwork BoundingBoxNetworkType
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TensorToBoundingBoxSet >":
        return _fast.TensorToBoundingBoxSet_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TensorToBoundingBoxSet_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TensorToBoundingBoxSet_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TensorToBoundingBoxSet >":
        return _fast.TensorToBoundingBoxSet_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::TensorToBoundingBoxSet >":
        r"""
        Create instance

        :type type: int
        :param type: Type of bounding box detection network. Used to determine how the output tensor should be handled to create bounding boxes. Default: YOLOv3
        :type threshold: float
        :param threshold: Threshold for how high score a bounding box need to be accepted.
        :type anchors: std::vector< std::vector< Vector2f,std::allocator< Vector2f > >,std::allocator< std::vector< Vector2f,std::allocator< Vector2f > > > >
        :param anchors: List of anchors to use when calculating bounding boxes parameters from the output tensor.
        :rtype: :py:class:`TensorToBoundingBoxSet`
        :return: instance
        """
        return _fast.TensorToBoundingBoxSet_create(*args, **kwargs)

    def setType(self, type: "fast::BoundingBoxNetworkType") -> "void":
        return _fast.TensorToBoundingBoxSet_setType(self, type)

    def setThreshold(self, threshold: "float") -> "void":
        return _fast.TensorToBoundingBoxSet_setThreshold(self, threshold)

    def setAnchors(self, anchors: "std::vector< std::vector< Vector2f,std::allocator< Vector2f > >,std::allocator< std::vector< Vector2f,std::allocator< Vector2f > > > >") -> "void":
        return _fast.TensorToBoundingBoxSet_setAnchors(self, anchors)

    def getAnchors(self) -> "std::vector< std::vector< Vector2f,std::allocator< Vector2f > >,std::allocator< std::vector< Vector2f,std::allocator< Vector2f > > > >":
        return _fast.TensorToBoundingBoxSet_getAnchors(self)

    def setInputConnection(self, *args) -> "void":
        return _fast.TensorToBoundingBoxSet_setInputConnection(self, *args)

    def setNrOfInputNodes(self, nr: "int") -> "void":
        return _fast.TensorToBoundingBoxSet_setNrOfInputNodes(self, nr)

    def loadAttributes(self) -> "void":
        return _fast.TensorToBoundingBoxSet_loadAttributes(self)
    __swig_destroy__ = _fast.delete_TensorToBoundingBoxSet

# Register TensorToBoundingBoxSet in _fast:
_fast.TensorToBoundingBoxSet_swigregister(TensorToBoundingBoxSet)

def TensorToBoundingBoxSet_New() -> "std::shared_ptr< fast::TensorToBoundingBoxSet >":
    return _fast.TensorToBoundingBoxSet_New()

def TensorToBoundingBoxSet_getStaticNameOfClass() -> "std::string":
    return _fast.TensorToBoundingBoxSet_getStaticNameOfClass()

def TensorToBoundingBoxSet_create(*args, **kwargs) -> "std::shared_ptr< fast::TensorToBoundingBoxSet >":
    r"""
    Create instance

    :type type: int
    :param type: Type of bounding box detection network. Used to determine how the output tensor should be handled to create bounding boxes. Default: YOLOv3
    :type threshold: float
    :param threshold: Threshold for how high score a bounding box need to be accepted.
    :type anchors: std::vector< std::vector< Vector2f,std::allocator< Vector2f > >,std::allocator< std::vector< Vector2f,std::allocator< Vector2f > > > >
    :param anchors: List of anchors to use when calculating bounding boxes parameters from the output tensor.
    :rtype: :py:class:`TensorToBoundingBoxSet`
    :return: instance
    """
    return _fast.TensorToBoundingBoxSet_create(*args, **kwargs)

class VertexTensorToSegmentation(ProcessObject):
    r"""
    Convert a tensor of vertex positions (graph) to a segmentation

    A vertex tensor is assumed to have the shape (2, N) consisting of N points with x, y positions.
    If multiple objects are present, they are drawn in the order specified.

    Inputs:
    - 0: Tensor

    Outputs:
    - 0: Segmentation Image
    - 1: Mesh with vertices and lines
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VertexTensorToSegmentation >":
        return _fast.VertexTensorToSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VertexTensorToSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VertexTensorToSegmentation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::VertexTensorToSegmentation >":
        return _fast.VertexTensorToSegmentation_connect(self, *args)

    @staticmethod
    def create(connections: "Connections", width: "int"=-1, height: "int"=-1) -> "std::shared_ptr< fast::VertexTensorToSegmentation >":
        r"""
        Create instance

        If multiple objects are provided to the connections param, they are drawn in the order the they are specified.
        :type connections: std::vector< std::vector< fast::MeshLine,std::allocator< fast::MeshLine > >,std::allocator< std::vector< fast::MeshLine,std::allocator< fast::MeshLine > > > >
        :param connections: List of connections for each object
        :type width: int
        :param width: specify width of output segmentation. If not specified width of network input that created the tensor is used instead.
        :type height: int
        :param height: specify height of output segmentation. If not specified, height of network input that created the tensor is used instead.
        :rtype: :py:class:`VertexTensorToSegmentation`
        :return: instance
        """
        return _fast.VertexTensorToSegmentation_create(connections, width, height)
    __swig_destroy__ = _fast.delete_VertexTensorToSegmentation

# Register VertexTensorToSegmentation in _fast:
_fast.VertexTensorToSegmentation_swigregister(VertexTensorToSegmentation)

def VertexTensorToSegmentation_New() -> "std::shared_ptr< fast::VertexTensorToSegmentation >":
    return _fast.VertexTensorToSegmentation_New()

def VertexTensorToSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.VertexTensorToSegmentation_getStaticNameOfClass()

def VertexTensorToSegmentation_create(connections: "Connections", width: "int"=-1, height: "int"=-1) -> "std::shared_ptr< fast::VertexTensorToSegmentation >":
    r"""
    Create instance

    If multiple objects are provided to the connections param, they are drawn in the order the they are specified.
    :type connections: std::vector< std::vector< fast::MeshLine,std::allocator< fast::MeshLine > >,std::allocator< std::vector< fast::MeshLine,std::allocator< fast::MeshLine > > > >
    :param connections: List of connections for each object
    :type width: int
    :param width: specify width of output segmentation. If not specified width of network input that created the tensor is used instead.
    :type height: int
    :param height: specify height of output segmentation. If not specified, height of network input that created the tensor is used instead.
    :rtype: :py:class:`VertexTensorToSegmentation`
    :return: instance
    """
    return _fast.VertexTensorToSegmentation_create(connections, width, height)

class NonLocalMeans(ProcessObject):
    r"""
    Multiscale Non-Local Means (NLM) smoothing

    Non-Local Means (NLM) is an excellent despeckling filter for ultrasound images.
    This GPU implementation is based on the article "Real-Time Nonlocal Means-Based Despeckling" by Breivik et al. 2017.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::NonLocalMeans >":
        return _fast.NonLocalMeans_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.NonLocalMeans_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.NonLocalMeans_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::NonLocalMeans >":
        return _fast.NonLocalMeans_connect(self, *args)

    @staticmethod
    def create(filterSize: "int"=3, searchSize: "int"=11, smoothingAmount: "float"=0.15, inputMultiplicationWeight: "float"=0.8, multiScaleIterations: "int"=3) -> "std::shared_ptr< fast::NonLocalMeans >":
        r"""
        Creates instance of this process object
        :type filterSize: int
        :param filterSize: Size in pixels of the filter region to search for. Must be odd.
        :type searchSize: int
        :param searchSize: How many pixels to search in each direction. Must be odd.
        :type smoothingAmount: float
        :param smoothingAmount: Parameter to control the amount of smoothing.
        :type multiScaleIterations: int
        :param multiScaleIterations: Number of multiscale iterations to perform
        :type inputMultiplicationWeight: float
        :param inputMultiplicationWeight: If > 0, the input image will be multiplied with the output with this weight.
        :rtype: :py:class:`NonLocalMeans`
        :return: smart pointer to instance
        """
        return _fast.NonLocalMeans_create(filterSize, searchSize, smoothingAmount, inputMultiplicationWeight, multiScaleIterations)

    def setSmoothingAmount(self, parameterH: "float") -> "void":
        return _fast.NonLocalMeans_setSmoothingAmount(self, parameterH)

    def setPreProcess(self, preProcess: "bool") -> "void":
        return _fast.NonLocalMeans_setPreProcess(self, preProcess)

    def setMultiscaleIterations(self, iterations: "int") -> "void":
        return _fast.NonLocalMeans_setMultiscaleIterations(self, iterations)

    def setSearchSize(self, searchSize: "int") -> "void":
        return _fast.NonLocalMeans_setSearchSize(self, searchSize)

    def setFilterSize(self, filterSize: "int") -> "void":
        return _fast.NonLocalMeans_setFilterSize(self, filterSize)

    def setInputMultiplicationWeight(self, weight: "float") -> "void":
        return _fast.NonLocalMeans_setInputMultiplicationWeight(self, weight)

    def loadAttributes(self) -> "void":
        return _fast.NonLocalMeans_loadAttributes(self)
    __swig_destroy__ = _fast.delete_NonLocalMeans

# Register NonLocalMeans in _fast:
_fast.NonLocalMeans_swigregister(NonLocalMeans)

def NonLocalMeans_New() -> "std::shared_ptr< fast::NonLocalMeans >":
    return _fast.NonLocalMeans_New()

def NonLocalMeans_getStaticNameOfClass() -> "std::string":
    return _fast.NonLocalMeans_getStaticNameOfClass()

def NonLocalMeans_create(filterSize: "int"=3, searchSize: "int"=11, smoothingAmount: "float"=0.15, inputMultiplicationWeight: "float"=0.8, multiScaleIterations: "int"=3) -> "std::shared_ptr< fast::NonLocalMeans >":
    r"""
    Creates instance of this process object
    :type filterSize: int
    :param filterSize: Size in pixels of the filter region to search for. Must be odd.
    :type searchSize: int
    :param searchSize: How many pixels to search in each direction. Must be odd.
    :type smoothingAmount: float
    :param smoothingAmount: Parameter to control the amount of smoothing.
    :type multiScaleIterations: int
    :param multiScaleIterations: Number of multiscale iterations to perform
    :type inputMultiplicationWeight: float
    :param inputMultiplicationWeight: If > 0, the input image will be multiplied with the output with this weight.
    :rtype: :py:class:`NonLocalMeans`
    :return: smart pointer to instance
    """
    return _fast.NonLocalMeans_create(filterSize, searchSize, smoothingAmount, inputMultiplicationWeight, multiScaleIterations)

class NonMaximumSuppression(ProcessObject):
    r"""
    Non-maximum suppression of bounding box sets

    Removes overlapping bounding boxes in a BoundingBoxSet if intersection over union is above a provided threshold.

    Inputs:
    - 0: BoundingBoxSet

    Outputs:
    - 0: BoundingBoxSet

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::NonMaximumSuppression >":
        return _fast.NonMaximumSuppression_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.NonMaximumSuppression_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.NonMaximumSuppression_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::NonMaximumSuppression >":
        return _fast.NonMaximumSuppression_connect(self, *args)

    @staticmethod
    def create(threshold: "float"=0.5) -> "std::shared_ptr< fast::NonMaximumSuppression >":
        r"""
        Create instance
        :type threshold: float
        :param threshold: Minimum intersection over union to remove overlapping bounding box.
        :rtype: :py:class:`NonMaximumSuppression`
        :return: instance
        """
        return _fast.NonMaximumSuppression_create(threshold)

    def setThreshold(self, threshold: "float") -> "void":
        return _fast.NonMaximumSuppression_setThreshold(self, threshold)

    def loadAttributes(self) -> "void":
        return _fast.NonMaximumSuppression_loadAttributes(self)
    __swig_destroy__ = _fast.delete_NonMaximumSuppression

# Register NonMaximumSuppression in _fast:
_fast.NonMaximumSuppression_swigregister(NonMaximumSuppression)

def NonMaximumSuppression_New() -> "std::shared_ptr< fast::NonMaximumSuppression >":
    return _fast.NonMaximumSuppression_New()

def NonMaximumSuppression_getStaticNameOfClass() -> "std::string":
    return _fast.NonMaximumSuppression_getStaticNameOfClass()

def NonMaximumSuppression_create(threshold: "float"=0.5) -> "std::shared_ptr< fast::NonMaximumSuppression >":
    r"""
    Create instance
    :type threshold: float
    :param threshold: Minimum intersection over union to remove overlapping bounding box.
    :rtype: :py:class:`NonMaximumSuppression`
    :return: instance
    """
    return _fast.NonMaximumSuppression_create(threshold)

class Region(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pixelCount = property(_fast.Region_pixelCount_get, _fast.Region_pixelCount_set)
    area = property(_fast.Region_area_get, _fast.Region_area_set)
    label = property(_fast.Region_label_get, _fast.Region_label_set)
    centroid = property(_fast.Region_centroid_get, _fast.Region_centroid_set)
    perimiterLength = property(_fast.Region_perimiterLength_get, _fast.Region_perimiterLength_set)
    averageRadius = property(_fast.Region_averageRadius_get, _fast.Region_averageRadius_set)
    maxPixelPosition = property(_fast.Region_maxPixelPosition_get, _fast.Region_maxPixelPosition_set)
    minPixelPosition = property(_fast.Region_minPixelPosition_get, _fast.Region_minPixelPosition_set)
    contourMesh = property(_fast.Region_contourMesh_get, _fast.Region_contourMesh_set)
    contourPixels = property(_fast.Region_contourPixels_get, _fast.Region_contourPixels_set)
    pixels = property(_fast.Region_pixels_get, _fast.Region_pixels_set)

    def __init__(self):
        _fast.Region_swiginit(self, _fast.new_Region())
    __swig_destroy__ = _fast.delete_Region

# Register Region in _fast:
_fast.Region_swigregister(Region)

class RegionList(RegionListT):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.RegionList_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RegionList_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::RegionList >":
        return _fast.RegionList_fromDataObject(object)

    @staticmethod
    def create(data: "Regions") -> "std::shared_ptr< fast::RegionList >":
        return _fast.RegionList_create(data)
    __swig_destroy__ = _fast.delete_RegionList

# Register RegionList in _fast:
_fast.RegionList_swigregister(RegionList)

def RegionList_getStaticNameOfClass() -> "std::string":
    return _fast.RegionList_getStaticNameOfClass()

def RegionList_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::RegionList >":
    return _fast.RegionList_fromDataObject(object)

def RegionList_create(data: "Regions") -> "std::shared_ptr< fast::RegionList >":
    return _fast.RegionList_create(data)

class RegionProperties(ProcessObject):
    r"""
    Calculate properties, such as area, contour and centroid, for every segmentation region

    Inputs:
    - 0: Image segmentation

    Outputs:
    - 0: RegionList, a simple data object which is a vector of Region

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::RegionProperties >":
        return _fast.RegionProperties_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.RegionProperties_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RegionProperties_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::RegionProperties >":
        return _fast.RegionProperties_connect(self, *args)

    @staticmethod
    def create(extractContours: "bool"=True) -> "std::shared_ptr< fast::RegionProperties >":
        r"""
        Create instance
        :type extractContours: boolean
        :param extractContours: Whether to extract contours of each region or not
        :rtype: :py:class:`RegionProperties`
        :return: instance
        """
        return _fast.RegionProperties_create(extractContours)
    __swig_destroy__ = _fast.delete_RegionProperties

# Register RegionProperties in _fast:
_fast.RegionProperties_swigregister(RegionProperties)

def RegionProperties_New() -> "std::shared_ptr< fast::RegionProperties >":
    return _fast.RegionProperties_New()

def RegionProperties_getStaticNameOfClass() -> "std::string":
    return _fast.RegionProperties_getStaticNameOfClass()

def RegionProperties_create(extractContours: "bool"=True) -> "std::shared_ptr< fast::RegionProperties >":
    r"""
    Create instance
    :type extractContours: boolean
    :param extractContours: Whether to extract contours of each region or not
    :rtype: :py:class:`RegionProperties`
    :return: instance
    """
    return _fast.RegionProperties_create(extractContours)

class RunUntilFinished(ProcessObject):
    r"""
    Calls run on parent PO until output is marked as last frame

    This PO is useful when having multi-step processsing and a previous step needs to run on
    a stream of data before it is finished.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::RunUntilFinished >":
        return _fast.RunUntilFinished_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.RunUntilFinished_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RunUntilFinished_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::RunUntilFinished >":
        return _fast.RunUntilFinished_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::RunUntilFinished >":
        return _fast.RunUntilFinished_create()
    __swig_destroy__ = _fast.delete_RunUntilFinished

# Register RunUntilFinished in _fast:
_fast.RunUntilFinished_swigregister(RunUntilFinished)

def RunUntilFinished_New() -> "std::shared_ptr< fast::RunUntilFinished >":
    return _fast.RunUntilFinished_New()

def RunUntilFinished_getStaticNameOfClass() -> "std::string":
    return _fast.RunUntilFinished_getStaticNameOfClass()

def RunUntilFinished_create() -> "std::shared_ptr< fast::RunUntilFinished >":
    return _fast.RunUntilFinished_create()

class SeededRegionGrowing(ProcessObject):
    r"""
    Segmentation by seeded region growing

    Inputs:
    - 0: Image

    Outputs
    - 0: Image segmentation

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SeededRegionGrowing >":
        return _fast.SeededRegionGrowing_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SeededRegionGrowing_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SeededRegionGrowing_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::SeededRegionGrowing >":
        return _fast.SeededRegionGrowing_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::SeededRegionGrowing >":
        r"""
        Create instance
        :type intensityMinimum: float
        :param intensityMinimum: Minimum intensity to accept voxel as part of segmentation.
        :type intensityMaximum: float
        :param intensityMaximum: Maximum intensity to accept voxel as part of segmentation.
        :type seedPoints: std::vector< Vector3i,std::allocator< Vector3i > >
        :param seedPoints: List of seed points in pixel space. If 2D, z component is not used.
        :type connectivity: int
        :param connectivity: Which connectivity to use when growing
        :rtype: :py:class:`SeededRegionGrowing`
        :return: instance
        """
        return _fast.SeededRegionGrowing_create(*args, **kwargs)

    def setIntensityRange(self, min: "float", max: "float") -> "void":
        return _fast.SeededRegionGrowing_setIntensityRange(self, min, max)

    def addSeedPoint(self, *args) -> "void":
        return _fast.SeededRegionGrowing_addSeedPoint(self, *args)

    def getSeedPoints(self) -> "std::vector< Vector3i,std::allocator< Vector3i > >":
        return _fast.SeededRegionGrowing_getSeedPoints(self)
    __swig_destroy__ = _fast.delete_SeededRegionGrowing

# Register SeededRegionGrowing in _fast:
_fast.SeededRegionGrowing_swigregister(SeededRegionGrowing)

def SeededRegionGrowing_New() -> "std::shared_ptr< fast::SeededRegionGrowing >":
    return _fast.SeededRegionGrowing_New()

def SeededRegionGrowing_getStaticNameOfClass() -> "std::string":
    return _fast.SeededRegionGrowing_getStaticNameOfClass()

def SeededRegionGrowing_create(*args, **kwargs) -> "std::shared_ptr< fast::SeededRegionGrowing >":
    r"""
    Create instance
    :type intensityMinimum: float
    :param intensityMinimum: Minimum intensity to accept voxel as part of segmentation.
    :type intensityMaximum: float
    :param intensityMaximum: Maximum intensity to accept voxel as part of segmentation.
    :type seedPoints: std::vector< Vector3i,std::allocator< Vector3i > >
    :param seedPoints: List of seed points in pixel space. If 2D, z component is not used.
    :type connectivity: int
    :param connectivity: Which connectivity to use when growing
    :rtype: :py:class:`SeededRegionGrowing`
    :return: instance
    """
    return _fast.SeededRegionGrowing_create(*args, **kwargs)

class SegmentationVolumeReconstructor(ProcessObject):
    r"""
    Reconstruct a stream of 2D segmentation images into a 3D segmentation image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SegmentationVolumeReconstructor >":
        return _fast.SegmentationVolumeReconstructor_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SegmentationVolumeReconstructor_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SegmentationVolumeReconstructor_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::SegmentationVolumeReconstructor >":
        return _fast.SegmentationVolumeReconstructor_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::SegmentationVolumeReconstructor >":
        return _fast.SegmentationVolumeReconstructor_create()
    __swig_destroy__ = _fast.delete_SegmentationVolumeReconstructor

# Register SegmentationVolumeReconstructor in _fast:
_fast.SegmentationVolumeReconstructor_swigregister(SegmentationVolumeReconstructor)

def SegmentationVolumeReconstructor_New() -> "std::shared_ptr< fast::SegmentationVolumeReconstructor >":
    return _fast.SegmentationVolumeReconstructor_New()

def SegmentationVolumeReconstructor_getStaticNameOfClass() -> "std::string":
    return _fast.SegmentationVolumeReconstructor_getStaticNameOfClass()

def SegmentationVolumeReconstructor_create() -> "std::shared_ptr< fast::SegmentationVolumeReconstructor >":
    return _fast.SegmentationVolumeReconstructor_create()

class Skeletonization(ProcessObject):
    r"""
    Extract the skeleton of 2D segmentation as a 2D image

    Inputs:
    - 0: Image segmentation 2D

    Outputs:
    - 0: Image Skeleton of input 0

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::Skeletonization >":
        return _fast.Skeletonization_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.Skeletonization_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Skeletonization_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::Skeletonization >":
        return _fast.Skeletonization_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::Skeletonization >":
        return _fast.Skeletonization_create()
    __swig_destroy__ = _fast.delete_Skeletonization

# Register Skeletonization in _fast:
_fast.Skeletonization_swigregister(Skeletonization)

def Skeletonization_New() -> "std::shared_ptr< fast::Skeletonization >":
    return _fast.Skeletonization_New()

def Skeletonization_getStaticNameOfClass() -> "std::string":
    return _fast.Skeletonization_getStaticNameOfClass()

def Skeletonization_create() -> "std::shared_ptr< fast::Skeletonization >":
    return _fast.Skeletonization_create()

class SurfaceExtraction(ProcessObject):
    r"""
    Extract triangle mesh from a 3D Image (volume)

    This process object uses the Marching Cubes algorithm to extract a isosurface, a triangle Mesh,
    from a 3D Image. This GPU OpenCL implementation uses histogram pyramids and is documented in the article
    "Real-time surface extraction and visualization of medical images using OpenCL and GPUs" Smistad et al. 2012

    Inputs:
    - 0: Image 3D

    Outputs:
    - 0: Mesh - Surface triangle mesh extracted from input image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SurfaceExtraction >":
        return _fast.SurfaceExtraction_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SurfaceExtraction_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SurfaceExtraction_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::SurfaceExtraction >":
        return _fast.SurfaceExtraction_connect(self, *args)

    @staticmethod
    def create(threshold: "float"=0.0) -> "std::shared_ptr< fast::SurfaceExtraction >":
        r"""
        Create instance
        :type threshold: float
        :param threshold: Intensity threshold to accept a voxel as part the segmentation.
        :rtype: :py:class:`SurfaceExtraction`
        :return: instance
        """
        return _fast.SurfaceExtraction_create(threshold)

    def setThreshold(self, threshold: "float") -> "void":
        return _fast.SurfaceExtraction_setThreshold(self, threshold)

    def getThreshold(self) -> "float":
        return _fast.SurfaceExtraction_getThreshold(self)
    __swig_destroy__ = _fast.delete_SurfaceExtraction

# Register SurfaceExtraction in _fast:
_fast.SurfaceExtraction_swigregister(SurfaceExtraction)

def SurfaceExtraction_New() -> "std::shared_ptr< fast::SurfaceExtraction >":
    return _fast.SurfaceExtraction_New()

def SurfaceExtraction_getStaticNameOfClass() -> "std::string":
    return _fast.SurfaceExtraction_getStaticNameOfClass()

def SurfaceExtraction_create(threshold: "float"=0.0) -> "std::shared_ptr< fast::SurfaceExtraction >":
    r"""
    Create instance
    :type threshold: float
    :param threshold: Intensity threshold to accept a voxel as part the segmentation.
    :rtype: :py:class:`SurfaceExtraction`
    :return: instance
    """
    return _fast.SurfaceExtraction_create(threshold)

class TemplateMatching(ProcessObject):
    r"""
    Match a template image to an image

    This algorithms matches a template image to an image using normalized cross correlation (NCC),
    sum of absolute differences (SAD) or sum of squared differences (SSD).

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TemplateMatching >":
        return _fast.TemplateMatching_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TemplateMatching_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TemplateMatching_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TemplateMatching >":
        return _fast.TemplateMatching_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::TemplateMatching >":
        return _fast.TemplateMatching_create(*args, **kwargs)

    def setRegionOfInterest(self, center: "Vector2i", offset: "Vector2i") -> "void":
        r"""
        Set region of interest of where to do the template matching.
        :type center: Vector2i
        :param center: 2D position
        :type offset: Vector2i
        :param offset: in x and y direction
        """
        return _fast.TemplateMatching_setRegionOfInterest(self, center, offset)

    def getBestFitPixelPosition(self) -> "Vector2i":
        r"""
        Get position of best fit
        :rtype: Vector2i
        :return: Vector2i
        """
        return _fast.TemplateMatching_getBestFitPixelPosition(self)

    def getBestFitSubPixelPosition(self) -> "Vector2f":
        r"""
        Get position of best fit with sub pixel accuracy using parabolic fitting
        :rtype: Vector2f
        :return: Vector2f
        """
        return _fast.TemplateMatching_getBestFitSubPixelPosition(self)

    def setMatchingMetric(self, type: "fast::MatchingMetric") -> "void":
        r"""
        Select which matching metric to use
        :type type: int
        :param type:
        """
        return _fast.TemplateMatching_setMatchingMetric(self, type)
    __swig_destroy__ = _fast.delete_TemplateMatching

# Register TemplateMatching in _fast:
_fast.TemplateMatching_swigregister(TemplateMatching)

def TemplateMatching_New() -> "std::shared_ptr< fast::TemplateMatching >":
    return _fast.TemplateMatching_New()

def TemplateMatching_getStaticNameOfClass() -> "std::string":
    return _fast.TemplateMatching_getStaticNameOfClass()

def TemplateMatching_create(*args, **kwargs) -> "std::shared_ptr< fast::TemplateMatching >":
    return _fast.TemplateMatching_create(*args, **kwargs)

class ImageWeightedMovingAverage(ProcessObject):
    r"""
    Temporal smoothing of image using weighted moving average

    Inputs:
    - 0: Image stream

    Outputs:
    - 0: Image stream

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageWeightedMovingAverage >":
        return _fast.ImageWeightedMovingAverage_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageWeightedMovingAverage_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageWeightedMovingAverage_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageWeightedMovingAverage >":
        return _fast.ImageWeightedMovingAverage_connect(self, *args)

    @staticmethod
    def create(frameCount: "int"=10, keepDataType: "bool"=False) -> "std::shared_ptr< fast::ImageWeightedMovingAverage >":
        return _fast.ImageWeightedMovingAverage_create(frameCount, keepDataType)

    def setFrameCount(self, frameCount: "int") -> "void":
        return _fast.ImageWeightedMovingAverage_setFrameCount(self, frameCount)

    def setKeepDataType(self, keep: "bool") -> "void":
        return _fast.ImageWeightedMovingAverage_setKeepDataType(self, keep)

    def reset(self) -> "void":
        return _fast.ImageWeightedMovingAverage_reset(self)
    __swig_destroy__ = _fast.delete_ImageWeightedMovingAverage

# Register ImageWeightedMovingAverage in _fast:
_fast.ImageWeightedMovingAverage_swigregister(ImageWeightedMovingAverage)

def ImageWeightedMovingAverage_New() -> "std::shared_ptr< fast::ImageWeightedMovingAverage >":
    return _fast.ImageWeightedMovingAverage_New()

def ImageWeightedMovingAverage_getStaticNameOfClass() -> "std::string":
    return _fast.ImageWeightedMovingAverage_getStaticNameOfClass()

def ImageWeightedMovingAverage_create(frameCount: "int"=10, keepDataType: "bool"=False) -> "std::shared_ptr< fast::ImageWeightedMovingAverage >":
    return _fast.ImageWeightedMovingAverage_create(frameCount, keepDataType)

class ImageMovingAverage(ProcessObject):
    r"""
    Temporal smoothing of image using moving average

    Inputs:
    - 0: Image stream

    Outputs:
    - 0: Image stream

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageMovingAverage >":
        return _fast.ImageMovingAverage_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageMovingAverage_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageMovingAverage_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageMovingAverage >":
        return _fast.ImageMovingAverage_connect(self, *args)

    @staticmethod
    def create(frameCount: "int"=10, keepDataType: "bool"=False) -> "std::shared_ptr< fast::ImageMovingAverage >":
        return _fast.ImageMovingAverage_create(frameCount, keepDataType)

    def setFrameCount(self, frameCount: "int") -> "void":
        return _fast.ImageMovingAverage_setFrameCount(self, frameCount)

    def setKeepDataType(self, keep: "bool") -> "void":
        return _fast.ImageMovingAverage_setKeepDataType(self, keep)

    def reset(self) -> "void":
        return _fast.ImageMovingAverage_reset(self)
    __swig_destroy__ = _fast.delete_ImageMovingAverage

# Register ImageMovingAverage in _fast:
_fast.ImageMovingAverage_swigregister(ImageMovingAverage)

def ImageMovingAverage_New() -> "std::shared_ptr< fast::ImageMovingAverage >":
    return _fast.ImageMovingAverage_New()

def ImageMovingAverage_getStaticNameOfClass() -> "std::string":
    return _fast.ImageMovingAverage_getStaticNameOfClass()

def ImageMovingAverage_create(frameCount: "int"=10, keepDataType: "bool"=False) -> "std::shared_ptr< fast::ImageMovingAverage >":
    return _fast.ImageMovingAverage_create(frameCount, keepDataType)

class StartTimer(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::StartTimer >":
        return _fast.StartTimer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.StartTimer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.StartTimer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::StartTimer >":
        return _fast.StartTimer_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::StartTimer >":
        return _fast.StartTimer_create()

    def getStartTime(self) -> "std::chrono::system_clock::time_point":
        return _fast.StartTimer_getStartTime(self)
    __swig_destroy__ = _fast.delete_StartTimer

# Register StartTimer in _fast:
_fast.StartTimer_swigregister(StartTimer)

def StartTimer_New() -> "std::shared_ptr< fast::StartTimer >":
    return _fast.StartTimer_New()

def StartTimer_getStaticNameOfClass() -> "std::string":
    return _fast.StartTimer_getStaticNameOfClass()

def StartTimer_create() -> "std::shared_ptr< fast::StartTimer >":
    return _fast.StartTimer_create()

class StopTimer(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::StopTimer >":
        return _fast.StopTimer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.StopTimer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.StopTimer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::StopTimer >":
        return _fast.StopTimer_connect(self, *args)

    @staticmethod
    def create(start: "std::shared_ptr< fast::StartTimer >", printEveryRun: "bool"=True, printAtEnd: "bool"=True, warmupRounds: "int"=0, maximumSamples: "int"=-1) -> "std::shared_ptr< fast::StopTimer >":
        return _fast.StopTimer_create(start, printEveryRun, printAtEnd, warmupRounds, maximumSamples)

    def setStartTimer(self, start: "fast::StartTimer::pointer") -> "void":
        return _fast.StopTimer_setStartTimer(self, start)

    def getFPS(self) -> "float":
        return _fast.StopTimer_getFPS(self)

    def getAverage(self) -> "float":
        return _fast.StopTimer_getAverage(self)

    def getRuntime(self) -> "fast::RuntimeMeasurement::pointer":
        return _fast.StopTimer_getRuntime(self)
    __swig_destroy__ = _fast.delete_StopTimer

# Register StopTimer in _fast:
_fast.StopTimer_swigregister(StopTimer)

def StopTimer_New() -> "std::shared_ptr< fast::StopTimer >":
    return _fast.StopTimer_New()

def StopTimer_getStaticNameOfClass() -> "std::string":
    return _fast.StopTimer_getStaticNameOfClass()

def StopTimer_create(start: "std::shared_ptr< fast::StartTimer >", printEveryRun: "bool"=True, printAtEnd: "bool"=True, warmupRounds: "int"=0, maximumSamples: "int"=-1) -> "std::shared_ptr< fast::StopTimer >":
    return _fast.StopTimer_create(start, printEveryRun, printAtEnd, warmupRounds, maximumSamples)

class TissueMicroArrayExtractor(Streamer):
    r"""
    Extract tissue micro arrays (TMAs) from a whole-slide image

    This method create a stream of images of the TMAs in a whole-slide image pyramid.

    Inputs:
    - 0: ImagePyramid WSI

    Outputs:
    - 0: Image stream of TMAs from input

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TissueMicroArrayExtractor >":
        return _fast.TissueMicroArrayExtractor_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TissueMicroArrayExtractor_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TissueMicroArrayExtractor_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TissueMicroArrayExtractor >":
        return _fast.TissueMicroArrayExtractor_connect(self, *args)

    @staticmethod
    def create(level: "int"=0, areaThreshold: "float"=0.5, tissueThreshold: "int"=85, dilationSize: "int"=9, erosionSize: "int"=9) -> "std::shared_ptr< fast::TissueMicroArrayExtractor >":
        r"""
        Create instance
        :type level: int
        :param level: Which image pyramid level to extract TMAs from. Default is 0 which is highest resolution level.
                 Negative level means the last level (lowest resolution).
        :type areaThreshold: float
        :param areaThreshold: Percentage of median area a TMA disc candidate has to have to be included.
        :type tissueThreshold: int
        :param tissueThreshold: Threshold for distance from white (255,255,255) to be considered as tissue.
        :type dilationSize: int
        :param dilationSize: Size of dilation to perform after thresholding
        :type erosionSize: int
        :param erosionSize: Size of erosion to perform after thresholding
        :rtype: :py:class:`TissueMicroArrayExtractor`
        :return: instance
        """
        return _fast.TissueMicroArrayExtractor_create(level, areaThreshold, tissueThreshold, dilationSize, erosionSize)

    def setLevel(self, level: "int") -> "void":
        return _fast.TissueMicroArrayExtractor_setLevel(self, level)

    def getLevel(self) -> "int":
        return _fast.TissueMicroArrayExtractor_getLevel(self)

    def setAreaThreshold(self, threshold: "float") -> "void":
        return _fast.TissueMicroArrayExtractor_setAreaThreshold(self, threshold)

    def getAreaThreshold(self) -> "float":
        return _fast.TissueMicroArrayExtractor_getAreaThreshold(self)

    def setTissueThreshold(self, threshold: "int") -> "void":
        return _fast.TissueMicroArrayExtractor_setTissueThreshold(self, threshold)

    def getTissueThreshold(self) -> "int":
        return _fast.TissueMicroArrayExtractor_getTissueThreshold(self)
    __swig_destroy__ = _fast.delete_TissueMicroArrayExtractor

# Register TissueMicroArrayExtractor in _fast:
_fast.TissueMicroArrayExtractor_swigregister(TissueMicroArrayExtractor)

def TissueMicroArrayExtractor_New() -> "std::shared_ptr< fast::TissueMicroArrayExtractor >":
    return _fast.TissueMicroArrayExtractor_New()

def TissueMicroArrayExtractor_getStaticNameOfClass() -> "std::string":
    return _fast.TissueMicroArrayExtractor_getStaticNameOfClass()

def TissueMicroArrayExtractor_create(level: "int"=0, areaThreshold: "float"=0.5, tissueThreshold: "int"=85, dilationSize: "int"=9, erosionSize: "int"=9) -> "std::shared_ptr< fast::TissueMicroArrayExtractor >":
    r"""
    Create instance
    :type level: int
    :param level: Which image pyramid level to extract TMAs from. Default is 0 which is highest resolution level.
             Negative level means the last level (lowest resolution).
    :type areaThreshold: float
    :param areaThreshold: Percentage of median area a TMA disc candidate has to have to be included.
    :type tissueThreshold: int
    :param tissueThreshold: Threshold for distance from white (255,255,255) to be considered as tissue.
    :type dilationSize: int
    :param dilationSize: Size of dilation to perform after thresholding
    :type erosionSize: int
    :param erosionSize: Size of erosion to perform after thresholding
    :rtype: :py:class:`TissueMicroArrayExtractor`
    :return: instance
    """
    return _fast.TissueMicroArrayExtractor_create(level, areaThreshold, tissueThreshold, dilationSize, erosionSize)

class TissueSegmentation(ProcessObject):
    r"""
    Segment tissue from a WSI

    Uses the GPU to perform a simple threshold-based tissue/glass segmentation of a WSI.
    Since glass is almost white, the threshold is the distance from the pixels color
    to white (255,255,255).
    A morphological closing (dilation+erosion) is performed after thresholding.

    Inputs:
    - 0: ImagePyramid WSI or Image patch

    Outputs:
    - 0: Segmentation tissue mask

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TissueSegmentation >":
        return _fast.TissueSegmentation_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TissueSegmentation_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TissueSegmentation_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TissueSegmentation >":
        return _fast.TissueSegmentation_connect(self, *args)

    @staticmethod
    def create(useColorThresholdingMethod: "bool"=False, level: "int"=-1, magnification: "float"=1.25, threshold: "int"=85, dilationSize: "int"=9, erosionSize: "int"=9, filterZeros: "bool"=True) -> "std::shared_ptr< fast::TissueSegmentation >":
        r"""
        Create an instance of TissueSegmentation

        :type useColorThresholdingMethod: boolean
        :param useColorThresholdingMethod: Whether to use a simple color thresholding method or a neural network to segment tissue
        :type level: int
        :param level: Level to run neural network on. Only used if magnification <= 0
        :type magnification: float
        :param magnification: Magnification to run neural network on.
        :type threshold: int
        :param threshold: Threshold for distance from white (255,255,255) to be considered as tissue.
        :type dilationSize: int
        :param dilationSize: Size of dilation to perform after thresholding
        :type erosionSize: int
        :param erosionSize: Size of erosion to perform after thresholding
        :rtype: :py:class:`TissueSegmentation`
        :return: A tissue segmentation instance
        """
        return _fast.TissueSegmentation_create(useColorThresholdingMethod, level, magnification, threshold, dilationSize, erosionSize, filterZeros)

    def setThreshold(self, thresh: "int") -> "void":
        r"""
        Set single threshold for pixel filtering based on the distance a RGB-triplet is from the color white. Default is 85
        :type thresh: int
        :param thresh:
        """
        return _fast.TissueSegmentation_setThreshold(self, thresh)

    def getThreshold(self) -> "int":
        r"""Get current threshold value"""
        return _fast.TissueSegmentation_getThreshold(self)

    def setDilate(self, radius: "int") -> "void":
        r"""
        Set radius for disk used in morphological dilation. Default is 9
        :type radius: int
        :param radius:
        """
        return _fast.TissueSegmentation_setDilate(self, radius)

    def getDilate(self) -> "int":
        r"""Get current dilation value"""
        return _fast.TissueSegmentation_getDilate(self)

    def setErode(self, radius: "int") -> "void":
        r"""
        Set radius for disk used in morphological erosion. Default is 9
        :type radius: int
        :param radius:
        """
        return _fast.TissueSegmentation_setErode(self, radius)

    def getErode(self) -> "int":
        r"""Get current erosion value"""
        return _fast.TissueSegmentation_getErode(self)

    def setFilterZeros(self, value: "bool") -> "void":
        r"""Set status for filtering zero uints."""
        return _fast.TissueSegmentation_setFilterZeros(self, value)

    def getFilterZeros(self) -> "bool":
        r"""Get current status whether to include zero uints into background class or not. Default is true"""
        return _fast.TissueSegmentation_getFilterZeros(self)

    def setLevel(self, level: "int") -> "void":
        return _fast.TissueSegmentation_setLevel(self, level)

    def getLevel(self) -> "int":
        return _fast.TissueSegmentation_getLevel(self)

    def setMagnification(self, magnification: "float") -> "void":
        return _fast.TissueSegmentation_setMagnification(self, magnification)

    def getMagnification(self) -> "float":
        return _fast.TissueSegmentation_getMagnification(self)

    def setUseColorThresholdingMethod(self, use: "bool") -> "void":
        return _fast.TissueSegmentation_setUseColorThresholdingMethod(self, use)

    def getUseColorThresholdingMethod(self) -> "bool":
        return _fast.TissueSegmentation_getUseColorThresholdingMethod(self)

    def loadAttributes(self) -> "void":
        return _fast.TissueSegmentation_loadAttributes(self)
    __swig_destroy__ = _fast.delete_TissueSegmentation

# Register TissueSegmentation in _fast:
_fast.TissueSegmentation_swigregister(TissueSegmentation)

def TissueSegmentation_New() -> "std::shared_ptr< fast::TissueSegmentation >":
    return _fast.TissueSegmentation_New()

def TissueSegmentation_getStaticNameOfClass() -> "std::string":
    return _fast.TissueSegmentation_getStaticNameOfClass()

def TissueSegmentation_create(useColorThresholdingMethod: "bool"=False, level: "int"=-1, magnification: "float"=1.25, threshold: "int"=85, dilationSize: "int"=9, erosionSize: "int"=9, filterZeros: "bool"=True) -> "std::shared_ptr< fast::TissueSegmentation >":
    r"""
    Create an instance of TissueSegmentation

    :type useColorThresholdingMethod: boolean
    :param useColorThresholdingMethod: Whether to use a simple color thresholding method or a neural network to segment tissue
    :type level: int
    :param level: Level to run neural network on. Only used if magnification <= 0
    :type magnification: float
    :param magnification: Magnification to run neural network on.
    :type threshold: int
    :param threshold: Threshold for distance from white (255,255,255) to be considered as tissue.
    :type dilationSize: int
    :param dilationSize: Size of dilation to perform after thresholding
    :type erosionSize: int
    :param erosionSize: Size of erosion to perform after thresholding
    :rtype: :py:class:`TissueSegmentation`
    :return: A tissue segmentation instance
    """
    return _fast.TissueSegmentation_create(useColorThresholdingMethod, level, magnification, threshold, dilationSize, erosionSize, filterZeros)

class TubeSegmentationAndCenterlineExtraction(ProcessObject):
    r"""
    Segmentation and centerline extraction of tubular structures

    This implementation is described in the article
    "GPU Accelerated Segmentation and Centerline Extraction of TubularStructures from Medical Images"
    by Smistad et al. 2014
    https://www.eriksmistad.no/wp-content/uploads/gpu_accelerated_extraction_of_tubular_structures.pdf

    Inputs:
    - 0: Image 3D

    Outputs:
    - 0: Image segmentation 3D
    - 1: Mesh centerline
    - 2: Image 3D tubular detection heatmap

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TubeSegmentationAndCenterlineExtraction >":
        return _fast.TubeSegmentationAndCenterlineExtraction_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TubeSegmentationAndCenterlineExtraction_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TubeSegmentationAndCenterlineExtraction_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TubeSegmentationAndCenterlineExtraction >":
        return _fast.TubeSegmentationAndCenterlineExtraction_connect(self, *args)

    @staticmethod
    def create(sensitivity: "float"=0.5, minimumRadius: "float"=1.0, maximumRadius: "float"=5.0, radiusStep: "float"=0.5, extractBrightTubes: "bool"=False, keepLargestTreeOnly: "bool"=False) -> "std::shared_ptr< fast::TubeSegmentationAndCenterlineExtraction >":
        return _fast.TubeSegmentationAndCenterlineExtraction_create(sensitivity, minimumRadius, maximumRadius, radiusStep, extractBrightTubes, keepLargestTreeOnly)

    def setKeepLargestTree(self, keep: "bool") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setKeepLargestTree(self, keep)

    def setMinimumTreeSize(self, nrOfVoxels: "int") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setMinimumTreeSize(self, nrOfVoxels)

    def setMinimumRadius(self, radius: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setMinimumRadius(self, radius)

    def setMaximumRadius(self, radius: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setMaximumRadius(self, radius)

    def setRadiusStep(self, step: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setRadiusStep(self, step)

    def setSensitivity(self, sensitivity: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setSensitivity(self, sensitivity)

    def setMinimumIntensity(self, intensity: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setMinimumIntensity(self, intensity)

    def setMaximumIntensity(self, intensity: "float") -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_setMaximumIntensity(self, intensity)

    def extractDarkTubes(self) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_extractDarkTubes(self)

    def extractBrightTubes(self) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_extractBrightTubes(self)

    def disableSegmentation(self) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_disableSegmentation(self)

    def enableSegmentation(self) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_enableSegmentation(self)

    def disableAutomaticCropping(self) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_disableAutomaticCropping(self)

    def enableAutomaticCropping(self, lungCropping: "bool"=False) -> "void":
        return _fast.TubeSegmentationAndCenterlineExtraction_enableAutomaticCropping(self, lungCropping)

    def getSegmentationOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.TubeSegmentationAndCenterlineExtraction_getSegmentationOutputPort(self)

    def getCenterlineOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.TubeSegmentationAndCenterlineExtraction_getCenterlineOutputPort(self)

    def getTDFOutputPort(self) -> "fast::DataChannel::pointer":
        return _fast.TubeSegmentationAndCenterlineExtraction_getTDFOutputPort(self)
    __swig_destroy__ = _fast.delete_TubeSegmentationAndCenterlineExtraction

# Register TubeSegmentationAndCenterlineExtraction in _fast:
_fast.TubeSegmentationAndCenterlineExtraction_swigregister(TubeSegmentationAndCenterlineExtraction)

def TubeSegmentationAndCenterlineExtraction_New() -> "std::shared_ptr< fast::TubeSegmentationAndCenterlineExtraction >":
    return _fast.TubeSegmentationAndCenterlineExtraction_New()

def TubeSegmentationAndCenterlineExtraction_getStaticNameOfClass() -> "std::string":
    return _fast.TubeSegmentationAndCenterlineExtraction_getStaticNameOfClass()

def TubeSegmentationAndCenterlineExtraction_create(sensitivity: "float"=0.5, minimumRadius: "float"=1.0, maximumRadius: "float"=5.0, radiusStep: "float"=0.5, extractBrightTubes: "bool"=False, keepLargestTreeOnly: "bool"=False) -> "std::shared_ptr< fast::TubeSegmentationAndCenterlineExtraction >":
    return _fast.TubeSegmentationAndCenterlineExtraction_create(sensitivity, minimumRadius, maximumRadius, radiusStep, extractBrightTubes, keepLargestTreeOnly)

class EnvelopeAndLogCompressor(ProcessObject):
    r"""
    Performs normalized envelope detection and log compression on IQ data

    Inputs:
    - 0: Image 2 channels float (IQ data)

    Outputs:
    - 0: Image 1 channel float (beamspace data in dB) if convertToGrayscale == false,
         or Image 1 channel uint8 (beamspace data in grayscale) if convertToGrayscale == true

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::EnvelopeAndLogCompressor >":
        return _fast.EnvelopeAndLogCompressor_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.EnvelopeAndLogCompressor_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.EnvelopeAndLogCompressor_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::EnvelopeAndLogCompressor >":
        return _fast.EnvelopeAndLogCompressor_connect(self, *args)

    @staticmethod
    def create(convertToGrayscale: "bool"=False, gain: "float"=0, dynamicRange: "float"=60) -> "std::shared_ptr< fast::EnvelopeAndLogCompressor >":
        return _fast.EnvelopeAndLogCompressor_create(convertToGrayscale, gain, dynamicRange)

    def setConvertToGrayscale(self, convert: "bool") -> "void":
        return _fast.EnvelopeAndLogCompressor_setConvertToGrayscale(self, convert)

    def setGain(self, gain: "float") -> "void":
        return _fast.EnvelopeAndLogCompressor_setGain(self, gain)

    def setDynamicRange(self, dynamicRange: "float") -> "void":
        return _fast.EnvelopeAndLogCompressor_setDynamicRange(self, dynamicRange)
    __swig_destroy__ = _fast.delete_EnvelopeAndLogCompressor

# Register EnvelopeAndLogCompressor in _fast:
_fast.EnvelopeAndLogCompressor_swigregister(EnvelopeAndLogCompressor)

def EnvelopeAndLogCompressor_New() -> "std::shared_ptr< fast::EnvelopeAndLogCompressor >":
    return _fast.EnvelopeAndLogCompressor_New()

def EnvelopeAndLogCompressor_getStaticNameOfClass() -> "std::string":
    return _fast.EnvelopeAndLogCompressor_getStaticNameOfClass()

def EnvelopeAndLogCompressor_create(convertToGrayscale: "bool"=False, gain: "float"=0, dynamicRange: "float"=60) -> "std::shared_ptr< fast::EnvelopeAndLogCompressor >":
    return _fast.EnvelopeAndLogCompressor_create(convertToGrayscale, gain, dynamicRange)

class ScanConverter(ProcessObject):
    r"""
    Scan convert beamspace image

    Inputs:
    - 0: Beamspace image (float) in dB (typically from EnvelopeAndLogCompressor)

    Outputs:
    - 0: Scan converted grayscale image (uint8)


    See also: EnvelopeAndLogCompressor
    See also: UFFStreamer
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ScanConverter >":
        return _fast.ScanConverter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ScanConverter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ScanConverter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ScanConverter >":
        return _fast.ScanConverter_connect(self, *args)

    @staticmethod
    def create(width: "int"=1024, height: "int"=1024, gain: "float"=10.0, dynamicRange: "float"=60.0, startDepth: "float"=0.0, endDepth: "float"=0.0, startAngle: "float"=0.0, endAngle: "float"=0.0, left: "float"=0.0, right: "float"=0.0) -> "std::shared_ptr< fast::ScanConverter >":
        r"""
        Create instance

        The scan converter parameters (start/end depth, start/end angle etc.) can be set manually here.
        But this is only needed if the input image frame lacks this information in its frame data.
        The UFFStreamer should provide this information.

        :type width: int
        :param width: Width of output image
        :type height: int
        :param height: Height of output image
        :type gain: float
        :param gain: Set gain to be used if input is in dB
        :type dynamicRange: float
        :param dynamicRange: Set dynamic range to be used if input is in dB
        :type startDepth: float
        :param startDepth: Start depth scan in millimeters.
                 This is only needed to be set manually if the input frame lacks this information in its frame data.
        :type endDepth: float
        :param endDepth: End depth of scan in millimeters.
                 This is only needed to be set manually if the input frame lacks this information in its frame data.
        :type startAngle: float
        :param startAngle: Start angle of sector scan in radians. Not needed if linear array image.
                 This is only needed to be set manually if the input frame lacks this information in its frame data.
        :type endAngle: float
        :param endAngle: End angle of sector scan in radians. Not needed if linear array image.
                 This is only needed to be set manually if the input frame lacks this information in its frame data.
        :type left: float
        :param left: Lateral start position of linear scan in millimeters. Not needed if sector scan.
                 This is only needed to be set manually if the input frame lacks this information in its frame data.
        :type right: float
        :param right: Lateral end position of linear scan in millimeters. Not needed if sector scan.
                 This is only needed to be set manually if the input frame lacks this information in its frame data.
        :rtype: :py:class:`ScanConverter`
        :return: instance
        """
        return _fast.ScanConverter_create(width, height, gain, dynamicRange, startDepth, endDepth, startAngle, endAngle, left, right)

    def setWidth(self, width: "int") -> "void":
        return _fast.ScanConverter_setWidth(self, width)

    def getWidth(self) -> "int":
        return _fast.ScanConverter_getWidth(self)

    def setHeight(self, height: "int") -> "void":
        return _fast.ScanConverter_setHeight(self, height)

    def getHeight(self) -> "int":
        return _fast.ScanConverter_getHeight(self)

    def setGain(self, gain: "float") -> "void":
        return _fast.ScanConverter_setGain(self, gain)

    def setDynamicRange(self, dynamicRange: "float") -> "void":
        return _fast.ScanConverter_setDynamicRange(self, dynamicRange)
    __swig_destroy__ = _fast.delete_ScanConverter

# Register ScanConverter in _fast:
_fast.ScanConverter_swigregister(ScanConverter)

def ScanConverter_New() -> "std::shared_ptr< fast::ScanConverter >":
    return _fast.ScanConverter_New()

def ScanConverter_getStaticNameOfClass() -> "std::string":
    return _fast.ScanConverter_getStaticNameOfClass()

def ScanConverter_create(width: "int"=1024, height: "int"=1024, gain: "float"=10.0, dynamicRange: "float"=60.0, startDepth: "float"=0.0, endDepth: "float"=0.0, startAngle: "float"=0.0, endAngle: "float"=0.0, left: "float"=0.0, right: "float"=0.0) -> "std::shared_ptr< fast::ScanConverter >":
    r"""
    Create instance

    The scan converter parameters (start/end depth, start/end angle etc.) can be set manually here.
    But this is only needed if the input image frame lacks this information in its frame data.
    The UFFStreamer should provide this information.

    :type width: int
    :param width: Width of output image
    :type height: int
    :param height: Height of output image
    :type gain: float
    :param gain: Set gain to be used if input is in dB
    :type dynamicRange: float
    :param dynamicRange: Set dynamic range to be used if input is in dB
    :type startDepth: float
    :param startDepth: Start depth scan in millimeters.
             This is only needed to be set manually if the input frame lacks this information in its frame data.
    :type endDepth: float
    :param endDepth: End depth of scan in millimeters.
             This is only needed to be set manually if the input frame lacks this information in its frame data.
    :type startAngle: float
    :param startAngle: Start angle of sector scan in radians. Not needed if linear array image.
             This is only needed to be set manually if the input frame lacks this information in its frame data.
    :type endAngle: float
    :param endAngle: End angle of sector scan in radians. Not needed if linear array image.
             This is only needed to be set manually if the input frame lacks this information in its frame data.
    :type left: float
    :param left: Lateral start position of linear scan in millimeters. Not needed if sector scan.
             This is only needed to be set manually if the input frame lacks this information in its frame data.
    :type right: float
    :param right: Lateral end position of linear scan in millimeters. Not needed if sector scan.
             This is only needed to be set manually if the input frame lacks this information in its frame data.
    :rtype: :py:class:`ScanConverter`
    :return: instance
    """
    return _fast.ScanConverter_create(width, height, gain, dynamicRange, startDepth, endDepth, startAngle, endAngle, left, right)

class UltrasoundImageCropper(ProcessObject):
    r"""
    Automatic cropping of an ultrasound scanner image

    When streaming or storing images/video on ultrasound scanner, the menu and a lot of information around the actual
    ultrasound image is often included.
    This algorithm tries to extract the ultrasound image from the entire scanner GUI image using two thresholds.
    It does this by counting the number of non-zero pixels in every row and column of the image.
    To find the min x and max x positions, it starts from the middle and stops at the first x position which has a
    number of pixels equal to 0 above the thresholdVertical. It does this both in the left and right direction.
    Then this is repeated for the vertical direction, y using thresholdHorizontal.
    Works best on linear array images.

    Inputs:
    - 0: Image

    Outputs:
    - 0: Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::UltrasoundImageCropper >":
        return _fast.UltrasoundImageCropper_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.UltrasoundImageCropper_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.UltrasoundImageCropper_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::UltrasoundImageCropper >":
        return _fast.UltrasoundImageCropper_connect(self, *args)

    @staticmethod
    def create(physicalWidth: "float"=0, staticCropping: "bool"=False, thresholdVertical: "float"=30, thresholdHorizontal: "float"=10) -> "std::shared_ptr< fast::UltrasoundImageCropper >":
        r"""
        Create instance
        :type physicalWidth: float
        :param physicalWidth: The physical width of the scanning region. This is used to set the pixel spacing correctly.
        :type staticCropping: boolean
        :param staticCropping: Estimate the cropping parameters (offset, size) on the first frame only, then use these for all subsequent frames
        :type thresholdVertical: float
        :param thresholdVertical: Number of pixels that have to be above 0 to accept an image column to be outside of ultrasound sector
        :type thresholdHorizontal: float
        :param thresholdHorizontal: Number of pixels that have to be above 0 to accept an image row to be outside of ultrasound sector
        :rtype: :py:class:`UltrasoundImageCropper`
        :return: instance
        """
        return _fast.UltrasoundImageCropper_create(physicalWidth, staticCropping, thresholdVertical, thresholdHorizontal)

    def setPhysicalWidth(self, width: "float") -> "void":
        r"""
        By setting the physical width of the image, the physical height can also
        be calculated and the spacing of the image set correctly.

        :type width: float
        :param width:
        """
        return _fast.UltrasoundImageCropper_setPhysicalWidth(self, width)

    def setStaticCropping(self, staticCropping: "bool") -> "void":
        r"""
        If static cropping is enabled, the cropping parameters are calculated only for the first frame.
        Otherwise, it is recalculated for every frame.
        :type staticCropping: boolean
        :param staticCropping:
        """
        return _fast.UltrasoundImageCropper_setStaticCropping(self, staticCropping)

    def setThresholds(self, threshold1: "float", threshold2: "float") -> "void":
        return _fast.UltrasoundImageCropper_setThresholds(self, threshold1, threshold2)

    def loadAttributes(self) -> "void":
        return _fast.UltrasoundImageCropper_loadAttributes(self)
    __swig_destroy__ = _fast.delete_UltrasoundImageCropper

# Register UltrasoundImageCropper in _fast:
_fast.UltrasoundImageCropper_swigregister(UltrasoundImageCropper)

def UltrasoundImageCropper_New() -> "std::shared_ptr< fast::UltrasoundImageCropper >":
    return _fast.UltrasoundImageCropper_New()

def UltrasoundImageCropper_getStaticNameOfClass() -> "std::string":
    return _fast.UltrasoundImageCropper_getStaticNameOfClass()

def UltrasoundImageCropper_create(physicalWidth: "float"=0, staticCropping: "bool"=False, thresholdVertical: "float"=30, thresholdHorizontal: "float"=10) -> "std::shared_ptr< fast::UltrasoundImageCropper >":
    r"""
    Create instance
    :type physicalWidth: float
    :param physicalWidth: The physical width of the scanning region. This is used to set the pixel spacing correctly.
    :type staticCropping: boolean
    :param staticCropping: Estimate the cropping parameters (offset, size) on the first frame only, then use these for all subsequent frames
    :type thresholdVertical: float
    :param thresholdVertical: Number of pixels that have to be above 0 to accept an image column to be outside of ultrasound sector
    :type thresholdHorizontal: float
    :param thresholdHorizontal: Number of pixels that have to be above 0 to accept an image row to be outside of ultrasound sector
    :rtype: :py:class:`UltrasoundImageCropper`
    :return: instance
    """
    return _fast.UltrasoundImageCropper_create(physicalWidth, staticCropping, thresholdVertical, thresholdHorizontal)

class UltrasoundImageEnhancement(ProcessObject):
    r"""
    Apply a color map and reject on an ultrasound image

    Inputs:
    - 0: Image grayscale

    Outputs:
    - 0: Image color

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::UltrasoundImageEnhancement >":
        return _fast.UltrasoundImageEnhancement_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.UltrasoundImageEnhancement_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.UltrasoundImageEnhancement_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::UltrasoundImageEnhancement >":
        return _fast.UltrasoundImageEnhancement_connect(self, *args)

    @staticmethod
    def create(reject: "int"=0) -> "std::shared_ptr< fast::UltrasoundImageEnhancement >":
        return _fast.UltrasoundImageEnhancement_create(reject)

    def loadAttributes(self) -> "void":
        return _fast.UltrasoundImageEnhancement_loadAttributes(self)

    def setReject(self, value: "int") -> "void":
        return _fast.UltrasoundImageEnhancement_setReject(self, value)
    __swig_destroy__ = _fast.delete_UltrasoundImageEnhancement

# Register UltrasoundImageEnhancement in _fast:
_fast.UltrasoundImageEnhancement_swigregister(UltrasoundImageEnhancement)

def UltrasoundImageEnhancement_New() -> "std::shared_ptr< fast::UltrasoundImageEnhancement >":
    return _fast.UltrasoundImageEnhancement_New()

def UltrasoundImageEnhancement_getStaticNameOfClass() -> "std::string":
    return _fast.UltrasoundImageEnhancement_getStaticNameOfClass()

def UltrasoundImageEnhancement_create(reject: "int"=0) -> "std::shared_ptr< fast::UltrasoundImageEnhancement >":
    return _fast.UltrasoundImageEnhancement_create(reject)

class VectorMedianFilter(ProcessObject):
    r"""
    Apply median filter on vector field to reduce noise

    Inputs:
    - 0: Image vector field

    Outputs:
    - 0: Image vector field

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VectorMedianFilter >":
        return _fast.VectorMedianFilter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VectorMedianFilter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VectorMedianFilter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::VectorMedianFilter >":
        return _fast.VectorMedianFilter_connect(self, *args)

    @staticmethod
    def create(size: "int"=7) -> "std::shared_ptr< fast::VectorMedianFilter >":
        return _fast.VectorMedianFilter_create(size)

    def setWindowSize(self, size: "int") -> "void":
        r"""
        Set window size of median filter. Must be odd
        :type size: int
        :param size:
        """
        return _fast.VectorMedianFilter_setWindowSize(self, size)

    def loadAttributes(self) -> "void":
        return _fast.VectorMedianFilter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_VectorMedianFilter

# Register VectorMedianFilter in _fast:
_fast.VectorMedianFilter_swigregister(VectorMedianFilter)

def VectorMedianFilter_New() -> "std::shared_ptr< fast::VectorMedianFilter >":
    return _fast.VectorMedianFilter_New()

def VectorMedianFilter_getStaticNameOfClass() -> "std::string":
    return _fast.VectorMedianFilter_getStaticNameOfClass()

def VectorMedianFilter_create(size: "int"=7) -> "std::shared_ptr< fast::VectorMedianFilter >":
    return _fast.VectorMedianFilter_create(size)

class MeshVertex(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        _fast.MeshVertex_swiginit(self, _fast.new_MeshVertex(*args, **kwargs))

    def getPosition(self) -> "Vector3f":
        return _fast.MeshVertex_getPosition(self)

    def getNormal(self) -> "Vector3f":
        return _fast.MeshVertex_getNormal(self)

    def setPosition(self, position: "Vector3f") -> "void":
        return _fast.MeshVertex_setPosition(self, position)

    def setNormal(self, normal: "Vector3f") -> "void":
        return _fast.MeshVertex_setNormal(self, normal)

    def setLabel(self, label: "int") -> "void":
        return _fast.MeshVertex_setLabel(self, label)

    def getLabel(self) -> "int":
        return _fast.MeshVertex_getLabel(self)

    def setColor(self, color: "Color") -> "void":
        return _fast.MeshVertex_setColor(self, color)

    def getColor(self) -> "fast::Color":
        return _fast.MeshVertex_getColor(self)
    __swig_destroy__ = _fast.delete_MeshVertex

# Register MeshVertex in _fast:
_fast.MeshVertex_swigregister(MeshVertex)

class MeshConnection(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getEndpoint(self, index: "uint") -> "int":
        return _fast.MeshConnection_getEndpoint(self, index)

    def getEndpoint1(self) -> "int":
        return _fast.MeshConnection_getEndpoint1(self)

    def getEndpoint2(self) -> "int":
        return _fast.MeshConnection_getEndpoint2(self)

    def getColor(self) -> "fast::Color":
        return _fast.MeshConnection_getColor(self)

    def setEndpoint(self, endpointIndex: "int", vertexIndex: "int") -> "void":
        return _fast.MeshConnection_setEndpoint(self, endpointIndex, vertexIndex)

    def setEndpoint1(self, index: "uint") -> "void":
        return _fast.MeshConnection_setEndpoint1(self, index)

    def setEndpoint2(self, index: "uint") -> "void":
        return _fast.MeshConnection_setEndpoint2(self, index)

    def setColor(self, color: "Color") -> "void":
        return _fast.MeshConnection_setColor(self, color)
    __swig_destroy__ = _fast.delete_MeshConnection

# Register MeshConnection in _fast:
_fast.MeshConnection_swigregister(MeshConnection)

class MeshLine(MeshConnection):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        _fast.MeshLine_swiginit(self, _fast.new_MeshLine(*args, **kwargs))
    __swig_destroy__ = _fast.delete_MeshLine

# Register MeshLine in _fast:
_fast.MeshLine_swigregister(MeshLine)

class MeshTriangle(MeshConnection):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        _fast.MeshTriangle_swiginit(self, _fast.new_MeshTriangle(*args, **kwargs))

    def getEndpoint3(self) -> "int":
        return _fast.MeshTriangle_getEndpoint3(self)

    def setEndpoint3(self, index: "uint") -> "void":
        return _fast.MeshTriangle_setEndpoint3(self, index)
    __swig_destroy__ = _fast.delete_MeshTriangle

# Register MeshTriangle in _fast:
_fast.MeshTriangle_swigregister(MeshTriangle)

class MeshAccess(object):
    r"""
    CPU access to Mesh data
    See also: Mesh
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, mCoordinates: "vectorf", mNormals: "vectorf", mColors: "vectorf", mLines: "vectorui", mTriangles: "vectorui", mesh: "std::shared_ptr< fast::Mesh >"):
        _fast.MeshAccess_swiginit(self, _fast.new_MeshAccess(mCoordinates, mNormals, mColors, mLines, mTriangles, mesh))

    def getVertex(self, i: "uint") -> "fast::MeshVertex":
        r"""
        Get vertex at position i
        :type i: int
        :param i: index
        """
        return _fast.MeshAccess_getVertex(self, i)

    def setVertex(self, i: "uint", vertex: "MeshVertex", updateBoundingBox: "bool"=True) -> "void":
        r"""
        Set vertex at given index
        :type i: int
        :param i: index
        :type vertex: :py:class:`MeshVertex`
        :param vertex: Vertex
        :type updateBoundingBox: boolean
        :param updateBoundingBox: Whether to update the Mesh bounding box or not
        """
        return _fast.MeshAccess_setVertex(self, i, vertex, updateBoundingBox)

    def addVertex(self, v: "MeshVertex") -> "void":
        return _fast.MeshAccess_addVertex(self, v)

    def addVertices(self, vertices: "vectormeshvertex") -> "void":
        return _fast.MeshAccess_addVertices(self, vertices)

    def getTriangle(self, i: "uint") -> "fast::MeshTriangle":
        return _fast.MeshAccess_getTriangle(self, i)

    def setTriangle(self, i: "uint", arg3: "MeshTriangle") -> "void":
        return _fast.MeshAccess_setTriangle(self, i, arg3)

    def addTriangle(self, t: "MeshTriangle") -> "void":
        return _fast.MeshAccess_addTriangle(self, t)

    def getLine(self, i: "uint") -> "fast::MeshLine":
        return _fast.MeshAccess_getLine(self, i)

    def setLine(self, i: "uint", arg3: "MeshLine") -> "void":
        return _fast.MeshAccess_setLine(self, i, arg3)

    def addLine(self, l: "MeshLine") -> "void":
        return _fast.MeshAccess_addLine(self, l)

    def getTriangles(self) -> "std::vector< fast::MeshTriangle,std::allocator< fast::MeshTriangle > >":
        return _fast.MeshAccess_getTriangles(self)

    def getLines(self) -> "std::vector< fast::MeshLine,std::allocator< fast::MeshLine > >":
        return _fast.MeshAccess_getLines(self)

    def getVertices(self) -> "std::vector< fast::MeshVertex,std::allocator< fast::MeshVertex > >":
        return _fast.MeshAccess_getVertices(self)

    def release(self) -> "void":
        return _fast.MeshAccess_release(self)
    __swig_destroy__ = _fast.delete_MeshAccess

# Register MeshAccess in _fast:
_fast.MeshAccess_swigregister(MeshAccess)

class MeshOpenCLAccess(object):
    r"""OpenCL buffer access to Mesh"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, coordinatesBuffer: "cl::Buffer *", lineBuffer: "cl::Buffer *", triangleBuffer: "cl::Buffer *", mesh: "std::shared_ptr< fast::Mesh >"):
        _fast.MeshOpenCLAccess_swiginit(self, _fast.new_MeshOpenCLAccess(coordinatesBuffer, lineBuffer, triangleBuffer, mesh))

    def getCoordinatesBuffer(self) -> "cl::Buffer *":
        return _fast.MeshOpenCLAccess_getCoordinatesBuffer(self)

    def getLineBuffer(self) -> "cl::Buffer *":
        return _fast.MeshOpenCLAccess_getLineBuffer(self)

    def getTriangleBuffer(self) -> "cl::Buffer *":
        return _fast.MeshOpenCLAccess_getTriangleBuffer(self)

    def release(self) -> "void":
        return _fast.MeshOpenCLAccess_release(self)
    __swig_destroy__ = _fast.delete_MeshOpenCLAccess

# Register MeshOpenCLAccess in _fast:
_fast.MeshOpenCLAccess_swigregister(MeshOpenCLAccess)

class VertexBufferObjectAccess(object):
    r"""Vertex Buffer Object (VBO) access to Mesh"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def getCoordinateVBO(self) -> "GLuint *":
        return _fast.VertexBufferObjectAccess_getCoordinateVBO(self)

    def getNormalVBO(self) -> "GLuint *":
        return _fast.VertexBufferObjectAccess_getNormalVBO(self)

    def getColorVBO(self) -> "GLuint *":
        return _fast.VertexBufferObjectAccess_getColorVBO(self)

    def getLineEBO(self) -> "GLuint *":
        return _fast.VertexBufferObjectAccess_getLineEBO(self)

    def getTriangleEBO(self) -> "GLuint *":
        return _fast.VertexBufferObjectAccess_getTriangleEBO(self)

    def hasNormalVBO(self) -> "bool":
        return _fast.VertexBufferObjectAccess_hasNormalVBO(self)

    def hasColorVBO(self) -> "bool":
        return _fast.VertexBufferObjectAccess_hasColorVBO(self)

    def hasEBO(self) -> "bool":
        return _fast.VertexBufferObjectAccess_hasEBO(self)

    def __init__(self, coordinateVBO: "GLuint", normalVBO: "GLuint", colorVBO: "GLuint", lineEBO: "GLuint", triangleEBO: "GLuint", useNormalVBO: "bool", useColorVBO: "bool", useEBO: "bool", mesh: "std::shared_ptr< fast::Mesh >"):
        _fast.VertexBufferObjectAccess_swiginit(self, _fast.new_VertexBufferObjectAccess(coordinateVBO, normalVBO, colorVBO, lineEBO, triangleEBO, useNormalVBO, useColorVBO, useEBO, mesh))

    def release(self) -> "void":
        return _fast.VertexBufferObjectAccess_release(self)
    __swig_destroy__ = _fast.delete_VertexBufferObjectAccess

# Register VertexBufferObjectAccess in _fast:
_fast.VertexBufferObjectAccess_swigregister(VertexBufferObjectAccess)

class TensorAccess(object):
    r"""CPU access to Tensor"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, data: "float *", shape: "TensorShape", tensor: "std::shared_ptr< fast::Tensor >"):
        _fast.TensorAccess_swiginit(self, _fast.new_TensorAccess(data, shape, tensor))

    def getRawData(self) -> "float *":
        return _fast.TensorAccess_getRawData(self)

    def getShape(self) -> "TensorShape":
        return _fast.TensorAccess_getShape(self)
    __swig_destroy__ = _fast.delete_TensorAccess

    def release(self) -> "void":
        return _fast.TensorAccess_release(self)

# Register TensorAccess in _fast:
_fast.TensorAccess_swigregister(TensorAccess)

ImageCompression_UNSPECIFIED = _fast.ImageCompression_UNSPECIFIED
ImageCompression_RAW = _fast.ImageCompression_RAW
ImageCompression_JPEG = _fast.ImageCompression_JPEG
ImageCompression_JPEG2000 = _fast.ImageCompression_JPEG2000
ImageCompression_JPEGXL = _fast.ImageCompression_JPEGXL
ImageCompression_LZW = _fast.ImageCompression_LZW
ImageCompression_NEURAL_NETWORK = _fast.ImageCompression_NEURAL_NETWORK
ImageCompression_DEFLATE = _fast.ImageCompression_DEFLATE
class ImagePyramidAccess(object):
    r"""CPU access to ImagePyramid"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, levels: "std::vector< fast::ImagePyramidLevel,std::allocator< fast::ImagePyramidLevel > >", fileHandle: "openslide_t *", tiffHandle: "TIFF *", imagePyramid: "std::shared_ptr< fast::ImagePyramid >", writeAccess: "bool", initializedPatchList: "std::unordered_set< std::string > &", readMutex: "std::mutex &", compressionFormat: "fast::ImageCompression", useCache: "bool"=False, cacheLimit: "int"=-1):
        _fast.ImagePyramidAccess_swiginit(self, _fast.new_ImagePyramidAccess(levels, fileHandle, tiffHandle, imagePyramid, writeAccess, initializedPatchList, readMutex, compressionFormat, useCache, cacheLimit))

    def setPatch(self, level: "int", x: "int", y: "int", patch: "std::shared_ptr< fast::Image >", propagate: "bool"=True) -> "void":
        r"""
        Write a patch to the pyramid
        :type level: int
        :param level:
        :type x: int
        :param x:
        :type y: int
        :param y:
        :type patch: :py:class:`Image`
        :param patch:
        :type propagate: boolean
        :param propagate:
        """
        return _fast.ImagePyramidAccess_setPatch(self, level, x, y, patch, propagate)

    def setBlankPatch(self, level: "int", x: "int", y: "int") -> "void":
        r"""
        Write patch/tile as empty. It will render as white/black
        :type level: int
        :param level:
        :type x: int
        :param x:
        :type y: int
        :param y:
        """
        return _fast.ImagePyramidAccess_setBlankPatch(self, level, x, y)

    def isPatchInitialized(self, level: "int", x: "int", y: "int") -> "bool":
        return _fast.ImagePyramidAccess_isPatchInitialized(self, level, x, y)

    def getLevelAsImage(self, level: "int") -> "std::shared_ptr< fast::Image >":
        r"""
        Get a specific level in an ImagePyramid as an Image object.
        If requesting a level with a width or height higher than 16384 pixels this will throw an exception.
        :type level: int
        :param level:
        :rtype: :py:class:`Image`
        :return: 
        """
        return _fast.ImagePyramidAccess_getLevelAsImage(self, level)

    def getPatchAsImage(self, *args) -> "std::shared_ptr< fast::Image >":
        r"""
        *Overload 1:*

        Extract a patch from the image pyramid and return it as an Image
        :type level: int
        :param level: Level to extract patch from
        :type offsetX: int
        :param offsetX: X offset
        :type offsetY: int
        :param offsetY: Y offset
        :type width: int
        :param width: Width of patch
        :type height: int
        :param height: Height of patch
        :type convertToRGB: boolean
        :param convertToRGB: convert to RGB when using OpenSlide, since it will return BGRA data
        :rtype: :py:class:`Image`
        :return: Patch as Image

        |

        *Overload 2:*

        Extract a tile from the Image Pyramid
        :type level: int
        :param level: Level to extract tile from
        :type patchIdX: int
        :param patchIdX: Tile X id
        :type patchIdY: int
        :param patchIdY:  Tile Y id
        :type convertToRGB: boolean
        :param convertToRGB: convert to RGB when using OpenSlide, since it will return BGRA data
        :rtype: :py:class:`Image`
        :return: Tile as Image
        """
        return _fast.ImagePyramidAccess_getPatchAsImage(self, *args)

    def getPatchAsImageForMagnification(self, magnification: "float", offsetX: "float", offsetY: "float", width: "int", height: "int", convertToRGB: "bool"=True) -> "std::shared_ptr< fast::Image >":
        r"""
        Get patch as Image at a specific magnification
        :type magnification: float
        :param magnification: Magnification. Example: for 20X this value should be 20
        :type offsetX: float
        :param offsetX: Physical offset x position of patch
        :type offsetY: float
        :param offsetY: Physical offset y position of patch
        :type width: int
        :param width: Width of patch in pixels
        :type height: int
        :param height: Height of patch in pixels
        :type convertToRGB: boolean
        :param convertToRGB: convert to RGB when using OpenSlide, since it will return BGRA data
        :rtype: :py:class:`Image`
        :return: patch as Image object
        """
        return _fast.ImagePyramidAccess_getPatchAsImageForMagnification(self, magnification, offsetX, offsetY, width, height, convertToRGB)

    def release(self) -> "void":
        return _fast.ImagePyramidAccess_release(self)
    __swig_destroy__ = _fast.delete_ImagePyramidAccess

    def setJPEGTables(self, tableCount: "uint32_t", tableData: "void *") -> "void":
        return _fast.ImagePyramidAccess_setJPEGTables(self, tableCount, tableData)

    def enableRuntimeMeasurements(self) -> "void":
        return _fast.ImagePyramidAccess_enableRuntimeMeasurements(self)

    def disableRuntimeMeasurements(self) -> "void":
        return _fast.ImagePyramidAccess_disableRuntimeMeasurements(self)

    def getRuntime(self, *args) -> "fast::RuntimeMeasurement::pointer":
        return _fast.ImagePyramidAccess_getRuntime(self, *args)

    def getAllRuntimes(self) -> "fast::RuntimeMeasurementsManager::pointer":
        return _fast.ImagePyramidAccess_getAllRuntimes(self)

# Register ImagePyramidAccess in _fast:
_fast.ImagePyramidAccess_swigregister(ImagePyramidAccess)

class BoundingBox(SpatialDataObject):
    r"""
    A 2D bounding box data object.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.BoundingBox_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BoundingBox_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::BoundingBox >":
        return _fast.BoundingBox_fromDataObject(object)

    @staticmethod
    def create(position: "Vector2f", size: "Vector2f", label: "uchar"=1, score: "float"=0.0) -> "std::shared_ptr< fast::BoundingBox >":
        return _fast.BoundingBox_create(position, size, label, score)

    def setLabel(self, label: "uchar") -> "void":
        return _fast.BoundingBox_setLabel(self, label)

    def getLabel(self) -> "uchar":
        return _fast.BoundingBox_getLabel(self)

    def setPosition(self, position: "Vector2f") -> "void":
        r"""Set position in millimeters"""
        return _fast.BoundingBox_setPosition(self, position)

    def getPosition(self) -> "Vector2f":
        return _fast.BoundingBox_getPosition(self)

    def setSize(self, size: "Vector2f") -> "void":
        r"""Set size in millimeters"""
        return _fast.BoundingBox_setSize(self, size)

    def getSize(self) -> "Vector2f":
        return _fast.BoundingBox_getSize(self)

    def setScore(self, score: "float") -> "void":
        return _fast.BoundingBox_setScore(self, score)

    def getScore(self) -> "float":
        return _fast.BoundingBox_getScore(self)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.BoundingBox_free(self, device)

    def freeAll(self) -> "void":
        return _fast.BoundingBox_freeAll(self)

    def intersectionOverUnion(self, bbox2: "fast::BoundingBox::pointer") -> "float":
        return _fast.BoundingBox_intersectionOverUnion(self, bbox2)
    __swig_destroy__ = _fast.delete_BoundingBox

# Register BoundingBox in _fast:
_fast.BoundingBox_swigregister(BoundingBox)

def BoundingBox_getStaticNameOfClass() -> "std::string":
    return _fast.BoundingBox_getStaticNameOfClass()

def BoundingBox_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::BoundingBox >":
    return _fast.BoundingBox_fromDataObject(object)

def BoundingBox_create(position: "Vector2f", size: "Vector2f", label: "uchar"=1, score: "float"=0.0) -> "std::shared_ptr< fast::BoundingBox >":
    return _fast.BoundingBox_create(position, size, label, score)

class BoundingBoxSet(SpatialDataObject):
    r"""
    A data object representing a (large) set of bounding boxes.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.BoundingBoxSet_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BoundingBoxSet_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::BoundingBoxSet >":
        return _fast.BoundingBoxSet_fromDataObject(object)

    @staticmethod
    def create() -> "std::shared_ptr< fast::BoundingBoxSet >":
        return _fast.BoundingBoxSet_create()

    def getNrOfLines(self) -> "int":
        return _fast.BoundingBoxSet_getNrOfLines(self)

    def getNrOfVertices(self) -> "int":
        return _fast.BoundingBoxSet_getNrOfVertices(self)

    def getMinimumSize(self) -> "float":
        return _fast.BoundingBoxSet_getMinimumSize(self)

    def getAccess(self, type: "accessType") -> "fast::BoundingBoxSetAccess::pointer":
        return _fast.BoundingBoxSet_getAccess(self, type)

    def getOpenGLAccess(self, type: "accessType") -> "fast::BoundingBoxSetOpenGLAccess::pointer":
        return _fast.BoundingBoxSet_getOpenGLAccess(self, type)

    def freeAll(self) -> "void":
        return _fast.BoundingBoxSet_freeAll(self)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.BoundingBoxSet_free(self, device)
    __swig_destroy__ = _fast.delete_BoundingBoxSet

    def getBoundingBox(self) -> "DataBoundingBox":
        return _fast.BoundingBoxSet_getBoundingBox(self)

# Register BoundingBoxSet in _fast:
_fast.BoundingBoxSet_swigregister(BoundingBoxSet)

def BoundingBoxSet_getStaticNameOfClass() -> "std::string":
    return _fast.BoundingBoxSet_getStaticNameOfClass()

def BoundingBoxSet_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::BoundingBoxSet >":
    return _fast.BoundingBoxSet_fromDataObject(object)

def BoundingBoxSet_create() -> "std::shared_ptr< fast::BoundingBoxSet >":
    return _fast.BoundingBoxSet_create()

class BoundingBoxSetAccumulator(ProcessObject):
    r"""
    Accumulate a stream of bounding box sets to a single large bounding box set.

    TODO: move to algorithms folder
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BoundingBoxSetAccumulator >":
        return _fast.BoundingBoxSetAccumulator_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BoundingBoxSetAccumulator_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BoundingBoxSetAccumulator_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::BoundingBoxSetAccumulator >":
        return _fast.BoundingBoxSetAccumulator_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::BoundingBoxSetAccumulator >":
        return _fast.BoundingBoxSetAccumulator_create()
    __swig_destroy__ = _fast.delete_BoundingBoxSetAccumulator

# Register BoundingBoxSetAccumulator in _fast:
_fast.BoundingBoxSetAccumulator_swigregister(BoundingBoxSetAccumulator)

def BoundingBoxSetAccumulator_New() -> "std::shared_ptr< fast::BoundingBoxSetAccumulator >":
    return _fast.BoundingBoxSetAccumulator_New()

def BoundingBoxSetAccumulator_getStaticNameOfClass() -> "std::string":
    return _fast.BoundingBoxSetAccumulator_getStaticNameOfClass()

def BoundingBoxSetAccumulator_create() -> "std::shared_ptr< fast::BoundingBoxSetAccumulator >":
    return _fast.BoundingBoxSetAccumulator_create()

class Image(SpatialDataObject):
    r"""
    Image data

    Class for image data, represents an image which can be stored in multiple different locations such as OpenCL Image,
    Buffer, OpenGL texture and as a C++ pointer on the host.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.Image_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Image_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Image >":
        return _fast.Image_fromDataObject(object)

    @staticmethod
    def createFromImage(image: "fast::Image::pointer") -> "std::shared_ptr< fast::Image >":
        r"""
        Create an image with same size and type as another image.

        Setup an image object with the same size, data type and pixel spacing as the given image.
        Does not allocate any memory.

        :type image: :py:class:`Image`
        :param image: to copy size and pixel spacing from
        """
        return _fast.Image_createFromImage(image)

    @staticmethod
    def createSegmentationFromImage(image: "fast::Image::pointer") -> "std::shared_ptr< fast::Image >":
        return _fast.Image_createSegmentationFromImage(image)

    @staticmethod
    def create(*args) -> "std::shared_ptr< fast::Image >":
        r"""
        *Overload 1:*

        Setup a 2D image object, but does not allocate any memory

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:

        |

        *Overload 2:*

        Setup a 3D image object, but does not allocate any memory.

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type depth: int
        :param depth:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:

        |

        *Overload 3:*

        Copies 2D data to given device

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:
        :type device: :py:class:`ExecutionDevice`
        :param device:
        :type data: void
        :param data:

        |

        *Overload 4:*

        Copies 3D data to given device

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type depth: int
        :param depth:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:
        :type device: :py:class:`ExecutionDevice`
        :param device:
        :type data: void
        :param data:

        |

        *Overload 5:*

        Copies 2D data to default device

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:
        :type data: void
        :param data:

        |

        *Overload 6:*

        Copies 3D data to default device

        :type width: int
        :param width:
        :type height: int
        :param height:
        :type depth: int
        :param depth:
        :type type: int
        :param type:
        :type nrOfChannels: int
        :param nrOfChannels:
        :type data: void
        :param data:
        """
        return _fast.Image_create(*args)

    def getOpenCLImageAccess(self, type: "accessType", arg3: "fast::OpenCLDevice::pointer") -> "fast::OpenCLImageAccess::pointer":
        return _fast.Image_getOpenCLImageAccess(self, type, arg3)

    def getOpenCLBufferAccess(self, type: "accessType", arg3: "fast::OpenCLDevice::pointer") -> "fast::OpenCLBufferAccess::pointer":
        return _fast.Image_getOpenCLBufferAccess(self, type, arg3)

    def getImageAccess(self, type: "accessType") -> "fast::ImageAccess::pointer":
        return _fast.Image_getImageAccess(self, type)

    def getOpenGLTextureAccess(self, type: "accessType", arg3: "fast::OpenCLDevice::pointer", compress: "bool"=False, getOwnership: "bool"=False) -> "fast::OpenGLTextureAccess::pointer":
        return _fast.Image_getOpenGLTextureAccess(self, type, arg3, compress, getOwnership)
    __swig_destroy__ = _fast.delete_Image

    def getWidth(self) -> "int":
        return _fast.Image_getWidth(self)

    def getHeight(self) -> "int":
        return _fast.Image_getHeight(self)

    def getDepth(self) -> "int":
        return _fast.Image_getDepth(self)

    def getNrOfVoxels(self) -> "int":
        r"""
        :rtype: int
        :return: the number of pixels/voxels width*height*depth
        """
        return _fast.Image_getNrOfVoxels(self)

    def getSize(self) -> "fast::Vector3ui":
        return _fast.Image_getSize(self)

    def getDimensions(self) -> "uchar":
        return _fast.Image_getDimensions(self)

    def getDataType(self) -> "fast::DataType":
        return _fast.Image_getDataType(self)

    def getNrOfChannels(self) -> "int":
        return _fast.Image_getNrOfChannels(self)

    def getSpacing(self) -> "Vector3f":
        return _fast.Image_getSpacing(self)

    def setSpacing(self, *args) -> "void":
        return _fast.Image_setSpacing(self, *args)

    def calculateMaximumIntensity(self) -> "float":
        return _fast.Image_calculateMaximumIntensity(self)

    def calculateMinimumIntensity(self) -> "float":
        return _fast.Image_calculateMinimumIntensity(self)

    def calculateAverageIntensity(self) -> "float":
        return _fast.Image_calculateAverageIntensity(self)

    def calculateSumIntensity(self) -> "float":
        return _fast.Image_calculateSumIntensity(self)

    def calculateStandardDeviationIntensity(self) -> "float":
        return _fast.Image_calculateStandardDeviationIntensity(self)

    def copy(self, device: "fast::ExecutionDevice::pointer") -> "fast::Image::pointer":
        r"""Copy image and put contents to specific device"""
        return _fast.Image_copy(self, device)

    def crop(self, offset: "VectorXi", size: "VectorXi", allowOutOfBoundsCropping: "bool"=False, croppingValue: "int"=0) -> "fast::Image::pointer":
        r"""Create a new image which is a cropped version of this image"""
        return _fast.Image_crop(self, offset, size, allowOutOfBoundsCropping, croppingValue)

    def fill(self, value: "float") -> "void":
        r"""
        Fill entire image with a value
        :type value: float
        :param value:
        """
        return _fast.Image_fill(self, value)

    def isSegmentationType(self) -> "bool":
        r"""
        Checks wheter this image is of segmentation type (UINT8 and 1 channel)
        :rtype: boolean
        :return: 
        """
        return _fast.Image_isSegmentationType(self)

    def getTransformedBoundingBox(self) -> "DataBoundingBox":
        return _fast.Image_getTransformedBoundingBox(self)

    def getBoundingBox(self) -> "DataBoundingBox":
        return _fast.Image_getBoundingBox(self)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.Image_free(self, device)

    def freeAll(self) -> "void":
        return _fast.Image_freeAll(self)

    def _getHostDataPointer(self) -> "std::size_t":
        return _fast.Image__getHostDataPointer(self)

    @staticmethod
    def _intToVoidPointer(intPointer: "std::size_t") -> "void *":
        return _fast.Image__intToVoidPointer(intPointer)


    @property
    def __array_interface__(self):
      if self.getDimensions() == 2:
          shape = (self.getHeight(), self.getWidth(), self.getNrOfChannels())
      else:
          shape = (self.getDepth(), self.getHeight(), self.getWidth(), self.getNrOfChannels())
      return {
        'shape': shape,
        'data': (self._getHostDataPointer(), False),
        'typestr': _data_type_to_str[self.getDataType()],
        'version': 3,
        'strides': None,
      }

    @staticmethod
    def createFromTensor(tensor):
      if not hasattr(tensor, '__array_interface__'):
    # Check if torch tensor
        try:
            import torch
            if isinstance(tensor, torch.Tensor):
    # Move tensor to cpu if needed
                tensor = tensor.cpu()
                shape = tensor.shape

                is_2d = True
                has_channels = False
                if len(shape) == 3 and shape[0] <= 4:
                    has_channels = True
                elif len(shape) == 3 and shape[0] > 4:
                    is_2d = False
                elif len(shape) >= 5:
                    raise ValueError('Input to image cannot have shape with more than 4 dimensions')
                elif len(shape) > 3:
                    is_2d = False
                    has_channels = True
                elif len(shape) < 2:
                    raise ValueError('Input to image must have a shape with at least 2 dimensions')

                if has_channels: # Torch is channel first, have to convert to channel last
                  if is_2d:
                      tensor = tensor.permute((1, 2, 0))
                  else:
                      tensor = tensor.permute((1, 2, 3, 0))
                if not tensor.is_contiguous():
                  tensor = tensor.clone(memory_format=torch.contiguous_format)
                tensor = tensor.__array__()
        except ImportError:
            pass

      return Image.createFromArray(tensor)

    @staticmethod
    def createFromArray(ndarray):
      """Create a FAST image from a N-D array (e.g. numpy ndarray)"""
      if not hasattr(ndarray, '__array_interface__'):
          try:
            import torch
            if isinstance(ndarray, torch.Tensor):
              raise ValueError('Input to given to Image.createFromArray() was a torch.Tensor, not an array. Use Image.createFromTensor instead.')
          except ImportError:
            pass
          if hasattr(ndarray, '__array__'):
              ndarray = ndarray.__array__()
          else:
              raise ValueError('Input to Image createFromArray() must have the array_interface property or the __array__() method.')
    # Make sure it is C contiguous first
      mem = memoryview(ndarray)
      import copy
      array_interface = copy.copy(ndarray.__array_interface__)
      typestr = array_interface['typestr'][1:]
      if typestr not in _str_to_data_type:
          raise TypeError('Unknown input type given to Image.createFromArray: ' + typestr)
      type = _str_to_data_type[typestr]
      shape = array_interface['shape']
      if not mem.c_contiguous:
          array_interface['data'] = (_convertToCContiguous(array_interface['data'][0], shape, type), False)
      is_2d = True
      has_channels = False
      if len(shape) == 3 and shape[-1] <= 4:
          has_channels = True
      elif len(shape) == 3 and shape[-1] > 4:
          is_2d = False
      elif len(shape) >= 5:
          raise ValueError('Input to image cannot have shape with more than 4 dimensions')
      elif len(shape) > 3:
          is_2d = False
          has_channels = True
      elif len(shape) < 2:
          raise ValueError('Input to image must have a shape with at least 2 dimensions')
      if is_2d:
          image = Image.create(
              shape[1],
              shape[0],
              type,
              shape[-1] if has_channels else 1,
              Image._intToVoidPointer(array_interface['data'][0])
          )
      else:
          image = Image.create(
              shape[2],
              shape[1],
              shape[0],
              type,
              shape[-1] if has_channels else 1,
              Image._intToVoidPointer(array_interface['data'][0])
          )
      if not mem.c_contiguous:
          _freePointer(array_interface['data'][0], type)
      return image;


# Register Image in _fast:
_fast.Image_swigregister(Image)

def Image_getStaticNameOfClass() -> "std::string":
    return _fast.Image_getStaticNameOfClass()

def Image_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Image >":
    return _fast.Image_fromDataObject(object)

def Image_createFromImage(image: "fast::Image::pointer") -> "std::shared_ptr< fast::Image >":
    r"""
    Create an image with same size and type as another image.

    Setup an image object with the same size, data type and pixel spacing as the given image.
    Does not allocate any memory.

    :type image: :py:class:`Image`
    :param image: to copy size and pixel spacing from
    """
    return _fast.Image_createFromImage(image)

def Image_createSegmentationFromImage(image: "fast::Image::pointer") -> "std::shared_ptr< fast::Image >":
    return _fast.Image_createSegmentationFromImage(image)

def Image_create(*args) -> "std::shared_ptr< fast::Image >":
    r"""
    *Overload 1:*

    Setup a 2D image object, but does not allocate any memory

    :type width: int
    :param width:
    :type height: int
    :param height:
    :type type: int
    :param type:
    :type nrOfChannels: int
    :param nrOfChannels:

    |

    *Overload 2:*

    Setup a 3D image object, but does not allocate any memory.

    :type width: int
    :param width:
    :type height: int
    :param height:
    :type depth: int
    :param depth:
    :type type: int
    :param type:
    :type nrOfChannels: int
    :param nrOfChannels:

    |

    *Overload 3:*

    Copies 2D data to given device

    :type width: int
    :param width:
    :type height: int
    :param height:
    :type type: int
    :param type:
    :type nrOfChannels: int
    :param nrOfChannels:
    :type device: :py:class:`ExecutionDevice`
    :param device:
    :type data: void
    :param data:

    |

    *Overload 4:*

    Copies 3D data to given device

    :type width: int
    :param width:
    :type height: int
    :param height:
    :type depth: int
    :param depth:
    :type type: int
    :param type:
    :type nrOfChannels: int
    :param nrOfChannels:
    :type device: :py:class:`ExecutionDevice`
    :param device:
    :type data: void
    :param data:

    |

    *Overload 5:*

    Copies 2D data to default device

    :type width: int
    :param width:
    :type height: int
    :param height:
    :type type: int
    :param type:
    :type nrOfChannels: int
    :param nrOfChannels:
    :type data: void
    :param data:

    |

    *Overload 6:*

    Copies 3D data to default device

    :type width: int
    :param width:
    :type height: int
    :param height:
    :type depth: int
    :param depth:
    :type type: int
    :param type:
    :type nrOfChannels: int
    :param nrOfChannels:
    :type data: void
    :param data:
    """
    return _fast.Image_create(*args)

def Image__intToVoidPointer(intPointer: "std::size_t") -> "void *":
    return _fast.Image__intToVoidPointer(intPointer)

class Mesh(SpatialDataObject):
    r"""
    Geometry data such as vertices, lines and triangles.

    The mesh data object contains vertices and optionally a set of lines and/or triangles.
    Each vertex is represented as a MeshVertex and the lines and triangles as MeshLine and MeshTriangle respectively.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.Mesh_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Mesh_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Mesh >":
        return _fast.Mesh_fromDataObject(object)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::Mesh >":
        r"""
        Create a mesh

        :type vertices: std::vector< fast::MeshVertex,std::allocator< fast::MeshVertex > >
        :param vertices:
        :type lines: std::vector< fast::MeshLine,std::allocator< fast::MeshLine > >
        :param lines:
        :type triangles: std::vector< fast::MeshTriangle,std::allocator< fast::MeshTriangle > >
        :param triangles:
        """
        return _fast.Mesh_create(*args, **kwargs)

    def getVertexBufferObjectAccess(self, access: "accessType") -> "fast::VertexBufferObjectAccess::pointer":
        return _fast.Mesh_getVertexBufferObjectAccess(self, access)

    def getMeshAccess(self, access: "accessType") -> "fast::MeshAccess::pointer":
        return _fast.Mesh_getMeshAccess(self, access)

    def getOpenCLAccess(self, access: "accessType", device: "fast::OpenCLDevice::pointer") -> "fast::MeshOpenCLAccess::pointer":
        return _fast.Mesh_getOpenCLAccess(self, access, device)

    def getNrOfTriangles(self) -> "int":
        return _fast.Mesh_getNrOfTriangles(self)

    def getNrOfLines(self) -> "int":
        return _fast.Mesh_getNrOfLines(self)

    def getNrOfVertices(self) -> "int":
        return _fast.Mesh_getNrOfVertices(self)

    def setBoundingBox(self, box: "DataBoundingBox") -> "void":
        return _fast.Mesh_setBoundingBox(self, box)
    __swig_destroy__ = _fast.delete_Mesh

# Register Mesh in _fast:
_fast.Mesh_swigregister(Mesh)

def Mesh_getStaticNameOfClass() -> "std::string":
    return _fast.Mesh_getStaticNameOfClass()

def Mesh_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Mesh >":
    return _fast.Mesh_fromDataObject(object)

def Mesh_create(*args, **kwargs) -> "std::shared_ptr< fast::Mesh >":
    r"""
    Create a mesh

    :type vertices: std::vector< fast::MeshVertex,std::allocator< fast::MeshVertex > >
    :param vertices:
    :type lines: std::vector< fast::MeshLine,std::allocator< fast::MeshLine > >
    :param lines:
    :type triangles: std::vector< fast::MeshTriangle,std::allocator< fast::MeshTriangle > >
    :param triangles:
    """
    return _fast.Mesh_create(*args, **kwargs)

class TensorShape(object):
    r"""
    Object representing the shape of a Tensor


    See also: Tensor
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Construct tensor shape
        :type dimensions: std::vector< int,std::allocator< int > >
        :param dimensions:
        """
        _fast.TensorShape_swiginit(self, _fast.new_TensorShape(*args, **kwargs))

    def empty(self) -> "bool":
        r"""If shape is empty or not"""
        return _fast.TensorShape_empty(self)

    def getTotalSize(self) -> "int":
        r"""
        Total size of tensor, excluding any unknown dimensions
        :rtype: int
        :return: 
        """
        return _fast.TensorShape_getTotalSize(self)

    def getDimensions(self) -> "int":
        r"""
        Get nr of dimensions
        :rtype: int
        :return: 
        """
        return _fast.TensorShape_getDimensions(self)

    def getKnownDimensions(self) -> "int":
        r"""
        Get nr of known dimensions (dimension not -1)
        :rtype: int
        :return: 
        """
        return _fast.TensorShape_getKnownDimensions(self)

    def getUnknownDimensions(self, excludingFirstDimension: "bool"=False) -> "int":
        r"""
        Get nr of unknown dimensions (dimensions that are -1)
        :type excludingFirstDimension: boolean
        :param excludingFirstDimension: Get nr of unknown dimensions, excluding the first dimension (batch dimension)
        """
        return _fast.TensorShape_getUnknownDimensions(self, excludingFirstDimension)

    def getAll(self) -> "std::vector< int,std::allocator< int > >":
        r"""
        Get all dimensions as vector
        :rtype: std::vector< int,std::allocator< int > >
        :return: 
        """
        return _fast.TensorShape_getAll(self)

    def setDimension(self, i: "int", value: "int") -> "void":
        r"""
        Set dimension i to value
        :type i: int
        :param i:
        :type value: int
        :param value:
        """
        return _fast.TensorShape_setDimension(self, i, value)

    def addDimension(self, value: "int") -> "void":
        r"""
        Add a dimension to the end of the shape with value
        :type value: int
        :param value:
        """
        return _fast.TensorShape_addDimension(self, value)

    def insertDimension(self, position: "int", value: "int") -> "void":
        r"""
        Insert a new dimension at a given position with the given value
        :type position: int
        :param position:
        :type value: int
        :param value:
        """
        return _fast.TensorShape_insertDimension(self, position, value)

    def toString(self) -> "std::string":
        r"""Convert shape into string"""
        return _fast.TensorShape_toString(self)

    def deleteDimension(self, index: "int") -> "void":
        r"""
        Delete a dimension
        :type index: int
        :param index:
        """
        return _fast.TensorShape_deleteDimension(self, index)

    def deleteDimensions(self, startIndex: "int", endIndex: "int") -> "void":
        r"""
        Delete a range of dimensions
        :type startIndex: int
        :param startIndex:
        :type endIndex: int
        :param endIndex:
        """
        return _fast.TensorShape_deleteDimensions(self, startIndex, endIndex)
    __swig_destroy__ = _fast.delete_TensorShape

# Register TensorShape in _fast:
_fast.TensorShape_swigregister(TensorShape)

class Tensor(SpatialDataObject):
    r"""
    N-Dimensional tensor data object

    This object represents an N-dimensional tensor.
    The data can be stored as a C++ pointer, and as an OpenCL buffer.
    The tensor data is stored as 32-bit floats.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.Tensor_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Tensor_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Tensor >":
        return _fast.Tensor_fromDataObject(object)

    @staticmethod
    def create(*args) -> "std::shared_ptr< fast::Tensor >":
        r"""
        *Overload 1:*

        Create a tensor using the provided data and shape. This method will COPY the data.
        :type data: float
        :param data:
        :type shape: :py:class:`TensorShape`
        :param shape:

        |

        *Overload 2:*

        Create an unitialized tensor with the provided shape
        :type shape: :py:class:`TensorShape`
        :param shape:
        """
        return _fast.Tensor_create(*args)

    def expandDims(self, position: "int"=0) -> "void":
        r"""
        Add a dimension of size 1 at provided position. -1 is last position.
        :type position: int
        :param position:
        """
        return _fast.Tensor_expandDims(self, position)

    def getShape(self) -> "fast::TensorShape":
        return _fast.Tensor_getShape(self)

    def getAccess(self, type: "accessType") -> "fast::TensorAccess::pointer":
        return _fast.Tensor_getAccess(self, type)

    def getOpenCLBufferAccess(self, type: "accessType", arg3: "fast::OpenCLDevice::pointer") -> "std::unique_ptr< fast::OpenCLBufferAccess >":
        return _fast.Tensor_getOpenCLBufferAccess(self, type, arg3)

    def freeAll(self) -> "void":
        return _fast.Tensor_freeAll(self)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.Tensor_free(self, device)

    def setSpacing(self, spacing: "VectorXf") -> "void":
        return _fast.Tensor_setSpacing(self, spacing)

    def getSpacing(self) -> "VectorXf":
        return _fast.Tensor_getSpacing(self)

    def deleteDimension(self, dimension: "int") -> "void":
        return _fast.Tensor_deleteDimension(self, dimension)

    def getTransformedBoundingBox(self) -> "DataBoundingBox":
        return _fast.Tensor_getTransformedBoundingBox(self)

    def getBoundingBox(self) -> "DataBoundingBox":
        return _fast.Tensor_getBoundingBox(self)
    __swig_destroy__ = _fast.delete_Tensor

    def _getHostDataPointer(self) -> "std::size_t":
        return _fast.Tensor__getHostDataPointer(self)

    @staticmethod
    def _intToFloatPointer(intPointer: "std::size_t") -> "float *":
        return _fast.Tensor__intToFloatPointer(intPointer)

    @property
    def __array_interface__(self):
      return {
        'shape': self.getShape().getAll(),
        'data': (self._getHostDataPointer(), False),
        'typestr': 'f4',
        'version': 3,
        'strides': None,
      }

    @staticmethod
    def createFromTensor(tensor, convertToChannelsLast:bool=False):
       if not hasattr(tensor, '__array_interface__'):
    # Check if torch tensor
           try:
               import torch
               if isinstance(tensor, torch.Tensor):
    # Move tensor to cpu if needed
                   tensor = tensor.cpu()
                   shape = tensor.shape
    # TODO should we always permute here to get channel last?
                   if convertToChannelsLast:
                       tensor = tensor.permute(list(range(1, len(shape))) + [0,])
                   if not tensor.is_contiguous():
                       tensor = tensor.clone(memory_format=torch.contiguous_format)
                   tensor = tensor.__array__()
           except ImportError:
              pass

       return Tensor.createFromArray(tensor)

    @staticmethod
    def createFromArray(ndarray):
      """Create a FAST Tensor from a N-D array (e.g. numpy ndarray)"""
      if not hasattr(ndarray, '__array_interface__'):
          try:
            import torch
            if isinstance(ndarray, torch.Tensor):
              raise ValueError('Input to given to Tensor.createFromArray() was a torch.Tensor, not an array. Use Tensor.createFromTensor instead.')
          except ImportError:
            pass
          if hasattr(ndarray, '__array__'):
              ndarray = ndarray.__array__()
          else:
              raise ValueError('Input to Tensor createFromArray() must have the array_interface property or the __array__() method.')

    # Make sure it is C contiguous, convert if needed
      mem = memoryview(ndarray)
      import copy
      array_interface = copy.copy(ndarray.__array_interface__)
      shape = array_interface['shape']
    # Check data type if it is correct
      converted = False
      if array_interface['typestr'][1:] != 'f4': # Is Float 32 bit?
          converted = True
          type = array_interface['typestr'][1:]
          print('WARNING: ndarray given to fast::Tensor::createFromArray was not 32 bit float and will now be converted.')
          if not mem.c_contiguous:
              array_interface['data'] = (_convertToCContiguousFloat(array_interface['data'][0], shape, type), False)
          else:
              array_interface['data'] = (_convertToFloat(array_interface['data'][0], shape, type), False)
          array_interface['typestr'] = array_interface['typestr'][0] + 'f4'
      else:
          if not mem.c_contiguous:
              type = _str_to_data_type[array_interface['typestr'][1:]]
              converted = True
              array_interface['data'] = (_convertToCContiguous(array_interface['data'][0], shape, type), False)

    # Convert to fast shape
      fast_shape = TensorShape()
      for i in shape:
          fast_shape.addDimension(i)

      return_value = Tensor.create(Tensor._intToFloatPointer(array_interface['data'][0]), fast_shape)
      if converted:
          _freePointer(array_interface['data'][0], TYPE_FLOAT)
      return return_value


# Register Tensor in _fast:
_fast.Tensor_swigregister(Tensor)

def Tensor_getStaticNameOfClass() -> "std::string":
    return _fast.Tensor_getStaticNameOfClass()

def Tensor_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Tensor >":
    return _fast.Tensor_fromDataObject(object)

def Tensor_create(*args) -> "std::shared_ptr< fast::Tensor >":
    r"""
    *Overload 1:*

    Create a tensor using the provided data and shape. This method will COPY the data.
    :type data: float
    :param data:
    :type shape: :py:class:`TensorShape`
    :param shape:

    |

    *Overload 2:*

    Create an unitialized tensor with the provided shape
    :type shape: :py:class:`TensorShape`
    :param shape:
    """
    return _fast.Tensor_create(*args)

def Tensor__intToFloatPointer(intPointer: "std::size_t") -> "float *":
    return _fast.Tensor__intToFloatPointer(intPointer)

class Text(SpatialDataObject):
    r"""
    Text data object

    A data object which represents a string of text.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.Text_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.Text_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Text >":
        return _fast.Text_fromDataObject(object)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::Text >":
        return _fast.Text_create(*args, **kwargs)

    def setPosition(self, position: "Vector2f") -> "void":
        return _fast.Text_setPosition(self, position)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.Text_free(self, device)

    def freeAll(self) -> "void":
        return _fast.Text_freeAll(self)

    def getText(self) -> "std::string":
        return _fast.Text_getText(self)

    def setText(self, text: "std::string") -> "void":
        return _fast.Text_setText(self, text)

    def getColor(self) -> "fast::Color":
        return _fast.Text_getColor(self)

    def setColor(self, color: "Color") -> "void":
        return _fast.Text_setColor(self, color)

    def setTextHeight(self, millimeters: "float") -> "void":
        return _fast.Text_setTextHeight(self, millimeters)

    def getTextHeight(self) -> "float":
        return _fast.Text_getTextHeight(self)
    __swig_destroy__ = _fast.delete_Text

# Register Text in _fast:
_fast.Text_swigregister(Text)

def Text_getStaticNameOfClass() -> "std::string":
    return _fast.Text_getStaticNameOfClass()

def Text_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::Text >":
    return _fast.Text_fromDataObject(object)

def Text_create(*args, **kwargs) -> "std::shared_ptr< fast::Text >":
    return _fast.Text_create(*args, **kwargs)

class ImagePyramid(SpatialDataObject):
    r"""
    Image pyramid data object

    Data object for storing large images as tiled image pyramids.
    Storage uses virtual memory enabling the images to be larger than
    the available RAM.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.ImagePyramid_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImagePyramid_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::ImagePyramid >":
        return _fast.ImagePyramid_fromDataObject(object)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::ImagePyramid >":
        r"""
        Create a tiled image pyramid instance

        Create a tiled image pyramid using TIFF.

        :type width: int
        :param width: Full width of image pyramid
        :type height: int
        :param height: Full height of image pyramid
        :type channels: int
        :param channels: Nr of channels of image pyramid (3 == color (RGB), 1 == grayscale)
        :type patchWidth: int
        :param patchWidth: Width of each patch
        :type patchHeight: int
        :param patchHeight: Height of each patch
        :type compression: int
        :param compression: Compression type to use when storing the data in the TIFF.
        :type compressionQuality: int
        :param compressionQuality: Quality of compression when using lossy compression like JPEG and JPEGXL.
                 100 = best, 0 = worst.
        :type dataType: int
        :param dataType: Data type
        :type levelDownsamples: std::vector< float,std::allocator< float > >
        :param levelDownsamples: If not specified an image pyramid with the default structure is used where each level is
                     downsampled with a factor of 2 for each level until a level with smaller width or height than 1024 is reached.
                     An alternative image pyramid structure can be achieved by specifying the downsampling factor for each level
                     in this list. E.g. [4, 4] will create an image pyramid with 3 levels, level 0 with the original width and height.
                     Level 1 with the size width/4, height/4, and level 2 with the size width/(4*4), height/(4*4).
        :type levelSizes: std::vector< Vector2i,std::allocator< Vector2i > >
        :param levelSizes: If not specified an image pyramid with the default structure is used where each level is
                     downsampled with a factor of 2 for each level until a level with smaller width or height than 1024 is reached.
                     An alternative image pyramid structure can be achieved by specifying the exact sizes for each level
                     in this list. If both levelDownsamples and levelSizes are provided, levelSizes is used.
        :rtype: :py:class:`ImagePyramid`
        :return: instance
        """
        return _fast.ImagePyramid_create(*args, **kwargs)

    def getNrOfLevels(self) -> "int":
        return _fast.ImagePyramid_getNrOfLevels(self)

    def getLevelWidth(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelWidth(self, level)

    def getLevelHeight(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelHeight(self, level)

    def getLevelTileWidth(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelTileWidth(self, level)

    def getLevelTileHeight(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelTileHeight(self, level)

    def getLevelTilesX(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelTilesX(self, level)

    def getLevelTilesY(self, level: "int") -> "int":
        return _fast.ImagePyramid_getLevelTilesY(self, level)

    def getLevelScale(self, level: "int") -> "float":
        return _fast.ImagePyramid_getLevelScale(self, level)

    def getLevelForMagnification(self, magnification: "float") -> "int":
        r"""
        Get level for a given magnification if it exists
        :type magnification: float
        :param magnification: Magnification amount (e.g. 40, 20, 10 etc.)
        :rtype: int
        :return: level
        """
        return _fast.ImagePyramid_getLevelForMagnification(self, magnification)

    def getClosestLevelForMagnification(self, magnification: "float", percentageSlack: "float"=0.1) -> "std::pair< int,float >":
        return _fast.ImagePyramid_getClosestLevelForMagnification(self, magnification, percentageSlack)

    def getFullWidth(self) -> "int":
        return _fast.ImagePyramid_getFullWidth(self)

    def getFullHeight(self) -> "int":
        return _fast.ImagePyramid_getFullHeight(self)

    def getWidth(self) -> "int":
        return _fast.ImagePyramid_getWidth(self)

    def getHeight(self) -> "int":
        return _fast.ImagePyramid_getHeight(self)

    def getNrOfChannels(self) -> "int":
        return _fast.ImagePyramid_getNrOfChannels(self)

    def isBGRA(self) -> "bool":
        return _fast.ImagePyramid_isBGRA(self)

    def usesTIFF(self) -> "bool":
        return _fast.ImagePyramid_usesTIFF(self)

    def isPyramidFullyInitialized(self) -> "bool":
        r"""Whether all patches in entire pyramid has been initialized."""
        return _fast.ImagePyramid_isPyramidFullyInitialized(self)

    def usesOpenSlide(self) -> "bool":
        return _fast.ImagePyramid_usesOpenSlide(self)

    def getTIFFPath(self) -> "std::string":
        return _fast.ImagePyramid_getTIFFPath(self)

    def setSpacing(self, spacing: "Vector3f") -> "void":
        return _fast.ImagePyramid_setSpacing(self, spacing)

    def getSpacing(self) -> "Vector3f":
        return _fast.ImagePyramid_getSpacing(self)

    def getAccess(self, type: "accessType", useTileCache: "bool"=False, tileCacheSize: "int"=-1) -> "fast::ImagePyramidAccess::pointer":
        return _fast.ImagePyramid_getAccess(self, type, useTileCache, tileCacheSize)

    def getDirtyPatches(self) -> "std::unordered_set< std::string >":
        return _fast.ImagePyramid_getDirtyPatches(self)

    def isDirtyPatch(self, tileID: "std::string const &") -> "bool":
        return _fast.ImagePyramid_isDirtyPatch(self, tileID)

    def isOMETIFF(self) -> "bool":
        return _fast.ImagePyramid_isOMETIFF(self)

    def setDirtyPatch(self, level: "int", patchIdX: "int", patchIdY: "int") -> "void":
        return _fast.ImagePyramid_setDirtyPatch(self, level, patchIdX, patchIdY)

    def clearDirtyPatches(self, patches: "std::set< std::string >") -> "void":
        return _fast.ImagePyramid_clearDirtyPatches(self, patches)

    def free(self, device: "fast::ExecutionDevice::pointer") -> "void":
        return _fast.ImagePyramid_free(self, device)

    def freeAll(self) -> "void":
        return _fast.ImagePyramid_freeAll(self)
    __swig_destroy__ = _fast.delete_ImagePyramid

    def getTransformedBoundingBox(self) -> "DataBoundingBox":
        return _fast.ImagePyramid_getTransformedBoundingBox(self)

    def getBoundingBox(self) -> "DataBoundingBox":
        return _fast.ImagePyramid_getBoundingBox(self)

    def getCompression(self) -> "fast::ImageCompression":
        return _fast.ImagePyramid_getCompression(self)

    def getCompressionQuality(self) -> "int":
        return _fast.ImagePyramid_getCompressionQuality(self)

    def setCompressionModels(self, compressionModel: "std::shared_ptr< fast::NeuralNetwork >", decompressionModel: "std::shared_ptr< fast::NeuralNetwork >", outputScaleFactor: "float"=1.0) -> "void":
        return _fast.ImagePyramid_setCompressionModels(self, compressionModel, decompressionModel, outputScaleFactor)

    def setCompressionModel(self, compressionModel: "std::shared_ptr< fast::NeuralNetwork >") -> "void":
        return _fast.ImagePyramid_setCompressionModel(self, compressionModel)

    def setDecompressionModel(self, decompressionModel: "std::shared_ptr< fast::NeuralNetwork >", outputScaleFactor: "float"=1.0) -> "void":
        return _fast.ImagePyramid_setDecompressionModel(self, decompressionModel, outputScaleFactor)

    def getCompressionModel(self) -> "std::shared_ptr< fast::NeuralNetwork >":
        return _fast.ImagePyramid_getCompressionModel(self)

    def getDecompressionModel(self) -> "std::shared_ptr< fast::NeuralNetwork >":
        return _fast.ImagePyramid_getDecompressionModel(self)

    def getDecompressionOutputScaleFactor(self) -> "float":
        return _fast.ImagePyramid_getDecompressionOutputScaleFactor(self)

    def getDataType(self) -> "fast::DataType":
        return _fast.ImagePyramid_getDataType(self)

    def getMagnification(self, estimateFromSpacingIfUnknown: "bool"=False) -> "float":
        return _fast.ImagePyramid_getMagnification(self, estimateFromSpacingIfUnknown)

    def setMagnification(self, magnification: "float") -> "void":
        return _fast.ImagePyramid_setMagnification(self, magnification)

# Register ImagePyramid in _fast:
_fast.ImagePyramid_swigregister(ImagePyramid)

def ImagePyramid_getStaticNameOfClass() -> "std::string":
    return _fast.ImagePyramid_getStaticNameOfClass()

def ImagePyramid_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::ImagePyramid >":
    return _fast.ImagePyramid_fromDataObject(object)

def ImagePyramid_create(*args, **kwargs) -> "std::shared_ptr< fast::ImagePyramid >":
    r"""
    Create a tiled image pyramid instance

    Create a tiled image pyramid using TIFF.

    :type width: int
    :param width: Full width of image pyramid
    :type height: int
    :param height: Full height of image pyramid
    :type channels: int
    :param channels: Nr of channels of image pyramid (3 == color (RGB), 1 == grayscale)
    :type patchWidth: int
    :param patchWidth: Width of each patch
    :type patchHeight: int
    :param patchHeight: Height of each patch
    :type compression: int
    :param compression: Compression type to use when storing the data in the TIFF.
    :type compressionQuality: int
    :param compressionQuality: Quality of compression when using lossy compression like JPEG and JPEGXL.
             100 = best, 0 = worst.
    :type dataType: int
    :param dataType: Data type
    :type levelDownsamples: std::vector< float,std::allocator< float > >
    :param levelDownsamples: If not specified an image pyramid with the default structure is used where each level is
                 downsampled with a factor of 2 for each level until a level with smaller width or height than 1024 is reached.
                 An alternative image pyramid structure can be achieved by specifying the downsampling factor for each level
                 in this list. E.g. [4, 4] will create an image pyramid with 3 levels, level 0 with the original width and height.
                 Level 1 with the size width/4, height/4, and level 2 with the size width/(4*4), height/(4*4).
    :type levelSizes: std::vector< Vector2i,std::allocator< Vector2i > >
    :param levelSizes: If not specified an image pyramid with the default structure is used where each level is
                 downsampled with a factor of 2 for each level until a level with smaller width or height than 1024 is reached.
                 An alternative image pyramid structure can be achieved by specifying the exact sizes for each level
                 in this list. If both levelDownsamples and levelSizes are provided, levelSizes is used.
    :rtype: :py:class:`ImagePyramid`
    :return: instance
    """
    return _fast.ImagePyramid_create(*args, **kwargs)

class Importer(ProcessObject):
    r"""
    Abstract base class for 'importers'

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fast.delete_Importer

# Register Importer in _fast:
_fast.Importer_swigregister(Importer)

class FileImporter(Importer):
    r"""
    Abstract base class for importers which import a file with a filename.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.FileImporter_setFilename(self, filename)

    def getFilename(self) -> "std::string":
        return _fast.FileImporter_getFilename(self)

    def loadAttributes(self) -> "void":
        return _fast.FileImporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_FileImporter

# Register FileImporter in _fast:
_fast.FileImporter_swigregister(FileImporter)

class ImageFileImporter(FileImporter):
    r"""
    Read image data stored in various file formats.

    This importer will look at the file extension and determine which image importer should be used to read the file.
    - .jpg, .jpeg, .png, .bmp, .gif -> ImageImporter
    - .dcm (or no extension) -> DICOMFileImporter
    - .mhd -> MetaImageImporter

    ### Output ports
    0: Image

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageFileImporter >":
        return _fast.ImageFileImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageFileImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageFileImporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageFileImporter >":
        return _fast.ImageFileImporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string", grayscale: "bool"=False) -> "std::shared_ptr< fast::ImageFileImporter >":
        r"""
        Create an instance

        :type filename: string
        :param filename: Path to image file to load
        :type grayscale: boolean
        :param grayscale: Convert images to grayscale if the source image is in color
        :rtype: :py:class:`ImageFileImporter`
        :return: instance
        """
        return _fast.ImageFileImporter_create(filename, grayscale)

    def setGrayscale(self, grayscale: "bool") -> "void":
        r"""
        Convert images to grayscale if the source image is in color
        :type grayscale: boolean
        :param grayscale: Convert or not
        """
        return _fast.ImageFileImporter_setGrayscale(self, grayscale)

    def loadAttributes(self) -> "void":
        return _fast.ImageFileImporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageFileImporter

# Register ImageFileImporter in _fast:
_fast.ImageFileImporter_swigregister(ImageFileImporter)

def ImageFileImporter_New() -> "std::shared_ptr< fast::ImageFileImporter >":
    return _fast.ImageFileImporter_New()

def ImageFileImporter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageFileImporter_getStaticNameOfClass()

def ImageFileImporter_create(filename: "std::string", grayscale: "bool"=False) -> "std::shared_ptr< fast::ImageFileImporter >":
    r"""
    Create an instance

    :type filename: string
    :param filename: Path to image file to load
    :type grayscale: boolean
    :param grayscale: Convert images to grayscale if the source image is in color
    :rtype: :py:class:`ImageFileImporter`
    :return: instance
    """
    return _fast.ImageFileImporter_create(filename, grayscale)

class MetaImageImporter(FileImporter):
    r"""
    Loads an image stored in the MetaImage format (.mhd/.raw)

    This importer loads 2D and 3D images stored in the MetaImage format which are pairs of .mhd text files and .raw files
    contain the raw pixel data.
    It supports the compressed .zraw format as well using zlib.
    It also loads all meta data stored in the .mhd text file which can be retrived by Image::getMetaData

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MetaImageImporter >":
        return _fast.MetaImageImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MetaImageImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MetaImageImporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::MetaImageImporter >":
        return _fast.MetaImageImporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string") -> "std::shared_ptr< fast::MetaImageImporter >":
        return _fast.MetaImageImporter_create(filename)
    __swig_destroy__ = _fast.delete_MetaImageImporter

# Register MetaImageImporter in _fast:
_fast.MetaImageImporter_swigregister(MetaImageImporter)

def MetaImageImporter_New() -> "std::shared_ptr< fast::MetaImageImporter >":
    return _fast.MetaImageImporter_New()

def MetaImageImporter_getStaticNameOfClass() -> "std::string":
    return _fast.MetaImageImporter_getStaticNameOfClass()

def MetaImageImporter_create(filename: "std::string") -> "std::shared_ptr< fast::MetaImageImporter >":
    return _fast.MetaImageImporter_create(filename)

class ImageImporter(FileImporter):
    r"""
    Read JPG/PNG/BMP/TIFF images

    Uses Qt5 to read and output plain JPG/PNG/BMP/GIF images from disk.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageImporter >":
        return _fast.ImageImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageImporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageImporter >":
        return _fast.ImageImporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string", grayscale: "bool"=False) -> "std::shared_ptr< fast::ImageImporter >":
        return _fast.ImageImporter_create(filename, grayscale)

    def setGrayscale(self, grayscale: "bool") -> "void":
        return _fast.ImageImporter_setGrayscale(self, grayscale)

    def loadAttributes(self) -> "void":
        return _fast.ImageImporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageImporter

# Register ImageImporter in _fast:
_fast.ImageImporter_swigregister(ImageImporter)

def ImageImporter_New() -> "std::shared_ptr< fast::ImageImporter >":
    return _fast.ImageImporter_New()

def ImageImporter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageImporter_getStaticNameOfClass()

def ImageImporter_create(filename: "std::string", grayscale: "bool"=False) -> "std::shared_ptr< fast::ImageImporter >":
    return _fast.ImageImporter_create(filename, grayscale)

class VTKMeshFileImporter(FileImporter):
    r"""
    Reads gemoetry mesh data from a .vtk polydata file.

    This importer reads geometry data such as vertices, lines and triangles from the VTK polydata format (.vtk) and
    outputs it as a FAST Mesh.

    - Output 0: Mesh

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VTKMeshFileImporter >":
        return _fast.VTKMeshFileImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VTKMeshFileImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VTKMeshFileImporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::VTKMeshFileImporter >":
        return _fast.VTKMeshFileImporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string") -> "std::shared_ptr< fast::VTKMeshFileImporter >":
        return _fast.VTKMeshFileImporter_create(filename)
    __swig_destroy__ = _fast.delete_VTKMeshFileImporter

# Register VTKMeshFileImporter in _fast:
_fast.VTKMeshFileImporter_swigregister(VTKMeshFileImporter)

def VTKMeshFileImporter_New() -> "std::shared_ptr< fast::VTKMeshFileImporter >":
    return _fast.VTKMeshFileImporter_New()

def VTKMeshFileImporter_getStaticNameOfClass() -> "std::string":
    return _fast.VTKMeshFileImporter_getStaticNameOfClass()

def VTKMeshFileImporter_create(filename: "std::string") -> "std::shared_ptr< fast::VTKMeshFileImporter >":
    return _fast.VTKMeshFileImporter_create(filename)

class NIFTIImporter(FileImporter):
    r"""
    Import NIfTI image files

    Supports reading both compressed (.nii.gz) and uncompressed (.nii) NIFTI files.
    Supports version 1 and 2 of the NIFTI format.

    Outputs:
    - 0: Image

    TODO: Read orientation information

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::NIFTIImporter >":
        return _fast.NIFTIImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.NIFTIImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.NIFTIImporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::NIFTIImporter >":
        return _fast.NIFTIImporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string") -> "std::shared_ptr< fast::NIFTIImporter >":
        return _fast.NIFTIImporter_create(filename)
    __swig_destroy__ = _fast.delete_NIFTIImporter

# Register NIFTIImporter in _fast:
_fast.NIFTIImporter_swigregister(NIFTIImporter)

def NIFTIImporter_New() -> "std::shared_ptr< fast::NIFTIImporter >":
    return _fast.NIFTIImporter_New()

def NIFTIImporter_getStaticNameOfClass() -> "std::string":
    return _fast.NIFTIImporter_getStaticNameOfClass()

def NIFTIImporter_create(filename: "std::string") -> "std::shared_ptr< fast::NIFTIImporter >":
    return _fast.NIFTIImporter_create(filename)

class DICOMFileImporter(FileImporter):
    r"""
    Read DICOM image data (both 2D and 3D).

    This importer uses the DCMTK library to load DICOM image data from disk.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::DICOMFileImporter >":
        return _fast.DICOMFileImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.DICOMFileImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DICOMFileImporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::DICOMFileImporter >":
        return _fast.DICOMFileImporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string", loadSeries: "bool"=True) -> "std::shared_ptr< fast::DICOMFileImporter >":
        return _fast.DICOMFileImporter_create(filename, loadSeries)

    def setLoadSeries(self, load: "bool") -> "void":
        return _fast.DICOMFileImporter_setLoadSeries(self, load)
    __swig_destroy__ = _fast.delete_DICOMFileImporter

# Register DICOMFileImporter in _fast:
_fast.DICOMFileImporter_swigregister(DICOMFileImporter)

def DICOMFileImporter_New() -> "std::shared_ptr< fast::DICOMFileImporter >":
    return _fast.DICOMFileImporter_New()

def DICOMFileImporter_getStaticNameOfClass() -> "std::string":
    return _fast.DICOMFileImporter_getStaticNameOfClass()

def DICOMFileImporter_create(filename: "std::string", loadSeries: "bool"=True) -> "std::shared_ptr< fast::DICOMFileImporter >":
    return _fast.DICOMFileImporter_create(filename, loadSeries)

class WholeSlideImageImporter(FileImporter):
    r"""
    Read a whole slide image from disk

    This importer uses the [OpenSlide](https://openslide.org/) library to read whole slide images used in digital pathology,
    in addition to support for the OME-TIFF format which is implemented in FAST using libtiff.
    Thus, this importer can read the following formats:

    - Aperio (.svs, .tif)
    - Hamamatsu (.vms, .vmu, .ndpi)
    - Leica (.scn)
    - MIRAX (.mrxs)
    - Philips (.tiff)
    - Sakura (.svslide)
    - Trestle (.tif)
    - Ventana (.bif, .tif)
    - Generic tiled TIFF (.tif)
    - OME-TIFF (ome.tiff, ome.tif, ome.btf)

    Outputs
    - 0: ImagePyramid


    See also: TIFFImagePyramidImporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::WholeSlideImageImporter >":
        return _fast.WholeSlideImageImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.WholeSlideImageImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.WholeSlideImageImporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::WholeSlideImageImporter >":
        return _fast.WholeSlideImageImporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string") -> "std::shared_ptr< fast::WholeSlideImageImporter >":
        return _fast.WholeSlideImageImporter_create(filename)

    def loadAttributes(self) -> "void":
        return _fast.WholeSlideImageImporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_WholeSlideImageImporter

# Register WholeSlideImageImporter in _fast:
_fast.WholeSlideImageImporter_swigregister(WholeSlideImageImporter)

def WholeSlideImageImporter_New() -> "std::shared_ptr< fast::WholeSlideImageImporter >":
    return _fast.WholeSlideImageImporter_New()

def WholeSlideImageImporter_getStaticNameOfClass() -> "std::string":
    return _fast.WholeSlideImageImporter_getStaticNameOfClass()

def WholeSlideImageImporter_create(filename: "std::string") -> "std::shared_ptr< fast::WholeSlideImageImporter >":
    return _fast.WholeSlideImageImporter_create(filename)

class ImagePyramidPatchImporter(ProcessObject):
    r"""
    Loads an image pyramid from a set of image patches stored in a folder.

    Imports an ImagePyramid stored as a set of image patches stored in a folder.
    Each patch is stored as a PNG image with the file name indicating its position and size.

    See also: ImagePyramidPatchExporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImagePyramidPatchImporter >":
        return _fast.ImagePyramidPatchImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImagePyramidPatchImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImagePyramidPatchImporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImagePyramidPatchImporter >":
        return _fast.ImagePyramidPatchImporter_connect(self, *args)

    @staticmethod
    def create(path: "std::string") -> "std::shared_ptr< fast::ImagePyramidPatchImporter >":
        return _fast.ImagePyramidPatchImporter_create(path)

    def setPath(self, path: "std::string") -> "void":
        return _fast.ImagePyramidPatchImporter_setPath(self, path)

    def loadAttributes(self) -> "void":
        return _fast.ImagePyramidPatchImporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImagePyramidPatchImporter

# Register ImagePyramidPatchImporter in _fast:
_fast.ImagePyramidPatchImporter_swigregister(ImagePyramidPatchImporter)

def ImagePyramidPatchImporter_New() -> "std::shared_ptr< fast::ImagePyramidPatchImporter >":
    return _fast.ImagePyramidPatchImporter_New()

def ImagePyramidPatchImporter_getStaticNameOfClass() -> "std::string":
    return _fast.ImagePyramidPatchImporter_getStaticNameOfClass()

def ImagePyramidPatchImporter_create(path: "std::string") -> "std::shared_ptr< fast::ImagePyramidPatchImporter >":
    return _fast.ImagePyramidPatchImporter_create(path)

class TIFFImagePyramidImporter(FileImporter):
    r"""
    Import image Pyramid stored as tiled multi-page TIFF

    This TIFFImagePyramidImporter is best used for important single channel
    image pyramids such as high-res segmentations.
    For instance if exported using the TIFFImagePyramidExporter.
    This exporter uses libtiff.

    Outputs:
    - 0: ImagePyramid

    See also: WholeSlideImageImporter TIFFImagePyramidExporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TIFFImagePyramidImporter >":
        return _fast.TIFFImagePyramidImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TIFFImagePyramidImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TIFFImagePyramidImporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TIFFImagePyramidImporter >":
        return _fast.TIFFImagePyramidImporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string") -> "std::shared_ptr< fast::TIFFImagePyramidImporter >":
        return _fast.TIFFImagePyramidImporter_create(filename)

    def loadAttributes(self) -> "void":
        return _fast.TIFFImagePyramidImporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_TIFFImagePyramidImporter

# Register TIFFImagePyramidImporter in _fast:
_fast.TIFFImagePyramidImporter_swigregister(TIFFImagePyramidImporter)

def TIFFImagePyramidImporter_New() -> "std::shared_ptr< fast::TIFFImagePyramidImporter >":
    return _fast.TIFFImagePyramidImporter_New()

def TIFFImagePyramidImporter_getStaticNameOfClass() -> "std::string":
    return _fast.TIFFImagePyramidImporter_getStaticNameOfClass()

def TIFFImagePyramidImporter_create(filename: "std::string") -> "std::shared_ptr< fast::TIFFImagePyramidImporter >":
    return _fast.TIFFImagePyramidImporter_create(filename)

class HDF5TensorImporter(FileImporter):
    r"""
    Read tensor data stored in HDF5 format.

    This importer uses the HDF5 C++ library to load Tensor (N-D array) data from disk.


    See also: HDF5TensorExporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::HDF5TensorImporter >":
        return _fast.HDF5TensorImporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.HDF5TensorImporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.HDF5TensorImporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::HDF5TensorImporter >":
        return _fast.HDF5TensorImporter_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::HDF5TensorImporter >":
        r"""
        Create instance
        :type filename: string
        :param filename: HDF5 file to read
        :type datasetName: string
        :param datasetName: Name of dataset in HDF5 file to import
        :rtype: :py:class:`HDF5TensorImporter`
        :return: instance
        """
        return _fast.HDF5TensorImporter_create(*args, **kwargs)

    def setDatasetName(self, datasetName: "std::string") -> "void":
        return _fast.HDF5TensorImporter_setDatasetName(self, datasetName)

    def loadAttributes(self) -> "void":
        return _fast.HDF5TensorImporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_HDF5TensorImporter

# Register HDF5TensorImporter in _fast:
_fast.HDF5TensorImporter_swigregister(HDF5TensorImporter)

def HDF5TensorImporter_New() -> "std::shared_ptr< fast::HDF5TensorImporter >":
    return _fast.HDF5TensorImporter_New()

def HDF5TensorImporter_getStaticNameOfClass() -> "std::string":
    return _fast.HDF5TensorImporter_getStaticNameOfClass()

def HDF5TensorImporter_create(*args, **kwargs) -> "std::shared_ptr< fast::HDF5TensorImporter >":
    r"""
    Create instance
    :type filename: string
    :param filename: HDF5 file to read
    :type datasetName: string
    :param datasetName: Name of dataset in HDF5 file to import
    :rtype: :py:class:`HDF5TensorImporter`
    :return: instance
    """
    return _fast.HDF5TensorImporter_create(*args, **kwargs)

class Exporter(ProcessObject):
    r"""
    Abstract base class for exporters

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fast.delete_Exporter

# Register Exporter in _fast:
_fast.Exporter_swigregister(Exporter)

class FileExporter(Exporter):
    r"""Abstract class for file exporters"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setFilename(self, filename: "std::string") -> "void":
        return _fast.FileExporter_setFilename(self, filename)

    def loadAttributes(self) -> "void":
        return _fast.FileExporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_FileExporter

# Register FileExporter in _fast:
_fast.FileExporter_swigregister(FileExporter)

class MetaImageExporter(FileExporter):
    r"""
    Export an Image to disk with the metaimage format (.mhd/.raw)

    This exporter writes 2D and 3D images using the MetaImage format which are pairs of .mhd text files and .raw files
    containing raw pixel data.
    Supports compression (.zraw) using the zlib library.
    All meta data in the Image is stored in the .mhd text file.

    ### Input ports
    0: Image


    See also: MetaImageImporter, ImageFileExporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MetaImageExporter >":
        return _fast.MetaImageExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MetaImageExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MetaImageExporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::MetaImageExporter >":
        return _fast.MetaImageExporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string", compress: "bool"=False) -> "std::shared_ptr< fast::MetaImageExporter >":
        return _fast.MetaImageExporter_create(filename, compress)

    def setCompression(self, compress: "bool") -> "void":
        r"""
        Enable or disable lossless compression
        :type compress: boolean
        :param compress:
        """
        return _fast.MetaImageExporter_setCompression(self, compress)

    def enableCompression(self) -> "void":
        r"""Deprecated"""
        return _fast.MetaImageExporter_enableCompression(self)

    def disableCompression(self) -> "void":
        r"""Deprecated"""
        return _fast.MetaImageExporter_disableCompression(self)

    def setMetadata(self, key: "std::string", value: "std::string") -> "void":
        r"""
        Add additional meta data to the mhd file.
        This can also be added to the input image object.

        :type key: string
        :param key:
        :type value: string
        :param value:
        """
        return _fast.MetaImageExporter_setMetadata(self, key, value)
    __swig_destroy__ = _fast.delete_MetaImageExporter

# Register MetaImageExporter in _fast:
_fast.MetaImageExporter_swigregister(MetaImageExporter)

def MetaImageExporter_New() -> "std::shared_ptr< fast::MetaImageExporter >":
    return _fast.MetaImageExporter_New()

def MetaImageExporter_getStaticNameOfClass() -> "std::string":
    return _fast.MetaImageExporter_getStaticNameOfClass()

def MetaImageExporter_create(filename: "std::string", compress: "bool"=False) -> "std::shared_ptr< fast::MetaImageExporter >":
    return _fast.MetaImageExporter_create(filename, compress)

class ImageFileExporter(FileExporter):
    r"""
    Write image to a file with various formats

    This exporter will look at the file extension and determine which image exporter should be used to read the file.
    - .jpg, .jpeg, .png, .bmp, .gif -> ImageExporter
    - .mhd -> MetaImageExporter

    ### Input ports
    0: Image


    See also: ImageFileImporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageFileExporter >":
        return _fast.ImageFileExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageFileExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageFileExporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageFileExporter >":
        return _fast.ImageFileExporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string", compress: "bool"=False, quality: "int"=90, resampleIfNeeded: "bool"=True) -> "std::shared_ptr< fast::ImageFileExporter >":
        r"""
        Create instance

        :type filename: string
        :param filename: Filename to export image to
        :type compress: boolean
        :param compress: Use lossless compression if possible (.mhd/.zraw)
        :type quality: int
        :param quality: When lossy compression is used like JPEG or JPEGXL, this parameter controls the quality vs size.
                 100 = best, 0 = worst.
        :type resampleIfNeeded: boolean
        :param resampleIfNeeded: If image is not isotropic and target format is standard image (jpg,gif,bmp etc),
                 image will be resampled first to be isotropic.
        :rtype: :py:class:`ImageFileExporter`
        :return: instance
        """
        return _fast.ImageFileExporter_create(filename, compress, quality, resampleIfNeeded)

    def setCompression(self, compress: "bool") -> "void":
        return _fast.ImageFileExporter_setCompression(self, compress)

    def setResampleIfNeeded(self, resample: "bool") -> "void":
        return _fast.ImageFileExporter_setResampleIfNeeded(self, resample)

    def setQuality(self, quality: "int") -> "void":
        return _fast.ImageFileExporter_setQuality(self, quality)
    __swig_destroy__ = _fast.delete_ImageFileExporter

# Register ImageFileExporter in _fast:
_fast.ImageFileExporter_swigregister(ImageFileExporter)

def ImageFileExporter_New() -> "std::shared_ptr< fast::ImageFileExporter >":
    return _fast.ImageFileExporter_New()

def ImageFileExporter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageFileExporter_getStaticNameOfClass()

def ImageFileExporter_create(filename: "std::string", compress: "bool"=False, quality: "int"=90, resampleIfNeeded: "bool"=True) -> "std::shared_ptr< fast::ImageFileExporter >":
    r"""
    Create instance

    :type filename: string
    :param filename: Filename to export image to
    :type compress: boolean
    :param compress: Use lossless compression if possible (.mhd/.zraw)
    :type quality: int
    :param quality: When lossy compression is used like JPEG or JPEGXL, this parameter controls the quality vs size.
             100 = best, 0 = worst.
    :type resampleIfNeeded: boolean
    :param resampleIfNeeded: If image is not isotropic and target format is standard image (jpg,gif,bmp etc),
             image will be resampled first to be isotropic.
    :rtype: :py:class:`ImageFileExporter`
    :return: instance
    """
    return _fast.ImageFileExporter_create(filename, compress, quality, resampleIfNeeded)

class StreamToFileExporter(ProcessObject):
    r"""
    Write a stream of Mesh or Image data as a sequence of files.

    ### Input ports
    - 0: Image or Mesh

    TODO: Supports more data types and formats
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::StreamToFileExporter >":
        return _fast.StreamToFileExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.StreamToFileExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.StreamToFileExporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::StreamToFileExporter >":
        return _fast.StreamToFileExporter_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::StreamToFileExporter >":
        r"""
        Create instance
        :type path: string
        :param path: Path to folder to store recordings/streams
        :type recordingFolderName: string
        :param recordingFolderName: Name of subfolder to store recordings/files in.
                 If not specified a folder with date and time will be used
        :rtype: :py:class:`StreamToFileExporter`
        :return: instance
        """
        return _fast.StreamToFileExporter_create(*args, **kwargs)

    def setPath(self, path: "std::string") -> "void":
        return _fast.StreamToFileExporter_setPath(self, path)

    def setRecordingFolderName(self, folder: "std::string") -> "void":
        return _fast.StreamToFileExporter_setRecordingFolderName(self, folder)

    def setFrameFilename(self, name: "std::string") -> "void":
        return _fast.StreamToFileExporter_setFrameFilename(self, name)

    def setEnabled(self, enabled: "bool") -> "void":
        return _fast.StreamToFileExporter_setEnabled(self, enabled)

    def setFrameLimit(self, limit: "uint64_t") -> "void":
        return _fast.StreamToFileExporter_setFrameLimit(self, limit)

    def getFrameCounter(self) -> "uint64_t":
        return _fast.StreamToFileExporter_getFrameCounter(self)

    def getCurrentDestinationFolder(self) -> "std::string":
        return _fast.StreamToFileExporter_getCurrentDestinationFolder(self)

    def getRecordingDuration(self) -> "float":
        return _fast.StreamToFileExporter_getRecordingDuration(self)

    def reset(self) -> "void":
        return _fast.StreamToFileExporter_reset(self)

    def isEnabled(self) -> "bool":
        return _fast.StreamToFileExporter_isEnabled(self)
    __swig_destroy__ = _fast.delete_StreamToFileExporter

# Register StreamToFileExporter in _fast:
_fast.StreamToFileExporter_swigregister(StreamToFileExporter)

def StreamToFileExporter_New() -> "std::shared_ptr< fast::StreamToFileExporter >":
    return _fast.StreamToFileExporter_New()

def StreamToFileExporter_getStaticNameOfClass() -> "std::string":
    return _fast.StreamToFileExporter_getStaticNameOfClass()

def StreamToFileExporter_create(*args, **kwargs) -> "std::shared_ptr< fast::StreamToFileExporter >":
    r"""
    Create instance
    :type path: string
    :param path: Path to folder to store recordings/streams
    :type recordingFolderName: string
    :param recordingFolderName: Name of subfolder to store recordings/files in.
             If not specified a folder with date and time will be used
    :rtype: :py:class:`StreamToFileExporter`
    :return: instance
    """
    return _fast.StreamToFileExporter_create(*args, **kwargs)

class VTKMeshFileExporter(FileExporter):
    r"""
    Write Mesh to file using the VTK polydata format

    ### Input ports
    - 0: Mesh

    See also: VTKMeshFileImporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VTKMeshFileExporter >":
        return _fast.VTKMeshFileExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VTKMeshFileExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VTKMeshFileExporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::VTKMeshFileExporter >":
        return _fast.VTKMeshFileExporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string", writeNormals: "bool"=False, writeColors: "bool"=False) -> "std::shared_ptr< fast::VTKMeshFileExporter >":
        return _fast.VTKMeshFileExporter_create(filename, writeNormals, writeColors)

    def setWriteNormals(self, writeNormals: "bool") -> "void":
        return _fast.VTKMeshFileExporter_setWriteNormals(self, writeNormals)

    def setWriteColors(self, writeColors: "bool") -> "void":
        return _fast.VTKMeshFileExporter_setWriteColors(self, writeColors)
    __swig_destroy__ = _fast.delete_VTKMeshFileExporter

# Register VTKMeshFileExporter in _fast:
_fast.VTKMeshFileExporter_swigregister(VTKMeshFileExporter)

def VTKMeshFileExporter_New() -> "std::shared_ptr< fast::VTKMeshFileExporter >":
    return _fast.VTKMeshFileExporter_New()

def VTKMeshFileExporter_getStaticNameOfClass() -> "std::string":
    return _fast.VTKMeshFileExporter_getStaticNameOfClass()

def VTKMeshFileExporter_create(filename: "std::string", writeNormals: "bool"=False, writeColors: "bool"=False) -> "std::shared_ptr< fast::VTKMeshFileExporter >":
    return _fast.VTKMeshFileExporter_create(filename, writeNormals, writeColors)

class ImageExporter(FileExporter):
    r"""
    Write an Image to a file using image format such as JPG/PNG/BMP/GIF

    This exporter uses Qt 5 to write an Image to file using common image formats.
    Check out [Qt 5 webpage for more details on formats supported](https://doc.qt.io/qt-5/qimage.html#reading-and-writing-image-files)

    ### Input ports
    0: Image


    See also: ImageImporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageExporter >":
        return _fast.ImageExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageExporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageExporter >":
        return _fast.ImageExporter_connect(self, *args)

    @staticmethod
    def create(filename: "std::string", quality: "int"=90, resampleIfNeeded: "bool"=True) -> "std::shared_ptr< fast::ImageExporter >":
        r"""
        Create instance
        :type filename: string
        :param filename:
        :type quality: int
        :param quality: When lossy compression is used like JPEG or JPEGXL, this parameter controls the quality vs size.
                 100 = best, 0 = worst.
        :type resampleIfNeeded: boolean
        :param resampleIfNeeded:
        :rtype: :py:class:`ImageExporter`
        :return: Instance
        """
        return _fast.ImageExporter_create(filename, quality, resampleIfNeeded)

    def setResampleIfNeeded(self, resample: "bool") -> "void":
        return _fast.ImageExporter_setResampleIfNeeded(self, resample)

    def setQuality(self, quality: "int") -> "void":
        return _fast.ImageExporter_setQuality(self, quality)

    def loadAttributes(self) -> "void":
        return _fast.ImageExporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImageExporter

# Register ImageExporter in _fast:
_fast.ImageExporter_swigregister(ImageExporter)

def ImageExporter_New() -> "std::shared_ptr< fast::ImageExporter >":
    return _fast.ImageExporter_New()

def ImageExporter_getStaticNameOfClass() -> "std::string":
    return _fast.ImageExporter_getStaticNameOfClass()

def ImageExporter_create(filename: "std::string", quality: "int"=90, resampleIfNeeded: "bool"=True) -> "std::shared_ptr< fast::ImageExporter >":
    r"""
    Create instance
    :type filename: string
    :param filename:
    :type quality: int
    :param quality: When lossy compression is used like JPEG or JPEGXL, this parameter controls the quality vs size.
             100 = best, 0 = worst.
    :type resampleIfNeeded: boolean
    :param resampleIfNeeded:
    :rtype: :py:class:`ImageExporter`
    :return: Instance
    """
    return _fast.ImageExporter_create(filename, quality, resampleIfNeeded)

class HDF5TensorExporter(FileExporter):
    r"""
    Write a Tensor to a HDF5 file

    Uses the HDF5 C++ library to write a Tensor to a HDF5 file

    ### Input ports
    - 0: Tensor


    See also: HDF5TensorImporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::HDF5TensorExporter >":
        return _fast.HDF5TensorExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.HDF5TensorExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.HDF5TensorExporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::HDF5TensorExporter >":
        return _fast.HDF5TensorExporter_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::HDF5TensorExporter >":
        r"""
        Create instance
        :type filename: string
        :param filename: Filename to open
        :type datasetName: string
        :param datasetName: Dataset in HDF file to open. Default is "tensor"
        :rtype: :py:class:`HDF5TensorExporter`
        :return: instance
        """
        return _fast.HDF5TensorExporter_create(*args, **kwargs)

    def setDatasetName(self, name: "std::string") -> "void":
        return _fast.HDF5TensorExporter_setDatasetName(self, name)

    def loadAttributes(self) -> "void":
        return _fast.HDF5TensorExporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_HDF5TensorExporter

# Register HDF5TensorExporter in _fast:
_fast.HDF5TensorExporter_swigregister(HDF5TensorExporter)

def HDF5TensorExporter_New() -> "std::shared_ptr< fast::HDF5TensorExporter >":
    return _fast.HDF5TensorExporter_New()

def HDF5TensorExporter_getStaticNameOfClass() -> "std::string":
    return _fast.HDF5TensorExporter_getStaticNameOfClass()

def HDF5TensorExporter_create(*args, **kwargs) -> "std::shared_ptr< fast::HDF5TensorExporter >":
    r"""
    Create instance
    :type filename: string
    :param filename: Filename to open
    :type datasetName: string
    :param datasetName: Dataset in HDF file to open. Default is "tensor"
    :rtype: :py:class:`HDF5TensorExporter`
    :return: instance
    """
    return _fast.HDF5TensorExporter_create(*args, **kwargs)

class ImagePyramidPatchExporter(Exporter):
    r"""
    Exports an ImagePyramid to disk as a large set of image patches.
    Each patch is stored as a PNG image with the file name indicating its position and size.
    This exporter can handle both an ImagePyramid input and a stream of image patches.

    ### Inputs
    - 0: ImagePyramid


    See also: ImagePyramidPatchImporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImagePyramidPatchExporter >":
        return _fast.ImagePyramidPatchExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImagePyramidPatchExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImagePyramidPatchExporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImagePyramidPatchExporter >":
        return _fast.ImagePyramidPatchExporter_connect(self, *args)

    @staticmethod
    def create(path: "std::string", level: "uint"=0, width: "uint"=512, height: "uint"=512) -> "std::shared_ptr< fast::ImagePyramidPatchExporter >":
        r"""
        Create instance
        :type path: string
        :param path: Path to a directory to export patches to
        :type level: int
        :param level: Image pyramid level to extract patches from
        :type width: int
        :param width: Width of patch
        :type height: int
        :param height: Height of patch
        :rtype: :py:class:`ImagePyramidPatchExporter`
        :return: instance
        """
        return _fast.ImagePyramidPatchExporter_create(path, level, width, height)

    def setPath(self, path: "std::string") -> "void":
        r"""
        Path to the folder to put all tiles in. If folder does not exist, it will be created.
        :type path: string
        :param path:
        """
        return _fast.ImagePyramidPatchExporter_setPath(self, path)

    def setPatchSize(self, width: "uint", height: "uint") -> "void":
        return _fast.ImagePyramidPatchExporter_setPatchSize(self, width, height)

    def setLevel(self, level: "uint") -> "void":
        r"""
        Which level in the image pyramid to export patches from. Default is 0.
        This is only used if input is an image pyramid.

        :type level: int
        :param level:
        """
        return _fast.ImagePyramidPatchExporter_setLevel(self, level)

    def loadAttributes(self) -> "void":
        return _fast.ImagePyramidPatchExporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImagePyramidPatchExporter

# Register ImagePyramidPatchExporter in _fast:
_fast.ImagePyramidPatchExporter_swigregister(ImagePyramidPatchExporter)

def ImagePyramidPatchExporter_New() -> "std::shared_ptr< fast::ImagePyramidPatchExporter >":
    return _fast.ImagePyramidPatchExporter_New()

def ImagePyramidPatchExporter_getStaticNameOfClass() -> "std::string":
    return _fast.ImagePyramidPatchExporter_getStaticNameOfClass()

def ImagePyramidPatchExporter_create(path: "std::string", level: "uint"=0, width: "uint"=512, height: "uint"=512) -> "std::shared_ptr< fast::ImagePyramidPatchExporter >":
    r"""
    Create instance
    :type path: string
    :param path: Path to a directory to export patches to
    :type level: int
    :param level: Image pyramid level to extract patches from
    :type width: int
    :param width: Width of patch
    :type height: int
    :param height: Height of patch
    :rtype: :py:class:`ImagePyramidPatchExporter`
    :return: instance
    """
    return _fast.ImagePyramidPatchExporter_create(path, level, width, height)

class TIFFImagePyramidExporter(FileExporter):
    r"""
    Export an ImagePyramid to disk in the tiled pyramid TIFF format.


    See also: TIFFImagePyramidImporter
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TIFFImagePyramidExporter >":
        return _fast.TIFFImagePyramidExporter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TIFFImagePyramidExporter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TIFFImagePyramidExporter_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TIFFImagePyramidExporter >":
        return _fast.TIFFImagePyramidExporter_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::TIFFImagePyramidExporter >":
        return _fast.TIFFImagePyramidExporter_create(*args, **kwargs)

    def setCompression(self, compression: "fast::ImageCompression") -> "void":
        return _fast.TIFFImagePyramidExporter_setCompression(self, compression)

    def loadAttributes(self) -> "void":
        return _fast.TIFFImagePyramidExporter_loadAttributes(self)
    __swig_destroy__ = _fast.delete_TIFFImagePyramidExporter

# Register TIFFImagePyramidExporter in _fast:
_fast.TIFFImagePyramidExporter_swigregister(TIFFImagePyramidExporter)

def TIFFImagePyramidExporter_New() -> "std::shared_ptr< fast::TIFFImagePyramidExporter >":
    return _fast.TIFFImagePyramidExporter_New()

def TIFFImagePyramidExporter_getStaticNameOfClass() -> "std::string":
    return _fast.TIFFImagePyramidExporter_getStaticNameOfClass()

def TIFFImagePyramidExporter_create(*args, **kwargs) -> "std::shared_ptr< fast::TIFFImagePyramidExporter >":
    return _fast.TIFFImagePyramidExporter_create(*args, **kwargs)

class Renderer(ProcessObject):
    r"""
    Abstract base class for 'renderers'

    Renderers are process objects which can visualize data in a View, typically using OpenGL.
    They should inherit from this class.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def draw(self, perspectiveMatrix: "Matrix4f", viewingMatrix: "Matrix4f", zNear: "float", zFar: "float", mode2D: "bool", viewWidth: "int", viewHeight: "int") -> "void":
        return _fast.Renderer_draw(self, perspectiveMatrix, viewingMatrix, zNear, zFar, mode2D, viewWidth, viewHeight)

    def postDraw(self) -> "void":
        return _fast.Renderer_postDraw(self)

    def addInputConnection(self, port: "fast::DataChannel::pointer") -> "uint":
        r"""
        Adds a new input connection
        :type port: :py:class:`DataChannel`
        :param port:
        :rtype: int
        :return: the input nr of the new connection
        """
        return _fast.Renderer_addInputConnection(self, port)

    def addInputData(self, data: "fast::DataObject::pointer") -> "uint":
        r"""
        Adds a new input connection to a specific data object
        :type data: :py:class:`DataObject`
        :param data:
        :rtype: int
        :return: the input nr of the new connection
        """
        return _fast.Renderer_addInputData(self, data)

    def getBoundingBox(self, transform: "bool"=True) -> "fast::DataBoundingBox":
        return _fast.Renderer_getBoundingBox(self, transform)

    def stopPipeline(self) -> "void":
        return _fast.Renderer_stopPipeline(self)

    def reset(self) -> "void":
        return _fast.Renderer_reset(self)

    def setDisabled(self, disabled: "bool") -> "void":
        r"""
        Set renderer to disabled or enabled. A disabled renderer will not draw.
        :type disabled: boolean
        :param disabled:
        """
        return _fast.Renderer_setDisabled(self, disabled)

    def isDisabled(self) -> "bool":
        r"""
        Get whether this renderer is disabled or not
        :rtype: boolean
        :return: 
        """
        return _fast.Renderer_isDisabled(self)

    def setView(self, view: "View") -> "void":
        return _fast.Renderer_setView(self, view)

    def is2DOnly(self) -> "bool":
        return _fast.Renderer_is2DOnly(self)

    def is3DOnly(self) -> "bool":
        return _fast.Renderer_is3DOnly(self)

    def loadAttributes(self) -> "void":
        return _fast.Renderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_Renderer

# Register Renderer in _fast:
_fast.Renderer_swigregister(Renderer)

class View(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def addRenderer(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.View_addRenderer(self, renderer)

    def removeRenderer(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.View_removeRenderer(self, renderer)

    def removeAllRenderers(self) -> "void":
        return _fast.View_removeAllRenderers(self)

    def keyPressEvent(self, event: "QKeyEvent *") -> "void":
        return _fast.View_keyPressEvent(self, event)

    def mouseMoveEvent(self, event: "QMouseEvent *") -> "void":
        return _fast.View_mouseMoveEvent(self, event)

    def mousePressEvent(self, event: "QMouseEvent *") -> "void":
        return _fast.View_mousePressEvent(self, event)

    def mouseReleaseEvent(self, event: "QMouseEvent *") -> "void":
        return _fast.View_mouseReleaseEvent(self, event)

    def wheelEvent(self, event: "QWheelEvent *") -> "void":
        return _fast.View_wheelEvent(self, event)

    def changeEvent(self, event: "QEvent *") -> "void":
        return _fast.View_changeEvent(self, event)

    def eventFilter(self, object: "QObject *", event: "QEvent *") -> "bool":
        return _fast.View_eventFilter(self, object, event)

    def setMaximumFramerate(self, framerate: "unsigned int") -> "void":
        return _fast.View_setMaximumFramerate(self, framerate)

    def setCameraInputConnection(self, port: "fast::DataChannel::pointer") -> "void":
        return _fast.View_setCameraInputConnection(self, port)

    def set2DMode(self) -> "void":
        return _fast.View_set2DMode(self)

    def set3DMode(self) -> "void":
        return _fast.View_set3DMode(self)

    def setLookAt(self, cameraPosition: "Vector3f", targetPosition: "Vector3f", cameraUpVector: "Vector3f", zNear: "float"=0.1, zFar: "float"=1000) -> "void":
        return _fast.View_setLookAt(self, cameraPosition, targetPosition, cameraUpVector, zNear, zFar)

    def quit(self) -> "void":
        return _fast.View_quit(self)

    def reinitialize(self) -> "void":
        return _fast.View_reinitialize(self)

    def hasQuit(self) -> "bool":
        return _fast.View_hasQuit(self)
    __swig_destroy__ = _fast.delete_View

    def recalculateCamera(self) -> "void":
        return _fast.View_recalculateCamera(self)

    def setBackgroundColor(self, color: "Color") -> "void":
        return _fast.View_setBackgroundColor(self, color)

    def setAutoUpdateCamera(self, autoUpdate: "bool") -> "void":
        return _fast.View_setAutoUpdateCamera(self, autoUpdate)

    def getOrthoProjectionParameters(self) -> "Vector4f":
        return _fast.View_getOrthoProjectionParameters(self)

    def getNameOfClass(self) -> "std::string":
        return _fast.View_getNameOfClass(self)

    def __init__(self):
        _fast.View_swiginit(self, _fast.new_View())

    def getRenderers(self) -> "std::vector< fast::Renderer::pointer,std::allocator< fast::Renderer::pointer > >":
        return _fast.View_getRenderers(self)

    @staticmethod
    def getGLFormat() -> "QGLFormat":
        return _fast.View_getGLFormat()

    def getViewMatrix(self) -> "Matrix4f":
        return _fast.View_getViewMatrix(self)

    def getPerspectiveMatrix(self) -> "Matrix4f":
        return _fast.View_getPerspectiveMatrix(self)

    def loadAttributes(self) -> "void":
        return _fast.View_loadAttributes(self)

    def setZoom(self, zoom: "float") -> "void":
        r"""
        Function for setting the zoom level of the view. Level 1 is no zooming.
                   Level 0.5 makes images in the view half its size. Level 2 makes images in the view double in size.
        """
        return _fast.View_setZoom(self, zoom)

    def asQGLWidget(self) -> "QGLWidget *":
        return _fast.View_asQGLWidget(self)

    def setScalebar(self, enable: "float") -> "void":
        r"""
        Enable or disable scalebar
        :type enable: float
        :param enable:
        """
        return _fast.View_setScalebar(self, enable)

# Register View in _fast:
_fast.View_swigregister(View)

def View_getGLFormat() -> "QGLFormat":
    return _fast.View_getGLFormat()

WidgetPosition_BOTTOM = _fast.WidgetPosition_BOTTOM
WidgetPosition_TOP = _fast.WidgetPosition_TOP
WidgetPosition_LEFT = _fast.WidgetPosition_LEFT
WidgetPosition_RIGHT = _fast.WidgetPosition_RIGHT
class Window(AttributeObject):
    r"""Abstract base class for windows"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def initializeQtApp() -> "void":
        return _fast.Window_initializeQtApp()

    @staticmethod
    def getMainGLContext() -> "QGLContext *":
        return _fast.Window_getMainGLContext()

    @staticmethod
    def getSecondaryGLContext() -> "QGLContext *":
        return _fast.Window_getSecondaryGLContext()

    @staticmethod
    def setMainGLContext(context: "QGLContext *") -> "void":
        return _fast.Window_setMainGLContext(context)

    def setTimeout(self, milliseconds: "unsigned int") -> "void":
        r"""Makes the window close after a specific number of ms"""
        return _fast.Window_setTimeout(self, milliseconds)
    __swig_destroy__ = _fast.delete_Window

    def start(self) -> "void":
        r"""Starts an update loop on all renderers attached to each view in this window."""
        return _fast.Window_start(self)

    def run(self) -> "void":
        r"""Opens window and starts pipeline on all renderers"""
        return _fast.Window_run(self)

    def setWidth(self, width: "uint") -> "void":
        return _fast.Window_setWidth(self, width)

    def setHeight(self, height: "uint") -> "void":
        return _fast.Window_setHeight(self, height)

    def setSize(self, width: "uint", height: "uint") -> "void":
        return _fast.Window_setSize(self, width, height)

    def enableMaximized(self) -> "void":
        return _fast.Window_enableMaximized(self)

    def disableMaximized(self) -> "void":
        return _fast.Window_disableMaximized(self)

    def enableFullscreen(self) -> "void":
        return _fast.Window_enableFullscreen(self)

    def disableFullscreen(self) -> "void":
        return _fast.Window_disableFullscreen(self)

    def setTitle(self, arg2: "std::string") -> "void":
        return _fast.Window_setTitle(self, arg2)

    def clearViews(self) -> "void":
        return _fast.Window_clearViews(self)

    def getViews(self) -> "std::vector< fast::View *,std::allocator< fast::View * > >":
        return _fast.Window_getViews(self)

    def getView(self, i: "uint") -> "fast::View *":
        return _fast.Window_getView(self, i)

    def addView(self, view: "View") -> "void":
        return _fast.Window_addView(self, view)

    @staticmethod
    def cleanup() -> "void":
        return _fast.Window_cleanup()

    def getScreenWidth(self) -> "int":
        r"""
        Get screen width in pixels
        :rtype: int
        :return: width in pixels
        """
        return _fast.Window_getScreenWidth(self)

    def getScreenHeight(self) -> "int":
        r"""
        Get screen height in pixels
        :rtype: int
        :return: height in pixels
        """
        return _fast.Window_getScreenHeight(self)

    def getScalingFactor(self) -> "float":
        r"""
        Get GUI scaling factor
        :rtype: float
        :return: 
        """
        return _fast.Window_getScalingFactor(self)

    def getWidget(self) -> "QWidget *":
        return _fast.Window_getWidget(self)

    def addProcessObject(self, po: "std::shared_ptr< fast::ProcessObject >") -> "void":
        r"""Add a process object to be updated by the computation thread."""
        return _fast.Window_addProcessObject(self, po)

    def getProcessObjects(self) -> "std::vector< std::shared_ptr< fast::ProcessObject >,std::allocator< std::shared_ptr< fast::ProcessObject > > >":
        r"""Get process objects to be updated by the computation thread."""
        return _fast.Window_getProcessObjects(self)

    def clearProcessObjects(self) -> "void":
        r"""Clear the process objects to be updated by the computation thread."""
        return _fast.Window_clearProcessObjects(self)

    def set2DMode(self) -> "void":
        r"""Set 2D mode for all views in this window"""
        return _fast.Window_set2DMode(self)

    def set3DMode(self) -> "void":
        r"""Set 3D mode for all views in this window"""
        return _fast.Window_set3DMode(self)

    def connect(self, *args) -> "std::shared_ptr< fast::Window >":
        return _fast.Window_connect(self, *args)

    def getNameOfClass(self) -> "std::string":
        return _fast.Window_getNameOfClass(self)

    def stop(self) -> "void":
        return _fast.Window_stop(self)

# Register Window in _fast:
_fast.Window_swigregister(Window)

def Window_initializeQtApp() -> "void":
    return _fast.Window_initializeQtApp()

def Window_getMainGLContext() -> "QGLContext *":
    return _fast.Window_getMainGLContext()

def Window_getSecondaryGLContext() -> "QGLContext *":
    return _fast.Window_getSecondaryGLContext()

def Window_setMainGLContext(context: "QGLContext *") -> "void":
    return _fast.Window_setMainGLContext(context)

def Window_cleanup() -> "void":
    return _fast.Window_cleanup()

class SimpleWindow(Window):
    r"""A Window with only 1 View"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SimpleWindow >":
        return _fast.SimpleWindow_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SimpleWindow_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SimpleWindow_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::SimpleWindow >":
        r"""
        Create a SimpleWindow object

        Args:
        :type mode2D: boolean
        :param mode2D: 2D or 3D mode
        :type bgcolor: :py:class:`Color`
        :param bgcolor: Background color
        :type width: int
        :param width: in pixels
        :type height: int
        :param height: in pixels
        :rtype: :py:class:`SimpleWindow`
        :return: shared ptr of new SimpleWindow
        """
        return _fast.SimpleWindow_create(*args, **kwargs)

    def addRenderer(self, renderer: "std::shared_ptr< fast::Renderer >") -> "void":
        return _fast.SimpleWindow_addRenderer(self, renderer)

    def addWidget(self, widget: "QWidget *") -> "void":
        return _fast.SimpleWindow_addWidget(self, widget)

    def removeAllRenderers(self) -> "void":
        return _fast.SimpleWindow_removeAllRenderers(self)

    def setMaximumFramerate(self, framerate: "unsigned int") -> "void":
        return _fast.SimpleWindow_setMaximumFramerate(self, framerate)

    def getView(self) -> "fast::View *":
        return _fast.SimpleWindow_getView(self)
    __swig_destroy__ = _fast.delete_SimpleWindow

    def connect(self, *args) -> "std::shared_ptr< fast::SimpleWindow >":
        return _fast.SimpleWindow_connect(self, *args)

# Register SimpleWindow in _fast:
_fast.SimpleWindow_swigregister(SimpleWindow)

def SimpleWindow_New() -> "std::shared_ptr< fast::SimpleWindow >":
    return _fast.SimpleWindow_New()

def SimpleWindow_getStaticNameOfClass() -> "std::string":
    return _fast.SimpleWindow_getStaticNameOfClass()

def SimpleWindow_create(*args, **kwargs) -> "std::shared_ptr< fast::SimpleWindow >":
    r"""
    Create a SimpleWindow object

    Args:
    :type mode2D: boolean
    :param mode2D: 2D or 3D mode
    :type bgcolor: :py:class:`Color`
    :param bgcolor: Background color
    :type width: int
    :param width: in pixels
    :type height: int
    :param height: in pixels
    :rtype: :py:class:`SimpleWindow`
    :return: shared ptr of new SimpleWindow
    """
    return _fast.SimpleWindow_create(*args, **kwargs)

class SimpleWindow2D(SimpleWindow):
    r"""A Window with only 1 View in 2D mode"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.SimpleWindow2D_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SimpleWindow2D_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::SimpleWindow2D >":
        r"""
        Create a SimpleWindow 2D object

        Args:
        :type bgcolor: :py:class:`Color`
        :param bgcolor: Background color
        :type width: int
        :param width: in pixels
        :type height: int
        :param height: in pixels
        :rtype: :py:class:`SimpleWindow2D`
        :return: shared ptr of new SimpleWindow
        """
        return _fast.SimpleWindow2D_create(*args, **kwargs)
    __swig_destroy__ = _fast.delete_SimpleWindow2D

# Register SimpleWindow2D in _fast:
_fast.SimpleWindow2D_swigregister(SimpleWindow2D)

def SimpleWindow2D_getStaticNameOfClass() -> "std::string":
    return _fast.SimpleWindow2D_getStaticNameOfClass()

def SimpleWindow2D_create(*args, **kwargs) -> "std::shared_ptr< fast::SimpleWindow2D >":
    r"""
    Create a SimpleWindow 2D object

    Args:
    :type bgcolor: :py:class:`Color`
    :param bgcolor: Background color
    :type width: int
    :param width: in pixels
    :type height: int
    :param height: in pixels
    :rtype: :py:class:`SimpleWindow2D`
    :return: shared ptr of new SimpleWindow
    """
    return _fast.SimpleWindow2D_create(*args, **kwargs)

class SimpleWindow3D(SimpleWindow):
    r"""A Window with only 1 View in 3D mode"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.SimpleWindow3D_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SimpleWindow3D_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::SimpleWindow3D >":
        r"""
        Create a SimpleWindow 3D object

        Args:
        :type bgcolor: :py:class:`Color`
        :param bgcolor: Background color
        :type width: int
        :param width: in pixels
        :type height: int
        :param height: in pixels
        :rtype: :py:class:`SimpleWindow3D`
        :return: shared ptr of new SimpleWindow
        """
        return _fast.SimpleWindow3D_create(*args, **kwargs)
    __swig_destroy__ = _fast.delete_SimpleWindow3D

# Register SimpleWindow3D in _fast:
_fast.SimpleWindow3D_swigregister(SimpleWindow3D)

def SimpleWindow3D_getStaticNameOfClass() -> "std::string":
    return _fast.SimpleWindow3D_getStaticNameOfClass()

def SimpleWindow3D_create(*args, **kwargs) -> "std::shared_ptr< fast::SimpleWindow3D >":
    r"""
    Create a SimpleWindow 3D object

    Args:
    :type bgcolor: :py:class:`Color`
    :param bgcolor: Background color
    :type width: int
    :param width: in pixels
    :type height: int
    :param height: in pixels
    :rtype: :py:class:`SimpleWindow3D`
    :return: shared ptr of new SimpleWindow
    """
    return _fast.SimpleWindow3D_create(*args, **kwargs)

class DualViewWindow(Window):
    r"""A Window with 2 views"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.DualViewWindow_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DualViewWindow_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::DualViewWindow >":
        r"""
        Create instance
        :type bgcolor: :py:class:`Color`
        :param bgcolor: background color for both views
        :type width: int
        :param width: Width of window, if 0 width is set automatically
        :type height: int
        :param height: Height of window, if 0 height is set automatically
        :type verticalMode: boolean
        :param verticalMode: Whether to display the two views vertically or horizontally
        :rtype: :py:class:`DualViewWindow`
        :return: instance
        """
        return _fast.DualViewWindow_create(*args, **kwargs)

    def addRendererToTopLeftView(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.DualViewWindow_addRendererToTopLeftView(self, renderer)

    def addRendererToBottomRightView(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.DualViewWindow_addRendererToBottomRightView(self, renderer)

    def addRendererToLeftView(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.DualViewWindow_addRendererToLeftView(self, renderer)

    def addRendererToRightView(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.DualViewWindow_addRendererToRightView(self, renderer)

    def addRendererToTopView(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.DualViewWindow_addRendererToTopView(self, renderer)

    def addRendererToBottomView(self, renderer: "fast::Renderer::pointer") -> "void":
        return _fast.DualViewWindow_addRendererToBottomView(self, renderer)

    def removeAllRenderers(self) -> "void":
        return _fast.DualViewWindow_removeAllRenderers(self)

    def getTopLeftView(self) -> "fast::View *":
        return _fast.DualViewWindow_getTopLeftView(self)

    def getBottomRightView(self) -> "fast::View *":
        return _fast.DualViewWindow_getBottomRightView(self)

    def setHorizontalMode(self) -> "void":
        return _fast.DualViewWindow_setHorizontalMode(self)

    def setVerticalMode(self) -> "void":
        return _fast.DualViewWindow_setVerticalMode(self)

    def setBackgroundColor(self, color: "Color") -> "void":
        return _fast.DualViewWindow_setBackgroundColor(self, color)

    def addWidget(self, widget: "QWidget *") -> "void":
        return _fast.DualViewWindow_addWidget(self, widget)
    __swig_destroy__ = _fast.delete_DualViewWindow

    def connectLeft(self, *args) -> "std::shared_ptr< fast::DualViewWindow >":
        return _fast.DualViewWindow_connectLeft(self, *args)

    def connectRight(self, *args) -> "std::shared_ptr< fast::DualViewWindow >":
        return _fast.DualViewWindow_connectRight(self, *args)

    def connectTop(self, *args) -> "std::shared_ptr< fast::DualViewWindow >":
        return _fast.DualViewWindow_connectTop(self, *args)

    def connectBottom(self, *args) -> "std::shared_ptr< fast::DualViewWindow >":
        return _fast.DualViewWindow_connectBottom(self, *args)

    def connect(self, *args) -> "std::shared_ptr< fast::Window >":
        return _fast.DualViewWindow_connect(self, *args)

# Register DualViewWindow in _fast:
_fast.DualViewWindow_swigregister(DualViewWindow)

def DualViewWindow_getStaticNameOfClass() -> "std::string":
    return _fast.DualViewWindow_getStaticNameOfClass()

def DualViewWindow_create(*args, **kwargs) -> "std::shared_ptr< fast::DualViewWindow >":
    r"""
    Create instance
    :type bgcolor: :py:class:`Color`
    :param bgcolor: background color for both views
    :type width: int
    :param width: Width of window, if 0 width is set automatically
    :type height: int
    :param height: Height of window, if 0 height is set automatically
    :type verticalMode: boolean
    :param verticalMode: Whether to display the two views vertically or horizontally
    :rtype: :py:class:`DualViewWindow`
    :return: instance
    """
    return _fast.DualViewWindow_create(*args, **kwargs)

class DualViewWindow2D(DualViewWindow):
    r"""A Window with 2 views in 2D mode"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.DualViewWindow2D_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DualViewWindow2D_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::DualViewWindow2D >":
        r"""
        Create a DualViewWindow 2D object

        Args:
        :type bgcolor: :py:class:`Color`
        :param bgcolor: Background color
        :type width: int
        :param width: in pixels
        :type height: int
        :param height: in pixels
        :rtype: :py:class:`DualViewWindow2D`
        :return: shared ptr of new SimpleWindow
        """
        return _fast.DualViewWindow2D_create(*args, **kwargs)
    __swig_destroy__ = _fast.delete_DualViewWindow2D

# Register DualViewWindow2D in _fast:
_fast.DualViewWindow2D_swigregister(DualViewWindow2D)

def DualViewWindow2D_getStaticNameOfClass() -> "std::string":
    return _fast.DualViewWindow2D_getStaticNameOfClass()

def DualViewWindow2D_create(*args, **kwargs) -> "std::shared_ptr< fast::DualViewWindow2D >":
    r"""
    Create a DualViewWindow 2D object

    Args:
    :type bgcolor: :py:class:`Color`
    :param bgcolor: Background color
    :type width: int
    :param width: in pixels
    :type height: int
    :param height: in pixels
    :rtype: :py:class:`DualViewWindow2D`
    :return: shared ptr of new SimpleWindow
    """
    return _fast.DualViewWindow2D_create(*args, **kwargs)

class DualViewWindow3D(DualViewWindow):
    r"""A Window with 2 views in 3D mode"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.DualViewWindow3D_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.DualViewWindow3D_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::DualViewWindow3D >":
        r"""
        Create a DualViewWindow 3D object

        Args:
        :type bgcolor: :py:class:`Color`
        :param bgcolor: Background color
        :type width: int
        :param width: in pixels
        :type height: int
        :param height: in pixels
        :rtype: :py:class:`DualViewWindow3D`
        :return: shared ptr of new SimpleWindow
        """
        return _fast.DualViewWindow3D_create(*args, **kwargs)
    __swig_destroy__ = _fast.delete_DualViewWindow3D

# Register DualViewWindow3D in _fast:
_fast.DualViewWindow3D_swigregister(DualViewWindow3D)

def DualViewWindow3D_getStaticNameOfClass() -> "std::string":
    return _fast.DualViewWindow3D_getStaticNameOfClass()

def DualViewWindow3D_create(*args, **kwargs) -> "std::shared_ptr< fast::DualViewWindow3D >":
    r"""
    Create a DualViewWindow 3D object

    Args:
    :type bgcolor: :py:class:`Color`
    :param bgcolor: Background color
    :type width: int
    :param width: in pixels
    :type height: int
    :param height: in pixels
    :rtype: :py:class:`DualViewWindow3D`
    :return: shared ptr of new SimpleWindow
    """
    return _fast.DualViewWindow3D_create(*args, **kwargs)

class MultiViewWindow(Window):
    r"""Window with multiple views"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.MultiViewWindow_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MultiViewWindow_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::MultiViewWindow >":
        return _fast.MultiViewWindow_create(*args, **kwargs)

    def addView(self, view: "View") -> "void":
        return _fast.MultiViewWindow_addView(self, view)

    def addRenderer(self, viewIndex: "int", renderer: "fast::Renderer::pointer") -> "void":
        return _fast.MultiViewWindow_addRenderer(self, viewIndex, renderer)

    def removeAllRenderers(self) -> "void":
        return _fast.MultiViewWindow_removeAllRenderers(self)

    def setHorizontalMode(self) -> "void":
        return _fast.MultiViewWindow_setHorizontalMode(self)

    def setVerticalMode(self) -> "void":
        return _fast.MultiViewWindow_setVerticalMode(self)

    def setBackgroundColor(self, color: "Color") -> "void":
        return _fast.MultiViewWindow_setBackgroundColor(self, color)

    def setNrOfViews(self, views: "int") -> "void":
        return _fast.MultiViewWindow_setNrOfViews(self, views)

    def start(self) -> "void":
        return _fast.MultiViewWindow_start(self)
    __swig_destroy__ = _fast.delete_MultiViewWindow

    def connect(self, *args) -> "std::shared_ptr< fast::MultiViewWindow >":
        return _fast.MultiViewWindow_connect(self, *args)

# Register MultiViewWindow in _fast:
_fast.MultiViewWindow_swigregister(MultiViewWindow)

def MultiViewWindow_getStaticNameOfClass() -> "std::string":
    return _fast.MultiViewWindow_getStaticNameOfClass()

def MultiViewWindow_create(*args, **kwargs) -> "std::shared_ptr< fast::MultiViewWindow >":
    return _fast.MultiViewWindow_create(*args, **kwargs)

class SlicerWindow(Window):
    r"""
    Window for showing slices of 3D data

    This window shows 3 views with slices of the volume data in three different directions (X, Y, Z).
    This windows features a slider for each view which controls which slice of the volume is being displayed.
    It also has a widget for controlling intensity window and level which is often needed for CT and MRI data.
    Use the SlicerWindow::connectImage and SlicerWindow::connectSegmentation methods to connect data to this window.
    The window will setup the appropriate renderers for you.

    TODO: Improve segmentation label rendering
    Support for image and segmentations with different sizes
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SlicerWindow_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::SlicerWindow >":
        r"""
        Create instance
        :type bgcolor: :py:class:`Color`
        :param bgcolor: Background color
        :type width: int
        :param width: Window width
        :type height: int
        :param height: Window height
        """
        return _fast.SlicerWindow_create(*args, **kwargs)

    def _connectImage(self, *args) -> "std::shared_ptr< fast::SlicerWindow >":
        r"""
        *Overload 1:*

        Connect an 3D image source to this window
        :type processObject: :py:class:`ProcessObject`
        :param processObject: Process object producing a 3D image
        :type level: float
        :param level: Intensity level
        :type window: float
        :param window: Intensity window
        :type outputPortID: int
        :param outputPortID: Output port id of process object

        |

        *Overload 2:*

        Connect a 3D image to this window
        :type image: :py:class:`Image`
        :param image: 3D image to connect
        :type level: float
        :param level: Intensity level
        :type window: float
        :param window: Intensity window
        """
        return _fast.SlicerWindow__connectImage(self, *args)

    def _connectSegmentation(self, *args) -> "std::shared_ptr< fast::SlicerWindow >":
        r"""
        *Overload 1:*

        Connect a 3D segmentation soruce to this window
        :type processObject: :py:class:`ProcessObject`
        :param processObject: Process object producing a 3D segmentation image
        :type colors: :py:class:`LabelColors`
        :param colors: Label colors
        :type opacity: float
        :param opacity: Segmentation overlay opacity
        :type borderOpacity: float
        :param borderOpacity: Segmentation overlay border opacity
        :type borderRadius: int
        :param borderRadius: How thick, in pixels, the border radius should be
        :type outputPortID: int
        :param outputPortID: Output port id of process object

        |

        *Overload 2:*

        Connect a 3D segmentation to this window
        :type image: :py:class:`Image`
        :param image: 3D segmentation image
        :type colors: :py:class:`LabelColors`
        :param colors: Label colors
        :type opacity: float
        :param opacity: Segmentation overlay opacity
        :type borderOpacity: float
        :param borderOpacity: Segmentation overlay border opacity
        :type borderRadius: int
        :param borderRadius: How thick, in pixels, the border radius should be
        """
        return _fast.SlicerWindow__connectSegmentation(self, *args)

    def setTextLabels(self, *args, **kwargs) -> "void":
        return _fast.SlicerWindow_setTextLabels(self, *args, **kwargs)

    def connect(self, *args) -> "std::shared_ptr< fast::Window >":
        return _fast.SlicerWindow_connect(self, *args)

    def getNameOfClass(self, *args) -> "std::string":
        return _fast.SlicerWindow_getNameOfClass(self, *args)

    def setBorderRadius(self, radius: "int") -> "void":
        return _fast.SlicerWindow_setBorderRadius(self, radius)

    def setOpacity(self, opacity: "float", borderOpacity: "float"=-1) -> "void":
        return _fast.SlicerWindow_setOpacity(self, opacity, borderOpacity)

    def setBorderOpacity(self, borderOpacity: "float") -> "void":
        return _fast.SlicerWindow_setBorderOpacity(self, borderOpacity)

    def getOpacity(self) -> "float":
        return _fast.SlicerWindow_getOpacity(self)

    def getBorderOpacity(self) -> "float":
        return _fast.SlicerWindow_getBorderOpacity(self)

    def getBorderRadius(self) -> "int":
        return _fast.SlicerWindow_getBorderRadius(self)

    def loadAttributes(self) -> "void":
        return _fast.SlicerWindow_loadAttributes(self)

    def connectImage(self, object, level: float = -1, window: float = -1, outputPort: int = 0) -> "std::shared_ptr< fast::SlicerWindow >":
        r"""
        Connect an 3D image source to this window.

        :type object: :py:class:`Object`
        :param object: Process object producing a 3D image or data object
        :type level: float
        :param level: Intensity level
        :type window: float
        :param window: Intensity window
        :type outputPortID: int
        :param outputPortID: Output port id of process object
        """
        if object.getNameOfClass() == "Image":
            return self._connectImage(object, level, window)
        else:
            return self._connectImage(object, level, window, outputPort)

    def connectSegmentation(self, object, colors: LabelColors = LabelColors(), opacity: float = 0.5, borderOpacity: float = -1.0, borderRadius: int = 1, outputPort: int = 0) -> "std::shared_ptr< fast::SlicerWindow >":
        r"""
        Connect an 3D segmentation source to this window.

        :type object: :py:class:`Object`
        :param object: Process object producing a 3D segmentation or data object
        :type colors: :py:class:`LabelColors`
        :param colors: Label colors
        :type opacity: float
        :param opacity: Segmentation overlay opacity
        :type borderOpacity: float
        :param borderOpacity: Segmentation overlay border opacity
        :type borderRadius: int
        :param borderRadius: How thick, in pixels, the border radius should be
        :type outputPortID: int
        :param outputPortID: Output port id of process object
        """
        if object.getNameOfClass() == "Image":
            return self._connectSegmentation(object, colors, opacity, borderOpacity, borderRadius)
        else:
            return self._connectSegmentation(object, colors, opacity, borderOpacity, borderRadius, outputPort)

    __swig_destroy__ = _fast.delete_SlicerWindow

# Register SlicerWindow in _fast:
_fast.SlicerWindow_swigregister(SlicerWindow)

def SlicerWindow_getStaticNameOfClass() -> "std::string":
    return _fast.SlicerWindow_getStaticNameOfClass()

def SlicerWindow_create(*args, **kwargs) -> "std::shared_ptr< fast::SlicerWindow >":
    r"""
    Create instance
    :type bgcolor: :py:class:`Color`
    :param bgcolor: Background color
    :type width: int
    :param width: Window width
    :type height: int
    :param height: Window height
    """
    return _fast.SlicerWindow_create(*args, **kwargs)

class LabelColorRenderer(Renderer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getColor(self, label: "int") -> "fast::Color":
        return _fast.LabelColorRenderer_getColor(self, label)

    def getColors(self) -> "fast::LabelColors":
        return _fast.LabelColorRenderer_getColors(self)

    def setColor(self, label: "int", color: "Color") -> "void":
        return _fast.LabelColorRenderer_setColor(self, label, color)

    def setColors(self, colors: "LabelColors") -> "void":
        return _fast.LabelColorRenderer_setColors(self, colors)
    __swig_destroy__ = _fast.delete_LabelColorRenderer

# Register LabelColorRenderer in _fast:
_fast.LabelColorRenderer_swigregister(LabelColorRenderer)

class ComputationThread(Object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.ComputationThread_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ComputationThread_getStaticNameOfClass()

    @staticmethod
    def create() -> "std::shared_ptr< fast::ComputationThread >":
        return _fast.ComputationThread_create()
    __swig_destroy__ = _fast.delete_ComputationThread

    def isRunning(self) -> "bool":
        return _fast.ComputationThread_isRunning(self)

    def stop(self) -> "void":
        r"""
        Stop this thread and block until it is done.
        To stop without blocking use ComputationThread::stopWithoutBlocking().
        """
        return _fast.ComputationThread_stop(self)

    def stopWithoutBlocking(self) -> "void":
        r"""
        Stop this thread, but return immediately.
        This function does not wait until the thread is finished. Use ComputationThread::stop() for that.
        """
        return _fast.ComputationThread_stopWithoutBlocking(self)

    def addView(self, view: "View") -> "void":
        return _fast.ComputationThread_addView(self, view)

    def clearViews(self) -> "void":
        return _fast.ComputationThread_clearViews(self)

    def getView(self, index: "int") -> "fast::View *":
        return _fast.ComputationThread_getView(self, index)

    def getViews(self) -> "std::vector< fast::View *,std::allocator< fast::View * > >":
        return _fast.ComputationThread_getViews(self)

    def addProcessObject(self, po: "std::shared_ptr< fast::ProcessObject >") -> "void":
        return _fast.ComputationThread_addProcessObject(self, po)

    def clearProcessObjects(self) -> "void":
        return _fast.ComputationThread_clearProcessObjects(self)

    def getProcessObjects(self, *args) -> "std::shared_ptr< fast::ProcessObject >":
        return _fast.ComputationThread_getProcessObjects(self, *args)

    def start(self) -> "QThread *":
        r"""
        Start this computation thread in a QThread
        :rtype: QThread
        :return: QThread
        """
        return _fast.ComputationThread_start(self)

    def setPipeline(self, pipeline: "Pipeline const &") -> "void":
        r"""
        Set a pipeline to run in this computation thread
        :type pipeline: Pipeline
        :param pipeline:
        """
        return _fast.ComputationThread_setPipeline(self, pipeline)

    def reset(self) -> "void":
        return _fast.ComputationThread_reset(self)

    def run(self) -> "void":
        return _fast.ComputationThread_run(self)

    def threadFinished(self) -> "void":
        r"""Signal which is emitted when thread is done and exciting its computation loop."""
        return _fast.ComputationThread_threadFinished(self)

    def pipelineFinished(self) -> "void":
        r"""
        Signal which is emitted when the pipeline is finished.

        Signal which is emitted when the pipeline assigned to this thread is finished
        If a pipeline does not have any streamer is is marked as finished after 1 iteration.
        If a pipeline has streamers it is signaled as finished when all streamers have a current output data frame
        which is marked as last frame.
        """
        return _fast.ComputationThread_pipelineFinished(self)

    def criticalError(self, msg: "QString") -> "void":
        r"""Signal when critical error happens in thread"""
        return _fast.ComputationThread_criticalError(self, msg)

# Register ComputationThread in _fast:
_fast.ComputationThread_swigregister(ComputationThread)

def ComputationThread_getStaticNameOfClass() -> "std::string":
    return _fast.ComputationThread_getStaticNameOfClass()

def ComputationThread_create() -> "std::shared_ptr< fast::ComputationThread >":
    return _fast.ComputationThread_create()

class ImageRenderer(Renderer):
    r"""
    Renders 2D Image data objects, both in 2D and 3D.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImageRenderer >":
        return _fast.ImageRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImageRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImageRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImageRenderer >":
        return _fast.ImageRenderer_connect(self, *args)

    @staticmethod
    def create(level: "float"=-1, window: "float"=-1, opacity: "float"=-1, applyTransformationsIn2D: "bool"=False) -> "std::shared_ptr< fast::ImageRenderer >":
        r"""
        Create instance

        :type level: float
        :param level:
        :type window: float
        :param window:
        :type opacity: float
        :param opacity: Draw image with an opacity. Useful if you want to draw an image on top of another
        :type applyTransformationsIn2D: boolean
        :param applyTransformationsIn2D: In 2D transformations (rotation/translation) are typically not applied.
                 by setting this to true they will be applied.
        :rtype: :py:class:`ImageRenderer`
        :return: instance
        """
        return _fast.ImageRenderer_create(level, window, opacity, applyTransformationsIn2D)

    def loadAttributes(self) -> "void":
        return _fast.ImageRenderer_loadAttributes(self)

    def setIntensityLevel(self, level: "float") -> "void":
        return _fast.ImageRenderer_setIntensityLevel(self, level)

    def getIntensityLevel(self) -> "float":
        return _fast.ImageRenderer_getIntensityLevel(self)

    def setIntensityWindow(self, window: "float") -> "void":
        return _fast.ImageRenderer_setIntensityWindow(self, window)

    def getIntensityWindow(self) -> "float":
        return _fast.ImageRenderer_getIntensityWindow(self)
    __swig_destroy__ = _fast.delete_ImageRenderer

# Register ImageRenderer in _fast:
_fast.ImageRenderer_swigregister(ImageRenderer)

def ImageRenderer_New() -> "std::shared_ptr< fast::ImageRenderer >":
    return _fast.ImageRenderer_New()

def ImageRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.ImageRenderer_getStaticNameOfClass()

def ImageRenderer_create(level: "float"=-1, window: "float"=-1, opacity: "float"=-1, applyTransformationsIn2D: "bool"=False) -> "std::shared_ptr< fast::ImageRenderer >":
    r"""
    Create instance

    :type level: float
    :param level:
    :type window: float
    :param window:
    :type opacity: float
    :param opacity: Draw image with an opacity. Useful if you want to draw an image on top of another
    :type applyTransformationsIn2D: boolean
    :param applyTransformationsIn2D: In 2D transformations (rotation/translation) are typically not applied.
             by setting this to true they will be applied.
    :rtype: :py:class:`ImageRenderer`
    :return: instance
    """
    return _fast.ImageRenderer_create(level, window, opacity, applyTransformationsIn2D)

class BoundingBoxRenderer(LabelColorRenderer):
    r"""
    Renders a set of bounding boxes

    See also: BoundingBoxSet

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::BoundingBoxRenderer >":
        return _fast.BoundingBoxRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.BoundingBoxRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.BoundingBoxRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::BoundingBoxRenderer >":
        return _fast.BoundingBoxRenderer_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::BoundingBoxRenderer >":
        r"""
        Create instance

        :type borderSize: float
        :param borderSize: Size of bounding box lines. If zero or negative value, the 10% of the minimum size of
                 BoundingBoxSet is used instead.
        :type labelColors: :py:class:`LabelColors`
        :param labelColors: Color of each label/class
        :rtype: :py:class:`BoundingBoxRenderer`
        :return: instance
        """
        return _fast.BoundingBoxRenderer_create(*args, **kwargs)

    def setBorderSize(self, size: "float") -> "void":
        return _fast.BoundingBoxRenderer_setBorderSize(self, size)

    def getBorderSize(self) -> "float":
        return _fast.BoundingBoxRenderer_getBorderSize(self)

    def attributesToString(self) -> "std::string":
        return _fast.BoundingBoxRenderer_attributesToString(self)

    def loadAttributes(self) -> "void":
        return _fast.BoundingBoxRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_BoundingBoxRenderer

# Register BoundingBoxRenderer in _fast:
_fast.BoundingBoxRenderer_swigregister(BoundingBoxRenderer)

def BoundingBoxRenderer_New() -> "std::shared_ptr< fast::BoundingBoxRenderer >":
    return _fast.BoundingBoxRenderer_New()

def BoundingBoxRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.BoundingBoxRenderer_getStaticNameOfClass()

def BoundingBoxRenderer_create(*args, **kwargs) -> "std::shared_ptr< fast::BoundingBoxRenderer >":
    r"""
    Create instance

    :type borderSize: float
    :param borderSize: Size of bounding box lines. If zero or negative value, the 10% of the minimum size of
             BoundingBoxSet is used instead.
    :type labelColors: :py:class:`LabelColors`
    :param labelColors: Color of each label/class
    :rtype: :py:class:`BoundingBoxRenderer`
    :return: instance
    """
    return _fast.BoundingBoxRenderer_create(*args, **kwargs)

class HeatmapRenderer(ImageRenderer):
    r"""
    Renders Tensor data objects as heatmaps.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::HeatmapRenderer >":
        return _fast.HeatmapRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.HeatmapRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.HeatmapRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::HeatmapRenderer >":
        return _fast.HeatmapRenderer_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::HeatmapRenderer >":
        return _fast.HeatmapRenderer_create(*args, **kwargs)

    def setMinConfidence(self, confidence: "float") -> "void":
        return _fast.HeatmapRenderer_setMinConfidence(self, confidence)

    def getMinConfidence(self) -> "float":
        return _fast.HeatmapRenderer_getMinConfidence(self)

    def setMaxOpacity(self, opacity: "float") -> "void":
        return _fast.HeatmapRenderer_setMaxOpacity(self, opacity)

    def getMaxOpacity(self) -> "float":
        return _fast.HeatmapRenderer_getMaxOpacity(self)

    def setChannelColor(self, channel: "uint", color: "Color") -> "void":
        return _fast.HeatmapRenderer_setChannelColor(self, channel, color)

    def getChannelColor(self, channel: "uint") -> "fast::Color":
        return _fast.HeatmapRenderer_getChannelColor(self, channel)

    def setChannelHidden(self, channel: "uint", hide: "bool") -> "void":
        return _fast.HeatmapRenderer_setChannelHidden(self, channel, hide)

    def getChannelHidden(self, channel: "uint") -> "bool":
        return _fast.HeatmapRenderer_getChannelHidden(self, channel)

    def setInterpolation(self, useInterpolation: "bool") -> "void":
        return _fast.HeatmapRenderer_setInterpolation(self, useInterpolation)

    def getInterpolation(self) -> "bool":
        return _fast.HeatmapRenderer_getInterpolation(self)

    def attributesToString(self) -> "std::string":
        return _fast.HeatmapRenderer_attributesToString(self)

    def loadAttributes(self) -> "void":
        return _fast.HeatmapRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_HeatmapRenderer

# Register HeatmapRenderer in _fast:
_fast.HeatmapRenderer_swigregister(HeatmapRenderer)

def HeatmapRenderer_New() -> "std::shared_ptr< fast::HeatmapRenderer >":
    return _fast.HeatmapRenderer_New()

def HeatmapRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.HeatmapRenderer_getStaticNameOfClass()

def HeatmapRenderer_create(*args, **kwargs) -> "std::shared_ptr< fast::HeatmapRenderer >":
    return _fast.HeatmapRenderer_create(*args, **kwargs)

class ImagePyramidRenderer(Renderer):
    r"""
    Renders tiled image pyramids

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ImagePyramidRenderer >":
        return _fast.ImagePyramidRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ImagePyramidRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ImagePyramidRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ImagePyramidRenderer >":
        return _fast.ImagePyramidRenderer_connect(self, *args)

    @staticmethod
    def create(sharpening: "bool"=True) -> "std::shared_ptr< fast::ImagePyramidRenderer >":
        return _fast.ImagePyramidRenderer_create(sharpening)

    def setSharpening(self, sharpening: "bool") -> "void":
        return _fast.ImagePyramidRenderer_setSharpening(self, sharpening)

    def getSharpening(self) -> "bool":
        return _fast.ImagePyramidRenderer_getSharpening(self)

    def loadAttributes(self) -> "void":
        return _fast.ImagePyramidRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_ImagePyramidRenderer

    def clearPyramid(self) -> "void":
        return _fast.ImagePyramidRenderer_clearPyramid(self)

# Register ImagePyramidRenderer in _fast:
_fast.ImagePyramidRenderer_swigregister(ImagePyramidRenderer)

def ImagePyramidRenderer_New() -> "std::shared_ptr< fast::ImagePyramidRenderer >":
    return _fast.ImagePyramidRenderer_New()

def ImagePyramidRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.ImagePyramidRenderer_getStaticNameOfClass()

def ImagePyramidRenderer_create(sharpening: "bool"=True) -> "std::shared_ptr< fast::ImagePyramidRenderer >":
    return _fast.ImagePyramidRenderer_create(sharpening)

class LineRenderer(Renderer):
    r"""
    Renders lines stored in Mesh data objects.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::LineRenderer >":
        return _fast.LineRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.LineRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.LineRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::LineRenderer >":
        return _fast.LineRenderer_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::LineRenderer >":
        r"""
        Create instance
        :type color: :py:class:`Color`
        :param color: Color of lines to draw
        :type lineWidth: float
        :param lineWidth: Width of line
        :type drawOnTop: boolean
        :param drawOnTop: Whether to draw on top of everything else or not. This disables the depth check in OpenGL
        :rtype: :py:class:`LineRenderer`
        :return: instance
        """
        return _fast.LineRenderer_create(*args, **kwargs)

    def addInputConnection(self, *args) -> "uint":
        return _fast.LineRenderer_addInputConnection(self, *args)

    def setDefaultColor(self, color: "Color") -> "void":
        return _fast.LineRenderer_setDefaultColor(self, color)

    def setDefaultLineWidth(self, width: "float") -> "void":
        r"""
        Set line width in percent (2D mode only atm.)
        :type width: float
        :param width:
        """
        return _fast.LineRenderer_setDefaultLineWidth(self, width)

    def setDefaultDrawOnTop(self, drawOnTop: "bool") -> "void":
        return _fast.LineRenderer_setDefaultDrawOnTop(self, drawOnTop)

    def setDrawOnTop(self, inputNr: "uint", drawOnTop: "bool") -> "void":
        return _fast.LineRenderer_setDrawOnTop(self, inputNr, drawOnTop)

    def setColor(self, inputNr: "uint", color: "Color") -> "void":
        return _fast.LineRenderer_setColor(self, inputNr, color)

    def setWidth(self, inputNr: "uint", width: "float") -> "void":
        return _fast.LineRenderer_setWidth(self, inputNr, width)

    def setDrawJoints(self, draw: "bool") -> "void":
        return _fast.LineRenderer_setDrawJoints(self, draw)

    def draw(self, perspectiveMatrix: "Matrix4f", viewingMatrix: "Matrix4f", zNear: "float", zFar: "float", mode2D: "bool", viewWidth: "int", viewHeight: "int") -> "void":
        return _fast.LineRenderer_draw(self, perspectiveMatrix, viewingMatrix, zNear, zFar, mode2D, viewWidth, viewHeight)
    __swig_destroy__ = _fast.delete_LineRenderer

# Register LineRenderer in _fast:
_fast.LineRenderer_swigregister(LineRenderer)

def LineRenderer_New() -> "std::shared_ptr< fast::LineRenderer >":
    return _fast.LineRenderer_New()

def LineRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.LineRenderer_getStaticNameOfClass()

def LineRenderer_create(*args, **kwargs) -> "std::shared_ptr< fast::LineRenderer >":
    r"""
    Create instance
    :type color: :py:class:`Color`
    :param color: Color of lines to draw
    :type lineWidth: float
    :param lineWidth: Width of line
    :type drawOnTop: boolean
    :param drawOnTop: Whether to draw on top of everything else or not. This disables the depth check in OpenGL
    :rtype: :py:class:`LineRenderer`
    :return: instance
    """
    return _fast.LineRenderer_create(*args, **kwargs)

class Plotter(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def setUpdateFrequency(self, frequency: "float") -> "void":
        r"""
        How often to update plot

        Set how many times per second the plot should update.
        This setting impacts performance.

        :type frequency: float
        :param frequency:
        """
        return _fast.Plotter_setUpdateFrequency(self, frequency)

    def getPlotterWidget(self) -> "JKQTPlotter *":
        return _fast.Plotter_getPlotterWidget(self)

    def processQueue(self) -> "void":
        return _fast.Plotter_processQueue(self)

    def newData(self) -> "void":
        return _fast.Plotter_newData(self)
    __swig_destroy__ = _fast.delete_Plotter

# Register Plotter in _fast:
_fast.Plotter_swigregister(Plotter)

class FloatScalar(FloatScalarT):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.FloatScalar_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.FloatScalar_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::FloatScalar >":
        return _fast.FloatScalar_fromDataObject(object)

    @staticmethod
    def create(data: "float") -> "std::shared_ptr< fast::FloatScalar >":
        return _fast.FloatScalar_create(data)
    __swig_destroy__ = _fast.delete_FloatScalar

# Register FloatScalar in _fast:
_fast.FloatScalar_swigregister(FloatScalar)

def FloatScalar_getStaticNameOfClass() -> "std::string":
    return _fast.FloatScalar_getStaticNameOfClass()

def FloatScalar_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::FloatScalar >":
    return _fast.FloatScalar_fromDataObject(object)

def FloatScalar_create(data: "float") -> "std::shared_ptr< fast::FloatScalar >":
    return _fast.FloatScalar_create(data)

class FloatPoint(FloatPointT):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def getNameOfClass(self) -> "std::string":
        return _fast.FloatPoint_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.FloatPoint_getStaticNameOfClass()

    @staticmethod
    def fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::FloatPoint >":
        return _fast.FloatPoint_fromDataObject(object)

    @staticmethod
    def create(data: "Vector2f") -> "std::shared_ptr< fast::FloatPoint >":
        return _fast.FloatPoint_create(data)
    __swig_destroy__ = _fast.delete_FloatPoint

# Register FloatPoint in _fast:
_fast.FloatPoint_swigregister(FloatPoint)

def FloatPoint_getStaticNameOfClass() -> "std::string":
    return _fast.FloatPoint_getStaticNameOfClass()

def FloatPoint_fromDataObject(object: "std::shared_ptr< fast::DataObject >") -> "std::shared_ptr< fast::FloatPoint >":
    return _fast.FloatPoint_fromDataObject(object)

def FloatPoint_create(data: "Vector2f") -> "std::shared_ptr< fast::FloatPoint >":
    return _fast.FloatPoint_create(data)

PlottingStyle_BRIGHT = _fast.PlottingStyle_BRIGHT
PlottingStyle_DARK = _fast.PlottingStyle_DARK
class LinePlotter(Plotter):
    r"""
    Plot lines to a graph Qt widget in real-time

    Inputs:
    - *: FloatScalar

    Outputs:
    None

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::LinePlotter >":
        return _fast.LinePlotter_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.LinePlotter_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.LinePlotter_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::LinePlotter >":
        return _fast.LinePlotter_create(*args, **kwargs)

    def connect(self, *args) -> "std::shared_ptr< fast::LinePlotter >":
        return _fast.LinePlotter_connect(self, *args)

    def setNames(self, names: "LabelNames") -> "void":
        r"""
        Set names for each line
        :type names: std::map< uint,std::string,std::less< uint >,std::allocator< std::pair< uint const,std::string > > >
        :param names:
        """
        return _fast.LinePlotter_setNames(self, names)

    def setBufferSize(self, size: "int") -> "void":
        return _fast.LinePlotter_setBufferSize(self, size)

    def addHorizontalLine(self, *args, **kwargs) -> "void":
        return _fast.LinePlotter_addHorizontalLine(self, *args, **kwargs)

    def setCircularMode(self, circular: "bool") -> "void":
        return _fast.LinePlotter_setCircularMode(self, circular)

    def processQueue(self) -> "void":
        return _fast.LinePlotter_processQueue(self)
    __swig_destroy__ = _fast.delete_LinePlotter

# Register LinePlotter in _fast:
_fast.LinePlotter_swigregister(LinePlotter)

def LinePlotter_New() -> "std::shared_ptr< fast::LinePlotter >":
    return _fast.LinePlotter_New()

def LinePlotter_getStaticNameOfClass() -> "std::string":
    return _fast.LinePlotter_getStaticNameOfClass()

def LinePlotter_create(*args, **kwargs) -> "std::shared_ptr< fast::LinePlotter >":
    return _fast.LinePlotter_create(*args, **kwargs)

class RenderToImage(ProcessObject):
    r"""
    Render to an image

    Use this process object to render to an Image object instead of a window on screen.
    Do this by connecting renderers to this object in order.
    Only supports 2D mode for now.

    TODO: 3D support

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::RenderToImage >":
        return _fast.RenderToImage_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.RenderToImage_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.RenderToImage_getStaticNameOfClass()

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::RenderToImage >":
        r"""
        Create instance
        :type bgcolor: :py:class:`Color`
        :param bgcolor: Background color of scene
        :type width: int
        :param width: Width of image to render to. If negative, the width will be determined using height and aspect ratio of scene.
        :type height: int
        :param height: Height of image to render to. If negative, the height will be determined using width and aspect ratio of scene.
        :rtype: :py:class:`RenderToImage`
        :return: 
        """
        return _fast.RenderToImage_create(*args, **kwargs)

    def addRenderer(self, renderer: "std::shared_ptr< fast::Renderer >") -> "void":
        return _fast.RenderToImage_addRenderer(self, renderer)

    def getRenderers(self) -> "std::vector< std::shared_ptr< fast::Renderer >,std::allocator< std::shared_ptr< fast::Renderer > > >":
        return _fast.RenderToImage_getRenderers(self)

    def connect(self, *args) -> "std::shared_ptr< fast::RenderToImage >":
        return _fast.RenderToImage_connect(self, *args)

    def reset(self) -> "void":
        return _fast.RenderToImage_reset(self)

    def removeAllRenderers(self) -> "void":
        return _fast.RenderToImage_removeAllRenderers(self)

    def set2DMode(self) -> "void":
        return _fast.RenderToImage_set2DMode(self)

    def set3DMode(self) -> "void":
        return _fast.RenderToImage_set3DMode(self)

    def setAutoUpdateCamera(self, autoUpdate: "bool") -> "void":
        return _fast.RenderToImage_setAutoUpdateCamera(self, autoUpdate)
    __swig_destroy__ = _fast.delete_RenderToImage

# Register RenderToImage in _fast:
_fast.RenderToImage_swigregister(RenderToImage)

def RenderToImage_New() -> "std::shared_ptr< fast::RenderToImage >":
    return _fast.RenderToImage_New()

def RenderToImage_getStaticNameOfClass() -> "std::string":
    return _fast.RenderToImage_getStaticNameOfClass()

def RenderToImage_create(*args, **kwargs) -> "std::shared_ptr< fast::RenderToImage >":
    r"""
    Create instance
    :type bgcolor: :py:class:`Color`
    :param bgcolor: Background color of scene
    :type width: int
    :param width: Width of image to render to. If negative, the width will be determined using height and aspect ratio of scene.
    :type height: int
    :param height: Height of image to render to. If negative, the height will be determined using width and aspect ratio of scene.
    :rtype: :py:class:`RenderToImage`
    :return: 
    """
    return _fast.RenderToImage_create(*args, **kwargs)

class SegmentationLabelRenderer(LabelColorRenderer):
    r"""
    Renders text labels on top of Segmentation data

    Renders text labels (e.g. Blood, Bone, ..) with colors on top of Segmentation data.
    A text label is rendered in the center of every segmentation region with an area larger than a given threshold.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SegmentationLabelRenderer >":
        return _fast.SegmentationLabelRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SegmentationLabelRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SegmentationLabelRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::SegmentationLabelRenderer >":
        return _fast.SegmentationLabelRenderer_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::SegmentationLabelRenderer >":
        r"""
        Create instnace
        :type labelNames: :py:class:`LabelNames`
        :param labelNames: Map from label id to label name
        :type labelColors: :py:class:`LabelColors`
        :param labelColors: Map from label id to color
        :type areaThreshold: float
        :param areaThreshold: Any segmentation region smaller than this threshold does not get a label
        :rtype: :py:class:`SegmentationLabelRenderer`
        :return: instance
        """
        return _fast.SegmentationLabelRenderer_create(*args, **kwargs)

    def setLabelNames(self, labelNames: "LabelNames") -> "void":
        return _fast.SegmentationLabelRenderer_setLabelNames(self, labelNames)

    def setLabelName(self, label: "uint", name: "std::string") -> "void":
        return _fast.SegmentationLabelRenderer_setLabelName(self, label, name)

    def setAreaThreshold(self, threshold: "float") -> "void":
        return _fast.SegmentationLabelRenderer_setAreaThreshold(self, threshold)

    def draw(self, perspectiveMatrix: "Matrix4f", viewingMatrix: "Matrix4f", zNear: "float", zFar: "float", mode2D: "bool", viewWidth: "int", viewHeight: "int") -> "void":
        return _fast.SegmentationLabelRenderer_draw(self, perspectiveMatrix, viewingMatrix, zNear, zFar, mode2D, viewWidth, viewHeight)

    def loadAttributes(self) -> "void":
        return _fast.SegmentationLabelRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_SegmentationLabelRenderer

# Register SegmentationLabelRenderer in _fast:
_fast.SegmentationLabelRenderer_swigregister(SegmentationLabelRenderer)

def SegmentationLabelRenderer_New() -> "std::shared_ptr< fast::SegmentationLabelRenderer >":
    return _fast.SegmentationLabelRenderer_New()

def SegmentationLabelRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.SegmentationLabelRenderer_getStaticNameOfClass()

def SegmentationLabelRenderer_create(*args, **kwargs) -> "std::shared_ptr< fast::SegmentationLabelRenderer >":
    r"""
    Create instnace
    :type labelNames: :py:class:`LabelNames`
    :param labelNames: Map from label id to label name
    :type labelColors: :py:class:`LabelColors`
    :param labelColors: Map from label id to color
    :type areaThreshold: float
    :param areaThreshold: Any segmentation region smaller than this threshold does not get a label
    :rtype: :py:class:`SegmentationLabelRenderer`
    :return: instance
    """
    return _fast.SegmentationLabelRenderer_create(*args, **kwargs)

class SegmentationRenderer(ImageRenderer, LabelColorRenderer):
    r"""
    Renders 2D segmentation data

    Renders segmentation data using colors and potentially transparency.

    Input can be 2D Segmentation, Image or ImagePyramid (of type TYPE_UINT8) objects.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SegmentationRenderer >":
        return _fast.SegmentationRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SegmentationRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SegmentationRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::SegmentationRenderer >":
        return _fast.SegmentationRenderer_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::SegmentationRenderer >":
        return _fast.SegmentationRenderer_create(*args, **kwargs)

    def setBorderRadius(self, radius: "int") -> "void":
        return _fast.SegmentationRenderer_setBorderRadius(self, radius)

    def setOpacity(self, opacity: "float", borderOpacity: "float"=-1) -> "void":
        return _fast.SegmentationRenderer_setOpacity(self, opacity, borderOpacity)

    def setBorderOpacity(self, borderOpacity: "float") -> "void":
        return _fast.SegmentationRenderer_setBorderOpacity(self, borderOpacity)

    def getOpacity(self) -> "float":
        return _fast.SegmentationRenderer_getOpacity(self)

    def getBorderOpacity(self) -> "float":
        return _fast.SegmentationRenderer_getBorderOpacity(self)

    def getBorderRadius(self) -> "int":
        return _fast.SegmentationRenderer_getBorderRadius(self)

    def attributesToString(self) -> "std::string":
        return _fast.SegmentationRenderer_attributesToString(self)

    def loadAttributes(self) -> "void":
        return _fast.SegmentationRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_SegmentationRenderer

# Register SegmentationRenderer in _fast:
_fast.SegmentationRenderer_swigregister(SegmentationRenderer)

def SegmentationRenderer_New() -> "std::shared_ptr< fast::SegmentationRenderer >":
    return _fast.SegmentationRenderer_New()

def SegmentationRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.SegmentationRenderer_getStaticNameOfClass()

def SegmentationRenderer_create(*args, **kwargs) -> "std::shared_ptr< fast::SegmentationRenderer >":
    return _fast.SegmentationRenderer_create(*args, **kwargs)

class SliceRenderer(ImageRenderer):
    r"""
    Renders a 2D image slice extracted from a 3D image.

    This renderer uses the ImageSlicer to extract a 2D image slice from a 3D image, and
    extends ImageRenderer to render the image slice.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::SliceRenderer >":
        return _fast.SliceRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.SliceRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.SliceRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::SliceRenderer >":
        return _fast.SliceRenderer_connect(self, *args)

    @staticmethod
    def create(*args) -> "std::shared_ptr< fast::SliceRenderer >":
        r"""
        *Overload 1:*

        Create instance

        Slice a 3D image with an orthogonal slice plane. Default slice nr is the center slice.

        :type orthogonalSlicePlane: int
        :param orthogonalSlicePlane: Which orthogonal slice plane to use X/Y/Z
        :type sliceNr: int
        :param sliceNr: Which slice nr to extract, must be smaller than size of the slicing dimension.
                 If negative center slice will be used
        :rtype: :py:class:`SliceRenderer`
        :return: instance

        |

        *Overload 2:*

        Create instance

        Slice a volume with an arbitrary slice plane defined by Plane.

        :type arbitrarySlicePlane: :py:class:`Plane`
        :param arbitrarySlicePlane:
        :rtype: :py:class:`SliceRenderer`
        :return: instance
        """
        return _fast.SliceRenderer_create(*args)

    def addInputConnection(self, *args) -> "uint":
        r"""
        *Overload 1:*

        Orthogonal slicing using the specified orthogonal plane.
        :type port: :py:class:`DataChannel`
        :param port:
        :type orthogonalSlicePlane: int
        :param orthogonalSlicePlane:
        :type sliceNr: int
        :param sliceNr:
        :rtype: int
        :return: port id of new port

        |

        *Overload 2:*

        Arbitrary slicing using the supplied plane.
        :type port: :py:class:`DataChannel`
        :param port:
        :type slicePlane: :py:class:`Plane`
        :param slicePlane:
        :rtype: int
        :return: port id of new port

        |

        *Overload 3:*

        Add new input connection using supplied slicer
        :type port: :py:class:`DataChannel`
        :param port:
        :type slicer: :py:class:`ImageSlicer`
        :param slicer:
        :rtype: int
        :return: port id of new port
        """
        return _fast.SliceRenderer_addInputConnection(self, *args)

    def setOrthogonalSlicePlane(self, portID: "uint", orthogonalSlicePlane: "fast::PlaneType", sliceNr: "int"=-1) -> "void":
        return _fast.SliceRenderer_setOrthogonalSlicePlane(self, portID, orthogonalSlicePlane, sliceNr)

    def setArbitrarySlicePlane(self, portID: "uint", slicePlane: "Plane") -> "void":
        return _fast.SliceRenderer_setArbitrarySlicePlane(self, portID, slicePlane)
    __swig_destroy__ = _fast.delete_SliceRenderer

# Register SliceRenderer in _fast:
_fast.SliceRenderer_swigregister(SliceRenderer)

def SliceRenderer_New() -> "std::shared_ptr< fast::SliceRenderer >":
    return _fast.SliceRenderer_New()

def SliceRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.SliceRenderer_getStaticNameOfClass()

def SliceRenderer_create(*args) -> "std::shared_ptr< fast::SliceRenderer >":
    r"""
    *Overload 1:*

    Create instance

    Slice a 3D image with an orthogonal slice plane. Default slice nr is the center slice.

    :type orthogonalSlicePlane: int
    :param orthogonalSlicePlane: Which orthogonal slice plane to use X/Y/Z
    :type sliceNr: int
    :param sliceNr: Which slice nr to extract, must be smaller than size of the slicing dimension.
             If negative center slice will be used
    :rtype: :py:class:`SliceRenderer`
    :return: instance

    |

    *Overload 2:*

    Create instance

    Slice a volume with an arbitrary slice plane defined by Plane.

    :type arbitrarySlicePlane: :py:class:`Plane`
    :param arbitrarySlicePlane:
    :rtype: :py:class:`SliceRenderer`
    :return: instance
    """
    return _fast.SliceRenderer_create(*args)

class TextRenderer(Renderer):
    r"""
    Renders Text data

    Renders text data objects.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TextRenderer >":
        return _fast.TextRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TextRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TextRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TextRenderer >":
        return _fast.TextRenderer_connect(self, *args)

    def getBoundingBox(self, transform: "bool") -> "fast::DataBoundingBox":
        return _fast.TextRenderer_getBoundingBox(self, transform)
    STYLE_NORMAL = _fast.TextRenderer_STYLE_NORMAL
    STYLE_BOLD = _fast.TextRenderer_STYLE_BOLD
    STYLE_ITALIC = _fast.TextRenderer_STYLE_ITALIC
    POSITION_CENTER = _fast.TextRenderer_POSITION_CENTER
    POSITION_TOP_CENTER = _fast.TextRenderer_POSITION_TOP_CENTER
    POSITION_BOTTOM_CENTER = _fast.TextRenderer_POSITION_BOTTOM_CENTER
    POSITION_BOTTOM_LEFT = _fast.TextRenderer_POSITION_BOTTOM_LEFT
    POSITION_BOTTOM_RIGHT = _fast.TextRenderer_POSITION_BOTTOM_RIGHT
    POSITION_TOP_LEFT = _fast.TextRenderer_POSITION_TOP_LEFT
    POSITION_TOP_RIGHT = _fast.TextRenderer_POSITION_TOP_RIGHT
    PositionType_STANDARD = _fast.TextRenderer_PositionType_STANDARD
    PositionType_VIEW = _fast.TextRenderer_PositionType_VIEW
    PositionType_WORLD = _fast.TextRenderer_PositionType_WORLD

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::TextRenderer >":
        return _fast.TextRenderer_create(*args, **kwargs)

    def setPosition(self, position: "fast::TextRenderer::TextPosition") -> "void":
        return _fast.TextRenderer_setPosition(self, position)

    def setViewPosition(self, position: "Vector2f", centerPosition: "float"=True) -> "void":
        r"""
        Set text position in normalization view position (x,y 0-1)
        :type position: Vector2f
        :param position:
        :type centerPosition: float
        :param centerPosition:
        """
        return _fast.TextRenderer_setViewPosition(self, position, centerPosition)

    def setWorldPosition(self, position: "Vector2f", centerPosition: "float"=True) -> "void":
        r"""
        Set text position in world coordinates (millimeters)
        :type position: Vector2f
        :param position:
        :type centerPosition: float
        :param centerPosition:
        """
        return _fast.TextRenderer_setWorldPosition(self, position, centerPosition)

    def setFontHeightInMM(self, heightInMillimeters: "float") -> "void":
        r"""
        Set font height in millimeters
        :type heightInMillimeters: float
        :param heightInMillimeters:
        """
        return _fast.TextRenderer_setFontHeightInMM(self, heightInMillimeters)

    def setPositionType(self, position: "fast::TextRenderer::PositionType") -> "void":
        return _fast.TextRenderer_setPositionType(self, position)

    def setFontSize(self, fontSize: "uint") -> "void":
        return _fast.TextRenderer_setFontSize(self, fontSize)

    def setColor(self, color: "Color") -> "void":
        return _fast.TextRenderer_setColor(self, color)

    def setStyle(self, arg2: "fast::TextRenderer::TextStyleType") -> "void":
        return _fast.TextRenderer_setStyle(self, arg2)

    def draw(self, perspectiveMatrix: "Matrix4f", viewingMatrix: "Matrix4f", zNear: "float", zFar: "float", mode2D: "bool", viewWidth: "int", viewHeight: "int") -> "void":
        return _fast.TextRenderer_draw(self, perspectiveMatrix, viewingMatrix, zNear, zFar, mode2D, viewWidth, viewHeight)

    def loadAttributes(self) -> "void":
        return _fast.TextRenderer_loadAttributes(self)
    __swig_destroy__ = _fast.delete_TextRenderer

# Register TextRenderer in _fast:
_fast.TextRenderer_swigregister(TextRenderer)

def TextRenderer_New() -> "std::shared_ptr< fast::TextRenderer >":
    return _fast.TextRenderer_New()

def TextRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.TextRenderer_getStaticNameOfClass()

def TextRenderer_create(*args, **kwargs) -> "std::shared_ptr< fast::TextRenderer >":
    return _fast.TextRenderer_create(*args, **kwargs)

class TriangleRenderer(Renderer):
    r"""
    Renders triangle Mesh data

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::TriangleRenderer >":
        return _fast.TriangleRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.TriangleRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.TriangleRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::TriangleRenderer >":
        return _fast.TriangleRenderer_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::TriangleRenderer >":
        r"""
        Create instance
        :type color: :py:class:`Color`
        :param color: Color of triangles
        :type opacity: float
        :param opacity: Triangle opacity
        :type wireframe: boolean
        :param wireframe: Display wireframe or not
        :type specularReflection: float
        :param specularReflection:
        :rtype: :py:class:`TriangleRenderer`
        :return: instance
        """
        return _fast.TriangleRenderer_create(*args, **kwargs)

    def addInputConnection(self, *args) -> "uint":
        return _fast.TriangleRenderer_addInputConnection(self, *args)

    def setDefaultOpacity(self, opacity: "float") -> "void":
        return _fast.TriangleRenderer_setDefaultOpacity(self, opacity)

    def setWireframe(self, wireframe: "bool") -> "void":
        r"""
        Enable/disable renderer of wireframe instead of filled polygons
        :type wireframe: boolean
        :param wireframe:
        """
        return _fast.TriangleRenderer_setWireframe(self, wireframe)

    def setDefaultColor(self, color: "Color") -> "void":
        return _fast.TriangleRenderer_setDefaultColor(self, color)

    def setDefaultSpecularReflection(self, specularReflection: "float") -> "void":
        return _fast.TriangleRenderer_setDefaultSpecularReflection(self, specularReflection)

    def setColor(self, inputNr: "uint", color: "Color") -> "void":
        return _fast.TriangleRenderer_setColor(self, inputNr, color)

    def setLabelColor(self, label: "int", color: "Color") -> "void":
        return _fast.TriangleRenderer_setLabelColor(self, label, color)

    def setOpacity(self, inputNr: "uint", opacity: "float") -> "void":
        return _fast.TriangleRenderer_setOpacity(self, inputNr, opacity)

    def setLineSize(self, size: "int") -> "void":
        return _fast.TriangleRenderer_setLineSize(self, size)

    def setIgnoreInvertedNormals(self, ignore: "bool") -> "void":
        r"""
        Ignore inverted normals. This gives a better visualization
        if some normals in a mesh points have opposite direction.

        Default: true
        :type ignore: boolean
        :param ignore:
        """
        return _fast.TriangleRenderer_setIgnoreInvertedNormals(self, ignore)
    __swig_destroy__ = _fast.delete_TriangleRenderer

# Register TriangleRenderer in _fast:
_fast.TriangleRenderer_swigregister(TriangleRenderer)

def TriangleRenderer_New() -> "std::shared_ptr< fast::TriangleRenderer >":
    return _fast.TriangleRenderer_New()

def TriangleRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.TriangleRenderer_getStaticNameOfClass()

def TriangleRenderer_create(*args, **kwargs) -> "std::shared_ptr< fast::TriangleRenderer >":
    r"""
    Create instance
    :type color: :py:class:`Color`
    :param color: Color of triangles
    :type opacity: float
    :param opacity: Triangle opacity
    :type wireframe: boolean
    :param wireframe: Display wireframe or not
    :type specularReflection: float
    :param specularReflection:
    :rtype: :py:class:`TriangleRenderer`
    :return: instance
    """
    return _fast.TriangleRenderer_create(*args, **kwargs)

class VectorFieldRenderer(LineRenderer):
    r"""
    Renders a vector field image using lines

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VectorFieldRenderer >":
        return _fast.VectorFieldRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VectorFieldRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VectorFieldRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::VectorFieldRenderer >":
        return _fast.VectorFieldRenderer_connect(self, *args)

    def __init__(self):
        _fast.VectorFieldRenderer_swiginit(self, _fast.new_VectorFieldRenderer())
    __swig_destroy__ = _fast.delete_VectorFieldRenderer

# Register VectorFieldRenderer in _fast:
_fast.VectorFieldRenderer_swigregister(VectorFieldRenderer)

def VectorFieldRenderer_New() -> "std::shared_ptr< fast::VectorFieldRenderer >":
    return _fast.VectorFieldRenderer_New()

def VectorFieldRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.VectorFieldRenderer_getStaticNameOfClass()

class VectorFieldColorRenderer(ImageRenderer):
    r"""
    Renders a vector field image using colors

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VectorFieldColorRenderer >":
        return _fast.VectorFieldColorRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VectorFieldColorRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VectorFieldColorRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::VectorFieldColorRenderer >":
        return _fast.VectorFieldColorRenderer_connect(self, *args)

    @staticmethod
    def create(maxOpacity: "float"=0.5, maxLength: "float"=-1.0) -> "std::shared_ptr< fast::VectorFieldColorRenderer >":
        return _fast.VectorFieldColorRenderer_create(maxOpacity, maxLength)

    def setMaxOpacity(self, maxOpacity: "float") -> "void":
        r"""
        Set the maximum opacity for the color overlay.

        :type maxOpacity: float
        :param maxOpacity:
        """
        return _fast.VectorFieldColorRenderer_setMaxOpacity(self, maxOpacity)

    def setMaxLength(self, max: "float") -> "void":
        return _fast.VectorFieldColorRenderer_setMaxLength(self, max)
    __swig_destroy__ = _fast.delete_VectorFieldColorRenderer

# Register VectorFieldColorRenderer in _fast:
_fast.VectorFieldColorRenderer_swigregister(VectorFieldColorRenderer)

def VectorFieldColorRenderer_New() -> "std::shared_ptr< fast::VectorFieldColorRenderer >":
    return _fast.VectorFieldColorRenderer_New()

def VectorFieldColorRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.VectorFieldColorRenderer_getStaticNameOfClass()

def VectorFieldColorRenderer_create(maxOpacity: "float"=0.5, maxLength: "float"=-1.0) -> "std::shared_ptr< fast::VectorFieldColorRenderer >":
    return _fast.VectorFieldColorRenderer_create(maxOpacity, maxLength)

class VertexRenderer(Renderer):
    r"""
    Renders vertices as a circular points


    See also: Mesh
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::VertexRenderer >":
        return _fast.VertexRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.VertexRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.VertexRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::VertexRenderer >":
        return _fast.VertexRenderer_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::VertexRenderer >":
        r"""
        Create instance
        :type size: float
        :param size: Vertex point size (can be in pixels or millimeters, see sizeIsInPixels parameter)
        :type sizeIsInPixels: boolean
        :param sizeIsInPixels: Whether size is given in pixels or millimeters
        :type minSize: int
        :param minSize: Minimum size in pixels, used when sizeInPixels = false
        :type color: :py:class:`Color`
        :param color: Override color stored for each vertex
        :type opacity: float
        :param opacity: Opacity of vertices: 1 = no transparency, 0 = fully transparent
        :type drawOnTop: boolean
        :param drawOnTop: Disable depth testing and always draw vertices on top
        :rtype: :py:class:`VertexRenderer`
        :return: instance
        """
        return _fast.VertexRenderer_create(*args, **kwargs)

    def addInputConnection(self, *args) -> "uint":
        return _fast.VertexRenderer_addInputConnection(self, *args)

    def addInputData(self, *args) -> "uint":
        return _fast.VertexRenderer_addInputData(self, *args)

    def setDefaultColor(self, color: "Color") -> "void":
        return _fast.VertexRenderer_setDefaultColor(self, color)

    def setDefaultSize(self, size: "float") -> "void":
        return _fast.VertexRenderer_setDefaultSize(self, size)

    def setDefaultDrawOnTop(self, drawOnTop: "bool") -> "void":
        return _fast.VertexRenderer_setDefaultDrawOnTop(self, drawOnTop)

    def setDrawOnTop(self, inputNr: "uint", drawOnTop: "bool") -> "void":
        return _fast.VertexRenderer_setDrawOnTop(self, inputNr, drawOnTop)

    def setColor(self, inputNr: "uint", color: "Color") -> "void":
        return _fast.VertexRenderer_setColor(self, inputNr, color)

    def setSize(self, inputNr: "uint", size: "float") -> "void":
        return _fast.VertexRenderer_setSize(self, inputNr, size)

    def setOpacity(self, opacity: "float") -> "void":
        return _fast.VertexRenderer_setOpacity(self, opacity)

    def draw(self, perspectiveMatrix: "Matrix4f", viewingMatrix: "Matrix4f", zNear: "float", zFar: "float", mode2D: "bool", viewWidth: "int", viewHeight: "int") -> "void":
        return _fast.VertexRenderer_draw(self, perspectiveMatrix, viewingMatrix, zNear, zFar, mode2D, viewWidth, viewHeight)
    __swig_destroy__ = _fast.delete_VertexRenderer

# Register VertexRenderer in _fast:
_fast.VertexRenderer_swigregister(VertexRenderer)

def VertexRenderer_New() -> "std::shared_ptr< fast::VertexRenderer >":
    return _fast.VertexRenderer_New()

def VertexRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.VertexRenderer_getStaticNameOfClass()

def VertexRenderer_create(*args, **kwargs) -> "std::shared_ptr< fast::VertexRenderer >":
    r"""
    Create instance
    :type size: float
    :param size: Vertex point size (can be in pixels or millimeters, see sizeIsInPixels parameter)
    :type sizeIsInPixels: boolean
    :param sizeIsInPixels: Whether size is given in pixels or millimeters
    :type minSize: int
    :param minSize: Minimum size in pixels, used when sizeInPixels = false
    :type color: :py:class:`Color`
    :param color: Override color stored for each vertex
    :type opacity: float
    :param opacity: Opacity of vertices: 1 = no transparency, 0 = fully transparent
    :type drawOnTop: boolean
    :param drawOnTop: Disable depth testing and always draw vertices on top
    :rtype: :py:class:`VertexRenderer`
    :return: instance
    """
    return _fast.VertexRenderer_create(*args, **kwargs)

class VolumeRenderer(Renderer):
    r"""
    Abstract base class for volume renderers

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fast.delete_VolumeRenderer

# Register VolumeRenderer in _fast:
_fast.VolumeRenderer_swigregister(VolumeRenderer)

class TransferFunction(object):
    r"""
    A class for defining a transfer function used in volume rendering.

    This used in the AlphaBlendingVolumeRenderer.
    The transfer function contains a set of 5-tuple points (intensity, red, green, blue, alpha).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Creates an empty transfer function

        |

        *Overload 2:*

        Initialize the transfer function. The input values have to be a multiple of 5.
        Thus a set of 5-tuples (intensity, red, green, blue, alpha)

        :type values: std::vector< float,std::allocator< float > >
        :param values:
        """
        _fast.TransferFunction_swiginit(self, _fast.new_TransferFunction(*args))

    def addPoint(self, intensity: "float", color: "Vector4f") -> "int":
        r"""
        Add a point to the transfer function. Intensity must be larger than previous point.
        I.e. the transfer function has to be sorted on increasing intensity

        :type intensity: float
        :param intensity:
        :type color: Vector4f
        :param color: (red, green, blue, alpha)
        :rtype: int
        :return: index
        """
        return _fast.TransferFunction_addPoint(self, intensity, color)

    def removePoint(self, i: "int") -> "void":
        r"""
        Remove transfer function point at index i
        :type i: int
        :param i: index
        """
        return _fast.TransferFunction_removePoint(self, i)

    def clear(self) -> "void":
        r"""Remove all points in the transfer function."""
        return _fast.TransferFunction_clear(self)

    def getSize(self) -> "int":
        r"""
        :rtype: int
        :return: number of points in the transfer function
        """
        return _fast.TransferFunction_getSize(self)

    def getPoint(self, i: "int") -> "std::tuple< float,Vector4f >":
        r"""
        Get intensity and color at index i
        :type i: int
        :param i: index
        :rtype: std::tuple< float,Vector4f >
        :return: 2-tuple of intensity and color(red, green, blue, alpha)
        """
        return _fast.TransferFunction_getPoint(self, i)

    def getAsOpenCLBuffer(self, device: "fast::OpenCLDevice::pointer") -> "cl::Buffer":
        r"""
        Create an OpenCL buffer from the transfer function data.
        :type device: :py:class:`OpenCLDevice`
        :param device: OpenCL device to transfer data to
        :rtype: cl::Buffer
        :return: OpenCL buffer
        """
        return _fast.TransferFunction_getAsOpenCLBuffer(self, device)

    @staticmethod
    def CT_Blood_And_Bone() -> "fast::TransferFunction":
        return _fast.TransferFunction_CT_Blood_And_Bone()

    @staticmethod
    def CT_Bone() -> "fast::TransferFunction":
        return _fast.TransferFunction_CT_Bone()

    @staticmethod
    def CT_Blood() -> "fast::TransferFunction":
        return _fast.TransferFunction_CT_Blood()

    @staticmethod
    def Ultrasound() -> "fast::TransferFunction":
        return _fast.TransferFunction_Ultrasound()
    __swig_destroy__ = _fast.delete_TransferFunction

# Register TransferFunction in _fast:
_fast.TransferFunction_swigregister(TransferFunction)

def TransferFunction_CT_Blood_And_Bone() -> "fast::TransferFunction":
    return _fast.TransferFunction_CT_Blood_And_Bone()

def TransferFunction_CT_Bone() -> "fast::TransferFunction":
    return _fast.TransferFunction_CT_Bone()

def TransferFunction_CT_Blood() -> "fast::TransferFunction":
    return _fast.TransferFunction_CT_Blood()

def TransferFunction_Ultrasound() -> "fast::TransferFunction":
    return _fast.TransferFunction_Ultrasound()

class AlphaBlendingVolumeRenderer(VolumeRenderer):
    r"""
    Renders 3D images/volumes using ray-casting and alpha blending.

    Rays are cast back to front, accumulating color along the way based on a provided TransferFunction


    See also: TransferFunction
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::AlphaBlendingVolumeRenderer >":
        return _fast.AlphaBlendingVolumeRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.AlphaBlendingVolumeRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.AlphaBlendingVolumeRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::AlphaBlendingVolumeRenderer >":
        return _fast.AlphaBlendingVolumeRenderer_connect(self, *args)

    @staticmethod
    def create(*args, **kwargs) -> "std::shared_ptr< fast::AlphaBlendingVolumeRenderer >":
        return _fast.AlphaBlendingVolumeRenderer_create(*args, **kwargs)

    def setTransferFunction(self, transferFunction: "TransferFunction") -> "void":
        r"""
        Set transfer function to use during alpha blending

        :type transferFunction: :py:class:`TransferFunction`
        :param transferFunction:
        """
        return _fast.AlphaBlendingVolumeRenderer_setTransferFunction(self, transferFunction)
    __swig_destroy__ = _fast.delete_AlphaBlendingVolumeRenderer

# Register AlphaBlendingVolumeRenderer in _fast:
_fast.AlphaBlendingVolumeRenderer_swigregister(AlphaBlendingVolumeRenderer)

def AlphaBlendingVolumeRenderer_New() -> "std::shared_ptr< fast::AlphaBlendingVolumeRenderer >":
    return _fast.AlphaBlendingVolumeRenderer_New()

def AlphaBlendingVolumeRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.AlphaBlendingVolumeRenderer_getStaticNameOfClass()

def AlphaBlendingVolumeRenderer_create(*args, **kwargs) -> "std::shared_ptr< fast::AlphaBlendingVolumeRenderer >":
    return _fast.AlphaBlendingVolumeRenderer_create(*args, **kwargs)

class ThresholdVolumeRenderer(VolumeRenderer):
    r"""
    Renders 3D images using ray-casting and a threshold

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::ThresholdVolumeRenderer >":
        return _fast.ThresholdVolumeRenderer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.ThresholdVolumeRenderer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.ThresholdVolumeRenderer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::ThresholdVolumeRenderer >":
        return _fast.ThresholdVolumeRenderer_connect(self, *args)

    @staticmethod
    def create(threshold: "float"=0) -> "std::shared_ptr< fast::ThresholdVolumeRenderer >":
        return _fast.ThresholdVolumeRenderer_create(threshold)

    def setThreshold(self, threshold: "float") -> "void":
        return _fast.ThresholdVolumeRenderer_setThreshold(self, threshold)
    __swig_destroy__ = _fast.delete_ThresholdVolumeRenderer

# Register ThresholdVolumeRenderer in _fast:
_fast.ThresholdVolumeRenderer_swigregister(ThresholdVolumeRenderer)

def ThresholdVolumeRenderer_New() -> "std::shared_ptr< fast::ThresholdVolumeRenderer >":
    return _fast.ThresholdVolumeRenderer_New()

def ThresholdVolumeRenderer_getStaticNameOfClass() -> "std::string":
    return _fast.ThresholdVolumeRenderer_getStaticNameOfClass()

def ThresholdVolumeRenderer_create(threshold: "float"=0) -> "std::shared_ptr< fast::ThresholdVolumeRenderer >":
    return _fast.ThresholdVolumeRenderer_create(threshold)

class MaximumIntensityProjection(VolumeRenderer):
    r"""
    Renders 3D images using ray-casting and maximum intensity projection (MIP)

    Uses the highest intensity observed along the ray.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::MaximumIntensityProjection >":
        return _fast.MaximumIntensityProjection_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.MaximumIntensityProjection_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.MaximumIntensityProjection_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::MaximumIntensityProjection >":
        return _fast.MaximumIntensityProjection_connect(self, *args)

    @staticmethod
    def create() -> "std::shared_ptr< fast::MaximumIntensityProjection >":
        return _fast.MaximumIntensityProjection_create()
    __swig_destroy__ = _fast.delete_MaximumIntensityProjection

# Register MaximumIntensityProjection in _fast:
_fast.MaximumIntensityProjection_swigregister(MaximumIntensityProjection)

def MaximumIntensityProjection_New() -> "std::shared_ptr< fast::MaximumIntensityProjection >":
    return _fast.MaximumIntensityProjection_New()

def MaximumIntensityProjection_getStaticNameOfClass() -> "std::string":
    return _fast.MaximumIntensityProjection_getStaticNameOfClass()

def MaximumIntensityProjection_create() -> "std::shared_ptr< fast::MaximumIntensityProjection >":
    return _fast.MaximumIntensityProjection_create()


_button_callbacks = [] # Hack to avoid callbacks being deleted
def ButtonCallback(func):
    class CB(ButtonWidgetCallback):
        def __init__(self):
            super().__init__()

        def handle(self, value):
            func(value)

    obj = CB()
    _slider_callbacks.append(obj)
    return obj

class ButtonWidgetCallback(object):
    r"""
    Callback class for ButtonWidget
    Used primarily by pyFAST
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def handle(self, checked: "bool") -> "void":
        return _fast.ButtonWidgetCallback_handle(self, checked)
    __swig_destroy__ = _fast.delete_ButtonWidgetCallback

    def __init__(self):
        if self.__class__ == ButtonWidgetCallback:
            _self = None
        else:
            _self = self
        _fast.ButtonWidgetCallback_swiginit(self, _fast.new_ButtonWidgetCallback(_self, ))
    def __disown__(self):
        self.this.disown()
        _fast.disown_ButtonWidgetCallback(self)
        return weakref.proxy(self)

# Register ButtonWidgetCallback in _fast:
_fast.ButtonWidgetCallback_swigregister(ButtonWidgetCallback)

class ButtonWidget(object):
    r"""A button widget"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, text: "std::string", checkable: "bool", callback: "ButtonWidgetCallback", checked: "bool"=False, parent: "QWidget *"=None):
        _fast.ButtonWidget_swiginit(self, _fast.new_ButtonWidget(text, checkable, callback, checked, parent))

    def setChecked(self, checked: "bool") -> "void":
        return _fast.ButtonWidget_setChecked(self, checked)

    def getChecked(self) -> "bool":
        return _fast.ButtonWidget_getChecked(self)

    def getText(self) -> "std::string":
        return _fast.ButtonWidget_getText(self)
    __swig_destroy__ = _fast.delete_ButtonWidget

# Register ButtonWidget in _fast:
_fast.ButtonWidget_swigregister(ButtonWidget)

class PlaybackWidget(object):
    r"""A widget to control playback of a RandomAccessStreamer"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, streamer: "std::shared_ptr< fast::RandomAccessStreamer >", parent: "QWidget *"=None):
        _fast.PlaybackWidget_swiginit(self, _fast.new_PlaybackWidget(streamer, parent))

    def show(self) -> "void":
        return _fast.PlaybackWidget_show(self)
    __swig_destroy__ = _fast.delete_PlaybackWidget

# Register PlaybackWidget in _fast:
_fast.PlaybackWidget_swigregister(PlaybackWidget)


_slider_callbacks = [] # Hack to avoid callbacks being deleted
def SliderCallback(func):
    global _slider_callbacks
    class CB(SliderWidgetCallback):
        def __init__(self):
            super().__init__()

        def handle(self, value):
            func(value)
    obj = CB()
    _slider_callbacks.append(obj)
    return obj

class SliderWidgetCallback(object):
    r"""
    Callback class for SliderWidget
    Used primarily by pyFAST
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def handle(self, value: "float") -> "void":
        return _fast.SliderWidgetCallback_handle(self, value)
    __swig_destroy__ = _fast.delete_SliderWidgetCallback

    def __init__(self):
        if self.__class__ == SliderWidgetCallback:
            _self = None
        else:
            _self = self
        _fast.SliderWidgetCallback_swiginit(self, _fast.new_SliderWidgetCallback(_self, ))
    def __disown__(self):
        self.this.disown()
        _fast.disown_SliderWidgetCallback(self)
        return weakref.proxy(self)

# Register SliderWidgetCallback in _fast:
_fast.SliderWidgetCallback_swigregister(SliderWidgetCallback)

class SliderWidget(object):
    r"""A slider widget to change a numerical parameter"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "std::string", initial: "float", min: "float", max: "float", step: "float", callback: "SliderWidgetCallback", parent: "QWidget *"=None):
        _fast.SliderWidget_swiginit(self, _fast.new_SliderWidget(name, initial, min, max, step, callback, parent))

    def setValue(self, value: "float") -> "void":
        return _fast.SliderWidget_setValue(self, value)

    def getValue(self) -> "float":
        return _fast.SliderWidget_getValue(self)

    def getName(self) -> "std::string":
        return _fast.SliderWidget_getName(self)
    __swig_destroy__ = _fast.delete_SliderWidget

# Register SliderWidget in _fast:
_fast.SliderWidget_swigregister(SliderWidget)

class TextWidget(object):
    r"""A text widget"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, text: "std::string", parent: "QWidget *"=None):
        r"""
        Create a text widget
        :type text: string
        :param text: The text to display. Can contain HTML and also variables, e.g. {this_var}.
                 The values of the variables can be set with TextWidget::setVariable("this_var", "value");
        :type parent: QWidget
        :param parent:
        """
        _fast.TextWidget_swiginit(self, _fast.new_TextWidget(text, parent))

    def setText(self, text: "std::string") -> "void":
        r"""
        Set text
        :type text: string
        :param text: The text to display. Can contain HTML and also variables, e.g. {this_var}.
                 The values of the variables can be set with TextWidget::setVariable("this_var", "value");
        :type text: string
        :param text:
        """
        return _fast.TextWidget_setText(self, text)

    def getText(self) -> "std::string":
        return _fast.TextWidget_getText(self)

    def setVariable(self, name: "std::string", value: "std::string") -> "void":
        r"""
        Set a variable
        :type name: string
        :param name:  Name of variable, should exist as {<name>} in the text, and will be replaced with <value>
        :type value: string
        :param value:  Value of variable
        """
        return _fast.TextWidget_setVariable(self, name, value)

    def setVariables(self, variables: "StringMap") -> "void":
        r"""
        Set multiple variables
        :type variables: std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >
        :param variables: map of name and values of the variables
        """
        return _fast.TextWidget_setVariables(self, variables)

    def getVariable(self, name: "std::string") -> "std::string":
        return _fast.TextWidget_getVariable(self, name)
    __swig_destroy__ = _fast.delete_TextWidget

# Register TextWidget in _fast:
_fast.TextWidget_swigregister(TextWidget)

class FramerateSynchronizer(ProcessObject):
    r"""
    Synchronize multiple process objects
    This PO takes in N input connections and creates N output connections.
    It keeps the last frame of every connection, and every time a connection
    has a new data frame, it send out the latest frame to all output connections.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    @staticmethod
    def New() -> "std::shared_ptr< fast::FramerateSynchronizer >":
        return _fast.FramerateSynchronizer_New()

    def getNameOfClass(self) -> "std::string":
        return _fast.FramerateSynchronizer_getNameOfClass(self)

    @staticmethod
    def getStaticNameOfClass() -> "std::string":
        return _fast.FramerateSynchronizer_getStaticNameOfClass()

    def connect(self, *args) -> "std::shared_ptr< fast::FramerateSynchronizer >":
        return _fast.FramerateSynchronizer_connect(self, *args)

    @staticmethod
    def create(priorityPort: "int"=-1) -> "std::shared_ptr< fast::FramerateSynchronizer >":
        return _fast.FramerateSynchronizer_create(priorityPort)
    __swig_destroy__ = _fast.delete_FramerateSynchronizer

    def setInputConnection(self, portID: "uint", port: "fast::DataChannel::pointer") -> "void":
        return _fast.FramerateSynchronizer_setInputConnection(self, portID, port)

# Register FramerateSynchronizer in _fast:
_fast.FramerateSynchronizer_swigregister(FramerateSynchronizer)

def FramerateSynchronizer_New() -> "std::shared_ptr< fast::FramerateSynchronizer >":
    return _fast.FramerateSynchronizer_New()

def FramerateSynchronizer_getStaticNameOfClass() -> "std::string":
    return _fast.FramerateSynchronizer_getStaticNameOfClass()

def FramerateSynchronizer_create(priorityPort: "int"=-1) -> "std::shared_ptr< fast::FramerateSynchronizer >":
    return _fast.FramerateSynchronizer_create(priorityPort)

class DataHubItems(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _fast.DataHubItems_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _fast.DataHubItems___nonzero__(self)

    def __bool__(self) -> "bool":
        return _fast.DataHubItems___bool__(self)

    def __len__(self) -> "std::vector< fast::DataHub::Item >::size_type":
        return _fast.DataHubItems___len__(self)

    def __getslice__(self, i: "std::vector< fast::DataHub::Item >::difference_type", j: "std::vector< fast::DataHub::Item >::difference_type") -> "std::vector< fast::DataHub::Item,std::allocator< fast::DataHub::Item > > *":
        return _fast.DataHubItems___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _fast.DataHubItems___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< fast::DataHub::Item >::difference_type", j: "std::vector< fast::DataHub::Item >::difference_type") -> "void":
        return _fast.DataHubItems___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _fast.DataHubItems___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< fast::DataHub::Item >::value_type const &":
        return _fast.DataHubItems___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _fast.DataHubItems___setitem__(self, *args)

    def append(self, x: "DataHubItem") -> "void":
        return _fast.DataHubItems_append(self, x)

    def empty(self) -> "bool":
        return _fast.DataHubItems_empty(self)

    def size(self) -> "std::vector< fast::DataHub::Item >::size_type":
        return _fast.DataHubItems_size(self)

    def swap(self, v: "DataHubItems") -> "void":
        return _fast.DataHubItems_swap(self, v)

    def begin(self) -> "std::vector< fast::DataHub::Item >::iterator":
        return _fast.DataHubItems_begin(self)

    def end(self) -> "std::vector< fast::DataHub::Item >::iterator":
        return _fast.DataHubItems_end(self)

    def rbegin(self) -> "std::vector< fast::DataHub::Item >::reverse_iterator":
        return _fast.DataHubItems_rbegin(self)

    def rend(self) -> "std::vector< fast::DataHub::Item >::reverse_iterator":
        return _fast.DataHubItems_rend(self)

    def clear(self) -> "void":
        return _fast.DataHubItems_clear(self)

    def get_allocator(self) -> "std::vector< fast::DataHub::Item >::allocator_type":
        return _fast.DataHubItems_get_allocator(self)

    def pop_back(self) -> "void":
        return _fast.DataHubItems_pop_back(self)

    def erase(self, *args) -> "std::vector< fast::DataHub::Item >::iterator":
        return _fast.DataHubItems_erase(self, *args)

    def __init__(self, *args):
        _fast.DataHubItems_swiginit(self, _fast.new_DataHubItems(*args))

    def push_back(self, x: "DataHubItem") -> "void":
        return _fast.DataHubItems_push_back(self, x)

    def front(self) -> "std::vector< fast::DataHub::Item >::value_type const &":
        return _fast.DataHubItems_front(self)

    def back(self) -> "std::vector< fast::DataHub::Item >::value_type const &":
        return _fast.DataHubItems_back(self)

    def assign(self, n: "std::vector< fast::DataHub::Item >::size_type", x: "DataHubItem") -> "void":
        return _fast.DataHubItems_assign(self, n, x)

    def insert(self, *args) -> "void":
        return _fast.DataHubItems_insert(self, *args)

    def reserve(self, n: "std::vector< fast::DataHub::Item >::size_type") -> "void":
        return _fast.DataHubItems_reserve(self, n)

    def capacity(self) -> "std::vector< fast::DataHub::Item >::size_type":
        return _fast.DataHubItems_capacity(self)
    __swig_destroy__ = _fast.delete_DataHubItems

# Register DataHubItems in _fast:
_fast.DataHubItems_swigregister(DataHubItems)

class DataHub(object):
    r"""
    Object uses to browse and download data, models and pipelines from the FAST DataHub

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Setup DataHub object
        :type URL: string
        :param URL: Address to DataHub. If empty use default.
        :type storageDirectory: string
        :param storageDirectory: Where on disk to store downloaded items. If empty use default.
        """
        _fast.DataHub_swiginit(self, _fast.new_DataHub(*args, **kwargs))

    def getItems(self, tag: "std::string") -> "std::vector< fast::DataHub::Item,std::allocator< fast::DataHub::Item > >":
        r"""
        Get list of items for a given tag
        :type tag: string
        :param tag:
        :rtype: std::vector< fast::DataHub::Item,std::allocator< fast::DataHub::Item > >
        :return: list of items
        """
        return _fast.DataHub_getItems(self, tag)

    def getItem(self, id: "std::string") -> "fast::DataHub::Item":
        r"""
        Get item details from DataHub
        :type id: string
        :param id:
        :rtype: :py:class:`Item`
        :return: item
        """
        return _fast.DataHub_getItem(self, id)

    def download(self, itemID: "std::string", force: "bool"=False) -> "fast::DataHub::Download":
        r"""
        Download an item and all dependencies from the DataHub
        :type itemID: string
        :param itemID:
        :type force: boolean
        :param force: Force item to be downloaded (override version check)
        :rtype: :py:class:`Download`
        :return: 
        """
        return _fast.DataHub_download(self, itemID, force)

    def isDownloaded(self, itemID: "std::string") -> "bool":
        r"""
        Whether an item (including dependencies) has been downloaded or not.
        :type itemID: string
        :param itemID:
        :rtype: boolean
        :return: 
        """
        return _fast.DataHub_isDownloaded(self, itemID)

    def getStorageDirectory(self) -> "std::string":
        r"""
        Get DataHub storage directory
        :rtype: string
        :return: 
        """
        return _fast.DataHub_getStorageDirectory(self)

    def getURL(self) -> "std::string":
        r"""
        Get DataHub URL
        :rtype: string
        :return: 
        """
        return _fast.DataHub_getURL(self)

    def progress(self, fileNr: "int", percent: "int") -> "void":
        return _fast.DataHub_progress(self, fileNr, percent)

    def finished(self) -> "void":
        return _fast.DataHub_finished(self)
    __swig_destroy__ = _fast.delete_DataHub

# Register DataHub in _fast:
_fast.DataHub_swigregister(DataHub)

class DataHubItem(object):
    r"""Object representing and item on the DataHub"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    id = property(_fast.DataHubItem_id_get, _fast.DataHubItem_id_set)
    name = property(_fast.DataHubItem_name_get, _fast.DataHubItem_name_set)
    description = property(_fast.DataHubItem_description_get, _fast.DataHubItem_description_set)
    author = property(_fast.DataHubItem_author_get, _fast.DataHubItem_author_set)
    copyright = property(_fast.DataHubItem_copyright_get, _fast.DataHubItem_copyright_set)
    type = property(_fast.DataHubItem_type_get, _fast.DataHubItem_type_set)
    license = property(_fast.DataHubItem_license_get, _fast.DataHubItem_license_set)
    licenseCustom = property(_fast.DataHubItem_licenseCustom_get, _fast.DataHubItem_licenseCustom_set)
    licenseURL = property(_fast.DataHubItem_licenseURL_get, _fast.DataHubItem_licenseURL_set)
    thumbnailURL = property(_fast.DataHubItem_thumbnailURL_get, _fast.DataHubItem_thumbnailURL_set)
    downloadURL = property(_fast.DataHubItem_downloadURL_get, _fast.DataHubItem_downloadURL_set)
    minFASTVersion = property(_fast.DataHubItem_minFASTVersion_get, _fast.DataHubItem_minFASTVersion_set)
    maxFASTVersion = property(_fast.DataHubItem_maxFASTVersion_get, _fast.DataHubItem_maxFASTVersion_set)
    downloads = property(_fast.DataHubItem_downloads_get, _fast.DataHubItem_downloads_set)
    needs = property(_fast.DataHubItem_needs_get, _fast.DataHubItem_needs_set)

    def __init__(self, json: "QJsonObject"):
        r"""
        Create Item from JSON
        :type json: QJsonObject
        :param json:
        """
        _fast.DataHubItem_swiginit(self, _fast.new_DataHubItem(json))

    @staticmethod
    def fromJSONFile(pathToJSONFile: "std::string const &") -> "fast::DataHub::Item":
        r"""
        Create Item from JSON file
        :type pathToJSONFile: string
        :param pathToJSONFile:
        :rtype: :py:class:`Item`
        :return: 
        """
        return _fast.DataHubItem_fromJSONFile(pathToJSONFile)

    def toJSON(self) -> "QJsonObject":
        r"""
        Return Item as JSON
        :rtype: QJsonObject
        :return: 
        """
        return _fast.DataHubItem_toJSON(self)

    def getAllAuthors(self) -> "std::set< std::string >":
        r"""
        Get all authors of this item and dependencies
        :rtype: std::set< std::string >
        :return: authors
        """
        return _fast.DataHubItem_getAllAuthors(self)

    def getAllCopyrights(self) -> "std::set< std::string >":
        r"""
        Get all copyrights of this item and dependencies
        :rtype: std::set< std::string >
        :return: copyrights
        """
        return _fast.DataHubItem_getAllCopyrights(self)

    def getAllLicences(self) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""
        Get all licenses and URLS of this item and dependencies
        :rtype: std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >
        :return: licenses
        """
        return _fast.DataHubItem_getAllLicences(self)
    __swig_destroy__ = _fast.delete_DataHubItem

# Register DataHubItem in _fast:
_fast.DataHubItem_swigregister(DataHubItem)

def DataHubItem_fromJSONFile(pathToJSONFile: "std::string const &") -> "fast::DataHub::Item":
    r"""
    Create Item from JSON file
    :type pathToJSONFile: string
    :param pathToJSONFile:
    :rtype: :py:class:`Item`
    :return: 
    """
    return _fast.DataHubItem_fromJSONFile(pathToJSONFile)

class DataHubDownload(object):
    r"""Download results from DataHub"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    items = property(_fast.DataHubDownload_items_get, _fast.DataHubDownload_items_set)
    paths = property(_fast.DataHubDownload_paths_get, _fast.DataHubDownload_paths_set)

    def __init__(self):
        _fast.DataHubDownload_swiginit(self, _fast.new_DataHubDownload())
    __swig_destroy__ = _fast.delete_DataHubDownload

# Register DataHubDownload in _fast:
_fast.DataHubDownload_swigregister(DataHubDownload)

class DataHubBrowser(object):
    r"""A widget to browse the DataHub"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        _fast.DataHubBrowser_swiginit(self, _fast.new_DataHubBrowser(*args, **kwargs))

    def getDataHub(self) -> "fast::DataHub &":
        return _fast.DataHubBrowser_getDataHub(self)

    def downloadThumbnail(self, URL: "std::string const &") -> "QPixmap":
        return _fast.DataHubBrowser_downloadThumbnail(self, URL)

    def download(self, itemID: "std::string") -> "void":
        return _fast.DataHubBrowser_download(self, itemID)
    __swig_destroy__ = _fast.delete_DataHubBrowser

# Register DataHubBrowser in _fast:
_fast.DataHubBrowser_swigregister(DataHubBrowser)

class Pipeline(object):
    r"""A class representing a text pipeline."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        Setup a text pipeline
        :type filename: string
        :param filename: path to text pipeline file
        :type variables: :py:class:`StringMap`
        :param variables:
        """
        _fast.Pipeline_swiginit(self, _fast.new_Pipeline(*args, **kwargs))

    @staticmethod
    def fromDataHub(*args, **kwargs) -> "fast::Pipeline":
        r"""
        Create pipeline object from DataHub
        This will download the pipeline item from the DataHub and any dependencies (models, data etc.).

        :type itemID: string
        :param itemID: DataHub item ID
        :type variables: :py:class:`StringMap`
        :param variables:
        :type hub: :py:class:`DataHub`
        :param hub:
        :rtype: :py:class:`Pipeline`
        :return: pipeline
        """
        return _fast.Pipeline_fromDataHub(*args, **kwargs)

    def getViews(self) -> "std::vector< fast::View *,std::allocator< fast::View * > >":
        r"""
        Get all views in this pipeline
        :rtype: std::vector< fast::View *,std::allocator< fast::View * > >
        :return: list of views
        """
        return _fast.Pipeline_getViews(self)

    def getRenderers(self) -> "std::vector< std::shared_ptr< fast::Renderer >,std::allocator< std::shared_ptr< fast::Renderer > > >":
        r"""
        Get renderers in this pipeline
        :rtype: std::vector< std::shared_ptr< fast::Renderer >,std::allocator< std::shared_ptr< fast::Renderer > > >
        :return: list of renderers
        """
        return _fast.Pipeline_getRenderers(self)

    def getProcessObjects(self) -> "std::map< std::string,std::shared_ptr< fast::ProcessObject >,std::less< std::string >,std::allocator< std::pair< std::string const,std::shared_ptr< fast::ProcessObject > > > >":
        r"""
        Get all process objects in this pipeline, excluding renderers.
        :rtype: std::map< std::string,std::shared_ptr< fast::ProcessObject >,std::less< std::string >,std::allocator< std::pair< std::string const,std::shared_ptr< fast::ProcessObject > > > >
        :return: list of process objects
        """
        return _fast.Pipeline_getProcessObjects(self)

    def getProcessObject(self, name: "std::string") -> "std::shared_ptr< fast::ProcessObject >":
        r"""
        Get a process object in this pipeline
        :type name: string
        :param name: Name of process object to extract
        :rtype: :py:class:`ProcessObject`
        :return: process object
        """
        return _fast.Pipeline_getProcessObject(self, name)

    def getName(self) -> "std::string":
        return _fast.Pipeline_getName(self)

    def getDescription(self) -> "std::string":
        return _fast.Pipeline_getDescription(self)

    def getFilename(self) -> "std::string":
        return _fast.Pipeline_getFilename(self)

    def getPipelineAttribute(self, name: "std::string") -> "std::string":
        r"""
        Get pipeline attribute
        :param attribute: name
        :rtype: string
        :return: attribute value
        """
        return _fast.Pipeline_getPipelineAttribute(self, name)

    def getPipelineAttributes(self) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""
        Get all pipeline attributes;
        :rtype: std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >
        :return: map of attributes
        """
        return _fast.Pipeline_getPipelineAttributes(self)

    def parse(self, *args, **kwargs) -> "void":
        r"""
        Parse the pipeline file

        :type inputData: :py:class:`DataMap`
        :param inputData: Input data objects
        :type processObjects: :py:class:`ProcessObjectMap`
        :param processObjects: Process objects to connect to this pipeline
        :type visualization: boolean
        :param visualization: If false parse will ignore any renderers and views
        """
        return _fast.Pipeline_parse(self, *args, **kwargs)

    def isParsed(self) -> "bool":
        r"""
        Check if pipeline has been parsed
        :rtype: boolean
        :return: 
        """
        return _fast.Pipeline_isParsed(self)

    def run(self, *args, **kwargs) -> "std::map< std::string,fast::DataObject::pointer,std::less< std::string >,std::allocator< std::pair< std::string const,fast::DataObject::pointer > > >":
        r"""
        Parse and run this pipeline. If pipeline contains views, it will open a window and render.

        :type inputData: :py:class:`DataMap`
        :param inputData: Input data objects
        :type processObjects: :py:class:`ProcessObjectMap`
        :param processObjects: Process objects to connect to this pipeline
        :type visualization: boolean
        :param visualization: If false parse will ignore any renderers and views
        :rtype: std::map< std::string,fast::DataObject::pointer,std::less< std::string >,std::allocator< std::pair< std::string const,fast::DataObject::pointer > > >
        :return: pipeline output data
        """
        return _fast.Pipeline_run(self, *args, **kwargs)

    def getRequiredPipelineInputData(self) -> "std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >":
        r"""
        Get list of all required input data for this pipeline
        :rtype: std::map< std::string,std::string,std::less< std::string >,std::allocator< std::pair< std::string const,std::string > > >
        :return: 
        """
        return _fast.Pipeline_getRequiredPipelineInputData(self)

    def getAllPipelineOutputData(self) -> "std::map< std::string,fast::DataObject::pointer,std::less< std::string >,std::allocator< std::pair< std::string const,fast::DataObject::pointer > > >":
        r"""
        Get all data objects which has been declared as output data in this pipeline

        Pipeline output data is declared using "PipelineOutputData <name> <process object> <output port id>"
        This function will block until done.

        :rtype: std::map< std::string,fast::DataObject::pointer,std::less< std::string >,std::allocator< std::pair< std::string const,fast::DataObject::pointer > > >
        :return: map of pipeline output data
        """
        return _fast.Pipeline_getAllPipelineOutputData(self)

    def getPipelineOutputData(self, name: "std::string") -> "fast::DataObject::pointer":
        r"""
        Get data object which has been declared as output data in this pipeline with a given name.

        Pipeline output data is declared using "PipelineOutputData <name> <process object> <output port id>"
        This function will block until done.

        :rtype: :py:class:`DataObject`
        :return: pipeline output data object
        """
        return _fast.Pipeline_getPipelineOutputData(self, name)

    def hasWindow(self) -> "bool":
        r"""
        Check whether pipeline has a window specified or not
        :rtype: boolean
        :return: If pipeline has defined a pipeline
        """
        return _fast.Pipeline_hasWindow(self)

    def getWindow(self) -> "std::shared_ptr< fast::Window >":
        r"""
        Get window defined in pipeline. If none is defined it will be a nullptr
        :rtype: :py:class:`Window`
        :return: Window defined in pipeline, null if none was defined.
        """
        return _fast.Pipeline_getWindow(self)
    __swig_destroy__ = _fast.delete_Pipeline

# Register Pipeline in _fast:
_fast.Pipeline_swigregister(Pipeline)

def Pipeline_fromDataHub(*args, **kwargs) -> "fast::Pipeline":
    r"""
    Create pipeline object from DataHub
    This will download the pipeline item from the DataHub and any dependencies (models, data etc.).

    :type itemID: string
    :param itemID: DataHub item ID
    :type variables: :py:class:`StringMap`
    :param variables:
    :type hub: :py:class:`DataHub`
    :param hub:
    :rtype: :py:class:`Pipeline`
    :return: pipeline
    """
    return _fast.Pipeline_fromDataHub(*args, **kwargs)


def getAvailablePipelines(*args, **kwargs) -> "std::vector< fast::Pipeline,std::allocator< fast::Pipeline > >":
    r"""
    Retrieve a list of all pipelines stored in .fpl files in the specified pipeline directory
    :rtype: std::vector< fast::Pipeline,std::allocator< fast::Pipeline > >
    :return: 
    """
    return _fast.getAvailablePipelines(*args, **kwargs)
class DataStream:
    def __init__(self, *args):
        self._processObjects = args;
        self._ports = []
        self.finished = False
        self._executeToken = 0
        for po in self._processObjects:
            for i in range(po.getNrOfOutputPorts()):
                self._ports.append(po.getOutputPort(i))
        if len(self._ports) == 0:
            raise Exception('Can\'t create data stream (getDataStream) on a process object with 0 output ports')
    def __iter__(self):
        return self
    def __next__(self):
        if self.finished:
            raise StopIteration

        for port in self._ports:
            port.getProcessObject().run(self._executeToken)
        self._executeToken += 1
        if self._executeToken < 0:
            self._executeToken = 0
        result = []
        for port in self._ports:
            data = port.getNextFrame()
            if data.isLastFrame(): self.finished = True
            result.append(data)
        if len(result) == 1:
            return result[0]
        else:
            return result

"""
A few shortcut functions
"""
from typing import Dict, Union
import fast

def _set_default_shorcut_value(x, default):
    return default if x is None else x

def display2D(
            image:Union[Image, ProcessObject]=None,
            segmentation:Union[Image, ProcessObject]=None,
            imagePyramid:Union[ImagePyramid, ProcessObject]=None,
            lines:Union[Mesh, ProcessObject]=None,
            vertices: Union[Mesh, ProcessObject]=None,
            intensityLevel:float=None,
            intensityWindow:float=None,
            segmentationColors:Dict[int, Color]=None,
            segmentationOpacity:float=0.5,
            segmentationBorderOpacity:float=None,
            segmentationBorderRadius:int=1,
            lineWidth:float=1,
            lineColor:Color=Color.Green(),
            vertexSize:float=10.0,
            vertexSizeIsInPixels:bool=True,
            vertexMinSize:float=1.0,
            vertexColor:Color=Color.Null(),
            vertexOpacity:float=1.0,
            bgcolor:Color=Color.White(),
            width:int=None,
            height:int=None,
            timeout:int=None,
            renderToImage:bool=False,
            returnWindow:bool=False,
            widgets:Union[List, Dict[int, List]]=None,
        ):
    """
    Shortcut for displaying image, segmentation and meshes using SimpleWindow2D

    :param image: Image to display
    :param segmentation: Segmentation to display
    :param imagePyramid: ImagePyramid to display
    :param lines: Lines to display
    :param vertices: Vertices to display
    :param intensityLevel: Intensity level for image rendering
    :param intensityWindow: Intensity window for image rendering
    :param segmentationColors: Colors to use for segmentation
    :param segmentationOpacity: Opacity of segmentation
    :param segmentationBorderOpacity: Border opacity of segmentation
    :param segmentationBorderRadius: Size of segmentation border
    :param lineWidth: Width of line
    :param lineColor: Color of line
    :param vertexSize Vertex point size (can be in pixels or millimeters, see sizeIsInPixels parameter)
    :param vertexSizeIsInPixels Whether size is given in pixels or millimeters
    :param vertexMinSize Minimum size in pixels, used when sizeInPixels = false
    :param vertexColor Override color stored for each vertex
    :param vertexOpacity Opacity of vertices: 1 = no transparency, 0 = fully transparent
    :param bgcolor: Background color
    :param width: Width of window
    :param height: Height of window
    :param timeout: If set to a number, the window will auto close after this many milliseconds
    :param renderToImage: Use RenderToImage instead of SimpleWindow and return the resulting image
    :param returnWindow: Whether to return the window object, or to run it
    :param widgets: Widgets to connect to the window
    :return: window if returnWindow is set to True, else None
    """

    if image is None and imagePyramid is None and segmentation is None and lines is None and vertices is None:
        raise ValueError('No data was given to display2D')


    width = _set_default_shorcut_value(width, 0)
    height = _set_default_shorcut_value(height, 0)
    intensityLevel = _set_default_shorcut_value(intensityLevel, -1)
    intensityWindow = _set_default_shorcut_value(intensityWindow, -1)
    segmentationColors = _set_default_shorcut_value(segmentationColors, LabelColors())
    segmentationBorderOpacity = _set_default_shorcut_value(segmentationBorderOpacity, -1)

    renderers = []

    if image is not None:
        renderer = ImageRenderer.create(
            level=intensityLevel,
            window=intensityWindow
        ).connect(image)
        renderers.append(renderer)

    if imagePyramid is not None:
        renderer = ImagePyramidRenderer.create(
        ).connect(imagePyramid)
        renderers.append(renderer)

    if segmentation is not None:
        renderer = SegmentationRenderer.create(
            colors=segmentationColors,
            opacity=segmentationOpacity,
            borderOpacity=segmentationBorderOpacity,
            borderRadius=segmentationBorderRadius
        ).connect(segmentation)
        renderers.append(renderer)

    if lines is not None:
        renderer = LineRenderer.create(
            lineWidth=lineWidth,
            color=lineColor
        ).connect(lines)
        renderers.append(renderer)

    if vertices is not None:
        renderer = VertexRenderer.create(
            size=vertexSize,
            sizeIsInPixels=vertexSizeIsInPixels,
            minSize=vertexMinSize,
            color=vertexColor,
            opacity=vertexOpacity,
        ).connect(vertices)
        renderers.append(renderer)

    if renderToImage:
        render = RenderToImage.create(
            bgcolor=bgcolor,
            width=width,
            height=height
        ).connect(renderers)
        return render.runAndGetOutputData()
    else:
        window = SimpleWindow2D.create(
            bgcolor=bgcolor,
            width=width,
            height=height
        ).connect(renderers)
        if widgets:
            if isinstance(widgets, dict):
                for pos, widget_list in widgets.items():
                    window.connect(widget_list, pos)
            else:
                window.connect(widgets)
        if timeout:
            window.setTimeout(timeout)
        if returnWindow:
            return window
        else:
            window.run()


from enum import Enum
class DisplayType(Enum):
    SLICER = 1
    ALPHA_BLENDING = 2
    MAXIMUM_INTENSITY_PROJECTION = 3

def display3D(
        image:Union[Image, ProcessObject]=None,
        segmentation:Union[Image, ProcessObject]=None,
        intensityLevel:float=None,
        intensityWindow:float=None,
        segmentationColors:Dict[int, Color]=None,
        segmentationOpacity:float=0.5,
        segmentationBorderOpacity:float=None,
        segmentationBorderRadius:int=1,
        transferFunction:TransferFunction=None,
        displayType:DisplayType=DisplayType.SLICER,
        bgcolor:Color=Color.White(),
        width:int=None,
        height:int=None,
        timeout:int=None,
        returnWindow:bool=False,
        widgets:Union[List, Dict[int, List]]=None,
        ):
    """
    Shortcut for displaying image, segmentation and meshes using SimpleWindow2D

    TODO:
        * Surface extraction or threshold volume rendering?
        * Mesh support: Vertices, lines and triangles

    :param image: Image to display
    :param segmentation: Segmentation to display
    :param bgcolor: Background color
    :param width: Width of window
    :param height: Height of window
    :param timeout: If set to a number, the window will auto close after this many milliseconds
    :param returnWindow: Whether to return the window object, or to run it
    :param widgets: Widgets to connect to the window
    :return: window if returnWindow is set to True, else None
    """

    width = _set_default_shorcut_value(width, 0)
    height = _set_default_shorcut_value(height, 0)
    intensityLevel = _set_default_shorcut_value(intensityLevel, -1)
    intensityWindow = _set_default_shorcut_value(intensityWindow, -1)
    segmentationColors = _set_default_shorcut_value(segmentationColors, LabelColors())
    segmentationBorderOpacity = _set_default_shorcut_value(segmentationBorderOpacity, -1)
    transferFunction = _set_default_shorcut_value(transferFunction, TransferFunction())

    if displayType == DisplayType.SLICER:
        window = fast.SlicerWindow.create(bgcolor=bgcolor, width=width, height=height)
        if image is not None:
            window.connectImage(image, intensityLevel, intensityWindow)

        if segmentation is not None:
            window.connectSegmentation(
                segmentation,
                colors=segmentationColors,
                opacity=segmentationOpacity,
                borderOpacity=segmentationBorderOpacity,
                borderRadius=segmentationBorderRadius
            )

    else:
        window = fast.SimpleWindow3D.create(bgcolor=bgcolor, width=width, height=height)
        if displayType == DisplayType.MAXIMUM_INTENSITY_PROJECTION:
            renderer = fast.MaximumIntensityProjection.create().connect(image)
            window.connect(renderer)
        elif displayType == DisplayType.ALPHA_BLENDING:
            renderer = fast.AlphaBlendingVolumeRenderer.create(transferFunction).connect(image)
            window.connect(renderer)

    if timeout is not None:
        window.setTimeout(timeout)
    if widgets:
        if isinstance(widgets, dict):
            for pos, widget_list in widgets.items():
                window.connect(widget_list, pos)
        else:
            window.connect(widgets)
    if returnWindow:
        return window
    else:
        window.run()


class PythonProcessObject(ProcessObject):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def execute(self) -> "void":
        return _fast.PythonProcessObject_execute(self)

    def getNameOfClass(self) -> "std::string":
        return _fast.PythonProcessObject_getNameOfClass(self)
    __swig_destroy__ = _fast.delete_PythonProcessObject
    m_hack = property(_fast.PythonProcessObject_m_hack_get, _fast.PythonProcessObject_m_hack_set)

    def __init__(self):
        if self.__class__ == PythonProcessObject:
            _self = None
        else:
            _self = self
        _fast.PythonProcessObject_swiginit(self, _fast.new_PythonProcessObject(_self, ))

    def setInputConnection(self, *args) -> "void":
        return _fast.PythonProcessObject_setInputConnection(self, *args)

    def setInputData(self, *args) -> "void":
        return _fast.PythonProcessObject_setInputData(self, *args)

    def getOutputPort(self, portID: "uint"=0) -> "fast::DataChannel::pointer":
        return _fast.PythonProcessObject_getOutputPort(self, portID)

    def addOutputData(self, port: "int", image: "std::shared_ptr< fast::DataObject >") -> "void":
        return _fast.PythonProcessObject_addOutputData(self, port, image)

    def _getInputData(self, port: "int"=0) -> "fast::DataObject::pointer":
        return _fast.PythonProcessObject__getInputData(self, port)

    def createInputPort(self, port: "int") -> "void":
        return _fast.PythonProcessObject_createInputPort(self, port)

    def createOutputPort(self, port: "int") -> "void":
        return _fast.PythonProcessObject_createOutputPort(self, port)

    def stopPipeline(self) -> "void":
        return _fast.PythonProcessObject_stopPipeline(self)
    @classmethod
    def create(cls, *args, **kwargs):
        instance = cls(*args, **kwargs)
    # This is hack for solving the problem with PythonProcessObjects being deleted too early
    # For instance in this case:
    # a = SomePythonPO.create()
    # b = SomeOtherPO.create().connect(a)
    # a = SomeOtherPO.create().connect(b) # Variable is overwritten, and gets deleted here, even though b has a reference to it..
    # This hack will however result in the PO never being deleted..
    # See section 32.5.3 here: https://swig.org/Doc4.0/Python.html
        return instance.__disown__() # Returns a weak reference


    def getInputData(self, portID:int=0):
        val = self._getInputData(portID)
        className = val.getNameOfClass()
        val = eval(className + '.fromDataObject')(val)
        return val


    def connect(self, *args):
        inputPortID = 0
        outputPortID = 0
        if len(args) == 1:
            parentProcessObject = args[0]
        elif len(args) == 2:
            if isinstance(args[0], int):
                inputPortID = int(args[0])
                parentProcessObject = args[1]
            else:
                parentProcessObject = args[0]
                outputPortID = int(args[1])
        elif len(args) == 3:
            inputPortID = int(args[0])
            parentProcessObject = args[1]
            outputPortID = int(args[2])
        else:
            raise TypeError("Incorrect arguemnts to connect()")

        if isinstance(parentProcessObject, DataObject):
            super().connect(inputPortID, parentProcessObject) # There is no output port id we are trying to connect to a dataobject
        else:
            super().connect(inputPortID, parentProcessObject, outputPortID)
        return self

    def __disown__(self):
        self.this.disown()
        _fast.disown_PythonProcessObject(self)
        return weakref.proxy(self)

    def preExecute(self) -> "void":
        return _fast.PythonProcessObject_preExecute(self)

    def postExecute(self) -> "void":
        return _fast.PythonProcessObject_postExecute(self)

    def waitToFinish(self) -> "void":
        return _fast.PythonProcessObject_waitToFinish(self)

# Register PythonProcessObject in _fast:
_fast.PythonProcessObject_swigregister(PythonProcessObject)

class PythonStreamer(Streamer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def generateStream(self) -> "void":
        return _fast.PythonStreamer_generateStream(self)

    def getNameOfClass(self) -> "std::string":
        return _fast.PythonStreamer_getNameOfClass(self)
    __swig_destroy__ = _fast.delete_PythonStreamer
    m_hack = property(_fast.PythonStreamer_m_hack_get, _fast.PythonStreamer_m_hack_set)

    def __init__(self):
        if self.__class__ == PythonStreamer:
            _self = None
        else:
            _self = self
        _fast.PythonStreamer_swiginit(self, _fast.new_PythonStreamer(_self, ))

    def isStopped(self) -> "bool":
        return _fast.PythonStreamer_isStopped(self)

    def stop(self) -> "void":
        return _fast.PythonStreamer_stop(self)

    def addOutputData(self, port: "int", image: "std::shared_ptr< fast::DataObject >") -> "void":
        return _fast.PythonStreamer_addOutputData(self, port, image)

    def _getInputData(self, port: "int"=0) -> "fast::DataObject::pointer":
        return _fast.PythonStreamer__getInputData(self, port)

    def getOutputPort(self, portID: "uint"=0) -> "fast::DataChannel::pointer":
        return _fast.PythonStreamer_getOutputPort(self, portID)

    def createInputPort(self, port: "int") -> "void":
        return _fast.PythonStreamer_createInputPort(self, port)

    def createOutputPort(self, port: "int") -> "void":
        return _fast.PythonStreamer_createOutputPort(self, port)

    def frameAdded(self) -> "void":
        return _fast.PythonStreamer_frameAdded(self)

    def stopPipeline(self) -> "void":
        return _fast.PythonStreamer_stopPipeline(self)
    @classmethod
    def create(cls, *args, **kwargs):
        instance = cls(*args, **kwargs)
    # This is hack for solving the problem with PythonProcessObjects being deleted too early
    # For instance in this case:
    # a = SomePythonPO.create()
    # b = SomeOtherPO.create().connect(a)
    # a = SomeOtherPO.create().connect(b) # Variable is overwritten, and gets deleted here, even though b has a reference to it..
    # This hack will however result in the PO never being deleted..
    # See section 32.5.3 here: https://swig.org/Doc4.0/Python.html
        return instance.__disown__() # Returns a weak reference


    def getInputData(self, portID:int=0):
        val = self._getInputData(portID)
        className = val.getNameOfClass()
        val = eval(className + '.fromDataObject')(val)
        return val


    def connect(self, *args):
        inputPortID = 0
        outputPortID = 0
        if len(args) == 1:
            parentProcessObject = args[0]
        elif len(args) == 2:
            if isinstance(args[0], int):
                inputPortID = int(args[0])
                parentProcessObject = args[1]
            else:
                parentProcessObject = args[0]
                outputPortID = int(args[1])
        elif len(args) == 3:
            inputPortID = int(args[0])
            parentProcessObject = args[1]
            outputPortID = int(args[2])
        else:
            raise TypeError("Incorrect arguemnts to connect()")

        if isinstance(parentProcessObject, DataObject):
            super().connect(inputPortID, parentProcessObject) # There is no output port id we are trying to connect to a dataobject
        else:
            super().connect(inputPortID, parentProcessObject, outputPortID)
        return self

    def __disown__(self):
        self.this.disown()
        _fast.disown_PythonStreamer(self)
        return weakref.proxy(self)

    def preExecute(self) -> "void":
        return _fast.PythonStreamer_preExecute(self)

    def postExecute(self) -> "void":
        return _fast.PythonStreamer_postExecute(self)

    def waitToFinish(self) -> "void":
        return _fast.PythonStreamer_waitToFinish(self)

# Register PythonStreamer in _fast:
_fast.PythonStreamer_swigregister(PythonStreamer)

class PythonRandomAccessStreamer(RandomAccessStreamer):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def generateStream(self) -> "void":
        return _fast.PythonRandomAccessStreamer_generateStream(self)

    def getNrOfFrames(self) -> "int":
        return _fast.PythonRandomAccessStreamer_getNrOfFrames(self)

    def getNameOfClass(self) -> "std::string":
        return _fast.PythonRandomAccessStreamer_getNameOfClass(self)
    __swig_destroy__ = _fast.delete_PythonRandomAccessStreamer
    m_hack = property(_fast.PythonRandomAccessStreamer_m_hack_get, _fast.PythonRandomAccessStreamer_m_hack_set)

    def __init__(self):
        if self.__class__ == PythonRandomAccessStreamer:
            _self = None
        else:
            _self = self
        _fast.PythonRandomAccessStreamer_swiginit(self, _fast.new_PythonRandomAccessStreamer(_self, ))

    def isStopped(self) -> "bool":
        return _fast.PythonRandomAccessStreamer_isStopped(self)

    def stop(self) -> "void":
        return _fast.PythonRandomAccessStreamer_stop(self)

    def addOutputData(self, port: "int", image: "std::shared_ptr< fast::DataObject >") -> "void":
        return _fast.PythonRandomAccessStreamer_addOutputData(self, port, image)

    def _getInputData(self, port: "int"=0) -> "fast::DataObject::pointer":
        return _fast.PythonRandomAccessStreamer__getInputData(self, port)

    def getOutputPort(self, portID: "uint"=0) -> "fast::DataChannel::pointer":
        return _fast.PythonRandomAccessStreamer_getOutputPort(self, portID)

    def createInputPort(self, port: "int") -> "void":
        return _fast.PythonRandomAccessStreamer_createInputPort(self, port)

    def createOutputPort(self, port: "int") -> "void":
        return _fast.PythonRandomAccessStreamer_createOutputPort(self, port)

    def frameAdded(self) -> "void":
        return _fast.PythonRandomAccessStreamer_frameAdded(self)

    def getCurrentFrameIndex(self) -> "int":
        return _fast.PythonRandomAccessStreamer_getCurrentFrameIndex(self)

    def getCurrentFrameIndexAndUpdate(self) -> "int":
        return _fast.PythonRandomAccessStreamer_getCurrentFrameIndexAndUpdate(self)

    def setPause(self, pause: "bool") -> "void":
        return _fast.PythonRandomAccessStreamer_setPause(self, pause)

    def getLooping(self) -> "bool":
        return _fast.PythonRandomAccessStreamer_getLooping(self)

    def setLooping(self, loop: "bool") -> "void":
        return _fast.PythonRandomAccessStreamer_setLooping(self, loop)

    def setCurrentFrameIndex(self, i: "int") -> "void":
        return _fast.PythonRandomAccessStreamer_setCurrentFrameIndex(self, i)

    def getFramerate(self) -> "int":
        return _fast.PythonRandomAccessStreamer_getFramerate(self)

    def setFramerate(self, framerate: "int") -> "void":
        return _fast.PythonRandomAccessStreamer_setFramerate(self, framerate)

    def stopPipeline(self) -> "void":
        return _fast.PythonRandomAccessStreamer_stopPipeline(self)
    @classmethod
    def create(cls, *args, **kwargs):
        instance = cls(*args, **kwargs)
    # This is hack for solving the problem with PythonProcessObjects being deleted too early
    # For instance in this case:
    # a = SomePythonPO.create()
    # b = SomeOtherPO.create().connect(a)
    # a = SomeOtherPO.create().connect(b) # Variable is overwritten, and gets deleted here, even though b has a reference to it..
    # This hack will however result in the PO never being deleted..
    # See section 32.5.3 here: https://swig.org/Doc4.0/Python.html
        return instance.__disown__() # Returns a weak reference


    def getInputData(self, portID:int=0):
        val = self._getInputData(portID)
        className = val.getNameOfClass()
        val = eval(className + '.fromDataObject')(val)
        return val


    def connect(self, *args):
        inputPortID = 0
        outputPortID = 0
        if len(args) == 1:
            parentProcessObject = args[0]
        elif len(args) == 2:
            if isinstance(args[0], int):
                inputPortID = int(args[0])
                parentProcessObject = args[1]
            else:
                parentProcessObject = args[0]
                outputPortID = int(args[1])
        elif len(args) == 3:
            inputPortID = int(args[0])
            parentProcessObject = args[1]
            outputPortID = int(args[2])
        else:
            raise TypeError("Incorrect arguemnts to connect()")

        if isinstance(parentProcessObject, DataObject):
            super().connect(inputPortID, parentProcessObject) # There is no output port id we are trying to connect to a dataobject
        else:
            super().connect(inputPortID, parentProcessObject, outputPortID)
        return self

    def __disown__(self):
        self.this.disown()
        _fast.disown_PythonRandomAccessStreamer(self)
        return weakref.proxy(self)

    def preExecute(self) -> "void":
        return _fast.PythonRandomAccessStreamer_preExecute(self)

    def postExecute(self) -> "void":
        return _fast.PythonRandomAccessStreamer_postExecute(self)

    def waitToFinish(self) -> "void":
        return _fast.PythonRandomAccessStreamer_waitToFinish(self)

# Register PythonRandomAccessStreamer in _fast:
_fast.PythonRandomAccessStreamer_swigregister(PythonRandomAccessStreamer)



