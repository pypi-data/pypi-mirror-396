{
  "name": "React Hooks - Good Implementation",
  "description": "Comprehensive React hooks answer. Should get votes on lenient/balanced.",
  "original_message": "How do I properly use useEffect with async functions in React?",
  "existing_answers": {
    "agent_a": "To use async functions with useEffect in React, you need to define the async function inside useEffect and then call it, since useEffect itself can't be async. Here's the proper pattern:\n\n```jsx\nimport { useEffect, useState } from 'react';\n\nfunction MyComponent() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    // Define async function inside useEffect\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch('https://api.example.com/data');\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const result = await response.json();\n        setData(result);\n        setError(null);\n      } catch (err) {\n        setError(err.message);\n        setData(null);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    // Call the async function\n    fetchData();\n  }, []); // Empty dependency array means run once on mount\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  return <div>{JSON.stringify(data)}</div>;\n}\n```\n\n**Key points:**\n- Don't make useEffect itself async: ~~`useEffect(async () => {...})`~~ ❌\n- Define async function inside and call it ✓\n- Handle loading states and errors properly\n- Remember cleanup for things like AbortController if needed\n- Include dependencies in the dependency array\n\n**With cleanup (for canceling requests):**\n```jsx\nuseEffect(() => {\n  const abortController = new AbortController();\n  \n  const fetchData = async () => {\n    try {\n      const response = await fetch('https://api.example.com/data', {\n        signal: abortController.signal\n      });\n      const result = await response.json();\n      setData(result);\n    } catch (err) {\n      if (err.name !== 'AbortError') {\n        setError(err.message);\n      }\n    }\n  };\n  \n  fetchData();\n  \n  // Cleanup function\n  return () => {\n    abortController.abort();\n  };\n}, []);\n```\n\nThis pattern prevents memory leaks and race conditions when the component unmounts or re-renders."
  },
  "expected_behavior": {
    "lenient": "vote (comprehensive, shows correct pattern, includes error handling and cleanup)",
    "balanced": "vote (covers the key use case thoroughly)",
    "strict": "vote or new_answer (could add custom hooks pattern, more edge cases, dependency array nuances)"
  }
}
