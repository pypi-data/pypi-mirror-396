"""
gitcloakd GPG Key Management
Handles GPG key generation, publishing, and management
"""

import subprocess
from pathlib import Path
from typing import Optional, List, Dict, Any, Tuple
from datetime import datetime
import gnupg


class GPGManager:
    """Manages GPG keys for gitcloakd."""

    # Common keyservers
    KEYSERVERS = [
        "keyserver.ubuntu.com",
        "keys.openpgp.org",
        "pgp.mit.edu",
        "keys.gnupg.net",
    ]

    def __init__(self, gnupghome: Optional[str] = None):
        """Initialize GPG manager."""
        self.gpg = gnupg.GPG(gnupghome=gnupghome)

    def list_keys(self, secret: bool = False) -> List[Dict[str, Any]]:
        """
        List GPG keys.

        Args:
            secret: If True, list secret (private) keys

        Returns:
            List of key information dictionaries
        """
        keys = self.gpg.list_keys(secret=secret)
        result = []

        for key in keys:
            key_info = {
                "keyid": key["keyid"],
                "fingerprint": key["fingerprint"],
                "uids": key["uids"],
                "date": key["date"],
                "expires": key.get("expires", "never"),
                "trust": key.get("trust", "unknown"),
                "length": key.get("length", "unknown"),
                "algo": key.get("algo", "unknown"),
            }
            result.append(key_info)

        return result

    def get_key(self, key_id: str) -> Optional[Dict[str, Any]]:
        """Get information about a specific key."""
        keys = self.gpg.list_keys(keys=[key_id])
        if keys:
            key = keys[0]
            return {
                "keyid": key["keyid"],
                "fingerprint": key["fingerprint"],
                "uids": key["uids"],
                "date": key["date"],
                "expires": key.get("expires", "never"),
                "trust": key.get("trust", "unknown"),
            }
        return None

    def generate_key(
        self,
        name: str,
        email: str,
        passphrase: Optional[str] = None,
        key_type: str = "RSA",
        key_length: int = 4096,
        expire_date: str = "2y",
        comment: str = "Generated by gitcloakd"
    ) -> Tuple[str, str]:
        """
        Generate a new GPG key pair.

        Args:
            name: Real name for the key
            email: Email address for the key
            passphrase: Passphrase for the key (None for no passphrase)
            key_type: Key type (RSA, DSA, etc.)
            key_length: Key length in bits
            expire_date: Expiration (0 for never, or like "2y", "6m")
            comment: Comment for the key

        Returns:
            Tuple of (key_id, fingerprint)
        """
        # Create key input
        key_input = self.gpg.gen_key_input(
            key_type=key_type,
            key_length=key_length,
            name_real=name,
            name_email=email,
            name_comment=comment,
            expire_date=expire_date,
            passphrase=passphrase,
        )

        # Generate key
        key = self.gpg.gen_key(key_input)

        if not key:
            raise RuntimeError("Failed to generate GPG key")

        return str(key), key.fingerprint

    def export_public_key(self, key_id: str, armor: bool = True) -> str:
        """
        Export a public key.

        Args:
            key_id: Key ID or fingerprint
            armor: If True, return ASCII-armored key

        Returns:
            Exported public key
        """
        return self.gpg.export_keys(key_id, armor=armor)

    def export_private_key(
        self,
        key_id: str,
        passphrase: Optional[str] = None,
        armor: bool = True
    ) -> str:
        """
        Export a private key.

        Args:
            key_id: Key ID or fingerprint
            passphrase: Passphrase for the key
            armor: If True, return ASCII-armored key

        Returns:
            Exported private key
        """
        return self.gpg.export_keys(
            key_id,
            secret=True,
            armor=armor,
            passphrase=passphrase
        )

    def import_key(self, key_data: str) -> Dict[str, Any]:
        """
        Import a GPG key.

        Args:
            key_data: ASCII-armored key data

        Returns:
            Import result
        """
        result = self.gpg.import_keys(key_data)
        return {
            "count": result.count,
            "fingerprints": result.fingerprints,
            "results": result.results,
        }

    def import_key_from_file(self, file_path: str) -> Dict[str, Any]:
        """Import a GPG key from a file."""
        with open(file_path, "r") as f:
            key_data = f.read()
        return self.import_key(key_data)

    def publish_key(
        self,
        key_id: str,
        keyserver: Optional[str] = None
    ) -> bool:
        """
        Publish a key to a keyserver.

        Args:
            key_id: Key ID or fingerprint to publish
            keyserver: Keyserver URL (default: keyserver.ubuntu.com)

        Returns:
            True if successful
        """
        if keyserver is None:
            keyserver = self.KEYSERVERS[0]

        try:
            subprocess.run(
                [
                    "gpg",
                    "--keyserver", keyserver,
                    "--send-keys", key_id
                ],
                capture_output=True,
                text=True,
                check=True
            )
            return True
        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"Failed to publish key: {e.stderr}")

    def search_keyserver(
        self,
        query: str,
        keyserver: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        Search for keys on a keyserver.

        Args:
            query: Search query (email, name, or key ID)
            keyserver: Keyserver URL

        Returns:
            List of matching keys
        """
        if keyserver is None:
            keyserver = self.KEYSERVERS[0]

        try:
            result = subprocess.run(
                [
                    "gpg",
                    "--keyserver", keyserver,
                    "--search-keys", query
                ],
                capture_output=True,
                text=True,
                timeout=30
            )
            # Parse output (this is simplified)
            return [{"query": query, "output": result.stdout}]
        except subprocess.TimeoutExpired:
            return []
        except subprocess.CalledProcessError:
            return []

    def fetch_key(
        self,
        key_id: str,
        keyserver: Optional[str] = None
    ) -> bool:
        """
        Fetch a key from a keyserver.

        Args:
            key_id: Key ID to fetch
            keyserver: Keyserver URL

        Returns:
            True if successful
        """
        if keyserver is None:
            keyserver = self.KEYSERVERS[0]

        try:
            subprocess.run(
                [
                    "gpg",
                    "--keyserver", keyserver,
                    "--recv-keys", key_id
                ],
                capture_output=True,
                text=True,
                check=True
            )
            return True
        except subprocess.CalledProcessError as e:
            raise RuntimeError(f"Failed to fetch key: {e.stderr}")

    def delete_key(self, key_id: str, secret: bool = False) -> bool:
        """
        Delete a GPG key.

        Args:
            key_id: Key ID to delete
            secret: If True, delete secret key

        Returns:
            True if successful
        """
        if secret:
            result = self.gpg.delete_keys(key_id, secret=True)
        else:
            result = self.gpg.delete_keys(key_id)

        return result.ok

    def trust_key(self, key_id: str, trust_level: str = "ultimate") -> bool:
        """
        Set trust level for a key.

        Args:
            key_id: Key ID to trust
            trust_level: Trust level (unknown, never, marginal, full, ultimate)

        Returns:
            True if successful
        """
        trust_map = {
            "unknown": "1",
            "never": "2",
            "marginal": "3",
            "full": "4",
            "ultimate": "5",
        }

        trust_value = trust_map.get(trust_level, "5")

        try:
            # Use gpg command directly for trust
            process = subprocess.Popen(
                ["gpg", "--edit-key", key_id, "trust"],
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            process.communicate(input=f"{trust_value}\ny\nquit\n")
            return True
        except Exception:
            return False

    def verify_key(self, key_id: str) -> Dict[str, Any]:
        """
        Verify a key's validity and signatures.

        Args:
            key_id: Key ID to verify

        Returns:
            Verification results
        """
        key = self.get_key(key_id)
        if not key:
            return {"valid": False, "error": "Key not found"}

        # Check expiration
        expires = key.get("expires", "")
        is_expired = False
        if expires and expires != "never":
            try:
                exp_timestamp = int(expires)
                is_expired = exp_timestamp < datetime.now().timestamp()
            except ValueError:
                pass

        return {
            "valid": not is_expired,
            "key_id": key["keyid"],
            "fingerprint": key["fingerprint"],
            "expires": expires,
            "is_expired": is_expired,
            "trust": key.get("trust", "unknown"),
        }

    def backup_keys(self, output_dir: str, key_ids: Optional[List[str]] = None) -> List[str]:
        """
        Backup GPG keys to files.

        Args:
            output_dir: Directory to save backups
            key_ids: Specific keys to backup (None for all)

        Returns:
            List of backup file paths
        """
        output_path = Path(output_dir)
        output_path.mkdir(parents=True, exist_ok=True)

        if key_ids is None:
            keys = self.list_keys(secret=True)
            key_ids = [k["keyid"] for k in keys]

        backup_files = []
        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")

        for key_id in key_ids:
            # Export public key
            pub_key = self.export_public_key(key_id)
            pub_file = output_path / f"{key_id}-public-{timestamp}.asc"
            pub_file.write_text(pub_key)
            backup_files.append(str(pub_file))

            # Export private key
            try:
                priv_key = self.export_private_key(key_id)
                priv_file = output_path / f"{key_id}-private-{timestamp}.asc"
                priv_file.write_text(priv_key)
                priv_file.chmod(0o600)
                backup_files.append(str(priv_file))
            except Exception:
                pass  # May not have permission to export private key

        return backup_files
