# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "clients.baml": "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n\n// This is a stub client definition.\n// Actual provider clients (with real implementations) are selected and\n// instantiated at runtime based on the config/env\nclient<llm> Base {\n  provider \"openai-generic\"\n  options {\n    base_url \"\"\n  }\n}\n\nclient<llm> GPT_QQ {\n  provider openai\n  retry_policy Exponential\n  options {\n    model \"gpt-4o-mini\"\n    base_url \"https://api.key77qiqi.com/v1\"\n    api_key env.OPENAI_QQ_API_KEY\n    temperature 0.0\n  }\n}\n\nclient<llm> GPT_QQ_4O {\n  provider openai\n  retry_policy Exponential\n  options {\n    model \"gpt-4o\"\n    base_url \"https://api.key77qiqi.com/v1\"\n    api_key env.OPENAI_QQ_API_KEY\n    temperature 0.0\n  }\n}\n\nclient<llm> GEMINI_QQ {\n  provider google-ai\n  retry_policy Exponential\n  options {\n    model \"gemini-2.5-flash\"\n    base_url \"https://api.key77qiqi.com/v1\"\n    api_key env.OPENAI_QQ_API_KEY\n    temperature 0.0\n  }\n}\n\nclient<llm> GPTOfficial {\n  provider openai\n  // retry_policy Exponential\n  options {\n    model \"gpt-4o-mini\"\n    api_key env.OPENAI_API_KEY\n    temperature 0.0\n  }\n}\n\nclient<llm> Gemini {\n  provider google-ai\n  retry_policy Exponential\n  options {\n    model \"gemini-2.5-pro\"\n    api_key env.GOOGLEAI_API_KEY\n  }\n}\n\nclient<llm> Claude {\n  provider anthropic\n  retry_policy Exponential\n  options {\n    model \"claude-sonnet-4-20250514\"\n    api_key env.ANTHROPIC_API_KEY\n  }\n}\n\nclient<llm> Qwen72b {\n  provider \"openai-generic\"\n  options {\n    base_url \"http://localhost:8000/v1\"\n    model \"Qwen/Qwen2.5-VL-72B-Instruct-AWQ\"\n  }\n}\n\nclient<llm> Qwen32b {\n  provider \"openai-generic\"\n  options {\n    base_url \"http://localhost:8000/v1\"\n    model \"Qwen/Qwen2.5-VL-32B-Instruct-AWQ\"\n  }\n}\n\nclient<llm> Qwen7b {\n  provider \"openai-generic\"\n  options {\n    base_url \"http://localhost:8000/v1\"\n    model \"Qwen/Qwen2.5-VL-7B-Instruct-AWQ\"\n  }\n}\n\nclient<llm> Qwen3b {\n  provider \"openai-generic\"\n  options {\n    base_url \"http://localhost:8000/v1\"\n    model \"Qwen/Qwen2.5-VL-3B-Instruct-AWQ\"\n  }\n}\n\nclient<llm> OpenRouter {\n  provider \"openai-generic\"\n  options {\n    base_url \"https://openrouter.ai/api/v1\"\n    model \"openai/gpt-oss-120b\"\n    api_key env.OPENROUTER_API_KEY\n  }\n}\n\nclient<llm> ZrokLocalModel {\n  provider \"openai-generic\"\n  retry_policy Exponential\n  options {\n    base_url \"https://llms.zrok.06946099.xyz/v1\"\n    model \"Qwen/Qwen3-VL-30B-A3B-Thinking\"\n    temperature 0.0\n  }\n}\n\nclient<llm> NgrokShowUI {\n  provider \"openai-generic\"\n  // retry_policy Exponential\n  options {\n    base_url \"https://viperish-fawn-superhumanly.ngrok-free.dev/v1\"\n    model \"showlab/ShowUI-2B\"\n    // temperature 0.0\n  }\n}\n\nclient<llm> NgrokLocalModel {\n  provider \"openai-generic\"\n  retry_policy Exponential\n  options {\n    base_url \"https://viperish-fawn-superhumanly.ngrok-free.dev/v1\"\n    model \"Qwen/Qwen3-VL-30B-A3B-Thinking\"\n    temperature 0.0\n    request_timeout_ms 8000\n    connect_timeout_ms 2000\n  }\n}\n\nclient<llm> FallbackLocalModel {\n  provider fallback\n  options {\n    strategy [\n      GPT_QQ\n    ]\n  }\n}\n\nclient<llm> ZrokUIVenus {\n  provider \"openai-generic\"\n  // retry_policy Exponential\n  options {\n    base_url \"https://uivenus.zrok.06946099.xyz/v1\"\n    api_key \"token-abc123\"\n    model \"inclusionAI/UI-Venus-Ground-7B\"\n    temperature 0.0\n    http {\n      request_timeout_ms 8000\n      connect_timeout_ms 2000\n    }\n    header {\n      \"secret\" \"sjtu-course-cs3604-2025\"\n    }\n  }\n}\n\nclient<llm> ZrokUIVenus2 {\n  provider \"openai-generic\"\n  retry_policy Exponential\n  options {\n    base_url \"http://202.120.37.109:23497/v1\"\n    api_key \"token-abc123\"\n    model \"inclusionAI/UI-Venus-Ground-7B\"\n    temperature 0.0\n    http {\n      request_timeout_ms 8000\n      connect_timeout_ms 2000\n    }\n    header {\n      \"secret\" \"sjtu-course-cs3604-2025\"\n    }\n  }\n}\n\nclient<llm> NgrokUIVenus {\n  provider \"openai-generic\"\n  // retry_policy Exponential\n  options {\n    base_url \"https://8dcd0b9d943d.ngrok-free.app/v1\"\n    api_key \"token-abc123\"\n    http {\n      request_timeout_ms 8000\n      connect_timeout_ms 2000\n    }\n    model \"inclusionAI/UI-Venus-Ground-7B\"\n    temperature 0.0\n  }\n}\n\nclient<llm> NgrokUIVenus2 {\n  provider \"openai-generic\"\n  // retry_policy Exponential\n  options {\n    base_url \"https://viperish-fawn-superhumanly.ngrok-free.dev/v1\"\n    api_key \"token-abc123\"\n    http {\n      request_timeout_ms 8000\n      connect_timeout_ms 2000\n    }\n    model \"inclusionAI/UI-Venus-Ground-7B\"\n    temperature 0.0\n  }\n}\n\nclient<llm> FallbackUIVenus1 {\n  provider fallback\n  options {\n    strategy [\n      ZrokUIVenus\n      ZrokUIVenus2\n      NgrokUIVenus\n      NgrokUIVenus2\n    ]\n  }\n}\n\nclient<llm> FallbackUIVenus2 {\n  provider fallback\n  options {\n    strategy [\n      ZrokUIVenus2\n      ZrokUIVenus\n      NgrokUIVenus2\n      NgrokUIVenus\n    ]\n  }\n}\n\nclient<llm> UIVenusRoundRobin {\n  provider round-robin\n  options {\n    strategy [\n      FallbackUIVenus2\n      // FallbackUIVenus1\n    ]\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 20000\n  }\n}\n",
    "executor/action.baml": "template_string InternVL_Prompt(screenshot: image, task: string) #\"\n  {{_.role(\"system\")}}\n  You are InternVL, a GUI agent.\n  You are given a task and a screenshot of the screen. You need to perform a series of pyautogui actions to complete the task. \n\n  {{_.role(\"user\")}}\n  {{ task }}\n  {{ screenshot }}\n\"#\n\ntemplate_string UITARS_Prompt(screenshot: image, task: string) #\"\n  {{_.role(\"user\")}}\n  You are a GUI agent. You are given a task and your action history, with screenshots. You need to perform the next action to complete the task.\n\n  ## Output Format\n  ```\n  Thought: ...\n  Action: ...\n  ```\n\n  ## Action Space\n\n  click(point='<point>x1 y1</point>')\n  left_double(point='<point>x1 y1</point>')\n  right_single(point='<point>x1 y1</point>')\n  drag(start_point='<point>x1 y1</point>', end_point='<point>x2 y2</point>')\n  hotkey(key='ctrl c') # Split keys with a space and use lowercase. Also, do not use more than 3 keys in one hotkey action.\n  type(content='xxx') # Use escape characters \\\\', \\\\\\\", and \\\\n in content part to ensure we can parse the content in normal python string format. If you want to submit your input, use \\\\n at the end of content. \n  scroll(point='<point>x1 y1</point>', direction='down or up or right or left') # Show more information on the `direction` side.\n  wait() #Sleep for 5s and take a screenshot to check for any changes.\n  finished(content='xxx') # Use escape characters \\\\', \\\\\", and \\\\n in content part to ensure we can parse the content in normal python string format.\n\n\n  ## Note\n  - Use English in `Thought` part.\n  - Write a small plan and finally summarize your next action (with its target element) in one sentence in `Thought` part.\n\n  ## User Instruction\n  {{ task }}\n  {{ screenshot }}\n\"#\n\ntemplate_string ShowUI_Prompt(screenshot: image, task: string) #\"\n  {{ _.role(\"system\") }}\n  You are an assistant trained to navigate the web screen. \n  Given a task instruction, a screen observation, and an action history sequence, \n  output the next action and wait for the next observation. \n  Here is the action space:\n  1. `CLICK`: Click on an element, value is not applicable and the position [x,y] is required. \n  2. `INPUT`: Type a string into an element, value is a string to type and the position [x,y] is required. \n  3. `SELECT`: Select a value for an element, value is not applicable and the position [x,y] is required. \n  4. `HOVER`: Hover on an element, value is not applicable and the position [x,y] is required.\n  5. `ANSWER`: Answer the question, value is the answer and the position is not applicable.\n  6. `ENTER`: Enter operation, value and position are not applicable.\n  7. `SCROLL`: Scroll the screen, value is the direction to scroll and the position is not applicable.\n  8. `SELECT_TEXT`: Select some text content, value is not applicable and position [[x1,y1], [x2,y2]] is the start and end position of the select operation.\n  9. `COPY`: Copy the text, value is the text to copy and the position is not applicable.\n\n  Format the action as a dictionary with the following keys:\n  {'action': 'ACTION_TYPE', 'value': 'element', 'position': [x,y]}\n\n  If value or position is not applicable, set it as `None`.\n  Position might be [[x1,y1], [x2,y2]] if the action requires a start and end position.\n  Position represents the relative coordinates on the screenshot and should be scaled to a range of 0-1.\n\n  {{_.role(\"user\")}}\n\n  Task: {{ task }}\n  Screenshot: {{ screenshot }}\n\"#\n\ntemplate_string Prompt(screenshot: image, task: string) #\"\n  {{_.role(\"user\")}}\n  You are a UI/UX expert skilled at interacting with websites.\n\n  Given a task and current page screenshot, your goal is to propose one or more of the following actions in Python format, calling the functions directly as shown below (within a Python code block):\n\n  ```python\n  click(target_description=\"...\") # Click on the element matching the description\n  type(target_description=\"...\", content=\"...\") # Focus on the element matching the description and type the specified content\n  drag(source_description=\"...\", target_description=\"...\") # Drag from the source element to the target element, both specified by descriptions\n  scroll(target_description=\"...\", direction=\"...\") # Focus on the described element (or None to scroll the page) and scroll in the given direction (\"up\", \"down\", \"left\", or \"right\")\n  wait(duration=...) # Wait for the specified duration in milliseconds\n  finished() # No action required\n  ```\n\n  Do not provide any explanations in your output; only return the Python code block with the required actions.\n  Target descriptions should be descriptive (i.e. which element, how to find it, what it looks like, ...) for better locating.\n  Target description should comply descriptions in the given task description.\n  When there are similar elements, provide distinguishing features in the description.\n  When selecting from dropdown, don't use `type(...)`.\n\n  Task: {{ task }}\n  Screenshot: {{ screenshot }}\n\"#\n\nfunction ProposeActions(screenshot: image, task: string) -> string {\n  client \"Base\"\n  prompt #\"\n    {% if ctx.client.name == \"InternVL\" %}\n      {{ InternVL_Prompt(screenshot, task) }}\n    {% elif ctx.client.name == \"UITARS\" %}\n      {{ UITARS_Prompt(screenshot, task) }}\n    {% else %}\n      {{ Prompt(screenshot, task) }}\n    {% endif %}\n  \"#\n}\n\nfunction LocateUIElement(screenshot: image, description: string) -> string {\n  client \"Base\"\n  prompt #\"\n    {{_.role(\"user\")}}\n    Outline the position corresponding to the instruction and target description: {{description}}.\n    The output should be only [x1,y1,x2,y2].\n    Screenshot: {{ screenshot }}\n  \"#\n}\n\ntest TestProposeActions {\n  functions [ProposeActions]\n  args {\n    screenshot { url \"https://github.com/user-attachments/assets/624097ea-06f2-4c8f-83f6-b6b9ee439c0c\" }\n    task \"Search the weather for the New York city.\"\n  }\n}\n\ntest TestLocateUIElement {\n  functions [LocateUIElement]\n  args {\n    screenshot { url \"https://github.com/user-attachments/assets/624097ea-06f2-4c8f-83f6-b6b9ee439c0c\" }\n    description \"Search the weather for the New York city.\"\n  }\n}",
    "executor/assertion.baml": "class Feedback {\n    response string\n    reason string\n}\n\nclass History {\n    page_id string\n    layout string?\n    description string?\n    prev_action string?\n}\n\ntemplate_string Specification() #\"\n    # API Specification\n\n    ### Session API\n    - `history -> list[State]`: Chronological sequence of all captured states in the current test session.\n\n    ### State API\n    - `page_id -> str`: Canonical identifier for logical page/state identity.\n    - `title -> str`: Browser tab's visible title.\n    - `url -> str`: Current browser URL.\n    - `extract(instruction: str, schema: Type[BaseModel]) -> Type[BaseModel]`: Extract structured data from the state. `schema` should be a class inherited from `BaseModel`, NOT `BaseModel` itself.\n\n    Important requirements for `schema`:\n      - `schema` must be a subclass of `BaseModel` (a class that inherits from `BaseModel` and defines fields). Do NOT pass `BaseModel` itself.\n      - The subclass should declare the expected fields and their types. Example:\n        ```python\n        class User(BaseModel):\n            id: int\n            name: str\n        ```\n      - The extractor will populate and return an instance of the provided subclass (or data matching its schema). Provide only class objects, not instances or the `BaseModel` base class.\n      - If you provide a schema that is not a subclass of `BaseModel` or omits required fields, extraction will fail. Ensure the schema accurately reflects the structure you expect to extract from the state.\n      - Note that `list` or `dict` or `list[dict]` are not supported types for attributes, please specify inner types properly such as `list[str]`, ...\n      - Use same language with the interface for clarity when use .extract(). i.e. in Chinese interface, use Chinese terms in instruction.\n      - When want to get a list of items, please define a wrapper model. For example, to extract a list of `User` objects, define:\n        ```python\n        class User(BaseModel):\n            id: int\n            name: str\n        class UserList(BaseModel):\n            users: list[User]\n        ```\n        Then use `extract(\"...\", schema=UserList).users` to get it.\n\n    Examples:\n    - Correct: `extract(\"get user\", schema=User)` where `User` inherits from `BaseModel`.\n    - Incorrect: `extract(\"get user\", schema=BaseModel)` (do not pass the base type).\n\"#\n\ntemplate_string FormatHistory(history: History[]) #\"\n    {% for state in history %}\n    {% if loop.index == loop.length %}\n    Current State:\n    {% else %}\n    State ({{ loop.index0 }}):\n    {% endif %}\n        Page: {{ state.page_id or 'Unknown' }}\n    {% if state.description %}\n        Description: {{ state.description }}\n    {% endif %}\n    {% if state.layout %}\n        Layout: {{ state.layout }}\n    {% endif %}\n    {% if loop.index < loop.length %}\n        Action: {{ history[loop.index].prev_action }}\n    {% endif %}\n    {% endfor %}\n\"#\n\ntemplate_string FormatFeedback(feedback: Feedback[]) #\"\n    {% if feedback %}\n    {% for f in feedback %}\n    {{ _.role(\"user\") }}\n    # Feedback\n\n    Your previous assertion(s) might be incorrect:\n\n    {{ f.response }}\n\n    Reason: {{ f.reason }}\n\n    If you insist that it is correct, please output the same thing\n    Otherwise, modify the assertion\n    {% endfor %}\n    {% endif %}\n\"#",
    "executor/methods.baml": "class Output {\n    @@dynamic\n}\n\ntype Primitives = string | int | float | bool\ntype ExtractedData = Output | Primitives | Output[] | Primitives[]\n\n\nfunction ExtractFromState(screenshot: image, instruction: string) -> Output {\n    client \"Base\"\n    prompt #\"\n        {{_.role(\"user\")}}\n        Extract structured data from the webpage screenshot that is relevant to the instruction.\n\n        Screenshot: {{ screenshot }}\n\n        Instruction: {{ instruction }}\n        Make sure to comply the schema requirements. In case of list, no element match should return an empty list, not null.\n\n        {{ ctx.output_format }}\n    \"#\n}\n\nfunction ExtractFromElement(screenshot: image, html: string, instruction: string) -> Output {\n    client \"Base\"\n    prompt #\"\n        {{_.role(\"user\")}}\n        Extract structured data from the web UI element screenshot and HTML that is relevant to the instruction.\n\n        {{ screenshot }}\n\n        {{ html }}\n\n        Instruction: {{ instruction }}\n\n        {{ ctx.output_format }}\n    \"#\n}",
    "executor/postcondition.baml": "template_string PostconditionIntro() #\"\n    # Role\n    You are an expert QA tester.\n\n    # Objective\n    You are generating a **postcondition assertion** after a specific user action has been executed.\n    Your goal is to verify that the intended **effects** of the action have occurred.\n\n    # Instructions\n    - Construct a Python assertion function using the provided Session, State, and Element APIs as detailed below.\n    - Focus on **postcondition verification**: ensure the *intended outcome* is reflected in the state after the action.\n    - Identify which dependency types are relevant to the state change:\n        1. **Temporal Dependency:** Changes in a logical page over time (e.g., after an action, a formerly empty cart now has items).\n        2. **Data Dependency:** Propagation of information across states (e.g., product details remain consistent from search result to cart addition).\n        3. **Causal Dependency:** State changes resulting directly from user actions (e.g., clicking 'search' updates the page to show related items).\n    - Grounding: Use only information provided in the session or state. Do not invent or guess labels, text, or values.\n    - Prefer structural checks (e.g., count > 0, len >= N, is not None) when exact expected values are not known.\n    - No placeholders. Even if expectations are minimal.\n\n    - Write the assertion as a Python block:\n        ```python\n        def postcondition(session: Session):\n            ...\n        ```\n\n    # Important on assertion messages\n    - Assertions MUST have insightful, helpful messages with it, i.e. \"Message shown is not ...\", ...\n    - Messages should be helpful feedbacks for developer to know what to improve.\n\n    # MUST remember\n    - `schema` are classes that inherit from `BaseModel` but MUST MUST MUST NOT be `BaseModel` itself!.\n    - Code MUST be executable and does not have type error.\n    - Data models should be concise and sufficient for the assertions, unrelated details should be ignored.\n    - Use descriptive variable names for clarity.\n    - Minimal and to the point assertions.\n\n    # Avoid Common Pitfalls\n    - Avoid writing hardcoded values.\n    - Avoid checking page titles, `page_id` or `url`.\n    - Avoid matching exact terms or keywords in assertions, extract and check empty is better.\n\"#\n\ntemplate_string PostconditionExample() #\"\n    # Example 1\n    __input__\n    History:\n        State (0):\n            Page: Cart page;\n            Action: User clicks \"Continue Shopping\"\n        ...\n        State (4):\n            Page: Product detail view\n            Action: User adds the item to cart\n\n    Current: Cart page (After action)\n    Assert: Cart is correctly updated\n\n    __output__\n    ```python\n    def postcondition(session: Session):\n        # Define data models\n        class Product(BaseModel):\n            title: str = Field(..., description=\"The name of the product\")\n            price: float = Field(..., description=\"The unit price of the product in local currency\")\n            quantity: Optional[int] = Field(None, \"The quantity of this product (used in cart contexts). None indicates unlimited or not specified\")\n        \n        class Cart(BaseModel):\n            items: List[Product] = Field(default_factory=list, description=\"List of products in the cart with their respective quantities\")\n\n        # Extract product from latest state\n        added = session.history[-2].extract(\"get product detail\", schema=Product)\n\n        # Get current and prior cart items\n        current = session.history[-1].extract(\"get cart summary\", schema=Cart).items\n        prior = session.history[0].extract(\"get cart summary\", schema=Cart).items\n\n        # Assert cart contains prior items plus the added product\n        assert set(p.title for p in current) == set(p.title for p in prior + [added]) , \"Cart items do not match expected items after addition.\"\n\n    # Example 2: Check boolean flags\n    __input__\n    History: ...\n    Current State:\n        Page: Service Page\n        Description: ...\n        Layout: <Page>...</Page>\n    Current: Click \"Service\" button\n    Assert: Service page shows up\n\n    __output__\n    ```python\n    def postcondition(session: Session):\n        # Define data models for presence checking\n        class PresenceChecking(BaseModel):\n            service_menu_is_selected: bool = Field(..., description=\"Indicates if option A is selected\")\n            service_page_is_present: bool = Field(..., description=\"Indicates if the current page is related to services\")\n        \n        presence_checking = session.history[-1].extract(\"Check if the page is a service page\", schema=PresenceChecking)\n\n        # Check if service page is present\n        assert presence_checking.service_page_is_present is True, \"Service page is not displayed as expected.\"\n\n        # Check other flags if needed\n        assert presence_checking.service_menu_is_selected is False, \"Service menu should be selected.\"\n    ```\n\"#\n\nfunction GeneratePostcondition(screenshot: image, history: History[], action: string, verify: string, feedback: Feedback[]) -> string {\n    client \"Base\"\n    prompt #\"\n        {{_.role(\"system\")}}\n        {{ PostconditionIntro() }}\n        {{ Specification() }}\n        {{ PostconditionExample() }}\n\n        {{_.role(\"user\")}}\n        {{ screenshot }}\n\n        {{ FormatHistory(history) }}\n        After Action: {{ action }}\n        Assert: {{ verify }}\n        {{ FormatFeedback(feedback) }}\n    \"#\n}\n\n\ntest TestName {\n  functions [GeneratePostcondition]\n  args {\n    verify #\"\n      hello world\n    \"#\n    history [\n        {\n            page_id \"A\"\n        }\n    ]\n    feedback [\n        {\n            response \"test\"\n            reason \"test\"\n        }\n    ]\n    screenshot { url \"https://imgs.xkcd.com/comics/standards.png\" }\n  }\n}\n",
    "executor/precondition.baml": "template_string PreconditionIntro() #\"\n    # Role\n    You are an expert QA tester.\n\n    # Objective\n    You are generating a **precondition assertion** before a specific user action is executed.\n    Your goal is to verify that the current state is valid and ready for the intended action.\n\n    # Instructions\n    - Construct a Python assertion function using the provided Session, State, and Element APIs as detailed below.\n    - Focus on **postcondition verification**: ensure the *intended outcome* is reflected in the state after the action.\n    - Identify which dependency types are relevant to the state change:\n        1. **Temporal Dependency:** Changes in a logical page over time (e.g., after an action, a formerly empty cart now has items).\n        2. **Data Dependency:** Propagation of information across states (e.g., product details remain consistent from search result to cart addition).\n        3. **Causal Dependency:** State changes resulting directly from user actions (e.g., clicking 'search' updates the page to show related items).\n    - Grounding: Use only information provided in the session or state. Do not invent or guess labels, text, or values.\n    - Prefer structural checks (e.g., count > 0, len >= N, is not None) when exact expected values are not known.\n    - No placeholders. Even if expectations are minimal.\n    \n    - Write the assertion as a Python block:\n        ```python\n        def precondition(session: Session):\n            ...\n        ```\n\n    # Reminder\n    - `schema` must be classes that inherit from `BaseModel` but can NOT be `BaseModel`.\n\"#\n\ntemplate_string PreconditionExample() #\"\n    # Example\n    __input__\n    History:\n        State (0):\n            Page: Product search page\n            Action: User searches for 'Laptop'\n        State (1):\n            Page: Search results page\n            Action: User clicks on the desired product\n\n    Current: Product detail page (Before action)\n    Assert: Product information is loaded and 'Add to Cart' button is enabled\n\n    __output__\n    ```python\n    def precondition(session: Session):\n        # Define data model\n        class ProductDetail(BaseModel):\n            title: str = Field(..., description=\"The name of the product\")\n            price: float = Field(..., description=\"The price of the product\")\n            add_to_cart_enabled: bool = Field(..., description=\"Whether the 'Add to Cart' button is clickable\")\n\n        # Extract product details from the current page\n        details = session.history[-1].extract(\"get product detail with add-to-cart availability\", schema=ProductDetail)\n\n        # Assert that product information is complete and ready for action\n        assert details.title and details.price > 0\n        assert details.add_to_cart_enabled\n    ```\n\"#\n\nfunction GeneratePrecondition(screenshot: image, history: History[], action: string, verify: string, feedback: Feedback[]) -> string {\n    client \"Base\"\n    prompt #\"\n        {{_.role(\"system\")}}\n        {{ PreconditionIntro() }}\n        {{ Specification() }}\n        {{ PreconditionExample() }}\n        \n        {{_.role(\"user\")}}\n        {{ screenshot }}\n\n        {{ FormatHistory(history) }}\n        Before Action: {{ action }}\n        Assert: {{ verify }}\n        {{ FormatFeedback(feedback) }}\n    \"#\n}\n",
    "executor/reidentification.baml": "class PageAbstract {\n  name string\n  description string\n  layout string\n}\n\n\nfunction IsSameLogicalPage(page_a: image, page_b: image) -> bool {\n  client \"Base\"\n  prompt #\"\n    {{_.role(\"user\")}}\n    You are an expert UI/UX evaluator with deep knowledge of web page layout, semantics, and interaction patterns.\n\n    You are given two page screenshots. Determine whether they represent the same logical page \n    (i.e., the same underlying page in a web application or site), even if their visual states differ.\n\n    Guidelines:\n    1. Layout Consistency: Do the overall structure and arrangement of UI components match?\n\n    2. Functional Equivalence: Do they offer the same set of core actions and interactions?\n\n    3. Navigation Equivalence: Do they provide the same pathways to other parts of the application?\n\n    4. Two pages can be the same, even if their visual states differ. For example:\n        - One shows an expanded/triggered widget (e.g., dropdown, modal, accordion, pop-up).\n        - One contains different dynamic data but with the same type, structure, and placement.\n        - One has pre-filled or empty form fields, as long as the underlying form is the same.\n\n    {{ ctx.output_format }} with only \"True\" or \"False\".\n\n    {{ page_a }}\n\n    {{ page_b}}\n  \"#\n}\n\n\nfunction AbstractPage(page: image) -> PageAbstract {\n  client \"Base\"\n  prompt #\"\n    {{_.role(\"user\")}}\n    You are an expert UI/UX evaluator with deep knowledge of web page layout, semantics, and interaction patterns.\n    \n    You are given a page screenshot.\n    1. Assign a clear, semantically meaningful name to the page (e.g., Shopping Cart Page).\n    2. Write a summary <15 words describing both the function and visual state of the page.\n    3. Analyze the layout: extract as a page template in XML format. You may include non-data attributes for context.\n      ```example\n      <Page>\n        <Header visibleFor=\"allUsers\" role=\"navigation\" hasNotifications=\"true\" />\n        <Sidebar collapsible=\"true\" visible=\"true\" contains=\"menuItems\" />\n        <Breadcrumb currentPage=\"true\" hasPath=\"true\" />\n        <MainContent>\n          <CartItems type=\"list\" itemType=\"product\" selectable=\"true\" hasQuantity=\"true\" hasPrice=\"true\" availabilityState=\"enum\" />\n          <Recommendations type=\"list\" itemType=\"product\" algorithmType=\"collaborativeFiltering\" />\n        </MainContent>\n        <Footer role=\"footer\" contains=\"links,contactInfo\" />\n      </Page>\n      ```\n\n    {{ ctx.output_format }}\n\n    {{ page }}\n  \"#\n}\n\ntest TestName {\n  functions [AbstractPage]\n  args {\n    page { file \"/home/xiwen/WebTestPilot/webtestpilot/baml_src/executor/invoiceninja.png\" }\n  }\n}",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"python/pydantic\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../src\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.205.0\"\n\n    // Valid values: \"sync\", \"async\"\n    // This controls what `b.FunctionName()` will be (sync or async).\n    default_client_mode sync\n}\n",
    "parser/parser.baml": "class Step {\n  condition string\n  action string\n  expectation string\n}\n\nclass TestCase {\n  name string\n  steps Step[]\n}\n\nfunction ExtractTestCase(description: string) -> TestCase {\n  client \"Base\"\n  prompt #\"\n    You are an expert in semantic intent extraction for web application testing.\n\n    Your goal is to extract structured interaction intents as a list of step = (condition, action, expectation) triples from natural language requirements or acceptance criteria.\n    - `Condition`: The context under which the step is valid (e.g., user is on page)\n    - `Action`: A clear user action (e.g., user clicks Submit)\n    - `Expectation`: A testable outcome (e.g., page redirects to dashboard)\n\n    If the information is not provided, fill with <unknown> placeholder.\n    Please correct typos and other errors to produce well-formed, complete sentences, without adding or omitting any information.\n\n    {{ ctx.output_format }}\n\n    {{ description }}\n  \"#\n}\n\nfunction ImplicitGeneration(testcase: TestCase) -> TestCase {\n  client \"Base\"\n  prompt #\"\n    You are an expert in semantic intent understanding for web application testing.\n    Fill in the <unknown> blanks by inferring contextual information from other steps.\n    Return in the same format.\n\n    {{ testcase }}\n  \"#\n}",
}

def get_baml_files():
    return _file_map