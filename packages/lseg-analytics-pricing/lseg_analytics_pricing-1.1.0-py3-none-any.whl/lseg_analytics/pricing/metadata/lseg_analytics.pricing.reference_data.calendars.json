[
    {
        "type": "ClassChunk",
        "name": "AbsolutePositionWhen",
        "id": "lseg_analytics.pricing.reference_data.calendars.AbsolutePositionWhen",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "day_of_month",
                "type": "int"
            },
            {
                "name": "month",
                "type": "Month",
                "valuelookup": "enum.Month"
            },
            {
                "name": "observance",
                "type": "List[Observance]"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 90,
        "content": "class AbsolutePositionWhen:\n    \"\"\"An absolute position annual holiday rule. For example, New Year holiday on 1st Jan.\n\n    Attributes\n    ----------\n    position_type : str or ~analyticsapi.models.ABSOLUTE_POSITION_WHEN\n        The type of regular annual holiday rule. Only AbsolutePositionWhen\n        value applies. Required. A rule to determine a fixed holiday. For\n        example, New Year holiday on January 1.\n    day_of_month : int\n        The number of the day of the month. The minimum value is 0 (a special\n        case indication western Easter). The maximum value is 31. Required.\n    month : str or ~analyticsapi.models.Month\n        The month of the year, written in full (e.g. January). Required. Known\n        values are: \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n        \"July\", \"August\", \"September\", \"October\", \"November\", and \"December\".\n    observance : list[~analyticsapi.models.Observance]\n        An array of objects to determine a holiday rescheduling if it falls on\n        a rest day. This property is optional and only applied if explicitly\n        specified. If not provided, a holidays will not be rescheduled by\n        default.  The default value is None, needs to be assigned before using.\n    \n    \"\"\"\n    position_type: typing.Literal[<PositionType.ABSOLUTE_POSITION_WHEN: 'AbsolutePositionWhen'>]\n    day_of_month: int\n    month: typing.Union[str, ForwardRef('_models.Month')]\n    observance: typing.Optional[typing.List[ForwardRef('_models.Observance')]]",
        "metadata": {
            "doc": "An absolute position annual holiday rule. For example, New Year holiday on 1st Jan.\n\n    Attributes\n    ----------\n    position_type : str or ~analyticsapi.models.ABSOLUTE_POSITION_WHEN\n        The type of regular annual holiday rule. Only AbsolutePositionWhen\n        value applies. Required. A rule to determine a fixed holiday. For\n        example, New Year holiday on January 1.\n    day_of_month : int\n        The number of the day of the month. The minimum value is 0 (a special\n        case indication western Easter). The maximum value is 31. Required.\n    month : str or ~analyticsapi.models.Month\n        The month of the year, written in full (e.g. January). Required. Known\n        values are: \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n        \"July\", \"August\", \"September\", \"October\", \"November\", and \"December\".\n    observance : list[~analyticsapi.models.Observance]\n        An array of objects to determine a holiday rescheduling if it falls on\n        a rest day. This property is optional and only applied if explicitly\n        specified. If not provided, a holidays will not be rescheduled by\n        default.  The default value is None, needs to be assigned before using.\n    \n",
            "annotations": "    position_type: typing.Literal[<PositionType.ABSOLUTE_POSITION_WHEN: 'AbsolutePositionWhen'>]\n    day_of_month: int\n    month: typing.Union[str, ForwardRef('_models.Month')]\n    observance: typing.Optional[typing.List[ForwardRef('_models.Observance')]]",
            "signature": "class AbsolutePositionWhen:\n    \"\"\"\"\"\"\n    position_type: typing.Literal[<PositionType.ABSOLUTE_POSITION_WHEN: 'AbsolutePositionWhen'>]\n    day_of_month: int\n    month: typing.Union[str, ForwardRef('_models.Month')]\n    observance: typing.Optional[typing.List[ForwardRef('_models.Observance')]]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.AbsolutePositionWhen.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.Month",
                "lseg_analytics.pricing.reference_data.calendars.Observance"
            ],
            "base_classes": [
                "lseg_analytics.pricing.reference_data.calendars.When"
            ],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "AbsolutePositionWhen.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.AbsolutePositionWhen.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 146,
        "content": "class AbsolutePositionWhen:\n    @overload\n    def __init__(self, *, day_of_month: int, month: Union[str, ForwardRef('_models.Month')], observance: Optional[List[ForwardRef('_models.Observance')]] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "AbsolutePositionWhen"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.AbsolutePositionWhen"
            ],
            "use": [
                "lseg_analytics.pricing.common.Month",
                "lseg_analytics.pricing.reference_data.calendars.Observance"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "Calendar",
        "id": "lseg_analytics.pricing.reference_data.calendars.Calendar",
        "params": [
            {
                "name": "definition",
                "type": "CalendarDefinition"
            },
            {
                "name": "description",
                "type": "Description"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_calendar.py",
        "line_number": 41,
        "content": "class Calendar:\n    \"\"\"\n    Calendar object.\n\n    Contains all the necessary information to identify and define a Calendar instance.\n\n    Attributes\n    ----------\n    type : Union[str, ResourceType], optional\n        Property defining the type of the resource.\n    id : str, optional\n        Unique identifier of the Calendar.\n    location : Location\n        Object defining the location of the Calendar in the platform.\n    description : Description, optional\n        Object defining metadata for the Calendar.\n    definition : CalendarDefinition\n        Object defining the Calendar.\n\n    See Also\n    --------\n    Calendar.generateHolidays : Gets the holidays for the calendar within a date range. Start and End Dates are included in the calculation. Only saved calendars are supported.\n    Calendar.computeDates : Computes dates for the calendar according to specified conditions. Start Date is included in the calculation. Only saved calendars are supported.\n    Calendar.generateDateSchedule : Generates a date schedule for the calendar according to specified conditions. Start and End Dates are included in the calculation. Only saved calendars are supported.\n    Calendar.countPeriods : Counts the time periods that satisfy specified conditions. Note the use of date strings for convenience. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n    Examples\n    --------\n    >>> # Create a calendar instance with parameter.\n    >>> my_cal_definition = CalendarDefinition(rest_days=[\n    >>>                     RestDays(\n    >>>                         rest_days=[WeekDay.SATURDAY, WeekDay.SUNDAY],\n    >>>                         validity_period=ValidityPeriod(\n    >>>                             start_date=\"2024-01-01\",\n    >>>                             end_date=\"2024-12-31\",\n    >>>                         ),\n    >>>                     )\n    >>>                 ],\n    >>>                     first_day_of_week=WeekDay.FRIDAY,\n    >>>                     holiday_rules=[\n    >>>                     HolidayRule(\n    >>>                         name=\"New Year's Day\",\n    >>>                         duration=FullDayDuration(full_day=1),\n    >>>                         validity_period=ValidityPeriod(\n    >>>                             start_date=\"2024-01-01\",\n    >>>                             end_date=\"2024-12-31\",\n    >>>                         ),\n    >>>                         when=AbsolutePositionWhen(day_of_month=1, month=Month.JANUARY),\n    >>>                     ),\n    >>>                 ]\n    >>>                 )\n    >>> my_cal = Calendar(definition=my_cal_definition)\n\n\n    >>> # Save the instance with name and space.\n    >>> my_cal.save(name=\"my_personal_calendar\", space=\"HOME\")\n    True\n\n    \n    \"\"\"\n",
        "metadata": {
            "doc": "\n    Calendar object.\n\n    Contains all the necessary information to identify and define a Calendar instance.\n\n    Attributes\n    ----------\n    type : Union[str, ResourceType], optional\n        Property defining the type of the resource.\n    id : str, optional\n        Unique identifier of the Calendar.\n    location : Location\n        Object defining the location of the Calendar in the platform.\n    description : Description, optional\n        Object defining metadata for the Calendar.\n    definition : CalendarDefinition\n        Object defining the Calendar.\n\n    See Also\n    --------\n    Calendar.generateHolidays : Gets the holidays for the calendar within a date range. Start and End Dates are included in the calculation. Only saved calendars are supported.\n    Calendar.computeDates : Computes dates for the calendar according to specified conditions. Start Date is included in the calculation. Only saved calendars are supported.\n    Calendar.generateDateSchedule : Generates a date schedule for the calendar according to specified conditions. Start and End Dates are included in the calculation. Only saved calendars are supported.\n    Calendar.countPeriods : Counts the time periods that satisfy specified conditions. Note the use of date strings for convenience. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n    Examples\n    --------\n    >>> # Create a calendar instance with parameter.\n    >>> my_cal_definition = CalendarDefinition(rest_days=[\n    >>>                     RestDays(\n    >>>                         rest_days=[WeekDay.SATURDAY, WeekDay.SUNDAY],\n    >>>                         validity_period=ValidityPeriod(\n    >>>                             start_date=\"2024-01-01\",\n    >>>                             end_date=\"2024-12-31\",\n    >>>                         ),\n    >>>                     )\n    >>>                 ],\n    >>>                     first_day_of_week=WeekDay.FRIDAY,\n    >>>                     holiday_rules=[\n    >>>                     HolidayRule(\n    >>>                         name=\"New Year's Day\",\n    >>>                         duration=FullDayDuration(full_day=1),\n    >>>                         validity_period=ValidityPeriod(\n    >>>                             start_date=\"2024-01-01\",\n    >>>                             end_date=\"2024-12-31\",\n    >>>                         ),\n    >>>                         when=AbsolutePositionWhen(day_of_month=1, month=Month.JANUARY),\n    >>>                     ),\n    >>>                 ]\n    >>>                 )\n    >>> my_cal = Calendar(definition=my_cal_definition)\n\n\n    >>> # Save the instance with name and space.\n    >>> my_cal.save(name=\"my_personal_calendar\", space=\"HOME\")\n    True\n\n    \n",
            "annotations": "",
            "signature": "class Calendar:\n    \"\"\"\"\"\"\n"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar.__init__",
                "lseg_analytics.pricing.reference_data.calendars.Calendar.id",
                "lseg_analytics.pricing.reference_data.calendars.Calendar.location",
                "lseg_analytics.pricing.reference_data.calendars.Calendar.compute_dates",
                "lseg_analytics.pricing.reference_data.calendars.Calendar.count_periods",
                "lseg_analytics.pricing.reference_data.calendars.Calendar.generate_date_schedule",
                "lseg_analytics.pricing.reference_data.calendars.Calendar.generate_holidays",
                "lseg_analytics.pricing.reference_data.calendars.Calendar.save",
                "lseg_analytics.pricing.reference_data.calendars.Calendar.clone"
            ],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "MethodChunk",
        "name": "Calendar.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.Calendar.__init__",
        "params": [
            {
                "name": "definition",
                "type": "CalendarDefinition"
            },
            {
                "name": "description",
                "type": "Description"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_calendar.py",
        "line_number": 103,
        "content": "class Calendar:\n    def __init__(self, definition: CalendarDefinition, description: Optional[Description] = None):\n        \"\"\"\n        Calendar constructor\n\n        Parameters\n        ----------\n        definition : CalendarDefinition\n            Object defining the Calendar.\n        description : Description, optional\n            Object defining metadata for the Calendar.\n\n        Examples\n        --------\n        >>> # Create a calendar instance with parameter.\n        >>> my_cal_definition = CalendarDefinition(rest_days=[\n        >>>                     RestDays(\n        >>>                         rest_days=[WeekDay.SATURDAY, WeekDay.SUNDAY],\n        >>>                         validity_period=ValidityPeriod(\n        >>>                             start_date=\"2024-01-01\",\n        >>>                             end_date=\"2024-12-31\",\n        >>>                         ),\n        >>>                     )\n        >>>                 ],\n        >>>                     first_day_of_week=WeekDay.FRIDAY,\n        >>>                     holiday_rules=[\n        >>>                     HolidayRule(\n        >>>                         name=\"New Year's Day\",\n        >>>                         duration=FullDayDuration(full_day=1),\n        >>>                         validity_period=ValidityPeriod(\n        >>>                             start_date=\"2024-01-01\",\n        >>>                             end_date=\"2024-12-31\",\n        >>>                         ),\n        >>>                         when=AbsolutePositionWhen(day_of_month=1, month=Month.JANUARY),\n        >>>                     ),\n        >>>                 ]\n        >>>                 )\n        >>> my_cal = Calendar(definition=my_cal_definition)\n\n        \n        \"\"\"",
        "metadata": {
            "doc": "\n        Calendar constructor\n\n        Parameters\n        ----------\n        definition : CalendarDefinition\n            Object defining the Calendar.\n        description : Description, optional\n            Object defining metadata for the Calendar.\n\n        Examples\n        --------\n        >>> # Create a calendar instance with parameter.\n        >>> my_cal_definition = CalendarDefinition(rest_days=[\n        >>>                     RestDays(\n        >>>                         rest_days=[WeekDay.SATURDAY, WeekDay.SUNDAY],\n        >>>                         validity_period=ValidityPeriod(\n        >>>                             start_date=\"2024-01-01\",\n        >>>                             end_date=\"2024-12-31\",\n        >>>                         ),\n        >>>                     )\n        >>>                 ],\n        >>>                     first_day_of_week=WeekDay.FRIDAY,\n        >>>                     holiday_rules=[\n        >>>                     HolidayRule(\n        >>>                         name=\"New Year's Day\",\n        >>>                         duration=FullDayDuration(full_day=1),\n        >>>                         validity_period=ValidityPeriod(\n        >>>                             start_date=\"2024-01-01\",\n        >>>                             end_date=\"2024-12-31\",\n        >>>                         ),\n        >>>                         when=AbsolutePositionWhen(day_of_month=1, month=Month.JANUARY),\n        >>>                     ),\n        >>>                 ]\n        >>>                 )\n        >>> my_cal = Calendar(definition=my_cal_definition)\n\n        \n",
            "signature": "class Calendar:\n    def __init__(self, definition: CalendarDefinition, description: Optional[Description] = None):",
            "class": "Calendar"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar"
            ],
            "use": [
                "lseg_analytics.pricing.reference_data.calendars.CalendarDefinition",
                "lseg_analytics.pricing.common.Description"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "PropertyChunk",
        "name": "Calendar.id",
        "id": "lseg_analytics.pricing.reference_data.calendars.Calendar.id",
        "content": "class Calendar:\n    @property\n    def id(self):\n        \"\"\"\n        Returns the Calendar id\n\n        Parameters\n        ----------\n\n\n        Returns\n        --------\n        str\n            Unique identifier of the Calendar.\n\n        Examples\n        --------\n        >>> # Get the instance id.\n        >>> my_cal.id\n        '41d42531-2e1c-48c1-84e6-ea324c96eacd'\n\n        \n        \"\"\"",
        "metadata": {
            "doc": "\n        Returns the Calendar id\n\n        Parameters\n        ----------\n\n\n        Returns\n        --------\n        str\n            Unique identifier of the Calendar.\n\n        Examples\n        --------\n        >>> # Get the instance id.\n        >>> my_cal.id\n        '41d42531-2e1c-48c1-84e6-ea324c96eacd'\n\n        \n",
            "signature": "class Calendar:\n    def id(self):",
            "class": "Calendar"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "PropertyChunk",
        "name": "Calendar.location",
        "id": "lseg_analytics.pricing.reference_data.calendars.Calendar.location",
        "content": "class Calendar:\n    @property\n    def location(self):\n        \"\"\"\n        Returns the Calendar location\n\n        Parameters\n        ----------\n\n\n        Returns\n        --------\n        Location\n            Object defining the location of the Calendar in the platform.\n\n        Examples\n        --------\n        >>> # Get the location property.\n        >>> my_cal.location.name\n        'my_personal_calendar'\n\n\n        >>> my_cal.location.space\n        'HOME'\n\n        \n        \"\"\"",
        "metadata": {
            "doc": "\n        Returns the Calendar location\n\n        Parameters\n        ----------\n\n\n        Returns\n        --------\n        Location\n            Object defining the location of the Calendar in the platform.\n\n        Examples\n        --------\n        >>> # Get the location property.\n        >>> my_cal.location.name\n        'my_personal_calendar'\n\n\n        >>> my_cal.location.space\n        'HOME'\n\n        \n",
            "signature": "class Calendar:\n    def location(self):",
            "class": "Calendar"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "MethodChunk",
        "name": "Calendar.compute_dates",
        "id": "lseg_analytics.pricing.reference_data.calendars.Calendar.compute_dates",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "tenors",
                "type": "List[str]",
                "valuelookup": "tenors"
            },
            {
                "name": "start_date",
                "type": "date"
            },
            {
                "name": "date_moving_convention",
                "type": "DateMovingConvention",
                "valuelookup": "enum.DateMovingConvention"
            },
            {
                "name": "end_of_month_convention",
                "type": "EndOfMonthConvention",
                "valuelookup": "enum.EndOfMonthConvention"
            },
            {
                "name": "fields",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_calendar.py",
        "line_number": 209,
        "content": "class Calendar:\n    def compute_dates(self, *, tenors: List[str], start_date: Union[str, datetime.date, NoneType] = None, date_moving_convention: Union[str, DateMovingConvention, NoneType] = None, end_of_month_convention: Union[str, EndOfMonthConvention, NoneType] = None, fields: Optional[str] = None) -> List[ComputeDatesBatched]:\n        \"\"\"\n        Computes dates for the calendar according to specified conditions. Start Date is included in the calculation. Only saved calendars are supported.\n\n        Parameters\n        ----------\n        tenors : List[str]\n            Tenors to be added to startDate to calculate the resultant dates (e.g., 1M, 1Y).\n            A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:\n            - Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and Years (Y).\n            For example \"1D\" for one day, \"2W\" for two weeks or \"3M1D\" for three months and a day.\n            When mixing units, units must be written in descending order of size (Y > M > W > D).  So, 5M3D is valid, but 3D5M is not.\n            - Common tenors are expressed as letter codes:\n            - ON (Overnight) - A one business day period that starts today.\n            - TN (Tomorrow-Next) - A one business day period that starts next business day.\n            - SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date (today) + days to spot.\n            - SN (Spot-Next) - A one business day period that starts at the spot date.\n            - SW (Spot-Week) - A one business week period that starts at the spot date.\n        start_date : Union[str, datetime.date], optional\n            The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today.\n        date_moving_convention : Union[str, DateMovingConvention], optional\n            The method to adjust dates to working days. The default value is ModifiedFollowing.\n        end_of_month_convention : Union[str, EndOfMonthConvention], optional\n            Conventions to adjust payment dates when they fall at the end of a month.\n        fields : str, optional\n            A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n            Some usage examples:\n            1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n            2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n            3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n            4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n        Returns\n        --------\n        List[ComputeDatesBatched]\n            An object to definine the properties of the calculated dates returned, with a dedicated error object for each calculation. This serializable object behaves exactly like a list of dictionaries when iterated or displayed. It can be converted to a DataFrame without transformation.\n\n        Examples\n        --------\n        >>> my_cal.compute_dates(start_date=\"2023-11-01\", date_moving_convention=DateMovingConvention.NEXT_BUSINESS_DAY, tenors=[\"1M\", \"2M\"])\n        [{'endDate': '2023-12-01', 'tenor': '1M'},\n         {'endDate': '2024-01-02', 'tenor': '2M'}]\n\n        \n        \"\"\"",
        "metadata": {
            "doc": "\n        Computes dates for the calendar according to specified conditions. Start Date is included in the calculation. Only saved calendars are supported.\n\n        Parameters\n        ----------\n        tenors : List[str]\n            Tenors to be added to startDate to calculate the resultant dates (e.g., 1M, 1Y).\n            A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:\n            - Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and Years (Y).\n            For example \"1D\" for one day, \"2W\" for two weeks or \"3M1D\" for three months and a day.\n            When mixing units, units must be written in descending order of size (Y > M > W > D).  So, 5M3D is valid, but 3D5M is not.\n            - Common tenors are expressed as letter codes:\n            - ON (Overnight) - A one business day period that starts today.\n            - TN (Tomorrow-Next) - A one business day period that starts next business day.\n            - SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date (today) + days to spot.\n            - SN (Spot-Next) - A one business day period that starts at the spot date.\n            - SW (Spot-Week) - A one business week period that starts at the spot date.\n        start_date : Union[str, datetime.date], optional\n            The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today.\n        date_moving_convention : Union[str, DateMovingConvention], optional\n            The method to adjust dates to working days. The default value is ModifiedFollowing.\n        end_of_month_convention : Union[str, EndOfMonthConvention], optional\n            Conventions to adjust payment dates when they fall at the end of a month.\n        fields : str, optional\n            A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n            Some usage examples:\n            1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n            2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n            3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n            4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n        Returns\n        --------\n        List[ComputeDatesBatched]\n            An object to definine the properties of the calculated dates returned, with a dedicated error object for each calculation. This serializable object behaves exactly like a list of dictionaries when iterated or displayed. It can be converted to a DataFrame without transformation.\n\n        Examples\n        --------\n        >>> my_cal.compute_dates(start_date=\"2023-11-01\", date_moving_convention=DateMovingConvention.NEXT_BUSINESS_DAY, tenors=[\"1M\", \"2M\"])\n        [{'endDate': '2023-12-01', 'tenor': '1M'},\n         {'endDate': '2024-01-02', 'tenor': '2M'}]\n\n        \n",
            "signature": "class Calendar:\n    def compute_dates(self, *, tenors: List[str], start_date: Union[str, datetime.date, NoneType] = None, date_moving_convention: Union[str, DateMovingConvention, NoneType] = None, end_of_month_convention: Union[str, EndOfMonthConvention, NoneType] = None, fields: Optional[str] = None) -> List[ComputeDatesBatched]:",
            "class": "Calendar"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar"
            ],
            "use": [
                "lseg_analytics.pricing.common.DateMovingConvention",
                "lseg_analytics.pricing.common.EndOfMonthConvention",
                "lseg_analytics.pricing.reference_data.calendars.ComputeDatesBatched"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "MethodChunk",
        "name": "Calendar.count_periods",
        "id": "lseg_analytics.pricing.reference_data.calendars.Calendar.count_periods",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "start_date",
                "type": "date"
            },
            {
                "name": "end_date",
                "type": "date"
            },
            {
                "name": "day_count_basis",
                "type": "DayCountBasis",
                "valuelookup": "enum.DayCountBasis"
            },
            {
                "name": "period_type",
                "type": "PeriodType",
                "valuelookup": "enum.PeriodType"
            },
            {
                "name": "fields",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_calendar.py",
        "line_number": 283,
        "content": "class Calendar:\n    def count_periods(self, *, start_date: Union[str, datetime.date], end_date: Union[str, datetime.date], day_count_basis: Union[str, DayCountBasis, NoneType] = None, period_type: Union[str, PeriodType, NoneType] = None, fields: Optional[str] = None) -> CountPeriodsOutput:\n        \"\"\"\n        Counts the time periods that satisfy specified conditions. Note the use of date strings for convenience. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n        Parameters\n        ----------\n        start_date : Union[str, datetime.date]\n            The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).\n        end_date : Union[str, datetime.date]\n            The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n        day_count_basis : Union[str, DayCountBasis], optional\n            The day count basis convention used to calculate the period between two dates.\n            It is used when periodType is set to Year.\n            Each convention defines the number of days between two dates and the year length in days (basis) for the period calculation.\n            Default is DCB_ACTUAL_ACTUAL.\n        period_type : Union[str, PeriodType], optional\n            The method of the period calculation. Default is Day.\n        fields : str, optional\n            A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n            Some usage examples:\n            1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n            2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n            3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n            4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n        Returns\n        --------\n        CountPeriodsOutput\n            The result of the period calculation for the count periods endpoint.\n\n        Examples\n        --------\n        >>> my_cal.count_periods(\n        >>>     start_date=\"2023-01-01\",\n        >>>     end_date=\"2023-12-31\",\n        >>>     day_count_basis=DayCountBasis.DCB_30_360,\n        >>>     period_type=PeriodType.WORKING_DAY,\n        >>> )\n        {'count': 243, 'periodType': 'WorkingDay'}\n\n        \n        \"\"\"",
        "metadata": {
            "doc": "\n        Counts the time periods that satisfy specified conditions. Note the use of date strings for convenience. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n        Parameters\n        ----------\n        start_date : Union[str, datetime.date]\n            The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).\n        end_date : Union[str, datetime.date]\n            The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n        day_count_basis : Union[str, DayCountBasis], optional\n            The day count basis convention used to calculate the period between two dates.\n            It is used when periodType is set to Year.\n            Each convention defines the number of days between two dates and the year length in days (basis) for the period calculation.\n            Default is DCB_ACTUAL_ACTUAL.\n        period_type : Union[str, PeriodType], optional\n            The method of the period calculation. Default is Day.\n        fields : str, optional\n            A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n            Some usage examples:\n            1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n            2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n            3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n            4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n        Returns\n        --------\n        CountPeriodsOutput\n            The result of the period calculation for the count periods endpoint.\n\n        Examples\n        --------\n        >>> my_cal.count_periods(\n        >>>     start_date=\"2023-01-01\",\n        >>>     end_date=\"2023-12-31\",\n        >>>     day_count_basis=DayCountBasis.DCB_30_360,\n        >>>     period_type=PeriodType.WORKING_DAY,\n        >>> )\n        {'count': 243, 'periodType': 'WorkingDay'}\n\n        \n",
            "signature": "class Calendar:\n    def count_periods(self, *, start_date: Union[str, datetime.date], end_date: Union[str, datetime.date], day_count_basis: Union[str, DayCountBasis, NoneType] = None, period_type: Union[str, PeriodType, NoneType] = None, fields: Optional[str] = None) -> CountPeriodsOutput:",
            "class": "Calendar"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar"
            ],
            "use": [
                "lseg_analytics.pricing.common.DayCountBasis",
                "lseg_analytics.pricing.common.PeriodType",
                "lseg_analytics.pricing.reference_data.calendars.CountPeriodsOutput"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "MethodChunk",
        "name": "Calendar.generate_date_schedule",
        "id": "lseg_analytics.pricing.reference_data.calendars.Calendar.generate_date_schedule",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "frequency",
                "type": "Frequency",
                "valuelookup": "enum.Frequency"
            },
            {
                "name": "start_date",
                "type": "date"
            },
            {
                "name": "end_date",
                "type": "date"
            },
            {
                "name": "calendar_day_of_month",
                "type": "int"
            },
            {
                "name": "count",
                "type": "int"
            },
            {
                "name": "day_of_week",
                "type": "WeekDay",
                "valuelookup": "enum.WeekDay"
            },
            {
                "name": "fields",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_calendar.py",
        "line_number": 391,
        "content": "class Calendar:\n    def generate_date_schedule(self, *, frequency: Union[str, Frequency], start_date: Union[str, datetime.date, NoneType] = None, end_date: Union[str, datetime.date, NoneType] = None, calendar_day_of_month: Optional[int] = None, count: Optional[int] = None, day_of_week: Union[str, WeekDay, NoneType] = None, fields: Optional[str] = None) -> List[datetime.date]:\n        \"\"\"\n        Generates a date schedule for the calendar according to specified conditions. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n        Parameters\n        ----------\n        frequency : Union[str, Frequency]\n            The frequency of dates in the schedule which should be generated. Note that \"Daily\" refers to working days only.\n        start_date : Union[str, datetime.date], optional\n            The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).\n            The start date must be less or equal to the end date.\n            Required if endDate is in the past.\n        end_date : Union[str, datetime.date], optional\n            The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n            If startDate is not specified, endDate is used to define the list of dates from today's date to the end date.\n            The end date must be greater or equal to the start date.\n            Required if count is not specified. Only one of endDate and count can be set at a time.\n        calendar_day_of_month : int, optional\n            The number of the day of the month. Required if frequency is Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31.\n        count : int, optional\n            The number of dates to be generated,  counting from the start date (or today's date if the start day is not set) to the end date.\n            It should not have a negative value.\n            Required if endDate is not specified. Only one of endDate and count can be set at a time.\n        day_of_week : Union[str, WeekDay], optional\n            The day of the week. Required if frequency is Weekly or BiWeekly; do not use otherwise.\n        fields : str, optional\n            A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n            Some usage examples:\n            1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n            2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n            3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n            4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n        Returns\n        --------\n        List[datetime.date]\n            A date on a calendar without a time zone, e.g. \"April 10th\"\n\n        Examples\n        --------\n        >>> my_cal.generate_date_schedule(\n        >>>     start_date=\"2023-04-30\", frequency=Frequency.WEEKLY, count=20, day_of_week=WeekDay.TUESDAY\n        >>> )\n        [datetime.date(2023, 5, 9),\n         datetime.date(2023, 5, 16),\n         datetime.date(2023, 5, 23),\n         datetime.date(2023, 5, 30),\n         datetime.date(2023, 6, 6),\n         datetime.date(2023, 6, 13),\n         datetime.date(2023, 6, 16),\n         datetime.date(2023, 6, 27),\n         datetime.date(2023, 7, 4),\n         datetime.date(2023, 7, 11),\n         datetime.date(2023, 7, 18),\n         datetime.date(2023, 7, 25),\n         datetime.date(2023, 8, 1),\n         datetime.date(2023, 8, 8),\n         datetime.date(2023, 8, 15),\n         datetime.date(2023, 8, 22),\n         datetime.date(2023, 8, 29),\n         datetime.date(2023, 9, 5),\n         datetime.date(2023, 9, 12),\n         datetime.date(2023, 9, 19)]\n\n        \n        \"\"\"",
        "metadata": {
            "doc": "\n        Generates a date schedule for the calendar according to specified conditions. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n        Parameters\n        ----------\n        frequency : Union[str, Frequency]\n            The frequency of dates in the schedule which should be generated. Note that \"Daily\" refers to working days only.\n        start_date : Union[str, datetime.date], optional\n            The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).\n            The start date must be less or equal to the end date.\n            Required if endDate is in the past.\n        end_date : Union[str, datetime.date], optional\n            The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n            If startDate is not specified, endDate is used to define the list of dates from today's date to the end date.\n            The end date must be greater or equal to the start date.\n            Required if count is not specified. Only one of endDate and count can be set at a time.\n        calendar_day_of_month : int, optional\n            The number of the day of the month. Required if frequency is Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31.\n        count : int, optional\n            The number of dates to be generated,  counting from the start date (or today's date if the start day is not set) to the end date.\n            It should not have a negative value.\n            Required if endDate is not specified. Only one of endDate and count can be set at a time.\n        day_of_week : Union[str, WeekDay], optional\n            The day of the week. Required if frequency is Weekly or BiWeekly; do not use otherwise.\n        fields : str, optional\n            A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n            Some usage examples:\n            1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n            2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n            3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n            4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n        Returns\n        --------\n        List[datetime.date]\n            A date on a calendar without a time zone, e.g. \"April 10th\"\n\n        Examples\n        --------\n        >>> my_cal.generate_date_schedule(\n        >>>     start_date=\"2023-04-30\", frequency=Frequency.WEEKLY, count=20, day_of_week=WeekDay.TUESDAY\n        >>> )\n        [datetime.date(2023, 5, 9),\n         datetime.date(2023, 5, 16),\n         datetime.date(2023, 5, 23),\n         datetime.date(2023, 5, 30),\n         datetime.date(2023, 6, 6),\n         datetime.date(2023, 6, 13),\n         datetime.date(2023, 6, 16),\n         datetime.date(2023, 6, 27),\n         datetime.date(2023, 7, 4),\n         datetime.date(2023, 7, 11),\n         datetime.date(2023, 7, 18),\n         datetime.date(2023, 7, 25),\n         datetime.date(2023, 8, 1),\n         datetime.date(2023, 8, 8),\n         datetime.date(2023, 8, 15),\n         datetime.date(2023, 8, 22),\n         datetime.date(2023, 8, 29),\n         datetime.date(2023, 9, 5),\n         datetime.date(2023, 9, 12),\n         datetime.date(2023, 9, 19)]\n\n        \n",
            "signature": "class Calendar:\n    def generate_date_schedule(self, *, frequency: Union[str, Frequency], start_date: Union[str, datetime.date, NoneType] = None, end_date: Union[str, datetime.date, NoneType] = None, calendar_day_of_month: Optional[int] = None, count: Optional[int] = None, day_of_week: Union[str, WeekDay, NoneType] = None, fields: Optional[str] = None) -> List[datetime.date]:",
            "class": "Calendar"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar"
            ],
            "use": [
                "lseg_analytics.pricing.common.Frequency",
                "lseg_analytics.pricing.common.WeekDay"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "MethodChunk",
        "name": "Calendar.generate_holidays",
        "id": "lseg_analytics.pricing.reference_data.calendars.Calendar.generate_holidays",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "end_date",
                "type": "date"
            },
            {
                "name": "start_date",
                "type": "date"
            },
            {
                "name": "fields",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_calendar.py",
        "line_number": 490,
        "content": "class Calendar:\n    def generate_holidays(self, *, end_date: Union[str, datetime.date], start_date: Union[str, datetime.date, NoneType] = None, fields: Optional[str] = None) -> List[Holiday]:\n        \"\"\"\n        Gets the holidays for the calendar within a date range. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n        Parameters\n        ----------\n        start_date : Union[str, datetime.date], optional\n            The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01). Default is today.\n        end_date : Union[str, datetime.date]\n            The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n        fields : str, optional\n            A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n            Some usage examples:\n            1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n            2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n            3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n            4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n        Returns\n        --------\n        List[Holiday]\n            Dates and names of holidays for a requested calendar.\n\n        Examples\n        --------\n        >>> response = my_cal.generate_holidays(start_date='2023-01-01', end_date='2023-01-31')\n        >>> response[0]\n        {'date': '2023-01-01', 'names': [{'name': \"New Year's Day\", 'calendars': ['LSEG/ARG'], 'countries': ['ARG']}]}\n\n        \n        \"\"\"",
        "metadata": {
            "doc": "\n        Gets the holidays for the calendar within a date range. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n        Parameters\n        ----------\n        start_date : Union[str, datetime.date], optional\n            The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01). Default is today.\n        end_date : Union[str, datetime.date]\n            The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n        fields : str, optional\n            A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n            Some usage examples:\n            1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n            2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n            3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n            4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n        Returns\n        --------\n        List[Holiday]\n            Dates and names of holidays for a requested calendar.\n\n        Examples\n        --------\n        >>> response = my_cal.generate_holidays(start_date='2023-01-01', end_date='2023-01-31')\n        >>> response[0]\n        {'date': '2023-01-01', 'names': [{'name': \"New Year's Day\", 'calendars': ['LSEG/ARG'], 'countries': ['ARG']}]}\n\n        \n",
            "signature": "class Calendar:\n    def generate_holidays(self, *, end_date: Union[str, datetime.date], start_date: Union[str, datetime.date, NoneType] = None, fields: Optional[str] = None) -> List[Holiday]:",
            "class": "Calendar"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar"
            ],
            "use": [
                "lseg_analytics.pricing.reference_data.calendars.Holiday"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "MethodChunk",
        "name": "Calendar.save",
        "id": "lseg_analytics.pricing.reference_data.calendars.Calendar.save",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "name",
                "type": "str",
                "valuelookup": "Calendar.name"
            },
            {
                "name": "space",
                "type": "str",
                "valuelookup": "Calendar.space"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_calendar.py",
        "line_number": 572,
        "content": "class Calendar:\n    def save(self, *, name: Optional[str] = None, space: Optional[str] = None) -> bool:\n        \"\"\"\n        Save Calendar instance in the platform store.\n\n        Parameters\n        ----------\n        name : str, optional\n            The Calendar name. The name parameter must be specified when the object is first created. Thereafter it is optional. For first creation, name must follow the pattern '^[A-Za-z0-9_]{1,50}$'.\n        space : str, optional\n            The space where the Calendar is stored. Space is like a namespace where resources are stored. By default there are two spaces:\n            LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If space is not specified, HOME will be used.\n\n        Returns\n        --------\n        bool, optional\n            True, if saved successfully, otherwise None\n\n\n        Examples\n        --------\n        >>> # Create a calendar instance with parameter.\n        >>> my_cal_definition = CalendarDefinition(rest_days=[\n        >>>                     RestDays(\n        >>>                         rest_days=[WeekDay.SATURDAY, WeekDay.SUNDAY],\n        >>>                         validity_period=ValidityPeriod(\n        >>>                             start_date=\"2024-01-01\",\n        >>>                             end_date=\"2024-12-31\",\n        >>>                         ),\n        >>>                     )\n        >>>                 ],\n        >>>                     first_day_of_week=WeekDay.FRIDAY,\n        >>>                     holiday_rules=[\n        >>>                     HolidayRule(\n        >>>                         name=\"New Year's Day\",\n        >>>                         duration=FullDayDuration(full_day=1),\n        >>>                         validity_period=ValidityPeriod(\n        >>>                             start_date=\"2024-01-01\",\n        >>>                             end_date=\"2024-12-31\",\n        >>>                         ),\n        >>>                         when=AbsolutePositionWhen(day_of_month=1, month=Month.JANUARY),\n        >>>                     ),\n        >>>                 ]\n        >>>                 )\n        >>> my_cal = Calendar(definition=my_cal_definition)\n\n\n        >>> # Save the instance with name and space.\n        >>> my_cal.save(name=\"my_personal_calendar\", space=\"HOME\")\n        True\n\n        \n        \"\"\"",
        "metadata": {
            "doc": "\n        Save Calendar instance in the platform store.\n\n        Parameters\n        ----------\n        name : str, optional\n            The Calendar name. The name parameter must be specified when the object is first created. Thereafter it is optional. For first creation, name must follow the pattern '^[A-Za-z0-9_]{1,50}$'.\n        space : str, optional\n            The space where the Calendar is stored. Space is like a namespace where resources are stored. By default there are two spaces:\n            LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If space is not specified, HOME will be used.\n\n        Returns\n        --------\n        bool, optional\n            True, if saved successfully, otherwise None\n\n\n        Examples\n        --------\n        >>> # Create a calendar instance with parameter.\n        >>> my_cal_definition = CalendarDefinition(rest_days=[\n        >>>                     RestDays(\n        >>>                         rest_days=[WeekDay.SATURDAY, WeekDay.SUNDAY],\n        >>>                         validity_period=ValidityPeriod(\n        >>>                             start_date=\"2024-01-01\",\n        >>>                             end_date=\"2024-12-31\",\n        >>>                         ),\n        >>>                     )\n        >>>                 ],\n        >>>                     first_day_of_week=WeekDay.FRIDAY,\n        >>>                     holiday_rules=[\n        >>>                     HolidayRule(\n        >>>                         name=\"New Year's Day\",\n        >>>                         duration=FullDayDuration(full_day=1),\n        >>>                         validity_period=ValidityPeriod(\n        >>>                             start_date=\"2024-01-01\",\n        >>>                             end_date=\"2024-12-31\",\n        >>>                         ),\n        >>>                         when=AbsolutePositionWhen(day_of_month=1, month=Month.JANUARY),\n        >>>                     ),\n        >>>                 ]\n        >>>                 )\n        >>> my_cal = Calendar(definition=my_cal_definition)\n\n\n        >>> # Save the instance with name and space.\n        >>> my_cal.save(name=\"my_personal_calendar\", space=\"HOME\")\n        True\n\n        \n",
            "signature": "class Calendar:\n    def save(self, *, name: Optional[str] = None, space: Optional[str] = None) -> bool:",
            "class": "Calendar"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "MethodChunk",
        "name": "Calendar.clone",
        "id": "lseg_analytics.pricing.reference_data.calendars.Calendar.clone",
        "params": [],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_calendar.py",
        "line_number": 641,
        "content": "class Calendar:\n    def clone(self) -> 'Calendar':\n        \"\"\"\n        Return the same object, without id, name and space\n\n        Parameters\n        ----------\n\n\n        Returns\n        --------\n        Calendar\n            The cloned Calendar object\n\n\n        Examples\n        --------\n        >>> # Clone the existing instance on definition and description.\n        >>> my_cal_clone = my_cal.clone()\n        >>> my_cal_clone.save(name=\"my_cloned_calendar\", space=\"HOME\")\n        True\n\n        \n        \"\"\"",
        "metadata": {
            "doc": "\n        Return the same object, without id, name and space\n\n        Parameters\n        ----------\n\n\n        Returns\n        --------\n        Calendar\n            The cloned Calendar object\n\n\n        Examples\n        --------\n        >>> # Clone the existing instance on definition and description.\n        >>> my_cal_clone = my_cal.clone()\n        >>> my_cal_clone.save(name=\"my_cloned_calendar\", space=\"HOME\")\n        True\n\n        \n",
            "signature": "class Calendar:\n    def clone(self) -> 'Calendar':",
            "class": "Calendar"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar"
            ],
            "use": [
                "lseg_analytics.pricing.reference_data.calendars.Calendar"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "CalendarDefinition",
        "id": "lseg_analytics.pricing.reference_data.calendars.CalendarDefinition",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "rest_days",
                "type": "List[RestDays]"
            },
            {
                "name": "first_day_of_week",
                "type": "WeekDay",
                "valuelookup": "enum.WeekDay"
            },
            {
                "name": "holiday_rules",
                "type": "List[HolidayRule]"
            },
            {
                "name": "holiday_exception_rules",
                "type": "List[HolidayRule]"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 9431,
        "content": "class CalendarDefinition:\n    \"\"\"An object to define the Calendar resource. The list type properties will not be initialized as\n    empty list by default. A list of objects should be assigned first before adding new elements.\n\n    Attributes\n    ----------\n    rest_days : list[~analyticsapi.models.RestDays]\n        An array of objects to determine rest days for the calendar.  The\n        default value is None, needs to be assigned before using.\n    first_day_of_week : str or ~analyticsapi.models.WeekDay\n        The first day of the week set for the calendar. Known values are:\n        \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and\n        \"Sunday\".\n    holiday_rules : list[~analyticsapi.models.HolidayRule]\n        An array of objects to set holiday rules for the calendar.  The default\n        value is None, needs to be assigned before using.\n    holiday_exception_rules : list[~analyticsapi.models.HolidayRule]\n        An array of objects to determine exceptions from the holiday rules set\n        for the calendar.  The default value is None, needs to be assigned\n        before using.\n    \n    \"\"\"\n    rest_days: typing.Optional[typing.List[ForwardRef('_models.RestDays')]]\n    first_day_of_week: typing.Union[str, ForwardRef('_models.WeekDay'), NoneType]\n    holiday_rules: typing.Optional[typing.List[ForwardRef('_models.HolidayRule')]]\n    holiday_exception_rules: typing.Optional[typing.List[ForwardRef('_models.HolidayRule')]]",
        "metadata": {
            "doc": "An object to define the Calendar resource. The list type properties will not be initialized as\n    empty list by default. A list of objects should be assigned first before adding new elements.\n\n    Attributes\n    ----------\n    rest_days : list[~analyticsapi.models.RestDays]\n        An array of objects to determine rest days for the calendar.  The\n        default value is None, needs to be assigned before using.\n    first_day_of_week : str or ~analyticsapi.models.WeekDay\n        The first day of the week set for the calendar. Known values are:\n        \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and\n        \"Sunday\".\n    holiday_rules : list[~analyticsapi.models.HolidayRule]\n        An array of objects to set holiday rules for the calendar.  The default\n        value is None, needs to be assigned before using.\n    holiday_exception_rules : list[~analyticsapi.models.HolidayRule]\n        An array of objects to determine exceptions from the holiday rules set\n        for the calendar.  The default value is None, needs to be assigned\n        before using.\n    \n",
            "annotations": "    rest_days: typing.Optional[typing.List[ForwardRef('_models.RestDays')]]\n    first_day_of_week: typing.Union[str, ForwardRef('_models.WeekDay'), NoneType]\n    holiday_rules: typing.Optional[typing.List[ForwardRef('_models.HolidayRule')]]\n    holiday_exception_rules: typing.Optional[typing.List[ForwardRef('_models.HolidayRule')]]",
            "signature": "class CalendarDefinition:\n    \"\"\"\"\"\"\n    rest_days: typing.Optional[typing.List[ForwardRef('_models.RestDays')]]\n    first_day_of_week: typing.Union[str, ForwardRef('_models.WeekDay'), NoneType]\n    holiday_rules: typing.Optional[typing.List[ForwardRef('_models.HolidayRule')]]\n    holiday_exception_rules: typing.Optional[typing.List[ForwardRef('_models.HolidayRule')]]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.CalendarDefinition.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.reference_data.calendars.RestDays",
                "lseg_analytics.pricing.common.WeekDay",
                "lseg_analytics.pricing.reference_data.calendars.HolidayRule"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "CalendarDefinition.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.CalendarDefinition.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 9482,
        "content": "class CalendarDefinition:\n    @overload\n    def __init__(self, *, rest_days: Optional[List[ForwardRef('_models.RestDays')]] = None, first_day_of_week: Union[str, ForwardRef('_models.WeekDay'), NoneType] = None, holiday_rules: Optional[List[ForwardRef('_models.HolidayRule')]] = None, holiday_exception_rules: Optional[List[ForwardRef('_models.HolidayRule')]] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "CalendarDefinition"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.CalendarDefinition"
            ],
            "use": [
                "lseg_analytics.pricing.reference_data.calendars.RestDays",
                "lseg_analytics.pricing.common.WeekDay",
                "lseg_analytics.pricing.reference_data.calendars.HolidayRule"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "CalendarInfo",
        "id": "lseg_analytics.pricing.reference_data.calendars.CalendarInfo",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "location",
                "type": "Location"
            },
            {
                "name": "description",
                "type": "Description"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 9486,
        "content": "class CalendarInfo:\n    \"\"\"Object defining the links available on a Calendar resource.\n\n    Readonly variables are only populated by the server, and will be ignored when sending a request.\n\n    Attributes\n    ----------\n    type : str or ~analyticsapi.models.CALENDAR\n        Property defining the type of the resource.\n    id : str\n        Unique identifier of the Calendar.\n    location : ~analyticsapi.models.Location\n        Object defining metadata for the Calendar. Required.\n    description : ~analyticsapi.models.Description\n        Object defining the Calendar.\n    \n    \"\"\"\n    type: typing.Optional[typing.Literal[<ResourceType.CALENDAR: 'Calendar'>]]\n    id: typing.Optional[str]\n    location: _models.Location\n    description: typing.Optional[ForwardRef('_models.Description')]",
        "metadata": {
            "doc": "Object defining the links available on a Calendar resource.\n\n    Readonly variables are only populated by the server, and will be ignored when sending a request.\n\n    Attributes\n    ----------\n    type : str or ~analyticsapi.models.CALENDAR\n        Property defining the type of the resource.\n    id : str\n        Unique identifier of the Calendar.\n    location : ~analyticsapi.models.Location\n        Object defining metadata for the Calendar. Required.\n    description : ~analyticsapi.models.Description\n        Object defining the Calendar.\n    \n",
            "annotations": "    type: typing.Optional[typing.Literal[<ResourceType.CALENDAR: 'Calendar'>]]\n    id: typing.Optional[str]\n    location: _models.Location\n    description: typing.Optional[ForwardRef('_models.Description')]",
            "signature": "class CalendarInfo:\n    \"\"\"\"\"\"\n    type: typing.Optional[typing.Literal[<ResourceType.CALENDAR: 'Calendar'>]]\n    id: typing.Optional[str]\n    location: _models.Location\n    description: typing.Optional[ForwardRef('_models.Description')]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.CalendarInfo.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.Location",
                "lseg_analytics.pricing.common.Description"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "CalendarInfo.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.CalendarInfo.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 9529,
        "content": "class CalendarInfo:\n    @overload\n    def __init__(self, *, location: '_models.Location', description: Optional[ForwardRef('_models.Description')] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "CalendarInfo"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.CalendarInfo"
            ],
            "use": [
                "lseg_analytics.pricing.common.Location",
                "lseg_analytics.pricing.common.Description"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "ComputeDatesBatched",
        "id": "lseg_analytics.pricing.reference_data.calendars.ComputeDatesBatched",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "tenor",
                "type": "str",
                "valuelookup": "tenors"
            },
            {
                "name": "end_date",
                "type": "date"
            },
            {
                "name": "processing_information",
                "type": "str"
            },
            {
                "name": "error",
                "type": "ServiceError"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 18687,
        "content": "class ComputeDatesBatched:\n    \"\"\"An object to definine the properties of the calculated dates returned, with a dedicated error\n    object for each calculation. This serializable object behaves exactly like a list of\n    dictionaries when iterated or displayed. It can be converted to a DataFrame without\n    transformation.\n\n    Attributes\n    ----------\n    tenor : str\n        The code indicating the tenor added to startDate to calculate the\n        resulted date (e.g., 1Y). Required.\n    end_date : ~datetime.date\n        The date produced by the calculation. The value is expressed in ISO\n        8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n    processing_information : str\n        The error message for the calculation in case of a non-blocking error.\n    error : ~analyticsapi.models.ServiceError\n    \n    \"\"\"\n    tenor: str\n    end_date: typing.Optional[datetime.date]\n    processing_information: typing.Optional[str]\n    error: typing.Optional[ForwardRef('_models.ServiceError')]",
        "metadata": {
            "doc": "An object to definine the properties of the calculated dates returned, with a dedicated error\n    object for each calculation. This serializable object behaves exactly like a list of\n    dictionaries when iterated or displayed. It can be converted to a DataFrame without\n    transformation.\n\n    Attributes\n    ----------\n    tenor : str\n        The code indicating the tenor added to startDate to calculate the\n        resulted date (e.g., 1Y). Required.\n    end_date : ~datetime.date\n        The date produced by the calculation. The value is expressed in ISO\n        8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n    processing_information : str\n        The error message for the calculation in case of a non-blocking error.\n    error : ~analyticsapi.models.ServiceError\n    \n",
            "annotations": "    tenor: str\n    end_date: typing.Optional[datetime.date]\n    processing_information: typing.Optional[str]\n    error: typing.Optional[ForwardRef('_models.ServiceError')]",
            "signature": "class ComputeDatesBatched:\n    \"\"\"\"\"\"\n    tenor: str\n    end_date: typing.Optional[datetime.date]\n    processing_information: typing.Optional[str]\n    error: typing.Optional[ForwardRef('_models.ServiceError')]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.ComputeDatesBatched.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.ServiceError"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "ComputeDatesBatched.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.ComputeDatesBatched.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 18735,
        "content": "class ComputeDatesBatched:\n    @overload\n    def __init__(self, *, tenor: str, end_date: Optional[datetime.date] = None, processing_information: Optional[str] = None, error: Optional[ForwardRef('_models.ServiceError')] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "ComputeDatesBatched"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.ComputeDatesBatched"
            ],
            "use": [
                "lseg_analytics.pricing.common.ServiceError"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "CountPeriodsOutput",
        "id": "lseg_analytics.pricing.reference_data.calendars.CountPeriodsOutput",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "count",
                "type": "float"
            },
            {
                "name": "period_type",
                "type": "PeriodTypeOutput",
                "valuelookup": "enum.PeriodTypeOutput"
            },
            {
                "name": "processing_information",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 19192,
        "content": "class CountPeriodsOutput:\n    \"\"\"The result of the period calculation for the count periods endpoint.\n\n    Attributes\n    ----------\n    count : float\n        The calculated number of dates in the period from startDate to endDate.\n        endDate is included, startDate is not. Required.\n    period_type : str or ~analyticsapi.models.PeriodTypeOutput\n        The type of the calculated period. Required. Known values are: \"Day\",\n        \"WorkingDay\", \"Week\", \"Month\", \"Quarter\", and \"Year\".\n    processing_information : str\n        The error message for the calculation in case of a non-blocking error.\n    \n    \"\"\"\n    count: float\n    period_type: typing.Union[str, ForwardRef('_models.PeriodTypeOutput')]\n    processing_information: typing.Optional[str]",
        "metadata": {
            "doc": "The result of the period calculation for the count periods endpoint.\n\n    Attributes\n    ----------\n    count : float\n        The calculated number of dates in the period from startDate to endDate.\n        endDate is included, startDate is not. Required.\n    period_type : str or ~analyticsapi.models.PeriodTypeOutput\n        The type of the calculated period. Required. Known values are: \"Day\",\n        \"WorkingDay\", \"Week\", \"Month\", \"Quarter\", and \"Year\".\n    processing_information : str\n        The error message for the calculation in case of a non-blocking error.\n    \n",
            "annotations": "    count: float\n    period_type: typing.Union[str, ForwardRef('_models.PeriodTypeOutput')]\n    processing_information: typing.Optional[str]",
            "signature": "class CountPeriodsOutput:\n    \"\"\"\"\"\"\n    count: float\n    period_type: typing.Union[str, ForwardRef('_models.PeriodTypeOutput')]\n    processing_information: typing.Optional[str]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.CountPeriodsOutput.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.PeriodTypeOutput"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "CountPeriodsOutput.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.CountPeriodsOutput.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 19234,
        "content": "class CountPeriodsOutput:\n    @overload\n    def __init__(self, *, count: float, period_type: Union[str, ForwardRef('_models.PeriodTypeOutput')], processing_information: Optional[str] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "CountPeriodsOutput"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.CountPeriodsOutput"
            ],
            "use": [
                "lseg_analytics.pricing.common.PeriodTypeOutput"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "FullDayDuration",
        "id": "lseg_analytics.pricing.reference_data.calendars.FullDayDuration",
        "params": [
            {
                "name": "full_day",
                "type": "int"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 29825,
        "content": "class FullDayDuration:\n    \"\"\"An object to determine the duration of the holiday taking into account a full day.\n\n    Attributes\n    ----------\n    duration_type : str or ~analyticsapi.models.FULL_DAY_DURATION\n        The type of the holiday duration. Only FullDayDuration value applies.\n        Required. Full day holidays.\n    full_day : int\n        The number of full calendar days to determine the duration of the\n        holiday. The minimum value is 1. Required.\n    \n    \"\"\"\n    duration_type: typing.Literal[<DurationType.FULL_DAY_DURATION: 'FullDayDuration'>]\n    full_day: int",
        "metadata": {
            "doc": "An object to determine the duration of the holiday taking into account a full day.\n\n    Attributes\n    ----------\n    duration_type : str or ~analyticsapi.models.FULL_DAY_DURATION\n        The type of the holiday duration. Only FullDayDuration value applies.\n        Required. Full day holidays.\n    full_day : int\n        The number of full calendar days to determine the duration of the\n        holiday. The minimum value is 1. Required.\n    \n",
            "annotations": "    duration_type: typing.Literal[<DurationType.FULL_DAY_DURATION: 'FullDayDuration'>]\n    full_day: int",
            "signature": "class FullDayDuration:\n    \"\"\"\"\"\"\n    duration_type: typing.Literal[<DurationType.FULL_DAY_DURATION: 'FullDayDuration'>]\n    full_day: int"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.FullDayDuration.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [
                "lseg_analytics.pricing.common.Duration"
            ],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "FullDayDuration.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.FullDayDuration.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 29860,
        "content": "class FullDayDuration:\n    @overload\n    def __init__(self, full_day: int) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "FullDayDuration"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.FullDayDuration"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "HalfDayDuration",
        "id": "lseg_analytics.pricing.reference_data.calendars.HalfDayDuration",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "start_time",
                "type": "Time"
            },
            {
                "name": "end_time",
                "type": "Time"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 35110,
        "content": "class HalfDayDuration:\n    \"\"\"An object to determine the duration of the holiday within one day.\n\n    Attributes\n    ----------\n    duration_type : str or ~analyticsapi.models.HALF_DAY_DURATION\n        The type of the holiday duration. Only HalfDayDuration value applies.\n        Required. Half day holidays. Designed to account for the days the\n        markets are open, but not for a full trading session.\n    start_time : ~analyticsapi.models.Time\n        An object to determine the start time of the holiday duration.\n    end_time : ~analyticsapi.models.Time\n        An object to determine the end time of the holiday duration.\n    \n    \"\"\"\n    duration_type: typing.Literal[<DurationType.HALF_DAY_DURATION: 'HalfDayDuration'>]\n    start_time: typing.Optional[ForwardRef('_models.Time')]\n    end_time: typing.Optional[ForwardRef('_models.Time')]",
        "metadata": {
            "doc": "An object to determine the duration of the holiday within one day.\n\n    Attributes\n    ----------\n    duration_type : str or ~analyticsapi.models.HALF_DAY_DURATION\n        The type of the holiday duration. Only HalfDayDuration value applies.\n        Required. Half day holidays. Designed to account for the days the\n        markets are open, but not for a full trading session.\n    start_time : ~analyticsapi.models.Time\n        An object to determine the start time of the holiday duration.\n    end_time : ~analyticsapi.models.Time\n        An object to determine the end time of the holiday duration.\n    \n",
            "annotations": "    duration_type: typing.Literal[<DurationType.HALF_DAY_DURATION: 'HalfDayDuration'>]\n    start_time: typing.Optional[ForwardRef('_models.Time')]\n    end_time: typing.Optional[ForwardRef('_models.Time')]",
            "signature": "class HalfDayDuration:\n    \"\"\"\"\"\"\n    duration_type: typing.Literal[<DurationType.HALF_DAY_DURATION: 'HalfDayDuration'>]\n    start_time: typing.Optional[ForwardRef('_models.Time')]\n    end_time: typing.Optional[ForwardRef('_models.Time')]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.HalfDayDuration.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.Time"
            ],
            "base_classes": [
                "lseg_analytics.pricing.common.Duration"
            ],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "HalfDayDuration.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.HalfDayDuration.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 35151,
        "content": "class HalfDayDuration:\n    @overload\n    def __init__(self, *, start_time: Optional[ForwardRef('_models.Time')] = None, end_time: Optional[ForwardRef('_models.Time')] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "HalfDayDuration"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.HalfDayDuration"
            ],
            "use": [
                "lseg_analytics.pricing.common.Time"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "Holiday",
        "id": "lseg_analytics.pricing.reference_data.calendars.Holiday",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "date",
                "type": "date"
            },
            {
                "name": "names",
                "type": "List[HolidayNames]"
            },
            {
                "name": "processing_information",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 35307,
        "content": "class Holiday:\n    \"\"\"Dates and names of holidays for a requested calendar.\n\n    Attributes\n    ----------\n    date : ~datetime.date\n        The date on which the holiday falls. The value is expressed in ISO 8601\n        format: YYYY-MM-DD (e.g., 2024-01-01). Required.\n    names : list[~analyticsapi.models.HolidayNames]\n        An array of objects to define the holiday name, calendar and country in\n        which that holiday falls.  The default value is None, needs to be\n        assigned before using.\n    processing_information : str\n        The error message for the calculation in case of a non-blocking error.\n    \n    \"\"\"\n    date: date\n    names: typing.Optional[typing.List[ForwardRef('_models.HolidayNames')]]\n    processing_information: typing.Optional[str]",
        "metadata": {
            "doc": "Dates and names of holidays for a requested calendar.\n\n    Attributes\n    ----------\n    date : ~datetime.date\n        The date on which the holiday falls. The value is expressed in ISO 8601\n        format: YYYY-MM-DD (e.g., 2024-01-01). Required.\n    names : list[~analyticsapi.models.HolidayNames]\n        An array of objects to define the holiday name, calendar and country in\n        which that holiday falls.  The default value is None, needs to be\n        assigned before using.\n    processing_information : str\n        The error message for the calculation in case of a non-blocking error.\n    \n",
            "annotations": "    date: date\n    names: typing.Optional[typing.List[ForwardRef('_models.HolidayNames')]]\n    processing_information: typing.Optional[str]",
            "signature": "class Holiday:\n    \"\"\"\"\"\"\n    date: date\n    names: typing.Optional[typing.List[ForwardRef('_models.HolidayNames')]]\n    processing_information: typing.Optional[str]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.Holiday.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.reference_data.calendars.HolidayNames"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "Holiday.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.Holiday.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 35350,
        "content": "class Holiday:\n    @overload\n    def __init__(self, *, date: datetime.date, names: Optional[List[ForwardRef('_models.HolidayNames')]] = None, processing_information: Optional[str] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "Holiday"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Holiday"
            ],
            "use": [
                "lseg_analytics.pricing.reference_data.calendars.HolidayNames"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "HolidayNames",
        "id": "lseg_analytics.pricing.reference_data.calendars.HolidayNames",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "name",
                "type": "str"
            },
            {
                "name": "calendars",
                "type": "List[str]",
                "valuelookup": "Calendar.scoped"
            },
            {
                "name": "countries",
                "type": "List[str]",
                "valuelookup": "country_list"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 35354,
        "content": "class HolidayNames:\n    \"\"\"An object to define the holiday name, calendar and country in which that holiday falls.\n\n    Attributes\n    ----------\n    name : str\n        The name of the holiday.\n    calendars : list[str]\n        An array of calendar defining objects for which the calculation is\n        done.  The default value is None, needs to be assigned before using.\n    countries : list[str]\n        An array of country codes the holiday belongs to. For example, FRA for\n        France, UKG for The United Kingdom.  The default value is None, needs\n        to be assigned before using.\n    \n    \"\"\"\n    name: typing.Optional[str]\n    calendars: typing.Optional[typing.List[str]]\n    countries: typing.Optional[typing.List[str]]",
        "metadata": {
            "doc": "An object to define the holiday name, calendar and country in which that holiday falls.\n\n    Attributes\n    ----------\n    name : str\n        The name of the holiday.\n    calendars : list[str]\n        An array of calendar defining objects for which the calculation is\n        done.  The default value is None, needs to be assigned before using.\n    countries : list[str]\n        An array of country codes the holiday belongs to. For example, FRA for\n        France, UKG for The United Kingdom.  The default value is None, needs\n        to be assigned before using.\n    \n",
            "annotations": "    name: typing.Optional[str]\n    calendars: typing.Optional[typing.List[str]]\n    countries: typing.Optional[typing.List[str]]",
            "signature": "class HolidayNames:\n    \"\"\"\"\"\"\n    name: typing.Optional[str]\n    calendars: typing.Optional[typing.List[str]]\n    countries: typing.Optional[typing.List[str]]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.HolidayNames.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "HolidayNames.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.HolidayNames.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 35396,
        "content": "class HolidayNames:\n    @overload\n    def __init__(self, *, name: Optional[str] = None, calendars: Optional[List[str]] = None, countries: Optional[List[str]] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "HolidayNames"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.HolidayNames"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "HolidayRule",
        "id": "lseg_analytics.pricing.reference_data.calendars.HolidayRule",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "name",
                "type": "str"
            },
            {
                "name": "duration",
                "type": "Duration"
            },
            {
                "name": "validity_period",
                "type": "ValidityPeriod"
            },
            {
                "name": "when",
                "type": "When"
            },
            {
                "name": "description",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 35400,
        "content": "class HolidayRule:\n    \"\"\"An object to set holiday rules for the calendar.\n\n    Attributes\n    ----------\n    name : str\n        The name of the holiday rule. An alphanumeric character (upper or lower\n        case), followed by 1 to 75 characters: alpha numeric (upper and lower\n        case) plus spaces, parentheses, dashes, equals and single quotes.\n        Required.\n    description : str\n        The description of the holiday rule.\n    duration : ~analyticsapi.models.Duration\n        An object to determine the duration of the holiday. Either a number of\n        days or the object describing half day holiday should be defined.\n        Required.\n    validity_period : ~analyticsapi.models.ValidityPeriod\n        An object to determine the validity period. Required.\n    when : ~analyticsapi.models.When\n        An object to determine regular annual holiday rules for the calendar.\n        Possible values are: AbsolutePositionWhen (for fixed holidays),\n        RelativePositionWhen (for holidays that fall on a particular day of the\n        week) or RelativeToRulePositionWhen (for holidays that are set by\n        reference to another date). Required.\n    \n    \"\"\"\n    name: str\n    description: typing.Optional[str]\n    duration: _models.Duration\n    validity_period: _models.ValidityPeriod\n    when: _models.When",
        "metadata": {
            "doc": "An object to set holiday rules for the calendar.\n\n    Attributes\n    ----------\n    name : str\n        The name of the holiday rule. An alphanumeric character (upper or lower\n        case), followed by 1 to 75 characters: alpha numeric (upper and lower\n        case) plus spaces, parentheses, dashes, equals and single quotes.\n        Required.\n    description : str\n        The description of the holiday rule.\n    duration : ~analyticsapi.models.Duration\n        An object to determine the duration of the holiday. Either a number of\n        days or the object describing half day holiday should be defined.\n        Required.\n    validity_period : ~analyticsapi.models.ValidityPeriod\n        An object to determine the validity period. Required.\n    when : ~analyticsapi.models.When\n        An object to determine regular annual holiday rules for the calendar.\n        Possible values are: AbsolutePositionWhen (for fixed holidays),\n        RelativePositionWhen (for holidays that fall on a particular day of the\n        week) or RelativeToRulePositionWhen (for holidays that are set by\n        reference to another date). Required.\n    \n",
            "annotations": "    name: str\n    description: typing.Optional[str]\n    duration: _models.Duration\n    validity_period: _models.ValidityPeriod\n    when: _models.When",
            "signature": "class HolidayRule:\n    \"\"\"\"\"\"\n    name: str\n    description: typing.Optional[str]\n    duration: _models.Duration\n    validity_period: _models.ValidityPeriod\n    when: _models.When"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.HolidayRule.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.Duration",
                "lseg_analytics.pricing.common.ValidityPeriod",
                "lseg_analytics.pricing.reference_data.calendars.When"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "HolidayRule.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.HolidayRule.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 35463,
        "content": "class HolidayRule:\n    @overload\n    def __init__(self, *, name: str, duration: '_models.Duration', validity_period: '_models.ValidityPeriod', when: '_models.When', description: Optional[str] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "HolidayRule"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.HolidayRule"
            ],
            "use": [
                "lseg_analytics.pricing.common.Duration",
                "lseg_analytics.pricing.common.ValidityPeriod",
                "lseg_analytics.pricing.reference_data.calendars.When"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "LagDaysRescheduleDescription",
        "id": "lseg_analytics.pricing.reference_data.calendars.LagDaysRescheduleDescription",
        "params": [
            {
                "name": "lag_days",
                "type": "int"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 44847,
        "content": "class LagDaysRescheduleDescription:\n    \"\"\"An object to determine the rule for rescheduling a holiday using day lags.\n\n    Attributes\n    ----------\n    reschedule_type : str or ~analyticsapi.models.LAG_DAYS_RESCHEDULE_DESCRIPTION\n        The type of rescheduling for the observation period. Only\n        LagDaysRescheduleDescription value applies. Required. The rule for\n        rescheduling a holiday using day lags. For example, if a holiday falls\n        on Sunday, it is rescheduled by the number of days defined by the lag.\n    lag_days : int\n        The length of the lag in days. The holiday will be rescheduled to a\n        date this many days in the future. Value can be negative. Required.\n    \n    \"\"\"\n    reschedule_type: typing.Literal[<RescheduleType.LAG_DAYS_RESCHEDULE_DESCRIPTION: 'LagDaysRescheduleDescription'>]\n    lag_days: int",
        "metadata": {
            "doc": "An object to determine the rule for rescheduling a holiday using day lags.\n\n    Attributes\n    ----------\n    reschedule_type : str or ~analyticsapi.models.LAG_DAYS_RESCHEDULE_DESCRIPTION\n        The type of rescheduling for the observation period. Only\n        LagDaysRescheduleDescription value applies. Required. The rule for\n        rescheduling a holiday using day lags. For example, if a holiday falls\n        on Sunday, it is rescheduled by the number of days defined by the lag.\n    lag_days : int\n        The length of the lag in days. The holiday will be rescheduled to a\n        date this many days in the future. Value can be negative. Required.\n    \n",
            "annotations": "    reschedule_type: typing.Literal[<RescheduleType.LAG_DAYS_RESCHEDULE_DESCRIPTION: 'LagDaysRescheduleDescription'>]\n    lag_days: int",
            "signature": "class LagDaysRescheduleDescription:\n    \"\"\"\"\"\"\n    reschedule_type: typing.Literal[<RescheduleType.LAG_DAYS_RESCHEDULE_DESCRIPTION: 'LagDaysRescheduleDescription'>]\n    lag_days: int"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.LagDaysRescheduleDescription.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [
                "lseg_analytics.pricing.reference_data.calendars.RescheduleDescription"
            ],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "LagDaysRescheduleDescription.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.LagDaysRescheduleDescription.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 44885,
        "content": "class LagDaysRescheduleDescription:\n    @overload\n    def __init__(self, lag_days: int) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "LagDaysRescheduleDescription"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.LagDaysRescheduleDescription"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "Observance",
        "id": "lseg_analytics.pricing.reference_data.calendars.Observance",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "falls_on",
                "type": "WeekDay",
                "valuelookup": "enum.WeekDay"
            },
            {
                "name": "reschedule_description",
                "type": "RescheduleDescription"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 47493,
        "content": "class Observance:\n    \"\"\"An object to determine a holiday rescheduling if it falls on a rest day.\n\n    Attributes\n    ----------\n    falls_on : str or ~analyticsapi.models.WeekDay\n        The day of the week the holiday falls on. It is used as a reference\n        point. Required. Known values are: \"Monday\", \"Tuesday\", \"Wednesday\",\n        \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\".\n    reschedule_description : ~analyticsapi.models.RescheduleDescription\n        An object to determine a holiday rescheduling. Required.\n    \n    \"\"\"\n    falls_on: typing.Union[str, ForwardRef('_models.WeekDay')]\n    reschedule_description: _models.RescheduleDescription",
        "metadata": {
            "doc": "An object to determine a holiday rescheduling if it falls on a rest day.\n\n    Attributes\n    ----------\n    falls_on : str or ~analyticsapi.models.WeekDay\n        The day of the week the holiday falls on. It is used as a reference\n        point. Required. Known values are: \"Monday\", \"Tuesday\", \"Wednesday\",\n        \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\".\n    reschedule_description : ~analyticsapi.models.RescheduleDescription\n        An object to determine a holiday rescheduling. Required.\n    \n",
            "annotations": "    falls_on: typing.Union[str, ForwardRef('_models.WeekDay')]\n    reschedule_description: _models.RescheduleDescription",
            "signature": "class Observance:\n    \"\"\"\"\"\"\n    falls_on: typing.Union[str, ForwardRef('_models.WeekDay')]\n    reschedule_description: _models.RescheduleDescription"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.Observance.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.WeekDay",
                "lseg_analytics.pricing.reference_data.calendars.RescheduleDescription"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "Observance.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.Observance.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 47530,
        "content": "class Observance:\n    @overload\n    def __init__(self, *, falls_on: Union[str, ForwardRef('_models.WeekDay')], reschedule_description: '_models.RescheduleDescription') -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "Observance"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.Observance"
            ],
            "use": [
                "lseg_analytics.pricing.common.WeekDay",
                "lseg_analytics.pricing.reference_data.calendars.RescheduleDescription"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "RelativePositionWhen",
        "id": "lseg_analytics.pricing.reference_data.calendars.RelativePositionWhen",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "index",
                "type": "IndexOrder",
                "valuelookup": "enum.IndexOrder"
            },
            {
                "name": "day_of_week",
                "type": "WeekDay",
                "valuelookup": "enum.WeekDay"
            },
            {
                "name": "month",
                "type": "Month",
                "valuelookup": "enum.Month"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 51524,
        "content": "class RelativePositionWhen:\n    \"\"\"An object to determine the rule for a holiday that falls on a certain day of the week in a\n    certain month. For example, Summer holiday on last Monday of August.\n\n    Attributes\n    ----------\n    position_type : str or ~analyticsapi.models.RELATIVE_POSITION_WHEN\n        The type of regular annual holiday rule. Only RelativePositionWhen\n        value applies. Required. A rule to determine a holiday depending on the\n        day of the week in a certain month. For example, Summer holiday on the\n        last Monday of August.\n    index : str or ~analyticsapi.models.IndexOrder\n        The ordinal number of the day of the week in the month. Required. Known\n        values are: \"First\", \"Second\", \"Third\", \"Fourth\", and \"Last\".\n    day_of_week : str or ~analyticsapi.models.WeekDay\n        The day of the week. Required. Known values are: \"Monday\", \"Tuesday\",\n        \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\".\n    month : str or ~analyticsapi.models.Month\n        The month of the year. Required. Known values are: \"January\",\n        \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\",\n        \"September\", \"October\", \"November\", and \"December\".\n    \n    \"\"\"\n    position_type: typing.Literal[<PositionType.RELATIVE_POSITION_WHEN: 'RelativePositionWhen'>]\n    index: typing.Union[str, ForwardRef('_models.IndexOrder')]\n    day_of_week: typing.Union[str, ForwardRef('_models.WeekDay')]\n    month: typing.Union[str, ForwardRef('_models.Month')]",
        "metadata": {
            "doc": "An object to determine the rule for a holiday that falls on a certain day of the week in a\n    certain month. For example, Summer holiday on last Monday of August.\n\n    Attributes\n    ----------\n    position_type : str or ~analyticsapi.models.RELATIVE_POSITION_WHEN\n        The type of regular annual holiday rule. Only RelativePositionWhen\n        value applies. Required. A rule to determine a holiday depending on the\n        day of the week in a certain month. For example, Summer holiday on the\n        last Monday of August.\n    index : str or ~analyticsapi.models.IndexOrder\n        The ordinal number of the day of the week in the month. Required. Known\n        values are: \"First\", \"Second\", \"Third\", \"Fourth\", and \"Last\".\n    day_of_week : str or ~analyticsapi.models.WeekDay\n        The day of the week. Required. Known values are: \"Monday\", \"Tuesday\",\n        \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\".\n    month : str or ~analyticsapi.models.Month\n        The month of the year. Required. Known values are: \"January\",\n        \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\",\n        \"September\", \"October\", \"November\", and \"December\".\n    \n",
            "annotations": "    position_type: typing.Literal[<PositionType.RELATIVE_POSITION_WHEN: 'RelativePositionWhen'>]\n    index: typing.Union[str, ForwardRef('_models.IndexOrder')]\n    day_of_week: typing.Union[str, ForwardRef('_models.WeekDay')]\n    month: typing.Union[str, ForwardRef('_models.Month')]",
            "signature": "class RelativePositionWhen:\n    \"\"\"\"\"\"\n    position_type: typing.Literal[<PositionType.RELATIVE_POSITION_WHEN: 'RelativePositionWhen'>]\n    index: typing.Union[str, ForwardRef('_models.IndexOrder')]\n    day_of_week: typing.Union[str, ForwardRef('_models.WeekDay')]\n    month: typing.Union[str, ForwardRef('_models.Month')]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.RelativePositionWhen.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.IndexOrder",
                "lseg_analytics.pricing.common.WeekDay",
                "lseg_analytics.pricing.common.Month"
            ],
            "base_classes": [
                "lseg_analytics.pricing.reference_data.calendars.When"
            ],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "RelativePositionWhen.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.RelativePositionWhen.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 51580,
        "content": "class RelativePositionWhen:\n    @overload\n    def __init__(self, *, index: Union[str, ForwardRef('_models.IndexOrder')], day_of_week: Union[str, ForwardRef('_models.WeekDay')], month: Union[str, ForwardRef('_models.Month')]) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "RelativePositionWhen"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.RelativePositionWhen"
            ],
            "use": [
                "lseg_analytics.pricing.common.IndexOrder",
                "lseg_analytics.pricing.common.WeekDay",
                "lseg_analytics.pricing.common.Month"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "RelativeRescheduleDescription",
        "id": "lseg_analytics.pricing.reference_data.calendars.RelativeRescheduleDescription",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "index",
                "type": "IndexOrder",
                "valuelookup": "enum.IndexOrder"
            },
            {
                "name": "day_of_week",
                "type": "WeekDay",
                "valuelookup": "enum.WeekDay"
            },
            {
                "name": "direction",
                "type": "Direction",
                "valuelookup": "enum.Direction"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 51584,
        "content": "class RelativeRescheduleDescription:\n    \"\"\"An object to determine the rule for rescheduling a holiday to a specific day.\n\n    Attributes\n    ----------\n    reschedule_type : str or ~analyticsapi.models.RELATIVE_RESCHEDULE_DESCRIPTION\n        The type of rescheduling for the observation period. Only\n        RelativeRescheduleRescheduleDescription value applies. Required. The\n        rule for rescheduling a holiday to a specific day. For example, if a\n        holiday falls on Sunday, it is rescheduled to the first Monday after\n        the holiday.\n    index : str or ~analyticsapi.models.IndexOrder\n        The ordinal number of the day of the week in the month. The value\n        'Last' should only be used if the direction is set to 'Before'.\n        Required. Known values are: \"First\", \"Second\", \"Third\", \"Fourth\", and\n        \"Last\".\n    day_of_week : str or ~analyticsapi.models.WeekDay\n        The day of the week. Required. Known values are: \"Monday\", \"Tuesday\",\n        \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\".\n    direction : str or ~analyticsapi.models.Direction\n        An indicator of whether the observation period falls before or after\n        the reference point. Required. Known values are: \"Before\" and \"After\".\n    \n    \"\"\"\n    reschedule_type: typing.Literal[<RescheduleType.RELATIVE_RESCHEDULE_DESCRIPTION: 'RelativeRescheduleDescription'>]\n    index: typing.Union[str, ForwardRef('_models.IndexOrder')]\n    day_of_week: typing.Union[str, ForwardRef('_models.WeekDay')]\n    direction: typing.Union[str, ForwardRef('_models.Direction')]",
        "metadata": {
            "doc": "An object to determine the rule for rescheduling a holiday to a specific day.\n\n    Attributes\n    ----------\n    reschedule_type : str or ~analyticsapi.models.RELATIVE_RESCHEDULE_DESCRIPTION\n        The type of rescheduling for the observation period. Only\n        RelativeRescheduleRescheduleDescription value applies. Required. The\n        rule for rescheduling a holiday to a specific day. For example, if a\n        holiday falls on Sunday, it is rescheduled to the first Monday after\n        the holiday.\n    index : str or ~analyticsapi.models.IndexOrder\n        The ordinal number of the day of the week in the month. The value\n        'Last' should only be used if the direction is set to 'Before'.\n        Required. Known values are: \"First\", \"Second\", \"Third\", \"Fourth\", and\n        \"Last\".\n    day_of_week : str or ~analyticsapi.models.WeekDay\n        The day of the week. Required. Known values are: \"Monday\", \"Tuesday\",\n        \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\".\n    direction : str or ~analyticsapi.models.Direction\n        An indicator of whether the observation period falls before or after\n        the reference point. Required. Known values are: \"Before\" and \"After\".\n    \n",
            "annotations": "    reschedule_type: typing.Literal[<RescheduleType.RELATIVE_RESCHEDULE_DESCRIPTION: 'RelativeRescheduleDescription'>]\n    index: typing.Union[str, ForwardRef('_models.IndexOrder')]\n    day_of_week: typing.Union[str, ForwardRef('_models.WeekDay')]\n    direction: typing.Union[str, ForwardRef('_models.Direction')]",
            "signature": "class RelativeRescheduleDescription:\n    \"\"\"\"\"\"\n    reschedule_type: typing.Literal[<RescheduleType.RELATIVE_RESCHEDULE_DESCRIPTION: 'RelativeRescheduleDescription'>]\n    index: typing.Union[str, ForwardRef('_models.IndexOrder')]\n    day_of_week: typing.Union[str, ForwardRef('_models.WeekDay')]\n    direction: typing.Union[str, ForwardRef('_models.Direction')]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.RelativeRescheduleDescription.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.IndexOrder",
                "lseg_analytics.pricing.common.WeekDay",
                "lseg_analytics.pricing.common.Direction"
            ],
            "base_classes": [
                "lseg_analytics.pricing.reference_data.calendars.RescheduleDescription"
            ],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "RelativeRescheduleDescription.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.RelativeRescheduleDescription.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 51642,
        "content": "class RelativeRescheduleDescription:\n    @overload\n    def __init__(self, *, index: Union[str, ForwardRef('_models.IndexOrder')], day_of_week: Union[str, ForwardRef('_models.WeekDay')], direction: Union[str, ForwardRef('_models.Direction')]) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "RelativeRescheduleDescription"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.RelativeRescheduleDescription"
            ],
            "use": [
                "lseg_analytics.pricing.common.IndexOrder",
                "lseg_analytics.pricing.common.WeekDay",
                "lseg_analytics.pricing.common.Direction"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "RelativeToRulePositionWhen",
        "id": "lseg_analytics.pricing.reference_data.calendars.RelativeToRulePositionWhen",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "key",
                "type": "str"
            },
            {
                "name": "reschedule_description",
                "type": "RescheduleDescription"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 51646,
        "content": "class RelativeToRulePositionWhen:\n    \"\"\"An object to define a rule by reference to another rule. This defines the holiday period by\n    reference to another holiday rule. Easter is most commonly used as a reference point.\n\n    Attributes\n    ----------\n    position_type : str or ~analyticsapi.models.RELATIVE_TO_RULE_POSITION_WHEN\n        The type of regular annual holiday rule. Only\n        RelativeToRulePositionWhen value applies. Required. A rule that\n        references another rule. For example, Easter is most commonly used as a\n        reference point.\n    key : str\n        A user-defined key to create a reference to another rule (e.g. Easter)\n        by name. Required.\n    reschedule_description : ~analyticsapi.models.RescheduleDescription\n        An object to determine holiday rescheduling. Required.\n    \n    \"\"\"\n    position_type: typing.Literal[<PositionType.RELATIVE_TO_RULE_POSITION_WHEN: 'RelativeToRulePositionWhen'>]\n    key: str\n    reschedule_description: _models.RescheduleDescription",
        "metadata": {
            "doc": "An object to define a rule by reference to another rule. This defines the holiday period by\n    reference to another holiday rule. Easter is most commonly used as a reference point.\n\n    Attributes\n    ----------\n    position_type : str or ~analyticsapi.models.RELATIVE_TO_RULE_POSITION_WHEN\n        The type of regular annual holiday rule. Only\n        RelativeToRulePositionWhen value applies. Required. A rule that\n        references another rule. For example, Easter is most commonly used as a\n        reference point.\n    key : str\n        A user-defined key to create a reference to another rule (e.g. Easter)\n        by name. Required.\n    reschedule_description : ~analyticsapi.models.RescheduleDescription\n        An object to determine holiday rescheduling. Required.\n    \n",
            "annotations": "    position_type: typing.Literal[<PositionType.RELATIVE_TO_RULE_POSITION_WHEN: 'RelativeToRulePositionWhen'>]\n    key: str\n    reschedule_description: _models.RescheduleDescription",
            "signature": "class RelativeToRulePositionWhen:\n    \"\"\"\"\"\"\n    position_type: typing.Literal[<PositionType.RELATIVE_TO_RULE_POSITION_WHEN: 'RelativeToRulePositionWhen'>]\n    key: str\n    reschedule_description: _models.RescheduleDescription"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.RelativeToRulePositionWhen.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.reference_data.calendars.RescheduleDescription"
            ],
            "base_classes": [
                "lseg_analytics.pricing.reference_data.calendars.When"
            ],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "RelativeToRulePositionWhen.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.RelativeToRulePositionWhen.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 51690,
        "content": "class RelativeToRulePositionWhen:\n    @overload\n    def __init__(self, *, key: str, reschedule_description: '_models.RescheduleDescription') -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "RelativeToRulePositionWhen"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.RelativeToRulePositionWhen"
            ],
            "use": [
                "lseg_analytics.pricing.reference_data.calendars.RescheduleDescription"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "RescheduleDescription",
        "id": "lseg_analytics.pricing.reference_data.calendars.RescheduleDescription",
        "params": [],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 44806,
        "content": "class RescheduleDescription:\n    \"\"\"An object to determine a holiday rescheduling.\n\n    You probably want to use the sub-classes and not this class directly. Known sub-classes are:\n    LagDaysRescheduleDescription, RelativeRescheduleDescription\n\n    Attributes\n    ----------\n    reschedule_type : str or ~analyticsapi.models.RescheduleType\n        The type of rescheduling for the observation period. Required. Known\n        values are: \"LagDaysRescheduleDescription\" and\n        \"RelativeRescheduleDescription\".\n    \n    \"\"\"\n    reschedule_type: str",
        "metadata": {
            "doc": "An object to determine a holiday rescheduling.\n\n    You probably want to use the sub-classes and not this class directly. Known sub-classes are:\n    LagDaysRescheduleDescription, RelativeRescheduleDescription\n\n    Attributes\n    ----------\n    reschedule_type : str or ~analyticsapi.models.RescheduleType\n        The type of rescheduling for the observation period. Required. Known\n        values are: \"LagDaysRescheduleDescription\" and\n        \"RelativeRescheduleDescription\".\n    \n",
            "annotations": "    reschedule_type: str",
            "signature": "class RescheduleDescription:\n    \"\"\"\"\"\"\n    reschedule_type: str"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.RescheduleDescription.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": [
                "lseg_analytics.pricing.reference_data.calendars.LagDaysRescheduleDescription",
                "lseg_analytics.pricing.reference_data.calendars.RelativeRescheduleDescription"
            ]
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "RescheduleDescription.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.RescheduleDescription.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 44840,
        "content": "class RescheduleDescription:\n    @overload\n    def __init__(self, reschedule_type: str) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "RescheduleDescription"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.RescheduleDescription"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "RestDays",
        "id": "lseg_analytics.pricing.reference_data.calendars.RestDays",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "rest_days",
                "type": "List[WeekDay]",
                "valuelookup": "enum.WeekDay"
            },
            {
                "name": "validity_period",
                "type": "ValidityPeriod"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 52822,
        "content": "class RestDays:\n    \"\"\"An object to determine rest days for the calendar.\n\n    Attributes\n    ----------\n    rest_days : list[str or ~analyticsapi.models.WeekDay]\n        Days of the week that are set as rest days. An array of WeekDay\n        objects. Default is [WeekDay.Saturday, WeekDay.Sunday]. Required.  The\n        default value is None, needs to be assigned before using.\n    validity_period : ~analyticsapi.models.ValidityPeriod\n        An object to determine the validity period. If not specified, the\n        validity period is assumed to be perpetual.\n    \n    \"\"\"\n    rest_days: typing.List[typing.Union[str, ForwardRef('_models.WeekDay')]]\n    validity_period: typing.Optional[ForwardRef('_models.ValidityPeriod')]",
        "metadata": {
            "doc": "An object to determine rest days for the calendar.\n\n    Attributes\n    ----------\n    rest_days : list[str or ~analyticsapi.models.WeekDay]\n        Days of the week that are set as rest days. An array of WeekDay\n        objects. Default is [WeekDay.Saturday, WeekDay.Sunday]. Required.  The\n        default value is None, needs to be assigned before using.\n    validity_period : ~analyticsapi.models.ValidityPeriod\n        An object to determine the validity period. If not specified, the\n        validity period is assumed to be perpetual.\n    \n",
            "annotations": "    rest_days: typing.List[typing.Union[str, ForwardRef('_models.WeekDay')]]\n    validity_period: typing.Optional[ForwardRef('_models.ValidityPeriod')]",
            "signature": "class RestDays:\n    \"\"\"\"\"\"\n    rest_days: typing.List[typing.Union[str, ForwardRef('_models.WeekDay')]]\n    validity_period: typing.Optional[ForwardRef('_models.ValidityPeriod')]"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.RestDays.__init__"
            ],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.WeekDay",
                "lseg_analytics.pricing.common.ValidityPeriod"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "RestDays.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.RestDays.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 52860,
        "content": "class RestDays:\n    @overload\n    def __init__(self, *, rest_days: List[Union[str, ForwardRef('_models.WeekDay')]], validity_period: Optional[ForwardRef('_models.ValidityPeriod')] = None) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "RestDays"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.RestDays"
            ],
            "use": [
                "lseg_analytics.pricing.common.WeekDay",
                "lseg_analytics.pricing.common.ValidityPeriod"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "ClassChunk",
        "name": "When",
        "id": "lseg_analytics.pricing.reference_data.calendars.When",
        "params": [],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 43,
        "content": "class When:\n    \"\"\"An object to determine regular annual holiday rules for the calendar.\n\n    You probably want to use the sub-classes and not this class directly. Known sub-classes are:\n    AbsolutePositionWhen, RelativePositionWhen, RelativeToRulePositionWhen\n\n    Attributes\n    ----------\n    position_type : str or ~analyticsapi.models.PositionType\n        The type of regular annual holiday rule. Possible values are:\n        AbsolutePositionWhen (for fixed holidays), RelativePositionWhen (for\n        holidays that fall on a particular day of the week) or\n        RelativeToRulePositionWhen (for holidays that are set by reference to\n        another date). Required. Known values are: \"AbsolutePositionWhen\",\n        \"RelativePositionWhen\", and \"RelativeToRulePositionWhen\".\n    \n    \"\"\"\n    position_type: str",
        "metadata": {
            "doc": "An object to determine regular annual holiday rules for the calendar.\n\n    You probably want to use the sub-classes and not this class directly. Known sub-classes are:\n    AbsolutePositionWhen, RelativePositionWhen, RelativeToRulePositionWhen\n\n    Attributes\n    ----------\n    position_type : str or ~analyticsapi.models.PositionType\n        The type of regular annual holiday rule. Possible values are:\n        AbsolutePositionWhen (for fixed holidays), RelativePositionWhen (for\n        holidays that fall on a particular day of the week) or\n        RelativeToRulePositionWhen (for holidays that are set by reference to\n        another date). Required. Known values are: \"AbsolutePositionWhen\",\n        \"RelativePositionWhen\", and \"RelativeToRulePositionWhen\".\n    \n",
            "annotations": "    position_type: str",
            "signature": "class When:\n    \"\"\"\"\"\"\n    position_type: str"
        },
        "dependencies": {
            "children": [
                "lseg_analytics.pricing.reference_data.calendars.When.__init__"
            ],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": [
                "lseg_analytics.pricing.reference_data.calendars.AbsolutePositionWhen",
                "lseg_analytics.pricing.reference_data.calendars.RelativePositionWhen",
                "lseg_analytics.pricing.reference_data.calendars.RelativeToRulePositionWhen"
            ]
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "OverloadedMethodChunk",
        "name": "When.__init__",
        "id": "lseg_analytics.pricing.reference_data.calendars.When.__init__",
        "params": [
            {
                "name": "args",
                "type": "Any"
            },
            {
                "name": "kwargs",
                "type": "Any"
            }
        ],
        "file_path": "lseg_analytics/pricing/_basic_client/models/_models.py",
        "line_number": 83,
        "content": "class When:\n    @overload\n    def __init__(self, position_type: str) -> None:\n        \"\"\"\"\"\"\n\n    @overload\n    def __init__(self, mapping: Mapping[str, Any]) -> None:\n        \"\"\"\n        Parameters\n        ----------\n        mapping : Mapping[str, Any]\n            raw JSON to initialize the model.\n        \n        \"\"\"\n\n    def __init__(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"\"\"\"",
        "metadata": {
            "doc": "",
            "signature": "__init__(self, *args: Any, **kwargs: Any) -> None:",
            "class": "When"
        },
        "dependencies": {
            "children": [],
            "parent": [
                "lseg_analytics.pricing.reference_data.calendars.When"
            ],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "FunctionChunk",
        "name": "compute_dates",
        "id": "lseg_analytics.pricing.reference_data.calendars.compute_dates",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "tenors",
                "type": "List[str]",
                "valuelookup": "tenors"
            },
            {
                "name": "calendars",
                "type": "List[str]",
                "valuelookup": "Calendar.scoped"
            },
            {
                "name": "start_date",
                "type": "date"
            },
            {
                "name": "date_moving_convention",
                "type": "DateMovingConvention",
                "valuelookup": "enum.DateMovingConvention"
            },
            {
                "name": "end_of_month_convention",
                "type": "EndOfMonthConvention",
                "valuelookup": "enum.EndOfMonthConvention"
            },
            {
                "name": "fields",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_functions.py",
        "line_number": 210,
        "content": "def compute_dates(*, tenors: List[str], calendars: List[str], start_date: Union[str, datetime.date, NoneType] = None, date_moving_convention: Union[str, DateMovingConvention, NoneType] = None, end_of_month_convention: Union[str, EndOfMonthConvention, NoneType] = None, fields: Optional[str] = None) -> List[ComputeDatesBatched]:\n    \"\"\"\n    Computes dates for the calendar according to specified conditions. Start Date is included in the calculation. Only saved calendars are supported.\n\n    Parameters\n    ----------\n    tenors : List[str]\n        Tenors to be added to startDate to calculate the resultant dates (e.g., 1M, 1Y).\n        A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:\n        - Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and Years (Y).\n        For example \"1D\" for one day, \"2W\" for two weeks or \"3M1D\" for three months and a day.\n        When mixing units, units must be written in descending order of size (Y > M > W > D).  So, 5M3D is valid, but 3D5M is not.\n        - Common tenors are expressed as letter codes:\n        - ON (Overnight) - A one business day period that starts today.\n        - TN (Tomorrow-Next) - A one business day period that starts next business day.\n        - SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date (today) + days to spot.\n        - SN (Spot-Next) - A one business day period that starts at the spot date.\n        - SW (Spot-Week) - A one business week period that starts at the spot date.\n    start_date : Union[str, datetime.date], optional\n        The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today.\n    date_moving_convention : Union[str, DateMovingConvention], optional\n        The method to adjust dates to working days. The default value is ModifiedFollowing.\n    end_of_month_convention : Union[str, EndOfMonthConvention], optional\n        Conventions to adjust payment dates when they fall at the end of a month.\n    calendars : List[str]\n        An array of calendar defining objects for which the calculation should be done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG' space.\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    List[ComputeDatesBatched]\n        An object to definine the properties of the calculated dates returned, with a dedicated error object for each calculation. This serializable object behaves exactly like a list of dictionaries when iterated or displayed. It can be converted to a DataFrame without transformation.\n\n    Examples\n    --------\n    >>> computed_dates = compute_dates(\n    >>>     calendars=[\"LSEG/UKG\", \"LSEG/EUR\"],\n    >>>     tenors=[\"1M\", \"2M\"],\n    >>>     start_date=datetime.date(2023, 11, 1),\n    >>>     date_moving_convention=DateMovingConvention.NEXT_BUSINESS_DAY,\n    >>> )\n    >>>\n    >>> computed_dates\n    [{'endDate': '2023-12-01', 'tenor': '1M'},\n     {'endDate': '2024-01-02', 'tenor': '2M'}]\n\n\n    >>> # Display computed dates\n    >>> pd.DataFrame(computed_dates)\n          endDate tenor\n    0  2023-12-01    1M\n    1  2024-01-02    2M\n\n    \n    \"\"\"",
        "metadata": {
            "doc": "\n    Computes dates for the calendar according to specified conditions. Start Date is included in the calculation. Only saved calendars are supported.\n\n    Parameters\n    ----------\n    tenors : List[str]\n        Tenors to be added to startDate to calculate the resultant dates (e.g., 1M, 1Y).\n        A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:\n        - Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and Years (Y).\n        For example \"1D\" for one day, \"2W\" for two weeks or \"3M1D\" for three months and a day.\n        When mixing units, units must be written in descending order of size (Y > M > W > D).  So, 5M3D is valid, but 3D5M is not.\n        - Common tenors are expressed as letter codes:\n        - ON (Overnight) - A one business day period that starts today.\n        - TN (Tomorrow-Next) - A one business day period that starts next business day.\n        - SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date (today) + days to spot.\n        - SN (Spot-Next) - A one business day period that starts at the spot date.\n        - SW (Spot-Week) - A one business week period that starts at the spot date.\n    start_date : Union[str, datetime.date], optional\n        The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01). Default is Today.\n    date_moving_convention : Union[str, DateMovingConvention], optional\n        The method to adjust dates to working days. The default value is ModifiedFollowing.\n    end_of_month_convention : Union[str, EndOfMonthConvention], optional\n        Conventions to adjust payment dates when they fall at the end of a month.\n    calendars : List[str]\n        An array of calendar defining objects for which the calculation should be done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG' space.\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    List[ComputeDatesBatched]\n        An object to definine the properties of the calculated dates returned, with a dedicated error object for each calculation. This serializable object behaves exactly like a list of dictionaries when iterated or displayed. It can be converted to a DataFrame without transformation.\n\n    Examples\n    --------\n    >>> computed_dates = compute_dates(\n    >>>     calendars=[\"LSEG/UKG\", \"LSEG/EUR\"],\n    >>>     tenors=[\"1M\", \"2M\"],\n    >>>     start_date=datetime.date(2023, 11, 1),\n    >>>     date_moving_convention=DateMovingConvention.NEXT_BUSINESS_DAY,\n    >>> )\n    >>>\n    >>> computed_dates\n    [{'endDate': '2023-12-01', 'tenor': '1M'},\n     {'endDate': '2024-01-02', 'tenor': '2M'}]\n\n\n    >>> # Display computed dates\n    >>> pd.DataFrame(computed_dates)\n          endDate tenor\n    0  2023-12-01    1M\n    1  2024-01-02    2M\n\n    \n",
            "signature": "def compute_dates(*, tenors: List[str], calendars: List[str], start_date: Union[str, datetime.date, NoneType] = None, date_moving_convention: Union[str, DateMovingConvention, NoneType] = None, end_of_month_convention: Union[str, EndOfMonthConvention, NoneType] = None, fields: Optional[str] = None) -> List[ComputeDatesBatched]:"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.DateMovingConvention",
                "lseg_analytics.pricing.common.EndOfMonthConvention",
                "lseg_analytics.pricing.reference_data.calendars.ComputeDatesBatched"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "FunctionChunk",
        "name": "count_periods",
        "id": "lseg_analytics.pricing.reference_data.calendars.count_periods",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "start_date",
                "type": "date"
            },
            {
                "name": "end_date",
                "type": "date"
            },
            {
                "name": "day_count_basis",
                "type": "DayCountBasis",
                "valuelookup": "enum.DayCountBasis"
            },
            {
                "name": "period_type",
                "type": "PeriodType",
                "valuelookup": "enum.PeriodType"
            },
            {
                "name": "calendars",
                "type": "List[str]",
                "valuelookup": "Calendar.scoped"
            },
            {
                "name": "fields",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_functions.py",
        "line_number": 300,
        "content": "def count_periods(*, start_date: Union[str, datetime.date], end_date: Union[str, datetime.date], day_count_basis: Union[str, DayCountBasis, NoneType] = None, period_type: Union[str, PeriodType, NoneType] = None, calendars: Optional[List[str]] = None, fields: Optional[str] = None) -> CountPeriodsOutput:\n    \"\"\"\n    Counts the time periods that satisfy specified conditions. Note the use of date strings for convenience. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n    Parameters\n    ----------\n    start_date : Union[str, datetime.date]\n        The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).\n    end_date : Union[str, datetime.date]\n        The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n    day_count_basis : Union[str, DayCountBasis], optional\n        The day count basis convention used to calculate the period between two dates.\n        It is used when periodType is set to Year.\n        Each convention defines the number of days between two dates and the year length in days (basis) for the period calculation.\n        Default is DCB_ACTUAL_ACTUAL.\n    period_type : Union[str, PeriodType], optional\n        The method of the period calculation. Default is Day.\n    calendars : List[str], optional\n        An array of calendar defining objects for which the calculation should be done. Each string being composed of the space and name of a calendar.\n        For example 'LSEG/UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG' space.\n        The calendars parameter is optional only when periodType is \"Day\" or \"Year\".\n        For a given day to be considered a working day, it must be a working day in all of the selected calendars. If it is a non-working day in any of the calendars, it is a non-working day.\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    CountPeriodsOutput\n        The result of the period calculation for the count periods endpoint.\n\n    Examples\n    --------\n    >>> count_periods(\n    >>>     calendars=['LSEG/UKG'],\n    >>>     start_date=datetime.date(2023, 2, 1),\n    >>>     end_date=datetime.date(2023, 12, 31),\n    >>>     day_count_basis=DayCountBasis.DCB_30_360,\n    >>>     period_type=PeriodType.WORKING_DAY\n    >>> )\n    {'count': 247, 'periodType': 'WorkingDay'}\n\n    \n    \"\"\"",
        "metadata": {
            "doc": "\n    Counts the time periods that satisfy specified conditions. Note the use of date strings for convenience. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n    Parameters\n    ----------\n    start_date : Union[str, datetime.date]\n        The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).\n    end_date : Union[str, datetime.date]\n        The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n    day_count_basis : Union[str, DayCountBasis], optional\n        The day count basis convention used to calculate the period between two dates.\n        It is used when periodType is set to Year.\n        Each convention defines the number of days between two dates and the year length in days (basis) for the period calculation.\n        Default is DCB_ACTUAL_ACTUAL.\n    period_type : Union[str, PeriodType], optional\n        The method of the period calculation. Default is Day.\n    calendars : List[str], optional\n        An array of calendar defining objects for which the calculation should be done. Each string being composed of the space and name of a calendar.\n        For example 'LSEG/UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG' space.\n        The calendars parameter is optional only when periodType is \"Day\" or \"Year\".\n        For a given day to be considered a working day, it must be a working day in all of the selected calendars. If it is a non-working day in any of the calendars, it is a non-working day.\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    CountPeriodsOutput\n        The result of the period calculation for the count periods endpoint.\n\n    Examples\n    --------\n    >>> count_periods(\n    >>>     calendars=['LSEG/UKG'],\n    >>>     start_date=datetime.date(2023, 2, 1),\n    >>>     end_date=datetime.date(2023, 12, 31),\n    >>>     day_count_basis=DayCountBasis.DCB_30_360,\n    >>>     period_type=PeriodType.WORKING_DAY\n    >>> )\n    {'count': 247, 'periodType': 'WorkingDay'}\n\n    \n",
            "signature": "def count_periods(*, start_date: Union[str, datetime.date], end_date: Union[str, datetime.date], day_count_basis: Union[str, DayCountBasis, NoneType] = None, period_type: Union[str, PeriodType, NoneType] = None, calendars: Optional[List[str]] = None, fields: Optional[str] = None) -> CountPeriodsOutput:"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.DayCountBasis",
                "lseg_analytics.pricing.common.PeriodType",
                "lseg_analytics.pricing.reference_data.calendars.CountPeriodsOutput"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "FunctionChunk",
        "name": "delete",
        "id": "lseg_analytics.pricing.reference_data.calendars.delete",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "resource_id",
                "type": "str",
                "valuelookup": "Calendar.id"
            },
            {
                "name": "name",
                "type": "str",
                "valuelookup": "Calendar.name"
            },
            {
                "name": "space",
                "type": "str",
                "valuelookup": "Calendar.space"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_functions.py",
        "line_number": 152,
        "content": "def delete(*, resource_id: Optional[str] = None, name: Optional[str] = None, space: Optional[str] = None):\n    \"\"\"\n    Delete Calendar instance from the server.\n\n    Parameters\n    ----------\n    resource_id : str, optional\n        The Calendar resource ID.\n        Required if name is not provided.\n    name : str, optional\n        The Calendar name.\n        Required if resource_id is not provided.\n    space : str, optional\n        The space where the Calendar is stored. Space is like a namespace where resources are stored. By default there are two spaces:\n        LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If space is not specified, HOME will be used.\n\n    Returns\n    -------\n    ServiceErrorResponse, optional\n        Error response, if applicable, otherwise None\n\n    Examples\n    --------\n    Delete by Id.\n\n    >>> delete(resource_id='125B1FCD-6EE9-4B1F-870F-5BA89EBE71AF')\n    True\n\n    Delete by name and space.\n\n    >>> delete(name=\"my_calendar\", space=\"my_personal_space\")\n    True\n\n    \n    \"\"\"",
        "metadata": {
            "doc": "\n    Delete Calendar instance from the server.\n\n    Parameters\n    ----------\n    resource_id : str, optional\n        The Calendar resource ID.\n        Required if name is not provided.\n    name : str, optional\n        The Calendar name.\n        Required if resource_id is not provided.\n    space : str, optional\n        The space where the Calendar is stored. Space is like a namespace where resources are stored. By default there are two spaces:\n        LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If space is not specified, HOME will be used.\n\n    Returns\n    -------\n    ServiceErrorResponse, optional\n        Error response, if applicable, otherwise None\n\n    Examples\n    --------\n    Delete by Id.\n\n    >>> delete(resource_id='125B1FCD-6EE9-4B1F-870F-5BA89EBE71AF')\n    True\n\n    Delete by name and space.\n\n    >>> delete(name=\"my_calendar\", space=\"my_personal_space\")\n    True\n\n    \n",
            "signature": "def delete(*, resource_id: Optional[str] = None, name: Optional[str] = None, space: Optional[str] = None):"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "FunctionChunk",
        "name": "generate_date_schedule",
        "id": "lseg_analytics.pricing.reference_data.calendars.generate_date_schedule",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "frequency",
                "type": "Frequency",
                "valuelookup": "enum.Frequency"
            },
            {
                "name": "calendars",
                "type": "List[str]",
                "valuelookup": "Calendar.scoped"
            },
            {
                "name": "start_date",
                "type": "date"
            },
            {
                "name": "end_date",
                "type": "date"
            },
            {
                "name": "calendar_day_of_month",
                "type": "int"
            },
            {
                "name": "count",
                "type": "int"
            },
            {
                "name": "day_of_week",
                "type": "WeekDay",
                "valuelookup": "enum.WeekDay"
            },
            {
                "name": "fields",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_functions.py",
        "line_number": 408,
        "content": "def generate_date_schedule(*, frequency: Union[str, Frequency], calendars: List[str], start_date: Union[str, datetime.date, NoneType] = None, end_date: Union[str, datetime.date, NoneType] = None, calendar_day_of_month: Optional[int] = None, count: Optional[int] = None, day_of_week: Union[str, WeekDay, NoneType] = None, fields: Optional[str] = None) -> List[datetime.date]:\n    \"\"\"\n    Generates a date schedule for the calendar according to specified conditions. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n    Parameters\n    ----------\n    frequency : Union[str, Frequency]\n        The frequency of dates in the schedule which should be generated. Note that \"Daily\" refers to working days only.\n    start_date : Union[str, datetime.date], optional\n        The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).\n        The start date must be less or equal to the end date.\n        Required if endDate is in the past.\n    end_date : Union[str, datetime.date], optional\n        The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n        If startDate is not specified, endDate is used to define the list of dates from today's date to the end date.\n        The end date must be greater or equal to the start date.\n        Required if count is not specified. Only one of endDate and count can be set at a time.\n    calendar_day_of_month : int, optional\n        The number of the day of the month. Required if frequency is Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31.\n    count : int, optional\n        The number of dates to be generated,  counting from the start date (or today's date if the start day is not set) to the end date.\n        It should not have a negative value.\n        Required if endDate is not specified. Only one of endDate and count can be set at a time.\n    day_of_week : Union[str, WeekDay], optional\n        The day of the week. Required if frequency is Weekly or BiWeekly; do not use otherwise.\n    calendars : List[str]\n        An array of calendar defining objects for which the calculation should be done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG' space.\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    List[datetime.date]\n        A date on a calendar without a time zone, e.g. \"April 10th\"\n\n    Examples\n    --------\n    >>> generate_date_schedule(\n    >>>     calendars=['LSEG/UKG'],\n    >>>     frequency=Frequency.WEEKLY,\n    >>>     start_date=datetime.date(2023, 4, 30),\n    >>>     calendar_day_of_month=5,\n    >>>     count=20,\n    >>>     day_of_week=WeekDay.TUESDAY\n    >>> )\n    [datetime.date(2023, 5, 9),\n     datetime.date(2023, 5, 16),\n     datetime.date(2023, 5, 23),\n     datetime.date(2023, 5, 30),\n     datetime.date(2023, 6, 6),\n     datetime.date(2023, 6, 13),\n     datetime.date(2023, 6, 16),\n     datetime.date(2023, 6, 27),\n     datetime.date(2023, 7, 4),\n     datetime.date(2023, 7, 11),\n     datetime.date(2023, 7, 18),\n     datetime.date(2023, 7, 25),\n     datetime.date(2023, 8, 1),\n     datetime.date(2023, 8, 8),\n     datetime.date(2023, 8, 15),\n     datetime.date(2023, 8, 22),\n     datetime.date(2023, 8, 29),\n     datetime.date(2023, 9, 5),\n     datetime.date(2023, 9, 12),\n     datetime.date(2023, 9, 19)]\n\n    \n    \"\"\"",
        "metadata": {
            "doc": "\n    Generates a date schedule for the calendar according to specified conditions. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n    Parameters\n    ----------\n    frequency : Union[str, Frequency]\n        The frequency of dates in the schedule which should be generated. Note that \"Daily\" refers to working days only.\n    start_date : Union[str, datetime.date], optional\n        The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01).\n        The start date must be less or equal to the end date.\n        Required if endDate is in the past.\n    end_date : Union[str, datetime.date], optional\n        The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n        If startDate is not specified, endDate is used to define the list of dates from today's date to the end date.\n        The end date must be greater or equal to the start date.\n        Required if count is not specified. Only one of endDate and count can be set at a time.\n    calendar_day_of_month : int, optional\n        The number of the day of the month. Required if frequency is Monthly; do not use otherwise. The minimum value is 1. The maximum value is 31.\n    count : int, optional\n        The number of dates to be generated,  counting from the start date (or today's date if the start day is not set) to the end date.\n        It should not have a negative value.\n        Required if endDate is not specified. Only one of endDate and count can be set at a time.\n    day_of_week : Union[str, WeekDay], optional\n        The day of the week. Required if frequency is Weekly or BiWeekly; do not use otherwise.\n    calendars : List[str]\n        An array of calendar defining objects for which the calculation should be done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG' space.\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    List[datetime.date]\n        A date on a calendar without a time zone, e.g. \"April 10th\"\n\n    Examples\n    --------\n    >>> generate_date_schedule(\n    >>>     calendars=['LSEG/UKG'],\n    >>>     frequency=Frequency.WEEKLY,\n    >>>     start_date=datetime.date(2023, 4, 30),\n    >>>     calendar_day_of_month=5,\n    >>>     count=20,\n    >>>     day_of_week=WeekDay.TUESDAY\n    >>> )\n    [datetime.date(2023, 5, 9),\n     datetime.date(2023, 5, 16),\n     datetime.date(2023, 5, 23),\n     datetime.date(2023, 5, 30),\n     datetime.date(2023, 6, 6),\n     datetime.date(2023, 6, 13),\n     datetime.date(2023, 6, 16),\n     datetime.date(2023, 6, 27),\n     datetime.date(2023, 7, 4),\n     datetime.date(2023, 7, 11),\n     datetime.date(2023, 7, 18),\n     datetime.date(2023, 7, 25),\n     datetime.date(2023, 8, 1),\n     datetime.date(2023, 8, 8),\n     datetime.date(2023, 8, 15),\n     datetime.date(2023, 8, 22),\n     datetime.date(2023, 8, 29),\n     datetime.date(2023, 9, 5),\n     datetime.date(2023, 9, 12),\n     datetime.date(2023, 9, 19)]\n\n    \n",
            "signature": "def generate_date_schedule(*, frequency: Union[str, Frequency], calendars: List[str], start_date: Union[str, datetime.date, NoneType] = None, end_date: Union[str, datetime.date, NoneType] = None, calendar_day_of_month: Optional[int] = None, count: Optional[int] = None, day_of_week: Union[str, WeekDay, NoneType] = None, fields: Optional[str] = None) -> List[datetime.date]:"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.Frequency",
                "lseg_analytics.pricing.common.WeekDay"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "FunctionChunk",
        "name": "generate_holidays",
        "id": "lseg_analytics.pricing.reference_data.calendars.generate_holidays",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "end_date",
                "type": "date"
            },
            {
                "name": "calendars",
                "type": "List[str]",
                "valuelookup": "Calendar.scoped"
            },
            {
                "name": "start_date",
                "type": "date"
            },
            {
                "name": "fields",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_functions.py",
        "line_number": 514,
        "content": "def generate_holidays(*, end_date: Union[str, datetime.date], calendars: List[str], start_date: Union[str, datetime.date, NoneType] = None, fields: Optional[str] = None) -> List[Holiday]:\n    \"\"\"\n    Gets the holidays for the calendar within a date range. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n    Parameters\n    ----------\n    start_date : Union[str, datetime.date], optional\n        The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01). Default is today.\n    end_date : Union[str, datetime.date]\n        The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n    calendars : List[str]\n        An array of calendar defining objects for which the calculation should be done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG' space.\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    List[Holiday]\n        Dates and names of holidays for a requested calendar.\n\n    Examples\n    --------\n    >>> response = generate_holidays(calendars=[\"LSEG/UKG\"], start_date=\"2023-01-01\", end_date=\"2023-01-31\")\n    >>> response[0]\n    {'date': '2023-01-01', 'names': [{'name': \"New Year's Day\", 'calendars': ['LSEG/ARG', 'LSEG/UKG'], 'countries': ['ARG', 'GBR']}]}\n\n    \n    \"\"\"",
        "metadata": {
            "doc": "\n    Gets the holidays for the calendar within a date range. Start and End Dates are included in the calculation. Only saved calendars are supported.\n\n    Parameters\n    ----------\n    start_date : Union[str, datetime.date], optional\n        The start date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2023-01-01). Default is today.\n    end_date : Union[str, datetime.date]\n        The end date of the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., 2024-01-01).\n    calendars : List[str]\n        An array of calendar defining objects for which the calculation should be done. Each string being composed of the space and name of a calendar. For example 'LSEG/UKG' is the string referencing the 'UKG' calendar stored in the 'LSEG' space.\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    List[Holiday]\n        Dates and names of holidays for a requested calendar.\n\n    Examples\n    --------\n    >>> response = generate_holidays(calendars=[\"LSEG/UKG\"], start_date=\"2023-01-01\", end_date=\"2023-01-31\")\n    >>> response[0]\n    {'date': '2023-01-01', 'names': [{'name': \"New Year's Day\", 'calendars': ['LSEG/ARG', 'LSEG/UKG'], 'countries': ['ARG', 'GBR']}]}\n\n    \n",
            "signature": "def generate_holidays(*, end_date: Union[str, datetime.date], calendars: List[str], start_date: Union[str, datetime.date, NoneType] = None, fields: Optional[str] = None) -> List[Holiday]:"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.reference_data.calendars.Holiday"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "FunctionChunk",
        "name": "load",
        "id": "lseg_analytics.pricing.reference_data.calendars.load",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "resource_id",
                "type": "str",
                "valuelookup": "Calendar.id"
            },
            {
                "name": "name",
                "type": "str",
                "valuelookup": "Calendar.name"
            },
            {
                "name": "space",
                "type": "str",
                "valuelookup": "Calendar.space"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_functions.py",
        "line_number": 92,
        "content": "def load(*, resource_id: Optional[str] = None, name: Optional[str] = None, space: Optional[str] = None):\n    \"\"\"\n    Load a Calendar using its name and space to perform date-based operations such as calculating working days, generating schedules, and retrieving holiday information on a predefined calendar.\n\n    Parameters\n    ----------\n    resource_id : str, optional\n        The Calendar id. Or the combination of the space and name of the resource with a slash, e.g. 'HOME/my_resource'.\n        Required if name is not provided.\n    name : str, optional\n        The Calendar name.\n        Required if resource_id is not provided. The name parameter must be specified when the object is first created. Thereafter it is optional.\n    space : str, optional\n        The space where the Calendar is stored. Space is like a namespace where resources are stored. By default there are two spaces:\n        LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If space is not specified, HOME will be used.\n\n    Returns\n    -------\n    Calendar\n        The Calendar instance.\n\n    Examples\n    --------\n    Load by Id.\n\n    >>> load(resource_id=\"125B1FCD-6EE9-4B1F-870F-5BA89EBE71AF\")\n    <Calendar space='HOME' name='my_personal_calendar' 125B1FCD\u2025>\n\n    Load by name and space.\n\n    >>> load(name=\"EMU\", space=\"LSEG\")\n    <Calendar space='HOME' name='my_personal_calendar' 125B1FCD\u2025>\n\n    \n    \"\"\"",
        "metadata": {
            "doc": "\n    Load a Calendar using its name and space to perform date-based operations such as calculating working days, generating schedules, and retrieving holiday information on a predefined calendar.\n\n    Parameters\n    ----------\n    resource_id : str, optional\n        The Calendar id. Or the combination of the space and name of the resource with a slash, e.g. 'HOME/my_resource'.\n        Required if name is not provided.\n    name : str, optional\n        The Calendar name.\n        Required if resource_id is not provided. The name parameter must be specified when the object is first created. Thereafter it is optional.\n    space : str, optional\n        The space where the Calendar is stored. Space is like a namespace where resources are stored. By default there are two spaces:\n        LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space. If space is not specified, HOME will be used.\n\n    Returns\n    -------\n    Calendar\n        The Calendar instance.\n\n    Examples\n    --------\n    Load by Id.\n\n    >>> load(resource_id=\"125B1FCD-6EE9-4B1F-870F-5BA89EBE71AF\")\n    <Calendar space='HOME' name='my_personal_calendar' 125B1FCD\u2025>\n\n    Load by name and space.\n\n    >>> load(name=\"EMU\", space=\"LSEG\")\n    <Calendar space='HOME' name='my_personal_calendar' 125B1FCD\u2025>\n\n    \n",
            "signature": "def load(*, resource_id: Optional[str] = None, name: Optional[str] = None, space: Optional[str] = None):"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": [],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    },
    {
        "type": "FunctionChunk",
        "name": "search",
        "id": "lseg_analytics.pricing.reference_data.calendars.search",
        "params": [
            {
                "name": "*",
                "type": "python-keyword"
            },
            {
                "name": "item_per_page",
                "type": "int"
            },
            {
                "name": "page",
                "type": "int"
            },
            {
                "name": "spaces",
                "type": "List[str]",
                "valuelookup": "Calendar.space"
            },
            {
                "name": "names",
                "type": "List[str]",
                "valuelookup": "Calendar.name"
            },
            {
                "name": "space_name_sort_order",
                "type": "SortingOrderEnum",
                "valuelookup": "enum.SortingOrderEnum"
            },
            {
                "name": "tags",
                "type": "List[str]"
            },
            {
                "name": "fields",
                "type": "str"
            }
        ],
        "file_path": "lseg_analytics/pricing/reference_data/calendars/_functions.py",
        "line_number": 613,
        "content": "def search(*, item_per_page: Optional[int] = None, page: Optional[int] = None, spaces: Optional[List[str]] = None, names: Optional[List[str]] = None, space_name_sort_order: Union[str, SortingOrderEnum, NoneType] = None, tags: Optional[List[str]] = None, fields: Optional[str] = None) -> List[CalendarInfo]:\n    \"\"\"\n    List the Calendars existing in the platform (depending on permissions)\n\n    Parameters\n    ----------\n    item_per_page : int, optional\n        A parameter used to select the number of items allowed per page. The valid range is 1-500. If not provided, 50 will be used.\n    page : int, optional\n        A parameter used to define the page number to display.\n    spaces : List[str], optional\n        A parameter used to search for platform resources stored in a given space. Space is like a namespace where resources are stored. By default there are two spaces:\n        LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.\n        If space is not specified, it will search within all spaces.\n    names : List[str], optional\n        A parameter used to search for platform resources with given names.\n    space_name_sort_order : Union[str, SortingOrderEnum], optional\n        A parameter used to sort platform resources by name based on a defined order.\n    tags : List[str], optional\n        A parameter used to search for platform resources with given tags.\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    List[CalendarInfo]\n        Object defining the links available on a Calendar resource.\n\n    Examples\n    --------\n    Search all previously saved calendars.\n\n    >>> search()\n    [{'type': 'Calendar', 'id': '0cee3640-8063-49b4-a1a1-50ab1ee0030f', 'description': {'tags': [], 'summary': 'LSEG Euroland Calendar'}, 'location': {'name': 'EMU', 'space': 'LSEG'}}]\n\n    Search by names and spaces.\n\n    >>> search(names=[\"EMU\"], spaces=[\"LSEG\"])\n    [{'type': 'Calendar', 'id': '0cee3640-8063-49b4-a1a1-50ab1ee0030f', 'description': {'tags': [], 'summary': 'LSEG Euroland Calendar'}, 'location': {'name': 'EMU', 'space': 'LSEG'}}]\n\n    Search by names.\n\n    >>> search(names=[\"EMU\"])\n    [{'type': 'Calendar', 'id': '0cee3640-8063-49b4-a1a1-50ab1ee0030f', 'description': {'tags': [], 'summary': 'LSEG Euroland Calendar'}, 'location': {'name': 'EMU', 'space': 'LSEG'}}]\n\n    Search by spaces.\n\n    >>> search(spaces=[\"LSEG\"])\n    [{'type': 'Calendar', 'id': '0cee3640-8063-49b4-a1a1-50ab1ee0030f', 'description': {'tags': [], 'summary': 'LSEG Euroland Calendar'}, 'location': {'name': 'EMU', 'space': 'LSEG'}}]\n\n    Search by tags.\n\n    >>> search(tags=[\"EU calendar\"])\n    [{'type': 'Calendar', 'id': '0cee3640-8063-49b4-a1a1-50ab1ee0030f', 'description': {'tags': [], 'summary': 'LSEG Euroland Calendar'}, 'location': {'name': 'EMU', 'space': 'LSEG'}}]\n\n    \n    \"\"\"",
        "metadata": {
            "doc": "\n    List the Calendars existing in the platform (depending on permissions)\n\n    Parameters\n    ----------\n    item_per_page : int, optional\n        A parameter used to select the number of items allowed per page. The valid range is 1-500. If not provided, 50 will be used.\n    page : int, optional\n        A parameter used to define the page number to display.\n    spaces : List[str], optional\n        A parameter used to search for platform resources stored in a given space. Space is like a namespace where resources are stored. By default there are two spaces:\n        LSEG is reserved for LSEG maintained resources, HOME is reserved for user's default space.\n        If space is not specified, it will search within all spaces.\n    names : List[str], optional\n        A parameter used to search for platform resources with given names.\n    space_name_sort_order : Union[str, SortingOrderEnum], optional\n        A parameter used to sort platform resources by name based on a defined order.\n    tags : List[str], optional\n        A parameter used to search for platform resources with given tags.\n    fields : str, optional\n        A parameter used to select the fields to return in response. If not provided, all fields will be returned.\n        Some usage examples:\n        1. Simply enumerating the fields, separating them by ',', e.g. 'fields=//please insert the selected fields here, e.g., field1, field2 //'\n        2. Using parentheses to indicate nesting, e.g. 'fields= //please insert the selected field and subfields here, e.g., field1(subfield1, subfield2), field2(subfield3)//\u2019\n        3. Using forward slash '/' to indicate nesting, e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1/subfield1, field1/subfield2, field2/subfield3//\u2019 (same result as example above)\n        4. Operators can even be combined (forward slashes in brackets, not the way around), e.g. 'fields=//please insert the selected field and subfields here, e.g.,  field1(subfield1/subsubfield1), field2/subfield2//'\n\n    Returns\n    --------\n    List[CalendarInfo]\n        Object defining the links available on a Calendar resource.\n\n    Examples\n    --------\n    Search all previously saved calendars.\n\n    >>> search()\n    [{'type': 'Calendar', 'id': '0cee3640-8063-49b4-a1a1-50ab1ee0030f', 'description': {'tags': [], 'summary': 'LSEG Euroland Calendar'}, 'location': {'name': 'EMU', 'space': 'LSEG'}}]\n\n    Search by names and spaces.\n\n    >>> search(names=[\"EMU\"], spaces=[\"LSEG\"])\n    [{'type': 'Calendar', 'id': '0cee3640-8063-49b4-a1a1-50ab1ee0030f', 'description': {'tags': [], 'summary': 'LSEG Euroland Calendar'}, 'location': {'name': 'EMU', 'space': 'LSEG'}}]\n\n    Search by names.\n\n    >>> search(names=[\"EMU\"])\n    [{'type': 'Calendar', 'id': '0cee3640-8063-49b4-a1a1-50ab1ee0030f', 'description': {'tags': [], 'summary': 'LSEG Euroland Calendar'}, 'location': {'name': 'EMU', 'space': 'LSEG'}}]\n\n    Search by spaces.\n\n    >>> search(spaces=[\"LSEG\"])\n    [{'type': 'Calendar', 'id': '0cee3640-8063-49b4-a1a1-50ab1ee0030f', 'description': {'tags': [], 'summary': 'LSEG Euroland Calendar'}, 'location': {'name': 'EMU', 'space': 'LSEG'}}]\n\n    Search by tags.\n\n    >>> search(tags=[\"EU calendar\"])\n    [{'type': 'Calendar', 'id': '0cee3640-8063-49b4-a1a1-50ab1ee0030f', 'description': {'tags': [], 'summary': 'LSEG Euroland Calendar'}, 'location': {'name': 'EMU', 'space': 'LSEG'}}]\n\n    \n",
            "signature": "def search(*, item_per_page: Optional[int] = None, page: Optional[int] = None, spaces: Optional[List[str]] = None, names: Optional[List[str]] = None, space_name_sort_order: Union[str, SortingOrderEnum, NoneType] = None, tags: Optional[List[str]] = None, fields: Optional[str] = None) -> List[CalendarInfo]:"
        },
        "dependencies": {
            "children": [],
            "parent": [],
            "use": [
                "lseg_analytics.pricing.common.SortingOrderEnum",
                "lseg_analytics.pricing.reference_data.calendars.CalendarInfo"
            ],
            "base_classes": [],
            "sub_classes": []
        },
        "source_module": "lseg_analytics.pricing.reference_data.calendars",
        "module_version": "1.1.0"
    }
]