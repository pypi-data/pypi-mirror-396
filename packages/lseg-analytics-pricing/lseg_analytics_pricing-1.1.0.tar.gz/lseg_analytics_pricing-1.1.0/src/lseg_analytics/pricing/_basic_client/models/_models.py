# pylint: disable=too-many-lines
# coding=utf-8

# pylint: disable=useless-super-delegation

import datetime
import decimal
from abc import ABC
from typing import (
    TYPE_CHECKING,
    Any,
    Dict,
    List,
    Literal,
    Mapping,
    Optional,
    Union,
    overload,
)

from .. import _model_base
from .._model_base import rest_discriminator, rest_field
from ._enums import (
    CashFlowPaymentTypeEnum,
    CurveTypeEnum,
    DateType,
    DurationType,
    FxConstituentEnum,
    InstrumentTemplateTypeEnum,
    InterestRateTypeEnum,
    IrConstituentEnum,
    ModelTypeEnum,
    PositionType,
    RescheduleType,
    ResourceType,
    UnderlyingTypeEnum,
)

if TYPE_CHECKING:
    from .. import models as _models


class When(ABC, _model_base.Model):
    """An object to determine regular annual holiday rules for the calendar.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AbsolutePositionWhen, RelativePositionWhen, RelativeToRulePositionWhen

    Attributes
    ----------
    position_type : str or ~analyticsapi.models.PositionType
        The type of regular annual holiday rule. Possible values are:
        AbsolutePositionWhen (for fixed holidays), RelativePositionWhen (for
        holidays that fall on a particular day of the week) or
        RelativeToRulePositionWhen (for holidays that are set by reference to
        another date). Required. Known values are: "AbsolutePositionWhen",
        "RelativePositionWhen", and "RelativeToRulePositionWhen".
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    position_type: str = rest_discriminator(name="positionType")
    """The type of regular annual holiday rule. Possible values are: AbsolutePositionWhen (for fixed
     holidays), RelativePositionWhen (for holidays that fall on a particular day of the week) or
     RelativeToRulePositionWhen (for holidays that are set by reference to another date). Required.
     Known values are: \"AbsolutePositionWhen\", \"RelativePositionWhen\", and
     \"RelativeToRulePositionWhen\"."""

    @overload
    def __init__(
        self,
        position_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["position_type"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class AbsolutePositionWhen(When, discriminator="AbsolutePositionWhen"):
    """An absolute position annual holiday rule. For example, New Year holiday on 1st Jan.

    Attributes
    ----------
    position_type : str or ~analyticsapi.models.ABSOLUTE_POSITION_WHEN
        The type of regular annual holiday rule. Only AbsolutePositionWhen
        value applies. Required. A rule to determine a fixed holiday. For
        example, New Year holiday on January 1.
    day_of_month : int
        The number of the day of the month. The minimum value is 0 (a special
        case indication western Easter). The maximum value is 31. Required.
    month : str or ~analyticsapi.models.Month
        The month of the year, written in full (e.g. January). Required. Known
        values are: "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", and "December".
    observance : list[~analyticsapi.models.Observance]
        An array of objects to determine a holiday rescheduling if it falls on
        a rest day. This property is optional and only applied if explicitly
        specified. If not provided, a holidays will not be rescheduled by
        default.  The default value is None, needs to be assigned before using.
    """

    position_type: Literal[PositionType.ABSOLUTE_POSITION_WHEN] = rest_discriminator(name="positionType")  # type: ignore # pylint: disable=line-too-long
    """The type of regular annual holiday rule. Only AbsolutePositionWhen value applies. Required. A
     rule to determine a fixed holiday. For example, New Year holiday on January 1."""
    day_of_month: int = rest_field(name="dayOfMonth")
    """The number of the day of the month. The minimum value is 0 (a special case indication western
     Easter). The maximum value is 31. Required."""
    month: Union[str, "_models.Month"] = rest_field()
    """The month of the year, written in full (e.g. January). Required. Known values are: \"January\",
     \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\",
     \"October\", \"November\", and \"December\"."""
    observance: Optional[List["_models.Observance"]] = rest_field()
    """An array of objects to determine a holiday rescheduling if it falls on a rest day. This
     property is optional and only applied if explicitly specified. If not provided, a holidays will
     not be rescheduled by default."""

    @overload
    def __init__(
        self,
        *,
        day_of_month: int,
        month: Union[str, "_models.Month"],
        observance: Optional[List["_models.Observance"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, position_type=PositionType.ABSOLUTE_POSITION_WHEN, **kwargs)


class ActualVsProjectedGlobalSettings(_model_base.Model):
    """ActualVsProjectedGlobalSettings.

    Attributes
    ----------
    prepay_dials : ~analyticsapi.models.JsonRef
        Optional, reference a dial (custom prepay model setting).
    use_non_qm_collateral : bool
        Optional, if true, Non-QM collateral is used for non-agency RMBS model
        calls, otherwise Alt-A collateral is used. This flag only applies to
        prepay type v97. If this flag is set to true, you must also set
        'coreLogicCollateral' to 'USE'.
    core_logic_collateral : str
        Optional, for Non-Agency. Enables model to be run using from CoreLogic
        collateral data. Is one of the following types: Literal["DEFAULT"],
        Literal["USE"], Literal["IGNORE"]
    """

    prepay_dials: Optional["_models.JsonRef"] = rest_field(name="prepayDials")
    """Optional, reference a dial (custom prepay model setting)."""
    use_non_qm_collateral: Optional[bool] = rest_field(name="useNonQMCollateral")
    """Optional, if true, Non-QM collateral is used for non-agency RMBS model calls, otherwise Alt-A
     collateral is used. This flag only applies to prepay type v97. If this flag is set to true, you
     must also set 'coreLogicCollateral' to 'USE'."""
    core_logic_collateral: Optional[Literal["DEFAULT", "USE", "IGNORE"]] = rest_field(name="coreLogicCollateral")
    """Optional, for Non-Agency. Enables model to be run using from CoreLogic collateral data. Is one
     of the following types: Literal[\"DEFAULT\"], Literal[\"USE\"], Literal[\"IGNORE\"]"""

    @overload
    def __init__(
        self,
        *,
        prepay_dials: Optional["_models.JsonRef"] = None,
        use_non_qm_collateral: Optional[bool] = None,
        core_logic_collateral: Optional[Literal["DEFAULT", "USE", "IGNORE"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ActualVsProjectedRequest(_model_base.Model):
    """ActualVsProjectedRequest.

    Attributes
    ----------
    global_settings : ~analyticsapi.models.ActualVsProjectedGlobalSettings
    input : list[~analyticsapi.models.ActualVsProjectedRequestItem]
        The default value is None, needs to be assigned before using.
    """

    global_settings: Optional["_models.ActualVsProjectedGlobalSettings"] = rest_field(name="globalSettings")
    input: Optional[List["_models.ActualVsProjectedRequestItem"]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        global_settings: Optional["_models.ActualVsProjectedGlobalSettings"] = None,
        input: Optional[List["_models.ActualVsProjectedRequestItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ActualVsProjectedRequestItem(_model_base.Model):
    """ActualVsProjectedRequestItem.

    Attributes
    ----------
    identifier : str
        Security reference ID.
    id_type : str or ~analyticsapi.models.IdTypeEnum
        Known values are: "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN",
        "REGSISIN", "SEDOL", "Identifier", "ChinaInterbankCode",
        "ShanghaiExchangeCode", "ShenzhenExchangeCode", and "MXTickerID".
    user_instrument : ~analyticsapi.models.JsonRef
        Optional, a user defined security identifier. Only necessary when
        analyzing a user defined instrument.
    user_tag : str
        User provided tag - this will be returned in the response.
    prepay_type : str
        Required, the prepayment model selection. The options are Model,
        ExpModel, Model, NewModel, OldExpModel, OldModel, PreExpModel.
    dial_head_start : int
        Optional, only for use with prepayDials. This field allows the dials to
        become effective up to 24 months in the past.
    """

    identifier: Optional[str] = rest_field()
    """Security reference ID."""
    id_type: Optional[Union[str, "_models.IdTypeEnum"]] = rest_field(name="idType")
    """Known values are: \"SecurityIDEntry\", \"SecurityID\", \"CUSIP\", \"ISIN\", \"REGSISIN\",
     \"SEDOL\", \"Identifier\", \"ChinaInterbankCode\", \"ShanghaiExchangeCode\",
     \"ShenzhenExchangeCode\", and \"MXTickerID\"."""
    user_instrument: Optional["_models.JsonRef"] = rest_field(name="userInstrument")
    """Optional, a user defined security identifier. Only necessary when analyzing a user defined
     instrument."""
    user_tag: Optional[str] = rest_field(name="userTag")
    """User provided tag - this will be returned in the response."""
    prepay_type: Optional[str] = rest_field(name="prepayType")
    """Required, the prepayment model selection. The options are Model, ExpModel, Model, NewModel,
     OldExpModel, OldModel, PreExpModel."""
    dial_head_start: Optional[int] = rest_field(name="dialHeadStart")
    """Optional, only for use with prepayDials. This field allows the dials to become effective up to
     24 months in the past."""

    @overload
    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        id_type: Optional[Union[str, "_models.IdTypeEnum"]] = None,
        user_instrument: Optional["_models.JsonRef"] = None,
        user_tag: Optional[str] = None,
        prepay_type: Optional[str] = None,
        dial_head_start: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Date(ABC, _model_base.Model):
    """Date.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AdjustableDate, FutureDate, RelativeAdjustableDate

    Attributes
    ----------
    date_type : str or ~analyticsapi.models.DateType
        Required. Known values are: "AdjustableDate", "RelativeAdjustableDate",
        and "FutureDate".
    date_moving_convention : str or ~analyticsapi.models.DateMovingConvention
        The method to adjust dates to working days. The possible values are:
        ModifiedFollowing: dates are adjusted to the next business day
        convention unless it goes into the next month. In such case, the
        previous business day convention is used, NextBusinessDay: dates are
        moved to the following working day, PreviousBusinessDay: dates are
        moved to the preceding working day, NoMoving: dates are not adjusted,
        EveryThirdWednesday: dates are moved to the third Wednesday of the
        month, or to the next working day if the third Wednesday is not a
        working day, BbswModifiedFollowing: dates are adjusted to the next
        business day convention unless it goes into the next month, or crosses
        mid-month (15th). In such case, the previous business day convention is
        used. Default is ModifiedFollowing. Known values are:
        "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay",
        "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing".
    calendars : list[str]
        An array of calendars that should be used for the date adjustment.
        Typically the calendars are derived based on the instruments currency
        or crossCurrency code.  The default value is None, needs to be assigned
        before using.
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    date_type: str = rest_discriminator(name="dateType")
    """Required. Known values are: \"AdjustableDate\", \"RelativeAdjustableDate\", and \"FutureDate\"."""
    date_moving_convention: Optional[Union[str, "_models.DateMovingConvention"]] = rest_field(
        name="dateMovingConvention"
    )
    """The method to adjust dates to working days. The possible values are:
     ModifiedFollowing: dates are adjusted to the next business day convention unless it goes into
     the next month. In such case, the previous business day convention is used,
     NextBusinessDay: dates are moved to the following working day,
     PreviousBusinessDay: dates are moved to the preceding working day, NoMoving: dates are not
     adjusted,
     EveryThirdWednesday: dates are moved to the third Wednesday of the month, or to the next
     working day if the third Wednesday is not a working day,
     BbswModifiedFollowing: dates are adjusted to the next business day convention unless it goes
     into the next month, or crosses mid-month (15th). In such case, the previous business day
     convention is used.
     Default is ModifiedFollowing. Known values are: \"ModifiedFollowing\", \"NextBusinessDay\",
     \"PreviousBusinessDay\", \"NoMoving\", \"EveryThirdWednesday\", and \"BbswModifiedFollowing\"."""
    calendars: Optional[List[str]] = rest_field()
    """An array of calendars that should be used for the date adjustment. Typically the calendars are
     derived based on the instruments currency or crossCurrency code."""

    @overload
    def __init__(
        self,
        *,
        date_type: str,
        date_moving_convention: Optional[Union[str, "_models.DateMovingConvention"]] = None,
        calendars: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AdjustableDate(Date, discriminator="AdjustableDate"):
    """AdjustableDate.

    Attributes
    ----------
    date_moving_convention : str or ~analyticsapi.models.DateMovingConvention
        The method to adjust dates to working days. The possible values are:
        ModifiedFollowing: dates are adjusted to the next business day
        convention unless it goes into the next month. In such case, the
        previous business day convention is used, NextBusinessDay: dates are
        moved to the following working day, PreviousBusinessDay: dates are
        moved to the preceding working day, NoMoving: dates are not adjusted,
        EveryThirdWednesday: dates are moved to the third Wednesday of the
        month, or to the next working day if the third Wednesday is not a
        working day, BbswModifiedFollowing: dates are adjusted to the next
        business day convention unless it goes into the next month, or crosses
        mid-month (15th). In such case, the previous business day convention is
        used. Default is ModifiedFollowing. Known values are:
        "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay",
        "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing".
    calendars : list[str]
        An array of calendars that should be used for the date adjustment.
        Typically the calendars are derived based on the instruments currency
        or crossCurrency code.  The default value is None, needs to be assigned
        before using.
    date_type : str or ~analyticsapi.models.ADJUSTABLE_DATE
        The type of the Date input. Possible values are: AdjustableDate,
        RelativeAdjustableDate. Required. The date is defined as adjustable
        according the BusinessDayAdjustmentDefinition.
    date : ~datetime.date
        The date that will be adjusted based on the dateMovingConvention.The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01).
        Required.
    """

    date_type: Literal[DateType.ADJUSTABLE_DATE] = rest_discriminator(name="dateType")  # type: ignore
    """The type of the Date input. Possible values are: AdjustableDate, RelativeAdjustableDate.
     Required. The date is defined as adjustable according the BusinessDayAdjustmentDefinition."""
    date: datetime.date = rest_field()
    """The date that will be adjusted based on the dateMovingConvention.The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g. 2021-01-01). Required."""

    @overload
    def __init__(
        self,
        *,
        date: datetime.date,
        date_moving_convention: Optional[Union[str, "_models.DateMovingConvention"]] = None,
        calendars: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, date_type=DateType.ADJUSTABLE_DATE, **kwargs)


class AdjustedDate(_model_base.Model):
    """AdjustedDate.

    Attributes
    ----------
    un_adjusted : ~datetime.date
        The unadjusted date. The value is expressed in ISO 8601 format: YYYY-
        MM-DD (e.g. 2021-01-01). Required.
    adjusted : ~datetime.date
        The date which has been used as a reference date for the provided
        tenor. Possible values are: StartDate, ValuationDate, SpotDate. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01).
        Required.
    date_moving_convention : str or ~analyticsapi.models.DateMovingConvention
        The method to adjust dates to working days. The possible values are:
        ModifiedFollowing: dates are adjusted to the next business day
        convention unless it goes into the next month. In such case, the
        previous business day convention is used, NextBusinessDay: dates are
        moved to the following working day, PreviousBusinessDay: dates are
        moved to the preceding working day, NoMoving: dates are not adjusted,
        EveryThirdWednesday: dates are moved to the third Wednesday of the
        month, or to the next working day if the third Wednesday is not a
        working day, BbswModifiedFollowing: dates are adjusted to the next
        business day convention unless it goes into the next month, or crosses
        mid-month (15th). In such case, the previous business day convention is
        used. Default is ModifiedFollowing. Required. Known values are:
        "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay",
        "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing".
    reference_date : str or ~analyticsapi.models.ReferenceDate
        The date which has been used as a reference date for the provided
        tenor. Possible values are: StartDate, ValuationDate, SpotDate. Known
        values are: "SpotDate", "StartDate", "ValuationDate", and "EndDate".
    date : ~datetime.date
        The date that which has been provided in the request. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01).
    tenor : str
        A tenor (relative date) expressed as a code indicating the period
        between referenceDate(default=startDate) to endDate of the instrument
        (e.g., '6M', '1Y').
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    un_adjusted: datetime.date = rest_field(name="unAdjusted")
    """The unadjusted date. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g. 2021-01-01).
     Required."""
    adjusted: datetime.date = rest_field()
    """The date which has been used as a reference date for the provided tenor. Possible values are:
     StartDate, ValuationDate, SpotDate. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.
     2021-01-01). Required."""
    date_moving_convention: Union[str, "_models.DateMovingConvention"] = rest_field(name="dateMovingConvention")
    """The method to adjust dates to working days. The possible values are:
     ModifiedFollowing: dates are adjusted to the next business day convention unless it goes into
     the next month. In such case, the previous business day convention is used,
     NextBusinessDay: dates are moved to the following working day,
     PreviousBusinessDay: dates are moved to the preceding working day, NoMoving: dates are not
     adjusted,
     EveryThirdWednesday: dates are moved to the third Wednesday of the month, or to the next
     working day if the third Wednesday is not a working day,
     BbswModifiedFollowing: dates are adjusted to the next business day convention unless it goes
     into the next month, or crosses mid-month (15th). In such case, the previous business day
     convention is used.
     Default is ModifiedFollowing. Required. Known values are: \"ModifiedFollowing\",
     \"NextBusinessDay\", \"PreviousBusinessDay\", \"NoMoving\", \"EveryThirdWednesday\", and
     \"BbswModifiedFollowing\"."""
    reference_date: Optional[Union[str, "_models.ReferenceDate"]] = rest_field(name="referenceDate")
    """The date which has been used as a reference date for the provided tenor. Possible values are:
     StartDate, ValuationDate, SpotDate. Known values are: \"SpotDate\", \"StartDate\",
     \"ValuationDate\", and \"EndDate\"."""
    date: Optional[datetime.date] = rest_field()
    """The date that which has been provided in the request. The value is expressed in ISO 8601
     format: YYYY-MM-DD (e.g. 2021-01-01)."""
    tenor: Optional[str] = rest_field()
    """A tenor (relative date) expressed as a code indicating the period between
     referenceDate(default=startDate) to endDate of the instrument (e.g., '6M', '1Y')."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        un_adjusted: datetime.date,
        adjusted: datetime.date,
        date_moving_convention: Union[str, "_models.DateMovingConvention"],
        reference_date: Optional[Union[str, "_models.ReferenceDate"]] = None,
        date: Optional[datetime.date] = None,
        tenor: Optional[str] = None,
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AmortizationDefinition(_model_base.Model):
    """An object that defines the amortization schedule.

    Attributes
    ----------
    schedule_definition : ~analyticsapi.models.ScheduleDefinition
        An object that defines a schedule of amortization dates. Required.
    reference_amount : float
        The amortization amount for each schedule date.
    residual_amount : float
        The final payment of principal to ensure that the initial amount is
        fully repaid by the end date of the instruments leg.
    type : str or ~analyticsapi.models.AmortizationTypeEnum
        The type of amortization. Required. Known values are: "Linear" and
        "Annuity".
    """

    schedule_definition: "_models.ScheduleDefinition" = rest_field(name="scheduleDefinition")
    """An object that defines a schedule of amortization dates. Required."""
    reference_amount: Optional[float] = rest_field(name="referenceAmount")
    """The amortization amount for each schedule date."""
    residual_amount: Optional[float] = rest_field(name="residualAmount")
    """The final payment of principal to ensure that the initial amount is fully repaid by the end
     date of the instruments leg."""
    type: Union[str, "_models.AmortizationTypeEnum"] = rest_field(default="None")
    """The type of amortization. Required. Known values are: \"Linear\" and \"Annuity\"."""

    @overload
    def __init__(
        self,
        *,
        schedule_definition: "_models.ScheduleDefinition",
        type: Union[str, "_models.AmortizationTypeEnum"],
        reference_amount: Optional[float] = None,
        residual_amount: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AmortizationItemDefinition(_model_base.Model):
    """General class to describe a section/item of amortization schedule.

    Attributes
    ----------
    amortization_frequency : str or ~analyticsapi.models.AmortizationFrequencyEnum
        Frequency of the Amortization. Known values are: "Once", "EveryCoupon",
        "Every2ndCoupon", "Every3rdCoupon", "Every4thCoupon",
        "Every12thCoupon", "Annual", "SemiAnnual", "Quarterly", "Monthly",
        "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every91Days",
        "Every182Days", "Every364Days", "Every365Days", "Every90Days",
        "Every92Days", "Every93Days", "Every180Days", "Every183Days",
        "Every184Days", "Every4Months", "R2", "R4", "Zero", and "Scheduled".
    amortization_type : str or ~analyticsapi.models.IPAAmortizationTypeEnum
        Amortization type Annuity, Schedule, Linear or None. Known values are:
        "None", "Linear", "Annuity", and "Schedule".
    amount : float
        Amortization Amount at each Amortizatin Date.
    end_date : ~datetime.datetime
        End Date of an amortization section/window, or stepped rate.
    remaining_notional : float
        The Remaining Notional Amount after Amortization.
    start_date : ~datetime.datetime
        Start Date of an amortization section/window, or stepped rate.
    """

    amortization_frequency: Optional[Union[str, "_models.AmortizationFrequencyEnum"]] = rest_field(
        name="amortizationFrequency"
    )
    """Frequency of the Amortization. Known values are: \"Once\", \"EveryCoupon\", \"Every2ndCoupon\",
     \"Every3rdCoupon\", \"Every4thCoupon\", \"Every12thCoupon\", \"Annual\", \"SemiAnnual\",
     \"Quarterly\", \"Monthly\", \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\", \"Every7Days\",
     \"Every14Days\", \"Every28Days\", \"Every30Days\", \"Every91Days\", \"Every182Days\",
     \"Every364Days\", \"Every365Days\", \"Every90Days\", \"Every92Days\", \"Every93Days\",
     \"Every180Days\", \"Every183Days\", \"Every184Days\", \"Every4Months\", \"R2\", \"R4\",
     \"Zero\", and \"Scheduled\"."""
    amortization_type: Optional[Union[str, "_models.IPAAmortizationTypeEnum"]] = rest_field(name="amortizationType")
    """Amortization type Annuity, Schedule, Linear or None. Known values are: \"None\", \"Linear\",
     \"Annuity\", and \"Schedule\"."""
    amount: Optional[float] = rest_field()
    """Amortization Amount at each Amortizatin Date."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """End Date of an amortization section/window, or stepped rate."""
    remaining_notional: Optional[float] = rest_field(name="remainingNotional")
    """The Remaining Notional Amount after Amortization."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """Start Date of an amortization section/window, or stepped rate."""

    @overload
    def __init__(
        self,
        *,
        amortization_frequency: Optional[Union[str, "_models.AmortizationFrequencyEnum"]] = None,
        amortization_type: Optional[Union[str, "_models.IPAAmortizationTypeEnum"]] = None,
        amount: Optional[float] = None,
        end_date: Optional[datetime.datetime] = None,
        remaining_notional: Optional[float] = None,
        start_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Amount(_model_base.Model):
    """An object that specifies the amount and the currency in which it is expressed.

    Attributes
    ----------
    value : float
        The amount. Required.
    currency : str
        The currency in which the amount is expressed. The value is expressed
        in ISO 4217 alphabetical format (e.g., 'USD'). Required.
    """

    value: float = rest_field()
    """The amount. Required."""
    currency: str = rest_field()
    """The currency in which the amount is expressed. The value is expressed in ISO 4217 alphabetical
     format (e.g., 'USD'). Required."""

    @overload
    def __init__(
        self,
        *,
        value: float,
        currency: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ApimCurveShift(_model_base.Model):
    """ApimCurveShift.

    Attributes
    ----------
    year : ~decimal.Decimal
        Curve tenor to be shifted. If only one tenor is specified, the entire
        curve will be shifted by this amount (i.e. parallel shift).
    value : ~decimal.Decimal
        Shift amount, in basis points.
    """

    year: Optional[decimal.Decimal] = rest_field()
    """Curve tenor to be shifted. If only one tenor is specified, the entire curve will be shifted by
     this amount (i.e. parallel shift)."""
    value: Optional[decimal.Decimal] = rest_field()
    """Shift amount, in basis points."""

    @overload
    def __init__(
        self,
        *,
        year: Optional[decimal.Decimal] = None,
        value: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ApimError(_model_base.Model):
    """ApimError.

    Attributes
    ----------
    code : str
    description : str
    resolution : str
    location : str
    error : str
    path : str
    """

    code: Optional[str] = rest_field()
    description: Optional[str] = rest_field()
    resolution: Optional[str] = rest_field()
    location: Optional[str] = rest_field()
    error: Optional[str] = rest_field()
    path: Optional[str] = rest_field()

    @overload
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        description: Optional[str] = None,
        resolution: Optional[str] = None,
        location: Optional[str] = None,
        error: Optional[str] = None,
        path: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsianDefinition(_model_base.Model):
    """An object that defines an Asian option in which the final payout is based on the average price
    level of the underlying asset over a certain time period.

    Attributes
    ----------
    asian_type : str or ~analyticsapi.models.AsianTypeEnum
        The type of an Asian option based on whether the strike is fixed or
        not. Known values are: "Price" and "Strike".
    average_type : str or ~analyticsapi.models.AverageTypeEnum
        The mathematical type used to calculate the average price of the
        underlying asset. Known values are: "Arithmetic" and "Geometric".
    fixing_schedule : ~analyticsapi.models.ScheduleDefinition
        An object that defines the schedule of dates in the fixing period of an
        Asian option.
    """

    asian_type: Optional[Union[str, "_models.AsianTypeEnum"]] = rest_field(name="asianType")
    """The type of an Asian option based on whether the strike is fixed or not. Known values are:
     \"Price\" and \"Strike\"."""
    average_type: Optional[Union[str, "_models.AverageTypeEnum"]] = rest_field(name="averageType")
    """The mathematical type used to calculate the average price of the underlying asset. Known values
     are: \"Arithmetic\" and \"Geometric\"."""
    fixing_schedule: Optional["_models.ScheduleDefinition"] = rest_field(name="fixingSchedule")
    """An object that defines the schedule of dates in the fixing period of an Asian option."""

    @overload
    def __init__(
        self,
        *,
        asian_type: Optional[Union[str, "_models.AsianTypeEnum"]] = None,
        average_type: Optional[Union[str, "_models.AverageTypeEnum"]] = None,
        fixing_schedule: Optional["_models.ScheduleDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsianOtcOptionOverride(_model_base.Model):
    """An object that contains the properties of an Asian OTC option that can be overridden.

    Attributes
    ----------
    strike : float
        The set price at which the option holder can buy or sell the underlying
        asset. The value is expressed according to the market convention linked
        to the underlying asset.
    end_date : ~analyticsapi.models.Date
        An object that defines the maturity or expiry date of an option
        instrument.
    underlying_code : str
        The code (a RIC) used to define the underlying asset.
    option_type : str or ~analyticsapi.models.CallPutEnum
        An indicator of whether an option instrument is a call or a put. Known
        values are: "Call" and "Put".
    notional_amount : float
        The notional amount of an option instrument.
    fixing_start_date : ~datetime.date
        The start date of a predetermined set of dates (known as fixings) used
        to calculate the average underlying asset's price.
    fixing_end_date : ~datetime.date
        The end date of a predetermined set of dates (known as fixings) used to
        calculate the average underlying asset's price. It should be less or
        equal to the option expiry date.
    fixing_frequency : str or ~analyticsapi.models.FrequencyEnum
        The frequency of dates in the fixing period of an Asian option. Known
        values are: "Annual", "SemiAnnual", "Quarterly", "Monthly",
        "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every90Days",
        "Every91Days", "Every92Days", "Every93Days", "Every4Months",
        "Every180Days", "Every182Days", "Every183Days", "Every184Days",
        "Every364Days", "Every365Days", "R2", "R4", "Zero", and "Scheduled".
    """

    strike: Optional[float] = rest_field()
    """The set price at which the option holder can buy or sell the underlying asset. The value is
     expressed according to the market convention linked to the underlying asset."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """An object that defines the maturity or expiry date of an option instrument."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The code (a RIC) used to define the underlying asset."""
    option_type: Optional[Union[str, "_models.CallPutEnum"]] = rest_field(name="optionType")
    """An indicator of whether an option instrument is a call or a put. Known values are: \"Call\" and
     \"Put\"."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of an option instrument."""
    fixing_start_date: Optional[datetime.date] = rest_field(name="fixingStartDate")
    """The start date of a predetermined set of dates (known as fixings) used to calculate the average
     underlying asset's price."""
    fixing_end_date: Optional[datetime.date] = rest_field(name="fixingEndDate")
    """The end date of a predetermined set of dates (known as fixings) used to calculate the average
     underlying asset's price. It should be less or equal to the option expiry date."""
    fixing_frequency: Optional[Union[str, "_models.FrequencyEnum"]] = rest_field(name="fixingFrequency")
    """The frequency of dates in the fixing period of an Asian option. Known values are: \"Annual\",
     \"SemiAnnual\", \"Quarterly\", \"Monthly\", \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\",
     \"Every7Days\", \"Every14Days\", \"Every28Days\", \"Every30Days\", \"Every90Days\",
     \"Every91Days\", \"Every92Days\", \"Every93Days\", \"Every4Months\", \"Every180Days\",
     \"Every182Days\", \"Every183Days\", \"Every184Days\", \"Every364Days\", \"Every365Days\",
     \"R2\", \"R4\", \"Zero\", and \"Scheduled\"."""

    @overload
    def __init__(
        self,
        *,
        strike: Optional[float] = None,
        end_date: Optional["_models.Date"] = None,
        underlying_code: Optional[str] = None,
        option_type: Optional[Union[str, "_models.CallPutEnum"]] = None,
        notional_amount: Optional[float] = None,
        fixing_start_date: Optional[datetime.date] = None,
        fixing_end_date: Optional[datetime.date] = None,
        fixing_frequency: Optional[Union[str, "_models.FrequencyEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstrumentTemplateDefinition(ABC, _model_base.Model):
    """InstrumentTemplateDefinition.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    AsianOtcOptionTemplate, CrossCurrencySwapTemplateDefinition,
    CurrencyBasisSwapTemplateDefinition, DepositDefinitionTemplate, DoubleBarrierOtcOptionTemplate,
    DoubleBinaryOtcOptionTemplate, FraDefinitionTemplate, FxForwardTemplateDefinition,
    FxSpotTemplateDefinition, InterestRateLegTemplateDefinition, StirFutureTemplateDefinition,
    SingleBarrierOtcOptionTemplate, SingleBinaryOtcOptionTemplate,
    TenorBasisSwapTemplateDefinition, VanillaOtcOptionTemplate, InterestRateSwapTemplateDefinition

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.InstrumentTemplateTypeEnum
        Required. Known values are: "InterestRateLeg", "VanillaSwap",
        "TenorBasisSwap", "CrossCurrencySwap", "CurrencyBasisSwap", "FxSpot",
        "FxForward", "FxSwap", "NonDeliverableForward", "Deposit",
        "ForwardRateAgreement", "MoneyMarketFuture", "VanillaOtcOption",
        "AsianOtcOption", "SingleBarrierOtcOption", "DoubleBarrierOtcOption",
        "SingleBinaryOtcOption", and "DoubleBinaryOtcOption".
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    instrument_type: str = rest_discriminator(name="instrumentType")
    """Required. Known values are: \"InterestRateLeg\", \"VanillaSwap\", \"TenorBasisSwap\",
     \"CrossCurrencySwap\", \"CurrencyBasisSwap\", \"FxSpot\", \"FxForward\", \"FxSwap\",
     \"NonDeliverableForward\", \"Deposit\", \"ForwardRateAgreement\", \"MoneyMarketFuture\",
     \"VanillaOtcOption\", \"AsianOtcOption\", \"SingleBarrierOtcOption\",
     \"DoubleBarrierOtcOption\", \"SingleBinaryOtcOption\", and \"DoubleBinaryOtcOption\"."""

    @overload
    def __init__(
        self,
        instrument_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["instrument_type"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class AsianOtcOptionTemplate(InstrumentTemplateDefinition, discriminator="AsianOtcOption"):
    """AsianOtcOptionTemplate.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.ASIAN_OTC_OPTION
        Required. Asian OTC Option contract.
    template : ~analyticsapi.models.OptionDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.ASIAN_OTC_OPTION] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. Asian OTC Option contract."""
    template: "_models.OptionDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.OptionDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.ASIAN_OTC_OPTION, **kwargs)


class AssignmentKey(_model_base.Model):
    """AssignmentKey.

    Attributes
    ----------
    id : str
    key : str
    """

    id: Optional[str] = rest_field()
    key: Optional[str] = rest_field()

    @overload
    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        key: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsyncPollingIrSwapInstrumentArraySolveResponse(_model_base.Model):  # pylint: disable=name-too-long
    """AsyncPollingIrSwapInstrumentArraySolveResponse.

    Attributes
    ----------
    status : str or ~analyticsapi.models.AsyncStatusDecriptionEnum
        Required. Known values are: "Received", "InProgress", and "Complete".
    response : ~analyticsapi.models.IrSwapInstrumentArraySolveResponse
    """

    status: Union[str, "_models.AsyncStatusDecriptionEnum"] = rest_field()
    """Required. Known values are: \"Received\", \"InProgress\", and \"Complete\"."""
    response: Optional["_models.IrSwapInstrumentArraySolveResponse"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        status: Union[str, "_models.AsyncStatusDecriptionEnum"],
        response: Optional["_models.IrSwapInstrumentArraySolveResponse"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsyncPollingIrSwapInstrumentArrayValuationResponse(_model_base.Model):  # pylint: disable=name-too-long
    """AsyncPollingIrSwapInstrumentArrayValuationResponse.

    Attributes
    ----------
    status : str or ~analyticsapi.models.AsyncStatusDecriptionEnum
        Required. Known values are: "Received", "InProgress", and "Complete".
    response : ~analyticsapi.models.IrSwapInstrumentArrayValuationResponse
    """

    status: Union[str, "_models.AsyncStatusDecriptionEnum"] = rest_field()
    """Required. Known values are: \"Received\", \"InProgress\", and \"Complete\"."""
    response: Optional["_models.IrSwapInstrumentArrayValuationResponse"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        status: Union[str, "_models.AsyncStatusDecriptionEnum"],
        response: Optional["_models.IrSwapInstrumentArrayValuationResponse"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsyncPollingIrSwapInstrumentSolveResponse(_model_base.Model):  # pylint: disable=name-too-long
    """AsyncPollingIrSwapInstrumentSolveResponse.

    Attributes
    ----------
    status : str or ~analyticsapi.models.AsyncStatusDecriptionEnum
        Required. Known values are: "Received", "InProgress", and "Complete".
    response : ~analyticsapi.models.IrSwapInstrumentSolveResponse
    """

    status: Union[str, "_models.AsyncStatusDecriptionEnum"] = rest_field()
    """Required. Known values are: \"Received\", \"InProgress\", and \"Complete\"."""
    response: Optional["_models.IrSwapInstrumentSolveResponse"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        status: Union[str, "_models.AsyncStatusDecriptionEnum"],
        response: Optional["_models.IrSwapInstrumentSolveResponse"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsyncPollingIrSwapInstrumentValuationResponse(_model_base.Model):  # pylint: disable=name-too-long
    """AsyncPollingIrSwapInstrumentValuationResponse.

    Attributes
    ----------
    status : str or ~analyticsapi.models.AsyncStatusDecriptionEnum
        Required. Known values are: "Received", "InProgress", and "Complete".
    response : ~analyticsapi.models.IrSwapInstrumentValuationResponse
    """

    status: Union[str, "_models.AsyncStatusDecriptionEnum"] = rest_field()
    """Required. Known values are: \"Received\", \"InProgress\", and \"Complete\"."""
    response: Optional["_models.IrSwapInstrumentValuationResponse"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        status: Union[str, "_models.AsyncStatusDecriptionEnum"],
        response: Optional["_models.IrSwapInstrumentValuationResponse"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsyncPollingLoanInstrumentArraySolveResponse(_model_base.Model):  # pylint: disable=name-too-long
    """AsyncPollingLoanInstrumentArraySolveResponse.

    Attributes
    ----------
    status : str or ~analyticsapi.models.AsyncStatusDecriptionEnum
        Required. Known values are: "Received", "InProgress", and "Complete".
    response : ~analyticsapi.models.LoanInstrumentArraySolveResponse
    """

    status: Union[str, "_models.AsyncStatusDecriptionEnum"] = rest_field()
    """Required. Known values are: \"Received\", \"InProgress\", and \"Complete\"."""
    response: Optional["_models.LoanInstrumentArraySolveResponse"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        status: Union[str, "_models.AsyncStatusDecriptionEnum"],
        response: Optional["_models.LoanInstrumentArraySolveResponse"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsyncPollingLoanInstrumentArrayValuationResponse(_model_base.Model):  # pylint: disable=name-too-long
    """AsyncPollingLoanInstrumentArrayValuationResponse.

    Attributes
    ----------
    status : str or ~analyticsapi.models.AsyncStatusDecriptionEnum
        Required. Known values are: "Received", "InProgress", and "Complete".
    response : ~analyticsapi.models.LoanInstrumentArrayValuationResponse
    """

    status: Union[str, "_models.AsyncStatusDecriptionEnum"] = rest_field()
    """Required. Known values are: \"Received\", \"InProgress\", and \"Complete\"."""
    response: Optional["_models.LoanInstrumentArrayValuationResponse"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        status: Union[str, "_models.AsyncStatusDecriptionEnum"],
        response: Optional["_models.LoanInstrumentArrayValuationResponse"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsyncPollingLoanInstrumentSolveResponse(_model_base.Model):
    """AsyncPollingLoanInstrumentSolveResponse.

    Attributes
    ----------
    status : str or ~analyticsapi.models.AsyncStatusDecriptionEnum
        Required. Known values are: "Received", "InProgress", and "Complete".
    response : ~analyticsapi.models.LoanInstrumentSolveResponse
    """

    status: Union[str, "_models.AsyncStatusDecriptionEnum"] = rest_field()
    """Required. Known values are: \"Received\", \"InProgress\", and \"Complete\"."""
    response: Optional["_models.LoanInstrumentSolveResponse"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        status: Union[str, "_models.AsyncStatusDecriptionEnum"],
        response: Optional["_models.LoanInstrumentSolveResponse"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsyncPollingLoanInstrumentValuationResponse(_model_base.Model):  # pylint: disable=name-too-long
    """AsyncPollingLoanInstrumentValuationResponse.

    Attributes
    ----------
    status : str or ~analyticsapi.models.AsyncStatusDecriptionEnum
        Required. Known values are: "Received", "InProgress", and "Complete".
    response : ~analyticsapi.models.LoanInstrumentValuationResponse
    """

    status: Union[str, "_models.AsyncStatusDecriptionEnum"] = rest_field()
    """Required. Known values are: \"Received\", \"InProgress\", and \"Complete\"."""
    response: Optional["_models.LoanInstrumentValuationResponse"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        status: Union[str, "_models.AsyncStatusDecriptionEnum"],
        response: Optional["_models.LoanInstrumentValuationResponse"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class AsyncStatus(_model_base.Model):
    """Model representing the status of an asynchronous polling operation.

    Attributes
    ----------
    status : str or ~analyticsapi.models.AsyncStatusDecriptionEnum
        Required. Known values are: "Received", "InProgress", and "Complete".
    """

    status: Union[str, "_models.AsyncStatusDecriptionEnum"] = rest_field()
    """Required. Known values are: \"Received\", \"InProgress\", and \"Complete\"."""

    @overload
    def __init__(
        self,
        status: Union[str, "_models.AsyncStatusDecriptionEnum"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["status"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class ModelParameters(ABC, _model_base.Model):
    """An object that describes the pricing model parameters applied to an instrument.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    BachelierParameters, BlackScholesEquityParameters, BlackScholesFxParameters,
    BlackScholesInterestRateFuture, HestonEquityParameters

    Attributes
    ----------
    type : str or ~analyticsapi.models.ModelTypeEnum
        The type of the model used to determine the price of an instrument.
        Required. Known values are: "BlackScholesEquity", "BlackScholesFx",
        "BlackScholesInterestRateFuture", "HestonEquity", and "Bachelier".
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The type of the model used to determine the price of an instrument. Required. Known values are:
     \"BlackScholesEquity\", \"BlackScholesFx\", \"BlackScholesInterestRateFuture\",
     \"HestonEquity\", and \"Bachelier\"."""

    @overload
    def __init__(
        self,
        type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["type"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class BachelierParameters(ModelParameters, discriminator="Bachelier"):
    """An object that describes the Bachelier model parameters applied to the pricing of options.

    Attributes
    ----------
    type : str or ~analyticsapi.models.BACHELIER
        The type of the model used to determine the price of an instrument.
        Restricted to 'Bachelier'. Required. The Bachelier model applied to the
        pricing of options.
    volatility : ~analyticsapi.models.MarketVolatility
        An object that describes the volatility parameters.
    underlying_price : ~analyticsapi.models.Spot
        An object that describes the price of the underlying asset.
    risk_free_rate : ~analyticsapi.models.Rate
        An object that describes the discount zero coupon rate used to price an
        instrument based on its currency.
    """

    type: Literal[ModelTypeEnum.BACHELIER] = rest_discriminator(name="type")  # type: ignore
    """The type of the model used to determine the price of an instrument. Restricted to 'Bachelier'.
     Required. The Bachelier model applied to the pricing of options."""
    volatility: Optional["_models.MarketVolatility"] = rest_field()
    """An object that describes the volatility parameters."""
    underlying_price: Optional["_models.Spot"] = rest_field(name="underlyingPrice")
    """An object that describes the price of the underlying asset."""
    risk_free_rate: Optional["_models.Rate"] = rest_field(name="riskFreeRate")
    """An object that describes the discount zero coupon rate used to price an instrument based on its
     currency."""

    @overload
    def __init__(
        self,
        *,
        volatility: Optional["_models.MarketVolatility"] = None,
        underlying_price: Optional["_models.Spot"] = None,
        risk_free_rate: Optional["_models.Rate"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=ModelTypeEnum.BACHELIER, **kwargs)


class Balloon(_model_base.Model):
    """Balloon.

    Attributes
    ----------
    percent : float
        Percentage expected to default.
    loss_severity : float
        Severity of the defaults.
    recovery_period : int
        Time after maturity in which the holder gets recovered principal.
    loss_type : str
        Loss type setting. Is either a Literal["PLD"] type or a Literal["CDR"]
        type.
    loss_rate : float
        Loss rate. Either rate or vector is required.
    month_to_extend : int
        Number of months cash flows extend beyond final date. 0 indicates no
        extension.
    loss_vector : ~analyticsapi.models.Vector
    """

    percent: Optional[float] = rest_field()
    """Percentage expected to default."""
    loss_severity: Optional[float] = rest_field(name="lossSeverity")
    """Severity of the defaults."""
    recovery_period: Optional[int] = rest_field(name="recoveryPeriod")
    """Time after maturity in which the holder gets recovered principal."""
    loss_type: Optional[Literal["PLD", "CDR"]] = rest_field(name="lossType")
    """Loss type setting. Is either a Literal[\"PLD\"] type or a Literal[\"CDR\"] type."""
    loss_rate: Optional[float] = rest_field(name="lossRate")
    """Loss rate. Either rate or vector is required."""
    month_to_extend: Optional[int] = rest_field(name="monthToExtend")
    """Number of months cash flows extend beyond final date. 0 indicates no extension."""
    loss_vector: Optional["_models.Vector"] = rest_field(name="lossVector")

    @overload
    def __init__(
        self,
        *,
        percent: Optional[float] = None,
        loss_severity: Optional[float] = None,
        recovery_period: Optional[int] = None,
        loss_type: Optional[Literal["PLD", "CDR"]] = None,
        loss_rate: Optional[float] = None,
        month_to_extend: Optional[int] = None,
        loss_vector: Optional["_models.Vector"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BarrierDefinition(_model_base.Model):
    """An object that defines a barrier option which is activated or deactivated once the price of the
    underlying asset reaches a set level, known as the barrier at a specified time.

    Attributes
    ----------
    barrier_mode : str or ~analyticsapi.models.BarrierModeEnum
        The barrier mode that defines the timing and conditions under which the
        barrier level is monitored and can trigger activation. Known values
        are: "American", "European", and "Bermudan".
    in_or_out : str or ~analyticsapi.models.InOrOutEnum
        The type of a barrier option based on whether it is activated or
        deactivated when the price of the underlying asset reaches a certain
        barrier. Known values are: "In" and "Out".
    schedule : ~analyticsapi.models.ScheduleDefinition
        An object that defines the barrier schedule of a barrier option.
    level : float
        The price used as a barrier level.
    rebate_amount : ~analyticsapi.models.Amount
        The rebate provided to investors when a barrier option is not able to
        be exercised and becomes worthless. The amount is provided in the
        domestic currency.
    """

    barrier_mode: Optional[Union[str, "_models.BarrierModeEnum"]] = rest_field(name="barrierMode")
    """The barrier mode that defines the timing and conditions under which the barrier level is
     monitored and can trigger activation. Known values are: \"American\", \"European\", and
     \"Bermudan\"."""
    in_or_out: Optional[Union[str, "_models.InOrOutEnum"]] = rest_field(name="inOrOut")
    """The type of a barrier option based on whether it is activated or deactivated when the price of
     the underlying asset reaches a certain barrier. Known values are: \"In\" and \"Out\"."""
    schedule: Optional["_models.ScheduleDefinition"] = rest_field()
    """An object that defines the barrier schedule of a barrier option."""
    level: Optional[float] = rest_field()
    """The price used as a barrier level."""
    rebate_amount: Optional["_models.Amount"] = rest_field(name="rebateAmount")
    """The rebate provided to investors when a barrier option is not able to be exercised and becomes
     worthless. The amount is provided in the domestic currency."""

    @overload
    def __init__(
        self,
        *,
        barrier_mode: Optional[Union[str, "_models.BarrierModeEnum"]] = None,
        in_or_out: Optional[Union[str, "_models.InOrOutEnum"]] = None,
        schedule: Optional["_models.ScheduleDefinition"] = None,
        level: Optional[float] = None,
        rebate_amount: Optional["_models.Amount"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BarrierDefinitionElement(_model_base.Model):
    """BarrierDefinitionElement.

    Attributes
    ----------
    barrier_direction : str or ~analyticsapi.models.BarrierDirectionEnum
        The type of the barrier option based on the direction of the underlying
        asset price when it is activated or deactivated. The possible values
        are:

        * Up: the option is an up-barrier. It is activated or deactivated when the price goes beyond
        the barrier level,
        * Down: the option is a down-barrier. It is activated or deactivated when the price goes below
        the barrier level.

        Mandatory if no barrier value is specified. The default value depends on the type of barrier
        value used (barrierUpPercent or barrierDownPercent). Known values are: "Up" and "Down".
    barrier_down_percent : float
        The rate used as a barrier level. The value is expressed in
        percentages. Either barrierUpPercent or barrierDownPercent must be
        provided, if barrierDefinition is used. Mandatory for pricing a Knock
        Out CapFloor Default value set to Strike ATM - 1%.
    barrier_type : str or ~analyticsapi.models.BarrierTypeEnum
        The type of the barrier option. The possible values are:

        * KnockIn: the option is activated only when the underlying asset price reaches the barrier,
        * KnockOut: the option is deactivated when the underlying asset price reaches the barrier.

        Mandatory if barrierDefinition is used. Known values are: "KnockIn", "KnockOut",
        "KnockInKnockOut", and "KnockOutKnockIn".
    barrier_up_percent : float
        The rate used as a barrier level. The value is expressed in
        percentages. Either barrierUpPercent or barrierDownPercent must be
        provided, if barrierDefinition is used. Mandatory for pricing a Knock
        In CapFloor Default value set to Strike ATM + 1%.
    rebate_down_percent : float
        The rebate provided to investors when the down barrier option is not
        able to be exercised and becomes worthless. The value is expressed in
        percentages. Either rebateUpPercent or rebateDownPercent must be
        provided, if barrierDefinition is used.
    rebate_up_percent : float
        The rebate provided to investors when the up barrier option is not able
        to be exercised and becomes worthless. The value is expressed in
        percentages. Either rebateUpPercent or rebateDownPercent must be
        provided, if barrierDefinition is used.
    """

    barrier_direction: Optional[Union[str, "_models.BarrierDirectionEnum"]] = rest_field(name="barrierDirection")
    """The type of the barrier option based on the direction of the underlying asset price when it is
     activated or deactivated. The possible values are:
     
     
     * Up: the option is an up-barrier. It is activated or deactivated when the price goes beyond
     the barrier level,
     * Down: the option is a down-barrier. It is activated or deactivated when the price goes below
     the barrier level.
     
     Mandatory if no barrier value is specified. The default value depends on the type of barrier
     value used (barrierUpPercent or barrierDownPercent). Known values are: \"Up\" and \"Down\"."""
    barrier_down_percent: Optional[float] = rest_field(name="barrierDownPercent")
    """The rate used as a barrier level. The value is expressed in percentages.
     Either barrierUpPercent or barrierDownPercent must be provided, if barrierDefinition is used.
     Mandatory for pricing a Knock Out CapFloor
     Default value set to Strike ATM - 1%."""
    barrier_type: Optional[Union[str, "_models.BarrierTypeEnum"]] = rest_field(name="barrierType")
    """The type of the barrier option. The possible values are:
     
     
     * KnockIn: the option is activated only when the underlying asset price reaches the barrier,
     * KnockOut: the option is deactivated when the underlying asset price reaches the barrier.
     
     Mandatory if barrierDefinition is used. Known values are: \"KnockIn\", \"KnockOut\",
     \"KnockInKnockOut\", and \"KnockOutKnockIn\"."""
    barrier_up_percent: Optional[float] = rest_field(name="barrierUpPercent")
    """The rate used as a barrier level. The value is expressed in percentages.
     Either barrierUpPercent or barrierDownPercent must be provided, if barrierDefinition is used.
     Mandatory for pricing a Knock In CapFloor
     Default value set to Strike ATM + 1%."""
    rebate_down_percent: Optional[float] = rest_field(name="rebateDownPercent")
    """The rebate provided to investors when the down barrier option is not able to be exercised and
     becomes worthless. The value is expressed in percentages.
     Either rebateUpPercent or rebateDownPercent must be provided, if barrierDefinition is used."""
    rebate_up_percent: Optional[float] = rest_field(name="rebateUpPercent")
    """The rebate provided to investors when the up barrier option is not able to be exercised and
     becomes worthless. The value is expressed in percentages.
     Either rebateUpPercent or rebateDownPercent must be provided, if barrierDefinition is used."""

    @overload
    def __init__(
        self,
        *,
        barrier_direction: Optional[Union[str, "_models.BarrierDirectionEnum"]] = None,
        barrier_down_percent: Optional[float] = None,
        barrier_type: Optional[Union[str, "_models.BarrierTypeEnum"]] = None,
        barrier_up_percent: Optional[float] = None,
        rebate_down_percent: Optional[float] = None,
        rebate_up_percent: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BasePricingParameters(_model_base.Model):
    """An object that describes cross-asset calculation parameters.

    Attributes
    ----------
    valuation_date : ~datetime.date
        The date on which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). The valuation date
        should be less than or equal to the instrument's end date. If not
        provided, today's date will be used as the default valuation date.
    report_currency : str
        The reporting currency. The value is expressed in ISO 4217 alphabetical
        format (e.g., 'GBP'). Default is USD.
    """

    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """The date on which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01').
     The valuation date should be less than or equal to the instrument's end date. If not provided,
     today's date will be used as the default valuation date."""
    report_currency: Optional[str] = rest_field(name="reportCurrency")
    """The reporting currency. The value is expressed in ISO 4217 alphabetical format (e.g., 'GBP').
     Default is USD."""

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.date] = None,
        report_currency: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BasisInstrumentFutures(_model_base.Model):
    """BasisInstrumentFutures.

    Attributes
    ----------
    basis : list[str]
        Get basis.  The default value is None, needs to be assigned before
        using.
    fields : ~analyticsapi.models.CurvesAndSurfacesBidAskFields
    formula : str
        The formula used to adjust market data values of the instrument's Bid
        and Ask price side. For example, '100-marketPrice'.
    formula_parameters : list[~analyticsapi.models.FormulaParameter]
        The list of formula parameters used to adjust market data values of the
        instrument's Bid and Ask price side.  The default value is None, needs
        to be assigned before using.
    instrument_definition : ~analyticsapi.models.FuturesInstrumentDefinition
    """

    basis: Optional[List[str]] = rest_field()
    """Get basis."""
    fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """The formula used to adjust market data values of the instrument's Bid and Ask price side. For
     example, '100-marketPrice'."""
    formula_parameters: Optional[List["_models.FormulaParameter"]] = rest_field(name="formulaParameters")
    """The list of formula parameters used to adjust market data values of the instrument's Bid and
     Ask price side."""
    instrument_definition: Optional["_models.FuturesInstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        basis: Optional[List[str]] = None,
        fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameter"]] = None,
        instrument_definition: Optional["_models.FuturesInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BasisInstrumentFuturesOutput(_model_base.Model):
    """BasisInstrumentFuturesOutput.

    Attributes
    ----------
    basis : list[str]
        Get basis.  The default value is None, needs to be assigned before
        using.
    fields : ~analyticsapi.models.BidAskFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.FuturesInstrumentDefinitionOutput
    status_message : str
        Get statusMessage.
    """

    basis: Optional[List[str]] = rest_field()
    """Get basis."""
    fields: Optional["_models.BidAskFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.FuturesInstrumentDefinitionOutput"] = rest_field(
        name="instrumentDefinition"
    )
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        basis: Optional[List[str]] = None,
        fields: Optional["_models.BidAskFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.FuturesInstrumentDefinitionOutput"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BasketItem(_model_base.Model):
    """BasketItem.

    Attributes
    ----------
    alive : str
    notional : str
    recovery_rate : float
    underlying : ~analyticsapi.models.BasketUnderlying
    """

    alive: Optional[str] = rest_field()
    notional: Optional[str] = rest_field()
    recovery_rate: Optional[float] = rest_field(name="recoveryRate")
    underlying: Optional["_models.BasketUnderlying"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        alive: Optional[str] = None,
        notional: Optional[str] = None,
        recovery_rate: Optional[float] = None,
        underlying: Optional["_models.BasketUnderlying"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BasketUnderlying(_model_base.Model):
    """BasketUnderlying.

    Attributes
    ----------
    ccy : str
    code : str
    name : str
    type : str
    """

    ccy: Optional[str] = rest_field()
    code: Optional[str] = rest_field()
    name: Optional[str] = rest_field()
    type: Optional[str] = rest_field(default="None")

    @overload
    def __init__(
        self,
        *,
        ccy: Optional[str] = None,
        code: Optional[str] = None,
        name: Optional[str] = None,
        type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BermudanSwaptionDefinition(_model_base.Model):
    """BermudanSwaptionDefinition.

    Attributes
    ----------
    exercise_schedule : list[~datetime.datetime]
        An array of exercise dates for Bermudan options. The default values are
        the cash flow dates of the underlying swap together with the valuation
        date and the last day of the month in which the end date of the
        swaption falls.  The default value is None, needs to be assigned before
        using.
    exercise_schedule_type : str or ~analyticsapi.models.ExerciseScheduleTypeEnum
        The source of the exercise dates of Bermudan options. The possible
        values are:

        * FixedLeg: coupon dates of the fixed leg of the underlying swap are used as the swaption
        exercise schedule,
        * FloatLeg: coupon dates of the floating leg of the underlying swap are used as the swaption
        exercise schedule,
        * UserDefined: the exercise schedule to be defined by the user.

        The default value is 'FixedLeg'. Known values are: "FixedLeg", "FloatLeg", and "UserDefined".
    notification_days : int
        The number of days the owner of the option has to notify the writer
        about the option being exercised. The default value is '0'.
    """

    exercise_schedule: Optional[List[datetime.datetime]] = rest_field(name="exerciseSchedule", format="rfc3339")
    """An array of exercise dates for Bermudan options.
     The default values are the cash flow dates of the underlying swap together with the valuation
     date and the last day of the month in which the end date of the swaption falls."""
    exercise_schedule_type: Optional[Union[str, "_models.ExerciseScheduleTypeEnum"]] = rest_field(
        name="exerciseScheduleType"
    )
    """The source of the exercise dates of Bermudan options. The possible values are:
     
     
     * FixedLeg: coupon dates of the fixed leg of the underlying swap are used as the swaption
     exercise schedule,
     * FloatLeg: coupon dates of the floating leg of the underlying swap are used as the swaption
     exercise schedule,
     * UserDefined: the exercise schedule to be defined by the user.
     
     The default value is 'FixedLeg'. Known values are: \"FixedLeg\", \"FloatLeg\", and
     \"UserDefined\"."""
    notification_days: Optional[int] = rest_field(name="notificationDays")
    """The number of days the owner of the option has to notify the writer about the option being
     exercised.
     The default value is '0'."""

    @overload
    def __init__(
        self,
        *,
        exercise_schedule: Optional[List[datetime.datetime]] = None,
        exercise_schedule_type: Optional[Union[str, "_models.ExerciseScheduleTypeEnum"]] = None,
        notification_days: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BidAskFieldsDescription(_model_base.Model):
    """BidAskFieldsDescription.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldFormulaDescription
    bid : ~analyticsapi.models.FieldFormulaDescription
    """

    ask: Optional["_models.FieldFormulaDescription"] = rest_field()
    bid: Optional["_models.FieldFormulaDescription"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldFormulaDescription"] = None,
        bid: Optional["_models.FieldFormulaDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BidAskFieldsFormulaDescription(_model_base.Model):
    """BidAskFieldsFormulaDescription.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldDescription
    bid : ~analyticsapi.models.FieldDescription
    """

    ask: Optional["_models.FieldDescription"] = rest_field()
    bid: Optional["_models.FieldDescription"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldDescription"] = None,
        bid: Optional["_models.FieldDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BidAskFieldsFormulaOutput(_model_base.Model):
    """BidAskFieldsFormulaOutput.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldDoubleOutput
    bid : ~analyticsapi.models.FieldDoubleOutput
    market_data_date : ~datetime.date
        Get marketDataDate.
    market_data_time : ~analyticsapi.models.MarketDataTime
    """

    ask: Optional["_models.FieldDoubleOutput"] = rest_field()
    bid: Optional["_models.FieldDoubleOutput"] = rest_field()
    market_data_date: Optional[datetime.date] = rest_field(name="marketDataDate")
    """Get marketDataDate."""
    market_data_time: Optional["_models.MarketDataTime"] = rest_field(name="marketDataTime")

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldDoubleOutput"] = None,
        bid: Optional["_models.FieldDoubleOutput"] = None,
        market_data_date: Optional[datetime.date] = None,
        market_data_time: Optional["_models.MarketDataTime"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BidAskFieldsOutput(_model_base.Model):
    """BidAskFieldsOutput.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldFormulaDoubleOutput
    bid : ~analyticsapi.models.FieldFormulaDoubleOutput
    market_data_date : ~datetime.date
        Get marketDataDate.
    market_data_time : ~analyticsapi.models.MarketDataTime
    """

    ask: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    bid: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    market_data_date: Optional[datetime.date] = rest_field(name="marketDataDate")
    """Get marketDataDate."""
    market_data_time: Optional["_models.MarketDataTime"] = rest_field(name="marketDataTime")

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldFormulaDoubleOutput"] = None,
        bid: Optional["_models.FieldFormulaDoubleOutput"] = None,
        market_data_date: Optional[datetime.date] = None,
        market_data_time: Optional["_models.MarketDataTime"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BidAskFormulaFields(_model_base.Model):
    """BidAskFormulaFields.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldDoubleValue
    bid : ~analyticsapi.models.FieldDoubleValue
    """

    ask: Optional["_models.FieldDoubleValue"] = rest_field()
    bid: Optional["_models.FieldDoubleValue"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldDoubleValue"] = None,
        bid: Optional["_models.FieldDoubleValue"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BidAskMid(_model_base.Model):
    """BidAskMid.

    Attributes
    ----------
    ask : float
    bid : float
    mid : float
    """

    ask: Optional[float] = rest_field()
    bid: Optional[float] = rest_field()
    mid: Optional[float] = rest_field()

    @overload
    def __init__(
        self,
        *,
        ask: Optional[float] = None,
        bid: Optional[float] = None,
        mid: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BidAskMidSimpleValues(_model_base.Model):
    """An object that contains the bid, ask and mid quotes for the instrument.

    Attributes
    ----------
    bid : float
        The bid value.
    ask : float
        The ask value.
    mid : float
        The mid value.
    """

    bid: Optional[float] = rest_field()
    """The bid value."""
    ask: Optional[float] = rest_field()
    """The ask value."""
    mid: Optional[float] = rest_field()
    """The mid value."""

    @overload
    def __init__(
        self,
        *,
        bid: Optional[float] = None,
        ask: Optional[float] = None,
        mid: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BidAskSimpleValues(_model_base.Model):
    """An object that contains the bid, ask quotes for the instrument.

    Attributes
    ----------
    bid : float
        The bid quote.
    ask : float
        The ask quote.
    """

    bid: Optional[float] = rest_field()
    """The bid quote."""
    ask: Optional[float] = rest_field()
    """The ask quote."""

    @overload
    def __init__(
        self,
        *,
        bid: Optional[float] = None,
        ask: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BinaryDefinition(_model_base.Model):
    """An object that defines a binary option that pays an agreed amount if expires in-the-money.

    Attributes
    ----------
    binary_type : str or ~analyticsapi.models.BinaryTypeEnum
        The type of a binary option based on the trigger that activates it.
        Known values are: "OneTouch", "NoTouch", and "Digital".
    level : float
        The price used as a binary option level.
    payout_amount : ~analyticsapi.models.Amount
        The payout amount of a binary option.
    payment_type : str or ~analyticsapi.models.PaymentTypeEnum
        The type of a binary option based on when it is paid out. Known values
        are: "Immediate" and "Deferred".
    """

    binary_type: Optional[Union[str, "_models.BinaryTypeEnum"]] = rest_field(name="binaryType")
    """The type of a binary option based on the trigger that activates it. Known values are:
     \"OneTouch\", \"NoTouch\", and \"Digital\"."""
    level: Optional[float] = rest_field()
    """The price used as a binary option level."""
    payout_amount: Optional["_models.Amount"] = rest_field(name="payoutAmount")
    """The payout amount of a binary option."""
    payment_type: Optional[Union[str, "_models.PaymentTypeEnum"]] = rest_field(name="paymentType")
    """The type of a binary option based on when it is paid out. Known values are: \"Immediate\" and
     \"Deferred\"."""

    @overload
    def __init__(
        self,
        *,
        binary_type: Optional[Union[str, "_models.BinaryTypeEnum"]] = None,
        level: Optional[float] = None,
        payout_amount: Optional["_models.Amount"] = None,
        payment_type: Optional[Union[str, "_models.PaymentTypeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BlackScholesEquityParameters(ModelParameters, discriminator="BlackScholesEquity"):
    """An object that describes the Black-Scholes model parameters applied to the pricing of equity
    options.

    Attributes
    ----------
    type : str or ~analyticsapi.models.BLACK_SCHOLES_EQUITY
        The type of the model used to determine the price of an instrument.
        Restricted to 'BlackScholesEquity'. Required. The Black-Scholes model
        applied to the pricing of equity options.
    volatility : ~analyticsapi.models.MarketVolatility
        An object that describes the volatility parameters.
    dividend : ~analyticsapi.models.Dividend
        An object that describes the dividend parameters.
    risk_free_rate : ~analyticsapi.models.Rate
        An object that describes the discount zero coupon rate used to price an
        instrument based on its currency.
    underlying_price : ~analyticsapi.models.Spot
        An object that describes the price of the underlying asset.
    """

    type: Literal[ModelTypeEnum.BLACK_SCHOLES_EQUITY] = rest_discriminator(name="type")  # type: ignore
    """The type of the model used to determine the price of an instrument. Restricted to
     'BlackScholesEquity'. Required. The Black-Scholes model applied to the pricing of equity
     options."""
    volatility: Optional["_models.MarketVolatility"] = rest_field()
    """An object that describes the volatility parameters."""
    dividend: Optional["_models.Dividend"] = rest_field()
    """An object that describes the dividend parameters."""
    risk_free_rate: Optional["_models.Rate"] = rest_field(name="riskFreeRate")
    """An object that describes the discount zero coupon rate used to price an instrument based on its
     currency."""
    underlying_price: Optional["_models.Spot"] = rest_field(name="underlyingPrice")
    """An object that describes the price of the underlying asset."""

    @overload
    def __init__(
        self,
        *,
        volatility: Optional["_models.MarketVolatility"] = None,
        dividend: Optional["_models.Dividend"] = None,
        risk_free_rate: Optional["_models.Rate"] = None,
        underlying_price: Optional["_models.Spot"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=ModelTypeEnum.BLACK_SCHOLES_EQUITY, **kwargs)


class BlackScholesFxParameters(ModelParameters, discriminator="BlackScholesFx"):
    """An object that describes the Black-Scholes model parameters applied to the pricing of FX
    options.

    Attributes
    ----------
    type : str or ~analyticsapi.models.BLACK_SCHOLES_FX
        The type of the model used to determine the price of an instrument.
        Restricted to 'BlackScholesFx'. Required. The Black-Scholes model
        applied to the pricing of FX options.
    use_fx_forward_curve : bool
        An indicator of whether the FX Forward curve is used to price an
        instrument.
    volatility : ~analyticsapi.models.MarketVolatility
        An object that describes the volatility parameters.
    foreign_risk_free_rate : ~analyticsapi.models.Rate
        An object that describes the risk-free rate used to price an instrument
        based on a foreign currency.
    domestic_risk_free_rate : ~analyticsapi.models.Rate
        An object that describes the risk-free rate used to price an instrument
        based on the domestic currency.
    underlying_price : ~analyticsapi.models.Spot
        An object that describes the price of the underlying asset.
    """

    type: Literal[ModelTypeEnum.BLACK_SCHOLES_FX] = rest_discriminator(name="type")  # type: ignore
    """The type of the model used to determine the price of an instrument. Restricted to
     'BlackScholesFx'. Required. The Black-Scholes model applied to the pricing of FX options."""
    use_fx_forward_curve: Optional[bool] = rest_field(name="useFxForwardCurve")
    """An indicator of whether the FX Forward curve is used to price an instrument."""
    volatility: Optional["_models.MarketVolatility"] = rest_field()
    """An object that describes the volatility parameters."""
    foreign_risk_free_rate: Optional["_models.Rate"] = rest_field(name="foreignRiskFreeRate")
    """An object that describes the risk-free rate used to price an instrument based on a foreign
     currency."""
    domestic_risk_free_rate: Optional["_models.Rate"] = rest_field(name="domesticRiskFreeRate")
    """An object that describes the risk-free rate used to price an instrument based on the domestic
     currency."""
    underlying_price: Optional["_models.Spot"] = rest_field(name="underlyingPrice")
    """An object that describes the price of the underlying asset."""

    @overload
    def __init__(
        self,
        *,
        use_fx_forward_curve: Optional[bool] = None,
        volatility: Optional["_models.MarketVolatility"] = None,
        foreign_risk_free_rate: Optional["_models.Rate"] = None,
        domestic_risk_free_rate: Optional["_models.Rate"] = None,
        underlying_price: Optional["_models.Spot"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=ModelTypeEnum.BLACK_SCHOLES_FX, **kwargs)


class BlackScholesInterestRateFuture(ModelParameters, discriminator="BlackScholesInterestRateFuture"):
    """An object that describes the Black-Scholes model parameters applied to the pricing of interest
    rate futures.

    Attributes
    ----------
    type : str or ~analyticsapi.models.BLACK_SCHOLES_INTEREST_RATE_FUTURE
        The type of the model used to determine the price of an instrument.
        Restricted to 'BlackScholesInterestRateFuture'. Required. The Black-
        Scholes model applied to the pricing of interest rate futures.
    volatility : ~analyticsapi.models.MarketVolatility
        An object that describes the volatility parameters.
    risk_free_rate : ~analyticsapi.models.Rate
        An object that describes the discount zero coupon rate used to price an
        instrument based on its currency.
    underlying_price : ~analyticsapi.models.Spot
        An object that describes the price of the underlying asset.
    """

    type: Literal[ModelTypeEnum.BLACK_SCHOLES_INTEREST_RATE_FUTURE] = rest_discriminator(name="type")  # type: ignore
    """The type of the model used to determine the price of an instrument. Restricted to
     'BlackScholesInterestRateFuture'. Required. The Black-Scholes model applied to the pricing of
     interest rate futures."""
    volatility: Optional["_models.MarketVolatility"] = rest_field()
    """An object that describes the volatility parameters."""
    risk_free_rate: Optional["_models.Rate"] = rest_field(name="riskFreeRate")
    """An object that describes the discount zero coupon rate used to price an instrument based on its
     currency."""
    underlying_price: Optional["_models.Spot"] = rest_field(name="underlyingPrice")
    """An object that describes the price of the underlying asset."""

    @overload
    def __init__(
        self,
        *,
        volatility: Optional["_models.MarketVolatility"] = None,
        risk_free_rate: Optional["_models.Rate"] = None,
        underlying_price: Optional["_models.Spot"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=ModelTypeEnum.BLACK_SCHOLES_INTEREST_RATE_FUTURE, **kwargs)


class BondAnalyticsResponseData(_model_base.Model):
    """BondAnalyticsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.BondDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.BondPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.BondAnalyticsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketDataQps
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.BondDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.BondPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.BondAnalyticsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketDataQps"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.BondDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.BondPricingParameters"] = None,
        analytics: Optional[List["_models.BondAnalyticsResponseWithError"]] = None,
        market_data: Optional["_models.MarketDataQps"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondAnalyticsResponseWithError(_model_base.Model):
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    tabular_data : ~analyticsapi.models.FinancialContractResponse
        Standard Financial Contract Analytics in tabular format.
    cashflows : ~analyticsapi.models.BondCashflows
        Response categorized under Cashflows.
    description : ~analyticsapi.models.BondDescription
        Response categorized under Description.
    effective_measures : ~analyticsapi.models.BondEffectiveMeasures
        Response categorized under Effective measures.
    nominal_measures : ~analyticsapi.models.BondNominalMeasures
        Response categorized under Nominal measures.
    pricing_analysis : ~analyticsapi.models.BondPricingAnalysis
        Response categorized under Pricing analysis.
    spread_measures : ~analyticsapi.models.BondSpreadMeasures
        Response categorized under Spread measures.
    valuation : ~analyticsapi.models.BondValuation
        Response categorized under Valuation.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    tabular_data: Optional["_models.FinancialContractResponse"] = rest_field(name="tabularData")
    """Standard Financial Contract Analytics in tabular format."""
    cashflows: Optional["_models.BondCashflows"] = rest_field()
    """Response categorized under Cashflows."""
    description: Optional["_models.BondDescription"] = rest_field()
    """Response categorized under Description."""
    effective_measures: Optional["_models.BondEffectiveMeasures"] = rest_field(name="effectiveMeasures")
    """Response categorized under Effective measures."""
    nominal_measures: Optional["_models.BondNominalMeasures"] = rest_field(name="nominalMeasures")
    """Response categorized under Nominal measures."""
    pricing_analysis: Optional["_models.BondPricingAnalysis"] = rest_field(name="pricingAnalysis")
    """Response categorized under Pricing analysis."""
    spread_measures: Optional["_models.BondSpreadMeasures"] = rest_field(name="spreadMeasures")
    """Response categorized under Spread measures."""
    valuation: Optional["_models.BondValuation"] = rest_field()
    """Response categorized under Valuation."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        tabular_data: Optional["_models.FinancialContractResponse"] = None,
        cashflows: Optional["_models.BondCashflows"] = None,
        description: Optional["_models.BondDescription"] = None,
        effective_measures: Optional["_models.BondEffectiveMeasures"] = None,
        nominal_measures: Optional["_models.BondNominalMeasures"] = None,
        pricing_analysis: Optional["_models.BondPricingAnalysis"] = None,
        spread_measures: Optional["_models.BondSpreadMeasures"] = None,
        valuation: Optional["_models.BondValuation"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondCalculationResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.BondAnalyticsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.BondAnalyticsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.BondAnalyticsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class BondCashflows(_model_base.Model):
    """Cashflows Object.

    Attributes
    ----------
    normalization_factor : float
        The factor at valuation date for amortizable bonds. It can be defined
        from the remaining notional amount of a bond. For more details on the
        field calculation, please refer here.
    previous_coupon_date : ~datetime.date
        The date of the latest coupon payment preceding the settlement date. If
        the settlement date is before the first regular coupon, then this field
        shows the instrument issue date. The value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., '2021-01-01').
    next_coupon_date : ~datetime.date
        The date of the first coupon payment following the settlement date. If
        the settlement date is after the last regular coupon, then this field
        shows the instrument maturity date. The value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., '2021-01-01').
    previous_ex_dividend_date : ~datetime.date
        The previous date from which the stock (bond) starts trading without
        the value of its dividend (coupon) payment. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    next_ex_dividend_date : ~datetime.date
        The next date from which the stock (bond) starts trading without the
        value of its dividend (coupon) payment. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    previous_record_date : ~datetime.date
        The previous date on which the shareholder must own the share to be
        eligible to receive a dividend. The value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., '2021-01-01'). Available only for preferred
        stocks (  IsPreferred  =  True  ).
    next_record_date : ~datetime.date
        The next date on which the shareholder must own the share to be
        eligible to receive a dividend. The value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., '2021-01-01'). Available only for preferred
        stocks (  IsPreferred  =  True  ).
    next_coupon_value : float
        The next coupon value expressed in bond quotation units (percentage or
        cash).
    next_coupon_in_cash_value : float
        The value of the next coupon paid in cash. The value is expressed in
        bond quotation units (cash). It should be equal to  NextCouponValue
        except for coupon paid in kind.
    next_coupon_in_kind_value : float
        The value of the next coupon paid in kind (PIK). The value is computed
        for PIK bonds. The value is expressed in bond quotation units
        (percentage or cash).
    next_coupon_rate_percent : float
        The annual rate of the next coupon. The coupon may be paid in kind (
        PIK  ) or in cash. The value is expressed in percentages.
    next_coupon_in_cash_rate_percent : float
        The annual rate of the next coupon paid in cash. The value is expressed
        in percentages.
    next_coupon_in_kind_rate_percent : float
        The annual rate of the next coupon paid in kind (  PIK ). The value is
        computed for PIK bonds. The value is expressed in percentages.
    next_sink_date : ~datetime.date
        The next date, when a portion of the sinkable bond would be paid off.
        The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01'). Available only for sinkable bonds.
    cash_flows : list[any]
        The information on the contract's cash flows during its lifetime. It
        consists of the following properties:

        * instrumentType: the instrument type for which cash flows are computed,
        * payments: the array of properties which define all instruments cash flows (paid and received)
        during its lifetime. For more details please refer here.

        For more details on the field calculation, please refer here.  The default value is None, needs
        to be assigned before using.
    cash_flow_dates_array : list[~datetime.date]
        The dates of the future cash flows payments.  The default value is
        None, needs to be assigned before using.
    cash_flow_annual_rates_percent_array : list[float]
        The annual interest rates for each cash flow date. The default value is
        None, needs to be assigned before using.
    cash_flow_amended_annual_rates_percent_array : list[float]
        The annual interest rates for each cash flow date and amended by the
        paying agent. It can differ from  CashFlowAnnualRatesPercentArray ,
        because the paying agent may modify the value of the interest or the
        interest can be partially paid.  The default value is None, needs to be
        assigned before using.
    cash_flow_interest_percents_array : list[float]
        The interest payments for each cash flow date. The values are expressed
        in percentages of the instrument notional value.  The default value is
        None, needs to be assigned before using.
    cash_flow_capital_percents_array : list[float]
        The principal payments for each cash flow date. The values are
        expressed in the percentages of the instrument notional value.  The
        default value is None, needs to be assigned before using.
    cash_flow_total_percents_array : list[float]
        The total (interest + principal) payments for each cash flow date. The
        values are expressed in the percentages of the instrument notional
        value.  The default value is None, needs to be assigned before using.
    cash_flow_normalization_factors_array : list[float]
        The normalization factors for an amortizable instrument. The
        normalization factor is equal to  1  at the issue date.  The default
        value is None, needs to be assigned before using.
    """

    normalization_factor: Optional[float] = rest_field(name="normalizationFactor")
    """The factor at valuation date for amortizable bonds. It can be defined from the remaining
     notional amount of a bond.
     For more details on the field calculation, please refer here."""
    previous_coupon_date: Optional[datetime.date] = rest_field(name="previousCouponDate")
    """The date of the latest coupon payment preceding the settlement date. If the settlement date is
     before the first regular coupon, then this field shows the instrument issue date. The value is
     expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    next_coupon_date: Optional[datetime.date] = rest_field(name="nextCouponDate")
    """The date of the first coupon payment following the settlement date. If the settlement date is
     after the last regular coupon, then this field shows the instrument maturity date. The value is
     expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    previous_ex_dividend_date: Optional[datetime.date] = rest_field(name="previousExDividendDate")
    """The previous date from which the stock (bond) starts trading without the value of its dividend
     (coupon) payment. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    next_ex_dividend_date: Optional[datetime.date] = rest_field(name="nextExDividendDate")
    """The next date from which the stock (bond) starts trading without the value of its dividend
     (coupon) payment. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    previous_record_date: Optional[datetime.date] = rest_field(name="previousRecordDate")
    """The previous date on which the shareholder must own the share to be eligible to receive a
     dividend. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Available
     only for preferred stocks (  IsPreferred  =  True  )."""
    next_record_date: Optional[datetime.date] = rest_field(name="nextRecordDate")
    """The next date on which the shareholder must own the share to be eligible to receive a dividend.
     The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Available only for
     preferred stocks (  IsPreferred  =  True  )."""
    next_coupon_value: Optional[float] = rest_field(name="nextCouponValue")
    """The next coupon value expressed in bond quotation units (percentage or cash)."""
    next_coupon_in_cash_value: Optional[float] = rest_field(name="nextCouponInCashValue")
    """The value of the next coupon paid in cash. The value is expressed in bond quotation units
     (cash). It should be equal to  NextCouponValue  except for coupon paid in kind."""
    next_coupon_in_kind_value: Optional[float] = rest_field(name="nextCouponInKindValue")
    """The value of the next coupon paid in kind (PIK). The value is computed for PIK bonds. The value
     is expressed in bond quotation units (percentage or cash)."""
    next_coupon_rate_percent: Optional[float] = rest_field(name="nextCouponRatePercent")
    """The annual rate of the next coupon. The coupon may be paid in kind (  PIK  ) or in cash. The
     value is expressed in percentages."""
    next_coupon_in_cash_rate_percent: Optional[float] = rest_field(name="nextCouponInCashRatePercent")
    """The annual rate of the next coupon paid in cash. The value is expressed in percentages."""
    next_coupon_in_kind_rate_percent: Optional[float] = rest_field(name="nextCouponInKindRatePercent")
    """The annual rate of the next coupon paid in kind (  PIK  ). The value is computed for PIK bonds.
     The value is expressed in percentages."""
    next_sink_date: Optional[datetime.date] = rest_field(name="nextSinkDate")
    """The next date, when a portion of the sinkable bond would be paid off. The value is expressed in
     ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Available only for sinkable bonds."""
    cash_flows: Optional[List[Any]] = rest_field(name="cashFlows")
    """The information on the contract's cash flows during its lifetime. It consists of the following
     properties:
     
     
     * instrumentType: the instrument type for which cash flows are computed,
     * payments: the array of properties which define all instruments cash flows (paid and received)
     during its lifetime. For more details please refer here.
     
     For more details on the field calculation, please refer here."""
    cash_flow_dates_array: Optional[List[datetime.date]] = rest_field(name="cashFlowDatesArray")
    """The dates of the future cash flows payments."""
    cash_flow_annual_rates_percent_array: Optional[List[float]] = rest_field(name="cashFlowAnnualRatesPercentArray")
    """The annual interest rates for each cash flow date."""
    cash_flow_amended_annual_rates_percent_array: Optional[List[float]] = rest_field(
        name="cashFlowAmendedAnnualRatesPercentArray"
    )
    """The annual interest rates for each cash flow date and amended by the paying agent. It can
     differ from  CashFlowAnnualRatesPercentArray  , because the paying agent may modify the value
     of the interest or the interest can be partially paid."""
    cash_flow_interest_percents_array: Optional[List[float]] = rest_field(name="cashFlowInterestPercentsArray")
    """The interest payments for each cash flow date. The values are expressed in percentages of the
     instrument notional value."""
    cash_flow_capital_percents_array: Optional[List[float]] = rest_field(name="cashFlowCapitalPercentsArray")
    """The principal payments for each cash flow date. The values are expressed in the percentages of
     the instrument notional value."""
    cash_flow_total_percents_array: Optional[List[float]] = rest_field(name="cashFlowTotalPercentsArray")
    """The total (interest + principal) payments for each cash flow date. The values are expressed in
     the percentages of the instrument notional value."""
    cash_flow_normalization_factors_array: Optional[List[float]] = rest_field(name="cashFlowNormalizationFactorsArray")
    """The normalization factors for an amortizable instrument. The normalization factor is equal to
     1  at the issue date."""

    @overload
    def __init__(
        self,
        *,
        normalization_factor: Optional[float] = None,
        previous_coupon_date: Optional[datetime.date] = None,
        next_coupon_date: Optional[datetime.date] = None,
        previous_ex_dividend_date: Optional[datetime.date] = None,
        next_ex_dividend_date: Optional[datetime.date] = None,
        previous_record_date: Optional[datetime.date] = None,
        next_record_date: Optional[datetime.date] = None,
        next_coupon_value: Optional[float] = None,
        next_coupon_in_cash_value: Optional[float] = None,
        next_coupon_in_kind_value: Optional[float] = None,
        next_coupon_rate_percent: Optional[float] = None,
        next_coupon_in_cash_rate_percent: Optional[float] = None,
        next_coupon_in_kind_rate_percent: Optional[float] = None,
        next_sink_date: Optional[datetime.date] = None,
        cash_flows: Optional[List[Any]] = None,
        cash_flow_dates_array: Optional[List[datetime.date]] = None,
        cash_flow_annual_rates_percent_array: Optional[List[float]] = None,
        cash_flow_amended_annual_rates_percent_array: Optional[List[float]] = None,
        cash_flow_interest_percents_array: Optional[List[float]] = None,
        cash_flow_capital_percents_array: Optional[List[float]] = None,
        cash_flow_total_percents_array: Optional[List[float]] = None,
        cash_flow_normalization_factors_array: Optional[List[float]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondDefinition(_model_base.Model):
    """Contains the user input data for the bond.

    Attributes
    ----------
    accrued_calculation_method : str or ~analyticsapi.models.AccruedCalculationMethodEnum
        The day count basis method used to calculate the accrued interest
        payments (e.g. Dcb_30_360, Dcb_30_Actual). If instrumentCode is
        defined, the value comes from the instrument reference data. In case of
        a user-defined instrument, interestCalculationMethod is used. Known
        values are: "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German",
        "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
        "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual",
        "Dcb_30_Actual_ISDA", "Dcb_30E_360_ISMA", "Dcb_Actual_360",
        "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
        "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB",
        "Dcb_WorkingDays_252", "Dcb_Actual_365L", "Dcb_Actual_365P",
        "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525",
        "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
    adjust_interest_to_payment_date : str or ~analyticsapi.models.AdjustInterestToPaymentDateEnum
        An indication if the coupon dates are adjusted to the payment dates.
        The possible values are: Adjusted, Unadjusted. If instrumentCode is
        defined, the value comes from the instrument reference data.

        * For Swap: In case of a user-defined instrument, the default value is 'Adjusted'.
        * For Bond and Loan: In case of a user-defined instrument, the default value is 'Unadjusted'.
        Known values are: "Unadjusted" and "Adjusted".
    amortization_schedule : list[~analyticsapi.models.AmortizationItemDefinition]
        The amortization schedule of the instrument. It contains the following
        information: startDate, endDate, remainingNotional,
        amortizationFrequency, amount, amortizationType. Optional. No default
        value applies.  The default value is None, needs to be assigned before
        using.
    cap_strike_percent : float
        The contractual strike rate of the cap. The value is expressed in
        percentages. If this parameter is set, the cap will apply to the leg
        with the same parameters set in the swapLegDefinition (e.g.maturity,
        frequency, index, discounting rule). No default value applies.

        * For Bond and Loan: Not applicable.
    direction : str or ~analyticsapi.models.IPADirectionEnum
        The indication whether the cash flows of the instrument's leg are paid
        or received. Mandatory if instrumentCode or template is not defined. If
        instrumentCode or template is defined, the value comes from the
        instrument reference data. The possible values are:

        * For Swap:
          Paid: the cash flows are paid to the counterparty,
          Received: the cash flows are received from the counterparty.
        * For CDS:
          Paid: the fixed payments are paid by the counterparty (applied to the CDS buyer),
          Received: the fixed payments are received from the counterparty (applied to the CDS seller).
        * For Bond and Loan: Not applicable. Known values are: "Paid" and "Received".
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). Optional. If instrumentCode is not defined,
        and IsPerpetual is set to 'False', either endDate or endTenor must be
        provided. If instrumentCode is defined, the value comes from the
        instrument reference data.
    end_tenor : str
        In case no endDate value has been provided, the code indicating the
        period to compute endDate from issueDate (e.g. '1M'). No default value
        applies.
    first_accrual_date : ~datetime.datetime
        The date from which the interest starts accruing. The value is
        expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). Optional. If instrumentCode is defined, the
        value comes from the instrument reference data. In case of a user-
        defined instrument, the default value is the issue date.
    first_regular_payment_date : ~datetime.datetime
        The first regular interest payment date used for the odd first interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).

        * For Swap: No default value applies.
        * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
        stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
        instrument reference data.
        * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency.
    fixed_rate_percent : float
        The interest rate used to derive future fixed interest payments of the
        instrument. The value is expressed in percentages. Either
        fixedRatePercent or fixedRatePercentSchedule is used. In Swap, applies
        to fixed leg only. If instrumentCode is defined, the value comes from
        the instrument reference data. In case of a user-defined instrument,
        the default value is '0' for Bond, par rate for Swap and '1' for CDS.
        For Loan: Mandatory for a fixed rate loan. No default value applies.
    floor_strike_percent : float
        The contractual strike rate of the floor. The value is expressed in
        percentages. If this parameter is set, the floor will apply to the leg
        with the same parameters set in the swapLegDefinition (e.g.maturity,
        frequency, index, discounting rule). No default value applies.

        * For Bond and Loan: Not applicable.
    index_average_method : str or ~analyticsapi.models.IndexAverageMethodEnum
        The method of calculating the average index value. The possible values
        are: CompoundedActual, DailyCompoundedAverage, CompoundedAverageRate,
        ArithmeticAverage The default value depends on the index default
        convention.

        * For Bond and Loan: Not applicable. Known values are: "CompoundedActual",
        "DailyCompoundedAverage", "CompoundedAverageRate", and "ArithmeticAverage".
    index_compounding_method : str or ~analyticsapi.models.IndexCompoundingMethodEnum
        The method how the interest rate is calculated from the reset floating
        rates when the reset frequency is higher than the interest payment
        frequency (e.g. daily index reset with quarterly interest payments).
        The possible values are: Compounded, Average, Constant,
        AdjustedCompounded, MexicanCompounded. Optional.

        * For Bond and Loan: If instrumentCode is defined, the value comes from the instrument
        reference data. In case of a user-defined instrument, the default value is 'Constant'.
        * For Swap: The default value is defined by the market conventions of the index defined for the
        floating leg. Known values are: "Compounded", "AdjustedCompounded", "MexicanCompounded",
        "Average", and "Constant".
    index_fixing_lag : int
        The number of working days between the fixing date of the index and the
        start of the interest accrual period ('InAdvance') or the end of the
        interest accrual period ('InArrears').

        * For Swap: The InAdvance/InArrears mode is set in the indexResetType parameter. The default
        value is the fixing lag associated to the index defined/determined by default on the floating
        leg.
        * For Bond and Loan: In case of a user-defined instrument, the default value is 0. If
        instrumentCode is defined, the value comes from the instrument reference data.
    index_fixing_ric : str
        The RIC that carries the fixing value if the instrument has a floating
        interest.

        * For Swap: Optional. The default value depends on the notional currency.
        * For Bond and Loan: Mandatory for floating rate instruments if no instrumentCode is defined.
        If instrumentCode is defined, the value comes from the instrument reference data.
    index_lockout_period : int
        The period from the start date (inclusive) of the index lockout to the
        end date of the interest calculation period for which the reference
        rate is no longer updated. During this period the index of the day
        preceding the start date of the lockout period is applied to the
        remaining days of the interest period. The value is expressed in
        working days. Please note, that by (ISDA) definition the lockout method
        is applied only to payment periods (with Fixing) and not to future
        periods (with ZcCurve). Optional. The default value is 0.
    index_observation_method : str or ~analyticsapi.models.IPAIndexObservationMethodEnum
        (RFR) Method for determining the accrual observation period. The lag is
        defined using the indexFixingLag property. The possible values are:
        Lookback: use the interest period for both rate accrual and interest
        payment. PeriodShift: use the observation period for both rate accrual
        and interest payment. Mixed: use the observation period for rate
        accrual and the interest period for interest payment. Optional. No
        default value applies.

        * For Bond and Loan: Not applicable. Known values are: "Lookback", "PeriodShift", and "Mixed".
    index_reset_frequency : str or ~analyticsapi.models.IndexResetFrequencyEnum
        The reset frequency for the floating instrument (e.g. Annual,
        SemiAnnual).

        * For Swap: The default value is interestPaymentFrequency. For RFR index, the default value is
        EveryWorkingDay.
        * For Bond: If instrumentCode is defined, the value comes from the instrument reference data.
        In case of a user-defined instrument, the default value is derived from the index tenor.
        * For Loan: The default value is interestPaymentFrequency. Known values are: "Annual",
        "SemiAnnual", "Quarterly", "Monthly", "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every91Days", "Every182Days", "Every364Days",
        "Every365Days", "Every90Days", "Every92Days", "Every93Days", "Every180Days", "Every183Days",
        "Every184Days", "Every4Months", "R2", "R4", "Zero", and "Scheduled".
    instrument_code : str
        The code used to define the instrument. The possible values for each
        asset type are:

        * Bond: ISIN, RIC, CUSIP,
        * BondFuture: RIC,
        * InterestRateSwap: RIC,
        * Cds: RIC.

        Optional. Mandatory if no user-defined instrument data is provided. No default value applies.
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported. Optional. No default value applies.
    interest_calculation_method : str or ~analyticsapi.models.InterestCalculationMethodEnum
        The day count basis method used to calculate the interest payments(e.g.
        Dcb_30_360, Dcb_30_Actual).

        * For Swap: The default value is selected based on notionalCcy.
        * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
        comes from the instrument reference data.
        * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
        Otherwise, the default value is 'Dcb_Actual_360'.
        * For Loan: Mandatory. No default value applies. Known values are: "Dcb_30_360",
        "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA",
        "Dcb_30_365_German", "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual",
        "Dcb_30_Actual_ISDA", "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365",
        "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252",
        "Dcb_Actual_365L", "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
    interest_payment_delay : int
        The number of working days between the end of the interest accrual
        period and the interest payment date. If instrumentCode is defined, the
        value comes from the instrument reference data. In case of a user-
        defined instrument, the default value is '0'.
    interest_payment_frequency : str or ~analyticsapi.models.InterestPaymentFrequencyEnum
        The interest payment frequency.

        * For Swap: Either indexResetFrequency or InterestPaymentFrequency must be provided (e.g.
        Annual, SemiAnnual). The default value is indexResetFrequency.
        * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
        comes from the instrument reference data.
        * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
        Otherwise, the default value is 'Quaterly'.
        * For Loan: Mandatory. No default value applies. Known values are: "Annual", "SemiAnnual",
        "Quarterly", "Monthly", "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every91Days", "Every182Days", "Every364Days",
        "Every365Days", "Every90Days", "Every92Days", "Every93Days", "Every180Days", "Every183Days",
        "Every184Days", "Every4Months", "R2", "R4", "Zero", and "Scheduled".
    interest_type : str or ~analyticsapi.models.InterestTypeEnum
        An indicator whether the instrument pays a fixed or floating interest.
        The possible values are:

        * Fixed,
        * Float.

        For Swap: No default value applies. Mandatory for SwapLegDefinition.
        For Bond: Optional. If instrumentCode is defined, the value comes from the instrument reference
        data. Otherwise, the default value is 'Fixed'.
        For Loan: Mandatory. No default value applies. Known values are: "Fixed", "Float", and
        "Stepped".
    is_perpetual : bool
        An indicator whether the instrument is perpetual or not:

        * True: perpetual,
        * False: not perpetual.

        Optional. If instrumentCode is defined, the value comes from the instrument reference data. In
        case of a user-defined instrument, default value is 'False'.
    issue_date : ~datetime.datetime
        The date when the issue was registered. The value is expressed in ISO
        8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
        Optional. If instrumentCode is not defined, either issueDate or
        startTenor must be provided. If instrumentCode is defined, the value
        comes from the instrument reference data.
    last_regular_payment_date : ~datetime.datetime
        The last regular interest payment date used for the odd last interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).

        * For Swap: No default value applies.
        * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
        stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
        instrument reference data.
        * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency.
    notional_amount : float
        The notional amount of the instrument. Optional. The default value is
        '1,000,000'. For CDS: the amounts for the premium and protection legs
        must be equal.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g. 'USD'). If
        instrumentCode is defined, the value comes from the instrument
        reference data.

        * For Swap: Mandatory for SwapLegDefinition if instrumentCode is not defined.
        * For CDS: Mandatory for protectionLeg definition if instrumentCode is not defined. For
        premiumLeg definition, it is derived from pretctionLeg definition.
        * For Bond and Loan: Mandatory if no instrumentCode is defined.
    payment_business_day_convention : str or ~analyticsapi.models.PaymentBusinessDayConventionEnum
        The method to adjust dates to working days. The possible values are:
        PreviousBusinessDay, NextBusinessDay, Modified following, NoMoving,
        BBSWModifiedFollowing. If instrumentCode is defined, the value comes
        from the instrument reference data. In case of a user-defined
        instrument, the default value is 'ModifiedFollowing'. Known values are:
        "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay",
        "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing".
    payment_business_days : str
        A list of comma-separated calendar codes to adjust dates (e.g. 'EMU' or
        'USA').

        * For Swap: The default value is the calendar associated to the market conventions of the
        InterestPaymentCcy for the corresponding leg.
        * For Bond and Loan: The default value is the calendar associated to NotionalCcy.
    payment_roll_convention : str or ~analyticsapi.models.PaymentRollConventionEnum
        The method to adjust payment dates when they fall at the end of the
        month (e.g. 28th of February, 30th, 31st). Optional. If instrumentCode
        is defined, the value comes from the instrument reference data. In case
        of a user-defined instrument, default value is 'Same'. Known values
        are: "Last", "Same", "Same1", "Last28", and "Same28".
    spread_bp : float
        The spread applied to the floating interest rate of the instrument. The
        value is expressed in basis points. Optional. If instrumentCode is
        defined, the value comes from the instrument reference data. In case of
        a user-defined instrument, the default value is '0'.
    start_tenor : str
        In case no IssueDate value has been provided, the code indicating the
        period to compute issueDate from valuationDate (e.g. '1M'). No default
        value applies.
    stub_rule : str or ~analyticsapi.models.FinancialContractStubRuleEnum
        The rule that defines whether coupon roll dates are aligned to the
        maturity or issue date. The possible values are: Issue, Maturity,
        ShortFirstProRata, ShortFirstFull, LongFirstFull, ShortLastProRata. If
        instrumentCode is defined, the value comes from the instrument
        reference data. In case of a user-defined instrument, the default value
        is 'Maturity'. Known values are: "Issue", "Maturity",
        "ShortFirstProRata", "ShortFirstFull", "LongFirstFull", and
        "ShortLastProRata".
    template : str
        A reference to a style used to define the instrument. Either
        instrumentCode, template, or full definition must be provided.
        Optional. By default, template is filled from the instrument structure.
    """

    accrued_calculation_method: Optional[Union[str, "_models.AccruedCalculationMethodEnum"]] = rest_field(
        name="accruedCalculationMethod"
    )
    """The day count basis method used to calculate the accrued interest payments (e.g. Dcb_30_360,
     Dcb_30_Actual).
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, interestCalculationMethod is used. Known values are: \"Dcb_30_360\",
     \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\",
     \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\",
     \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\",
     \"Dcb_Actual_365_CanadianConvention\", and \"Dcb_Constant\"."""
    adjust_interest_to_payment_date: Optional[Union[str, "_models.AdjustInterestToPaymentDateEnum"]] = rest_field(
        name="adjustInterestToPaymentDate"
    )
    """An indication if the coupon dates are adjusted to the payment dates. The possible values are:
     Adjusted,
     Unadjusted.
     If instrumentCode is defined, the value comes from the instrument reference data.
     
     
     * For Swap: In case of a user-defined instrument, the default value is 'Adjusted'.
     * For Bond and Loan: In case of a user-defined instrument, the default value is 'Unadjusted'.
     Known values are: \"Unadjusted\" and \"Adjusted\"."""
    amortization_schedule: Optional[List["_models.AmortizationItemDefinition"]] = rest_field(
        name="amortizationSchedule"
    )
    """The amortization schedule of the instrument. It contains the following information:
     startDate,
     endDate,
     remainingNotional,
     amortizationFrequency,
     amount,
     amortizationType.
     Optional. No default value applies."""
    cap_strike_percent: Optional[float] = rest_field(name="capStrikePercent")
    """The contractual strike rate of the cap. The value is expressed in percentages.
     If this parameter is set, the cap will apply to the leg with the same parameters set in the
     swapLegDefinition (e.g.maturity, frequency, index, discounting rule).
     No default value applies.
     
     
     * For Bond and Loan: Not applicable."""
    direction: Optional[Union[str, "_models.IPADirectionEnum"]] = rest_field()
    """The indication whether the cash flows of the instrument's leg are paid or received.
     Mandatory if instrumentCode or template is not defined. If instrumentCode or template is
     defined, the value comes from the instrument reference data.
     The possible values are:
     
     
     * For Swap:
       Paid: the cash flows are paid to the counterparty,
       Received: the cash flows are received from the counterparty.
     * For CDS:
       Paid: the fixed payments are paid by the counterparty (applied to the CDS buyer),
       Received: the fixed payments are received from the counterparty (applied to the CDS seller).
     * For Bond and Loan: Not applicable. Known values are: \"Paid\" and \"Received\"."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     Optional.
     If instrumentCode is not defined, and IsPerpetual is set to 'False', either endDate or endTenor
     must be provided.
     If instrumentCode is defined, the value comes from the instrument reference data."""
    end_tenor: Optional[str] = rest_field(name="endTenor")
    """In case no endDate value has been provided, the code indicating the period to compute endDate
     from issueDate (e.g. '1M').
     No default value applies."""
    first_accrual_date: Optional[datetime.datetime] = rest_field(name="firstAccrualDate", format="rfc3339")
    """The date from which the interest starts accruing. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     Optional. If instrumentCode is defined, the value comes from the instrument reference data. In
     case of a user-defined instrument, the default value is the issue date."""
    first_regular_payment_date: Optional[datetime.datetime] = rest_field(
        name="firstRegularPaymentDate", format="rfc3339"
    )
    """The first regular interest payment date used for the odd first interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
     
     
     * For Swap: No default value applies.
     * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
     stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
     instrument reference data.
     * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency."""
    fixed_rate_percent: Optional[float] = rest_field(name="fixedRatePercent")
    """The interest rate used to derive future fixed interest payments of the instrument. The value is
     expressed in percentages. Either fixedRatePercent or fixedRatePercentSchedule is used.
     In Swap, applies to fixed leg only.
     If instrumentCode is defined, the value comes from the instrument reference data.
     In case of a user-defined instrument, the default value is '0' for Bond, par rate for Swap and
     '1' for CDS.
     For Loan: Mandatory for a fixed rate loan. No default value applies."""
    floor_strike_percent: Optional[float] = rest_field(name="floorStrikePercent")
    """The contractual strike rate of the floor. The value is expressed in percentages.
     If this parameter is set, the floor will apply to the leg with the same parameters set in the
     swapLegDefinition (e.g.maturity, frequency, index, discounting rule).
     No default value applies.
     
     
     * For Bond and Loan: Not applicable."""
    index_average_method: Optional[Union[str, "_models.IndexAverageMethodEnum"]] = rest_field(name="indexAverageMethod")
    """The method of calculating the average index value. The possible values are:
     CompoundedActual,
     DailyCompoundedAverage,
     CompoundedAverageRate,
     ArithmeticAverage
     The default value depends on the index default convention.
     
     
     * For Bond and Loan: Not applicable. Known values are: \"CompoundedActual\",
     \"DailyCompoundedAverage\", \"CompoundedAverageRate\", and \"ArithmeticAverage\"."""
    index_compounding_method: Optional[Union[str, "_models.IndexCompoundingMethodEnum"]] = rest_field(
        name="indexCompoundingMethod"
    )
    """The method how the interest rate is calculated from the reset floating rates when the reset
     frequency is higher than the interest payment frequency (e.g. daily index reset with quarterly
     interest payments). The possible values are:
     Compounded,
     Average,
     Constant,
     AdjustedCompounded,
     MexicanCompounded.
     Optional.
     
     
     * For Bond and Loan: If instrumentCode is defined, the value comes from the instrument
     reference data. In case of a user-defined instrument, the default value is 'Constant'.
     * For Swap: The default value is defined by the market conventions of the index defined for the
     floating leg. Known values are: \"Compounded\", \"AdjustedCompounded\", \"MexicanCompounded\",
     \"Average\", and \"Constant\"."""
    index_fixing_lag: Optional[int] = rest_field(name="indexFixingLag")
    """The number of working days between the fixing date of the index and the start of the interest
     accrual period ('InAdvance') or the end of the interest accrual period ('InArrears').
     
     
     * For Swap: The InAdvance/InArrears mode is set in the indexResetType parameter. The default
     value is the fixing lag associated to the index defined/determined by default on the floating
     leg.
     * For Bond and Loan: In case of a user-defined instrument, the default value is 0. If
     instrumentCode is defined, the value comes from the instrument reference data."""
    index_fixing_ric: Optional[str] = rest_field(name="indexFixingRic")
    """The RIC that carries the fixing value if the instrument has a floating interest.
     
     
     * For Swap: Optional. The default value depends on the notional currency.
     * For Bond and Loan: Mandatory for floating rate instruments if no instrumentCode is defined.
     If instrumentCode is defined, the value comes from the instrument reference data."""
    index_lockout_period: Optional[int] = rest_field(name="indexLockoutPeriod")
    """The period from the start date (inclusive) of the index lockout to the end date of the interest
     calculation period for which the reference rate is no longer updated.
     During this period the index of the day preceding the start date of the lockout period is
     applied to the remaining days of the interest period. The value is expressed in working days.
     Please note, that by (ISDA) definition the lockout method is applied only to payment periods
     (with Fixing) and not to future periods (with ZcCurve).
     Optional. The default value is 0."""
    index_observation_method: Optional[Union[str, "_models.IPAIndexObservationMethodEnum"]] = rest_field(
        name="indexObservationMethod"
    )
    """(RFR) Method for determining the accrual observation period. The lag is defined using the
     indexFixingLag property. The possible values are:
     Lookback: use the interest period for both rate accrual and interest payment.
     PeriodShift: use the observation period for both rate accrual and interest payment.
     Mixed: use the observation period for rate accrual and the interest period for interest
     payment.
     Optional. No default value applies.
     
     
     * For Bond and Loan: Not applicable. Known values are: \"Lookback\", \"PeriodShift\", and
     \"Mixed\"."""
    index_reset_frequency: Optional[Union[str, "_models.IndexResetFrequencyEnum"]] = rest_field(
        name="indexResetFrequency"
    )
    """The reset frequency for the floating instrument (e.g. Annual, SemiAnnual).
     
     
     * For Swap: The default value is interestPaymentFrequency. For RFR index, the default value is
     EveryWorkingDay.
     * For Bond: If instrumentCode is defined, the value comes from the instrument reference data.
     In case of a user-defined instrument, the default value is derived from the index tenor.
     * For Loan: The default value is interestPaymentFrequency. Known values are: \"Annual\",
     \"SemiAnnual\", \"Quarterly\", \"Monthly\", \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\",
     \"Every7Days\", \"Every14Days\", \"Every28Days\", \"Every30Days\", \"Every91Days\",
     \"Every182Days\", \"Every364Days\", \"Every365Days\", \"Every90Days\", \"Every92Days\",
     \"Every93Days\", \"Every180Days\", \"Every183Days\", \"Every184Days\", \"Every4Months\",
     \"R2\", \"R4\", \"Zero\", and \"Scheduled\"."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument. The possible values for each asset type are:
     
     
     * Bond: ISIN, RIC, CUSIP,
     * BondFuture: RIC,
     * InterestRateSwap: RIC,
     * Cds: RIC.
     
     Optional. Mandatory if no user-defined instrument data is provided. No default value applies."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported.
     Optional. No default value applies."""
    interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = rest_field(
        name="interestCalculationMethod"
    )
    """The day count basis method used to calculate the interest payments(e.g. Dcb_30_360,
     Dcb_30_Actual).
     
     
     * For Swap: The default value is selected based on notionalCcy.
     * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
     comes from the instrument reference data.
     * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
     Otherwise, the default value is 'Dcb_Actual_360'.
     * For Loan: Mandatory. No default value applies. Known values are: \"Dcb_30_360\",
     \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\",
     \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\",
     \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\",
     \"Dcb_Actual_365_CanadianConvention\", and \"Dcb_Constant\"."""
    interest_payment_delay: Optional[int] = rest_field(name="interestPaymentDelay")
    """The number of working days between the end of the interest accrual period and the interest
     payment date.
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, the default value is '0'."""
    interest_payment_frequency: Optional[Union[str, "_models.InterestPaymentFrequencyEnum"]] = rest_field(
        name="interestPaymentFrequency"
    )
    """The interest payment frequency.
     
     
     * For Swap: Either indexResetFrequency or InterestPaymentFrequency must be provided (e.g.
     Annual, SemiAnnual). The default value is indexResetFrequency.
     * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
     comes from the instrument reference data.
     * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
     Otherwise, the default value is 'Quaterly'.
     * For Loan: Mandatory. No default value applies. Known values are: \"Annual\", \"SemiAnnual\",
     \"Quarterly\", \"Monthly\", \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\", \"Every7Days\",
     \"Every14Days\", \"Every28Days\", \"Every30Days\", \"Every91Days\", \"Every182Days\",
     \"Every364Days\", \"Every365Days\", \"Every90Days\", \"Every92Days\", \"Every93Days\",
     \"Every180Days\", \"Every183Days\", \"Every184Days\", \"Every4Months\", \"R2\", \"R4\",
     \"Zero\", and \"Scheduled\"."""
    interest_type: Optional[Union[str, "_models.InterestTypeEnum"]] = rest_field(name="interestType")
    """An indicator whether the instrument pays a fixed or floating interest. The possible values are:
     
     
     * Fixed,
     * Float.
     
     For Swap: No default value applies. Mandatory for SwapLegDefinition.
     For Bond: Optional. If instrumentCode is defined, the value comes from the instrument reference
     data. Otherwise, the default value is 'Fixed'.
     For Loan: Mandatory. No default value applies. Known values are: \"Fixed\", \"Float\", and
     \"Stepped\"."""
    is_perpetual: Optional[bool] = rest_field(name="isPerpetual")
    """An indicator whether the instrument is perpetual or not:
     
     
     * True: perpetual,
     * False: not perpetual.
     
     Optional. If instrumentCode is defined, the value comes from the instrument reference data. In
     case of a user-defined instrument, default value is 'False'."""
    issue_date: Optional[datetime.datetime] = rest_field(name="issueDate", format="rfc3339")
    """The date when the issue was registered. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     Optional.
     If instrumentCode is not defined, either issueDate or startTenor must be provided.
     If instrumentCode is defined, the value comes from the instrument reference data."""
    last_regular_payment_date: Optional[datetime.datetime] = rest_field(name="lastRegularPaymentDate", format="rfc3339")
    """The last regular interest payment date used for the odd last interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
     
     
     * For Swap: No default value applies.
     * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
     stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
     instrument reference data.
     * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument.
     Optional. The default value is '1,000,000'.
     For CDS: the amounts for the premium and protection legs must be equal."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g. 'USD').
     If instrumentCode is defined, the value comes from the instrument reference data.
     
     
     * For Swap: Mandatory for SwapLegDefinition if instrumentCode is not defined.
     * For CDS: Mandatory for protectionLeg definition if instrumentCode is not defined. For
     premiumLeg definition, it is derived from pretctionLeg definition.
     * For Bond and Loan: Mandatory if no instrumentCode is defined."""
    payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = rest_field(
        name="paymentBusinessDayConvention"
    )
    """The method to adjust dates to working days. The possible values are:
     PreviousBusinessDay,
     NextBusinessDay,
     Modified following,
     NoMoving,
     BBSWModifiedFollowing.
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, the default value is 'ModifiedFollowing'. Known values are:
     \"ModifiedFollowing\", \"NextBusinessDay\", \"PreviousBusinessDay\", \"NoMoving\",
     \"EveryThirdWednesday\", and \"BbswModifiedFollowing\"."""
    payment_business_days: Optional[str] = rest_field(name="paymentBusinessDays")
    """A list of comma-separated calendar codes to adjust dates (e.g. 'EMU' or 'USA').
     
     
     * For Swap: The default value is the calendar associated to the market conventions of the
     InterestPaymentCcy for the corresponding leg.
     * For Bond and Loan: The default value is the calendar associated to NotionalCcy."""
    payment_roll_convention: Optional[Union[str, "_models.PaymentRollConventionEnum"]] = rest_field(
        name="paymentRollConvention"
    )
    """The method to adjust payment dates when they fall at the end of the month (e.g. 28th of
     February, 30th, 31st).
     Optional. If instrumentCode is defined, the value comes from the instrument reference data. In
     case of a user-defined instrument, default value is 'Same'. Known values are: \"Last\",
     \"Same\", \"Same1\", \"Last28\", and \"Same28\"."""
    spread_bp: Optional[float] = rest_field(name="spreadBp")
    """The spread applied to the floating interest rate of the instrument. The value is expressed in
     basis points.
     Optional. If instrumentCode is defined, the value comes from the instrument reference data. In
     case of a user-defined instrument, the default value is '0'."""
    start_tenor: Optional[str] = rest_field(name="startTenor")
    """In case no IssueDate value has been provided, the code indicating the period to compute
     issueDate from valuationDate (e.g. '1M').
     No default value applies."""
    stub_rule: Optional[Union[str, "_models.FinancialContractStubRuleEnum"]] = rest_field(name="stubRule")
    """The rule that defines whether coupon roll dates are aligned to the maturity or issue date. The
     possible values are:
     Issue,
     Maturity,
     ShortFirstProRata,
     ShortFirstFull,
     LongFirstFull,
     ShortLastProRata.
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, the default value is 'Maturity'. Known values are: \"Issue\",
     \"Maturity\", \"ShortFirstProRata\", \"ShortFirstFull\", \"LongFirstFull\", and
     \"ShortLastProRata\"."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument.
     Either instrumentCode, template, or full definition must be provided. Optional. By default,
     template is filled from the instrument structure."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        accrued_calculation_method: Optional[Union[str, "_models.AccruedCalculationMethodEnum"]] = None,
        adjust_interest_to_payment_date: Optional[Union[str, "_models.AdjustInterestToPaymentDateEnum"]] = None,
        amortization_schedule: Optional[List["_models.AmortizationItemDefinition"]] = None,
        cap_strike_percent: Optional[float] = None,
        direction: Optional[Union[str, "_models.IPADirectionEnum"]] = None,
        end_date: Optional[datetime.datetime] = None,
        end_tenor: Optional[str] = None,
        first_accrual_date: Optional[datetime.datetime] = None,
        first_regular_payment_date: Optional[datetime.datetime] = None,
        fixed_rate_percent: Optional[float] = None,
        floor_strike_percent: Optional[float] = None,
        index_average_method: Optional[Union[str, "_models.IndexAverageMethodEnum"]] = None,
        index_compounding_method: Optional[Union[str, "_models.IndexCompoundingMethodEnum"]] = None,
        index_fixing_lag: Optional[int] = None,
        index_fixing_ric: Optional[str] = None,
        index_lockout_period: Optional[int] = None,
        index_observation_method: Optional[Union[str, "_models.IPAIndexObservationMethodEnum"]] = None,
        index_reset_frequency: Optional[Union[str, "_models.IndexResetFrequencyEnum"]] = None,
        instrument_code: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = None,
        interest_payment_delay: Optional[int] = None,
        interest_payment_frequency: Optional[Union[str, "_models.InterestPaymentFrequencyEnum"]] = None,
        interest_type: Optional[Union[str, "_models.InterestTypeEnum"]] = None,
        is_perpetual: Optional[bool] = None,
        issue_date: Optional[datetime.datetime] = None,
        last_regular_payment_date: Optional[datetime.datetime] = None,
        notional_amount: Optional[float] = None,
        notional_ccy: Optional[str] = None,
        payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = None,
        payment_business_days: Optional[str] = None,
        payment_roll_convention: Optional[Union[str, "_models.PaymentRollConventionEnum"]] = None,
        spread_bp: Optional[float] = None,
        start_tenor: Optional[str] = None,
        stub_rule: Optional[Union[str, "_models.FinancialContractStubRuleEnum"]] = None,
        template: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.BondDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.BondDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.BondDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondDescription(_model_base.Model):
    """Description Object.

    Attributes
    ----------
    bond_type : str
        The type of the bond. The possible values are:

        * FixedRateBond,
        * IndexLinkedBond,
        * FloatingRateNote,
        * PreferredShare,
        * ConvertibleBond.
    instrument_tag : str
        A user-defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    instrument_code : str
        The code used to define the instrument. The possible values for each
        asset type are listed  here  .
    instrument_description : str
        The label that describes the instrument.
    ric : str
        The Reuters Instrument Code (  RIC  ) of the instrument.
    isin : str
        The International Securities Identification Number (  ISIN  ) of the
        instrument.
    asset_id_code : str
        The Refinitiv  AssetID  code of the instrument.
    asset_sub_type : str
        The code representing the subclassification of the instrument.
    asset_status : str
        A status of the asset (e.g.,  Issued  ,  Called  ,  Not  Active  ,
        Preliminary  , etc.).
    debt_type : str
        The code representing the class of debt, including the type of
        collateral backing the debt.
    ticker : str
        The Equity ticker for the issuer of the instrument.
    cusip : str
        The Committee on Uniform Security Identification Procedures (  CUSIP  )
        code of the instrument.
    sedol : str
        The Stock Exchange Daily Official List (  SEDOL  ) code of the
        instrument.
    wert_code : str
        The Wertpapierkennnummer (  WERT  ) code of the instrument.
    issuer_country : str
        The country of the instrument's issuer. The value is expressed as ISO
        3166 2-character code (e.g., 'CA' for Canada).
    issuer_org_id : str
        A unique Lseg system-assigned identifier for the issuer.
    country_of_issue : str
        A country where the issue is registered.
    country_of_borrower : str
        A country where the borrowing company is registered.
    country_of_incorporation : str
        A country, in which the party received its charter allowing it to
        operate as a corporation. If a country of incorporation is not
        disclosed or if a company is not a corporation, then this is the
        country where the company was formed.
    notional_amount : float
        The notional amount of the instrument. For more details on the field
        calculation, please refer here.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g., '  USD  ').
    report_ccy : str
        The currency code set for the fields ending with '  xxxInReportCcy  '.
        The value is expressed in ISO 4217 alphabetical format (e.g., '  USD
        ').
    par_value : float
        The instrument's face value which determines its maturity value as well
        as the value of coupon payments.
    denomination_minimum : float
        The minimum face value of an instrument that can be purchased. The
        value is expressed in units of the issuing currency.
    denomination_increment : float
        The minimum multiples in which a instrument can be held in the
        secondary market above the minimum denomination. The value is expressed
        in units of the issuing currency.
    price_factor : float
        The divisor of the instrument price, used to calculate its percentage
        value. The par value of the instrument is equal to  PriceFactor  .
    number_of_units : float
        The number of the instrument units.
    issue_price : float
        The instrument's price at the issue date quoted according to the market
        convention defined by  CashOrPercentConvention  .
    issue_date : ~datetime.date
        The date when the issue was registered. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    end_tenor : str
        A tenor used to define the maturity of a user-defined bond (e.g.,
        '2Y').
    trade_date : ~datetime.datetime
        The date when the instrument is traded. The value is expressed in ISO
        8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
    settlement_date : ~datetime.date
        The date on which payments are made to settle a trade. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    settlement_convention : str
        The settlement tenor of the instrument (e.g., '1WD') used to calculate
        SettlementDate  .
    interest_type : str
        An indicator whether the instrument pays a fixed or floating interest.
        The possible values are:

        * Fixed,
        * Float.
    coupon_rate_percent : float
        The interest rate of the instrument. The value is expressed in
        percentages. For more details on the field calculation, please refer
        here.
    coupon_formula : str
        The formula used to compute the coupon rate. It comes from the
        Refinitiv reference data. Available only for floating rate instruments.
    coupon_type : str
        The type of the instrument's coupon payment. This is identified by a
        code. A description is available in "  CouponTypeDescription  " field.
        (e.g., '  FXPV  ' stands for Plain Vanilla Fixed Coupon).
    coupon_type_description : str
        A description of the coupon type.
    first_accrual_date : ~datetime.date
        The date from which the interest starts accruing. The value is
        expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    first_coupon_date : ~datetime.date
        The date of the instrument's first coupon payment. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    first_regular_payment_date : ~datetime.datetime
        The first regular interest payment date used for the odd first interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
    last_regular_payment_date : ~datetime.datetime
        The last regular interest payment date used for the odd last interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
    announcement_date : ~datetime.date
        A date when the terms of issuance become available prior to the initial
        settlement date. For securities with initial placement via
        underwriting, this is the date on which terms of issuance are agreed
        upon between the Issuer and Underwriter. For securities with initial
        placement via an auction, this is the date on which the auction is
        announced. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '  2021-01-01  ').
    auction_date : ~datetime.date
        The date the asset was issued via an auction process. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    original_amount_issued : float
        The total principal amount of the securities offered as per the front
        cover of the prospectus.
    latest_reopening_price_percent : float
        An issue price of the security at its latest re-opening, expressed as a
        percentage of par.
    is_pik : bool
        An indicator whether the instrument is a Payment-In-Kind (PIK). The
        possible values are:

        * True: PIK,
        * False: not PIK.
    is_preferred : bool
        An indicator whether the instrument is a preferred stock. The possible
        values are:

        * True: a preferred stock,
        * False: not a preferred stock.
    is_us_muni : bool
        An indicator whether the instrument is a US Municipal bond. The
        possible values are:

        * True: a US Municipal bond,
        * False: not a US Municipal bond.
    is_callable : bool
        An indicator whether the instrument is callable. The possible values
        are:

        * True: callable,
        * False: not callable.
    is_puttable : bool
        An indicator whether the instrument is puttable. The possible values
        are:

        * True: puttable,
        * False: not puttable.
    is_perpetual : bool
        An indicator whether the instrument is perpetual. The possible values
        are:

        * True: perpetual,
        * False: not perpetual.
    is_sinkable : bool
        An indicator whether the instrument is sinkable. The possible values
        are:

        * True: sinkable,
        * False: not sinkable.
    index_fixing_ric : str
        The RIC that carries the fixing value if the instrument has a floating
        interest.
    tax_status_description : str
        The status of the instrument for tax purposes. It is usually used to
        define whether  TaxEquivalentYieldPercent  or
        TaxExemptEquivalentYieldPercent  should be used for a reference yield.
        The possible values are:

        * Subject to US Alternative Minimum Tax (AMT),
        * US Federal Tax Exempt,
        * US Federal Taxable.
    series : str
        The unique code to identify the deal from the issuer.
    industry_sub_sector : str
        The code of the issuer's subsector.
    accrued_calculation_method : str
        The day count basis method used to calculate the accrued interest
        payments. The possible values are listed  here  .
    interest_calculation_method : str
        The day count basis method used to calculate the interest payments. The
        possible values are listed  here  .
    interest_payment_frequency : str
        The interest payment frequency. The possible values are listed  here  .
    index_reset_frequency : str
        The reset frequency for the floating instrument. The possible values
        are listed  here  .
    projected_index_calculation_method : str
        The method used to define how the projected floating index rate value
        is computed for a floating rate instrument. The possible values are:

        * ConstantIndex - future index values are considered as constant and equal to the projected
        index value,
        * ForwardIndex - future index values are computed using a forward curve.
        * ConstantCouponPayment - coupon payments are computed based on fixed coupon market convention
        with the same index and accrued periods for every coupon period (Applies to Bond only).
    percent_of_ust : float
        A proportion of the instrument's yield to the US Treasury benchmark
        yields. Available only for municipal bonds. For more details on the
        field calculation, please refer here.
    cash_or_percent_convention : str
        An indicator whether the instrument's price is quoted in cash or
        percent. The possible values are:

        * Cash,
        * Percent.
    clean_or_dirty_convention : str
        An indicator whether the instrument's price is quoted in clean or dirty
        convention. The possible values are:

        * Clean: excluding accrued interest,
        * Dirty: including accrued interest.
    price_quotation_date : ~datetime.datetime
        The timestamp of the instrument's quotation data. The value is
        expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.
        '2021-01-01T00:00:00Z').
    quotation_mode : str
        The quotation defining the price type. The possible values are:

        * CashCleanPrice,
        * CashGrossPrice,
        * PercentCleanPrice,
        * PercentGrossPrice,
        * Yield,
        * MoneyMarketYield,
        * Discount,
        * Spread,
        * SimpleMargin,
        * DiscountMargin.
    price_side : str
        The price side of the instrument which comes from the instrument's
        quote or from the curve (derived from quotes) used to value the
        instrument. The possible values are:

        * Bid,
        * Ask,
        * Mid.
    price_source : str
        The contributor of the price quote.
    available_zccurves : list[str]
        The list of available zero-coupon curves that can be used as a forward
        curve or a discount curve.  The default value is None, needs to be
        assigned before using.
    ois_zc_benchmark_curve_name : str
        The name of the OIS benchmark curve used to compute OisZcSpreadBp  .
    inflation_mode : str
        The indicator used to define whether instrument parameters should be
        adjusted from inflation or not. The possible values are:

        * Default,
        * Unadjusted,
        * Adjusted.

        Available only for inflation-linked instruments.
    inflation_index_name : str
        The name of the inflation index (consumer price index). It depends on
        the instrument's country of issue. Available only for inflation-linked
        instruments.
    inflation_index_base_reference : float
        The value of the consumer price index (  CPI  ) at the time of issuing
        the inflation-linked instrument. Available only for inflation-linked
        instruments.
    inflation_index_lookback_tenor : str
        The lag applied to reference consumer price index (  CPI ) to be
        retrieved. The value is expressed as a tenor, usually a month tenor
        (e.g., '  1M  '). Available only for inflation-linked instruments.
    error_message : str
        The error message in case of a blocking error in calculation.
    error_code : str
        The code of ErrorMessage.
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    bond_type: Optional[str] = rest_field(name="bondType")
    """The type of the bond. The possible values are:
     
     
     * FixedRateBond,
     * IndexLinkedBond,
     * FloatingRateNote,
     * PreferredShare,
     * ConvertibleBond."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user-defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument. The possible values for each asset type are listed
     here  ."""
    instrument_description: Optional[str] = rest_field(name="instrumentDescription")
    """The label that describes the instrument."""
    ric: Optional[str] = rest_field()
    """The Reuters Instrument Code (  RIC  ) of the instrument."""
    isin: Optional[str] = rest_field()
    """The International Securities Identification Number (  ISIN  ) of the instrument."""
    asset_id_code: Optional[str] = rest_field(name="assetIdCode")
    """The Refinitiv  AssetID  code of the instrument."""
    asset_sub_type: Optional[str] = rest_field(name="assetSubType")
    """The code representing the subclassification of the instrument."""
    asset_status: Optional[str] = rest_field(name="assetStatus")
    """A status of the asset (e.g.,  Issued  ,  Called  ,  Not  Active  ,  Preliminary  , etc.)."""
    debt_type: Optional[str] = rest_field(name="debtType")
    """The code representing the class of debt, including the type of collateral backing the debt."""
    ticker: Optional[str] = rest_field()
    """The Equity ticker for the issuer of the instrument."""
    cusip: Optional[str] = rest_field()
    """The Committee on Uniform Security Identification Procedures (  CUSIP  ) code of the instrument."""
    sedol: Optional[str] = rest_field()
    """The Stock Exchange Daily Official List (  SEDOL  ) code of the instrument."""
    wert_code: Optional[str] = rest_field(name="wertCode")
    """The Wertpapierkennnummer (  WERT  ) code of the instrument."""
    issuer_country: Optional[str] = rest_field(name="issuerCountry")
    """The country of the instrument's issuer. The value is expressed as ISO 3166 2-character code
     (e.g., 'CA' for Canada)."""
    issuer_org_id: Optional[str] = rest_field(name="issuerOrgId")
    """A unique Lseg system-assigned identifier for the issuer."""
    country_of_issue: Optional[str] = rest_field(name="countryOfIssue")
    """A country where the issue is registered."""
    country_of_borrower: Optional[str] = rest_field(name="countryOfBorrower")
    """A country where the borrowing company is registered."""
    country_of_incorporation: Optional[str] = rest_field(name="countryOfIncorporation")
    """A country, in which the party received its charter allowing it to operate as a corporation. If
     a country of incorporation is not disclosed or if a company is not a corporation, then this is
     the country where the company was formed."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument.
     For more details on the field calculation, please refer here."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g., '  USD  ')."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with '  xxxInReportCcy  '. The value is expressed
     in ISO 4217 alphabetical format (e.g., '  USD  ')."""
    par_value: Optional[float] = rest_field(name="parValue")
    """The instrument's face value which determines its maturity value as well as the value of coupon
     payments."""
    denomination_minimum: Optional[float] = rest_field(name="denominationMinimum")
    """The minimum face value of an instrument that can be purchased. The value is expressed in units
     of the issuing currency."""
    denomination_increment: Optional[float] = rest_field(name="denominationIncrement")
    """The minimum multiples in which a instrument can be held in the secondary market above the
     minimum denomination. The value is expressed in units of the issuing currency."""
    price_factor: Optional[float] = rest_field(name="priceFactor")
    """The divisor of the instrument price, used to calculate its percentage value. The par value of
     the instrument is equal to  PriceFactor  ."""
    number_of_units: Optional[float] = rest_field(name="numberOfUnits")
    """The number of the instrument units."""
    issue_price: Optional[float] = rest_field(name="issuePrice")
    """The instrument's price at the issue date quoted according to the market convention defined by
     CashOrPercentConvention  ."""
    issue_date: Optional[datetime.date] = rest_field(name="issueDate")
    """The date when the issue was registered. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., '2021-01-01')."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    end_tenor: Optional[str] = rest_field(name="endTenor")
    """A tenor used to define the maturity of a user-defined bond (e.g., '2Y')."""
    trade_date: Optional[datetime.datetime] = rest_field(name="tradeDate", format="rfc3339")
    """The date when the instrument is traded. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    settlement_date: Optional[datetime.date] = rest_field(name="settlementDate")
    """The date on which payments are made to settle a trade. The value is expressed in ISO 8601
     format: YYYY-MM-DD (e.g., '2021-01-01')."""
    settlement_convention: Optional[str] = rest_field(name="settlementConvention")
    """The settlement tenor of the instrument (e.g., '1WD') used to calculate  SettlementDate  ."""
    interest_type: Optional[str] = rest_field(name="interestType")
    """An indicator whether the instrument pays a fixed or floating interest. The possible values are:
     
     
     * Fixed,
     * Float."""
    coupon_rate_percent: Optional[float] = rest_field(name="couponRatePercent")
    """The interest rate of the instrument. The value is expressed in percentages.
     For more details on the field calculation, please refer here."""
    coupon_formula: Optional[str] = rest_field(name="couponFormula")
    """The formula used to compute the coupon rate. It comes from the Refinitiv reference data.
     Available only for floating rate instruments."""
    coupon_type: Optional[str] = rest_field(name="couponType")
    """The type of the instrument's coupon payment. This is identified by a code. A description is
     available in \"  CouponTypeDescription  \" field. (e.g., '  FXPV  ' stands for Plain Vanilla
     Fixed Coupon)."""
    coupon_type_description: Optional[str] = rest_field(name="couponTypeDescription")
    """A description of the coupon type."""
    first_accrual_date: Optional[datetime.date] = rest_field(name="firstAccrualDate")
    """The date from which the interest starts accruing. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    first_coupon_date: Optional[datetime.date] = rest_field(name="firstCouponDate")
    """The date of the instrument's first coupon payment. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01')."""
    first_regular_payment_date: Optional[datetime.datetime] = rest_field(
        name="firstRegularPaymentDate", format="rfc3339"
    )
    """The first regular interest payment date used for the odd first interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    last_regular_payment_date: Optional[datetime.datetime] = rest_field(name="lastRegularPaymentDate", format="rfc3339")
    """The last regular interest payment date used for the odd last interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    announcement_date: Optional[datetime.date] = rest_field(name="announcementDate")
    """A date when the terms of issuance become available prior to the initial settlement date. For
     securities with initial placement via underwriting, this is the date on which terms of issuance
     are agreed upon between the Issuer and Underwriter. For securities with initial placement via
     an auction, this is the date on which the auction is announced. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '  2021-01-01  ')."""
    auction_date: Optional[datetime.date] = rest_field(name="auctionDate")
    """The date the asset was issued via an auction process. The value is expressed in ISO 8601
     format: YYYY-MM-DD (e.g., '2021-01-01')."""
    original_amount_issued: Optional[float] = rest_field(name="originalAmountIssued")
    """The total principal amount of the securities offered as per the front cover of the prospectus."""
    latest_reopening_price_percent: Optional[float] = rest_field(name="latestReopeningPricePercent")
    """An issue price of the security at its latest re-opening, expressed as a percentage of par."""
    is_pik: Optional[bool] = rest_field(name="isPik")
    """An indicator whether the instrument is a Payment-In-Kind (PIK). The possible values are:
     
     
     * True: PIK,
     * False: not PIK."""
    is_preferred: Optional[bool] = rest_field(name="isPreferred")
    """An indicator whether the instrument is a preferred stock. The possible values are:
     
     
     * True: a preferred stock,
     * False: not a preferred stock."""
    is_us_muni: Optional[bool] = rest_field(name="isUsMuni")
    """An indicator whether the instrument is a US Municipal bond. The possible values are:
     
     
     * True: a US Municipal bond,
     * False: not a US Municipal bond."""
    is_callable: Optional[bool] = rest_field(name="isCallable")
    """An indicator whether the instrument is callable. The possible values are:
     
     
     * True: callable,
     * False: not callable."""
    is_puttable: Optional[bool] = rest_field(name="isPuttable")
    """An indicator whether the instrument is puttable. The possible values are:
     
     
     * True: puttable,
     * False: not puttable."""
    is_perpetual: Optional[bool] = rest_field(name="isPerpetual")
    """An indicator whether the instrument is perpetual. The possible values are:
     
     
     * True: perpetual,
     * False: not perpetual."""
    is_sinkable: Optional[bool] = rest_field(name="isSinkable")
    """An indicator whether the instrument is sinkable. The possible values are:
     
     
     * True: sinkable,
     * False: not sinkable."""
    index_fixing_ric: Optional[str] = rest_field(name="indexFixingRic")
    """The RIC that carries the fixing value if the instrument has a floating interest."""
    tax_status_description: Optional[str] = rest_field(name="taxStatusDescription")
    """The status of the instrument for tax purposes. It is usually used to define whether
     TaxEquivalentYieldPercent  or  TaxExemptEquivalentYieldPercent  should be used for a reference
     yield. The possible values are:
     
     
     * Subject to US Alternative Minimum Tax (AMT),
     * US Federal Tax Exempt,
     * US Federal Taxable."""
    series: Optional[str] = rest_field()
    """The unique code to identify the deal from the issuer."""
    industry_sub_sector: Optional[str] = rest_field(name="industrySubSector")
    """The code of the issuer's subsector."""
    accrued_calculation_method: Optional[str] = rest_field(name="accruedCalculationMethod")
    """The day count basis method used to calculate the accrued interest payments. The possible values
     are listed  here  ."""
    interest_calculation_method: Optional[str] = rest_field(name="interestCalculationMethod")
    """The day count basis method used to calculate the interest payments. The possible values are
     listed  here  ."""
    interest_payment_frequency: Optional[str] = rest_field(name="interestPaymentFrequency")
    """The interest payment frequency. The possible values are listed  here  ."""
    index_reset_frequency: Optional[str] = rest_field(name="indexResetFrequency")
    """The reset frequency for the floating instrument. The possible values are listed  here  ."""
    projected_index_calculation_method: Optional[str] = rest_field(name="projectedIndexCalculationMethod")
    """The method used to define how the projected floating index rate value is computed for a
     floating rate instrument. The possible values are:
     
     
     * ConstantIndex - future index values are considered as constant and equal to the projected
     index value,
     * ForwardIndex - future index values are computed using a forward curve.
     * ConstantCouponPayment - coupon payments are computed based on fixed coupon market convention
     with the same index and accrued periods for every coupon period (Applies to Bond only)."""
    percent_of_ust: Optional[float] = rest_field(name="percentOfUst")
    """A proportion of the instrument's yield to the US Treasury benchmark yields. Available only for
     municipal bonds.
     For more details on the field calculation, please refer here."""
    cash_or_percent_convention: Optional[str] = rest_field(name="cashOrPercentConvention")
    """An indicator whether the instrument's price is quoted in cash or percent. The possible values
     are:
     
     
     * Cash,
     * Percent."""
    clean_or_dirty_convention: Optional[str] = rest_field(name="cleanOrDirtyConvention")
    """An indicator whether the instrument's price is quoted in clean or dirty convention. The
     possible values are:
     
     
     * Clean: excluding accrued interest,
     * Dirty: including accrued interest."""
    price_quotation_date: Optional[datetime.datetime] = rest_field(name="priceQuotationDate", format="rfc3339")
    """The timestamp of the instrument's quotation data. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. '2021-01-01T00:00:00Z')."""
    quotation_mode: Optional[str] = rest_field(name="quotationMode")
    """The quotation defining the price type. The possible values are:
     
     
     * CashCleanPrice,
     * CashGrossPrice,
     * PercentCleanPrice,
     * PercentGrossPrice,
     * Yield,
     * MoneyMarketYield,
     * Discount,
     * Spread,
     * SimpleMargin,
     * DiscountMargin."""
    price_side: Optional[str] = rest_field(name="priceSide")
    """The price side of the instrument which comes from the instrument's quote or from the curve
     (derived from quotes) used to value the instrument. The possible values are:
     
     
     * Bid,
     * Ask,
     * Mid."""
    price_source: Optional[str] = rest_field(name="priceSource")
    """The contributor of the price quote."""
    available_zccurves: Optional[List[str]] = rest_field(name="availableZccurves")
    """The list of available zero-coupon curves that can be used as a forward curve or a discount
     curve."""
    ois_zc_benchmark_curve_name: Optional[str] = rest_field(name="oisZcBenchmarkCurveName")
    """The name of the OIS benchmark curve used to compute  OisZcSpreadBp  ."""
    inflation_mode: Optional[str] = rest_field(name="inflationMode")
    """The indicator used to define whether instrument parameters should be adjusted from inflation or
     not. The possible values are:
     
     
     * Default,
     * Unadjusted,
     * Adjusted.
     
     Available only for inflation-linked instruments."""
    inflation_index_name: Optional[str] = rest_field(name="inflationIndexName")
    """The name of the inflation index (consumer price index). It depends on the instrument's country
     of issue. Available only for inflation-linked instruments."""
    inflation_index_base_reference: Optional[float] = rest_field(name="inflationIndexBaseReference")
    """The value of the consumer price index (  CPI  ) at the time of issuing the inflation-linked
     instrument. Available only for inflation-linked instruments."""
    inflation_index_lookback_tenor: Optional[str] = rest_field(name="inflationIndexLookbackTenor")
    """The lag applied to reference consumer price index (  CPI  ) to be retrieved. The value is
     expressed as a tenor, usually a month tenor (e.g., '  1M  '). Available only for
     inflation-linked instruments."""
    error_message: Optional[str] = rest_field(name="errorMessage")
    """The error message in case of a blocking error in calculation."""
    error_code: Optional[str] = rest_field(name="errorCode")
    """The code of ErrorMessage."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        bond_type: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        instrument_code: Optional[str] = None,
        instrument_description: Optional[str] = None,
        ric: Optional[str] = None,
        isin: Optional[str] = None,
        asset_id_code: Optional[str] = None,
        asset_sub_type: Optional[str] = None,
        asset_status: Optional[str] = None,
        debt_type: Optional[str] = None,
        ticker: Optional[str] = None,
        cusip: Optional[str] = None,
        sedol: Optional[str] = None,
        wert_code: Optional[str] = None,
        issuer_country: Optional[str] = None,
        issuer_org_id: Optional[str] = None,
        country_of_issue: Optional[str] = None,
        country_of_borrower: Optional[str] = None,
        country_of_incorporation: Optional[str] = None,
        notional_amount: Optional[float] = None,
        notional_ccy: Optional[str] = None,
        report_ccy: Optional[str] = None,
        par_value: Optional[float] = None,
        denomination_minimum: Optional[float] = None,
        denomination_increment: Optional[float] = None,
        price_factor: Optional[float] = None,
        number_of_units: Optional[float] = None,
        issue_price: Optional[float] = None,
        issue_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.datetime] = None,
        end_tenor: Optional[str] = None,
        trade_date: Optional[datetime.datetime] = None,
        settlement_date: Optional[datetime.date] = None,
        settlement_convention: Optional[str] = None,
        interest_type: Optional[str] = None,
        coupon_rate_percent: Optional[float] = None,
        coupon_formula: Optional[str] = None,
        coupon_type: Optional[str] = None,
        coupon_type_description: Optional[str] = None,
        first_accrual_date: Optional[datetime.date] = None,
        first_coupon_date: Optional[datetime.date] = None,
        first_regular_payment_date: Optional[datetime.datetime] = None,
        last_regular_payment_date: Optional[datetime.datetime] = None,
        announcement_date: Optional[datetime.date] = None,
        auction_date: Optional[datetime.date] = None,
        original_amount_issued: Optional[float] = None,
        latest_reopening_price_percent: Optional[float] = None,
        is_pik: Optional[bool] = None,
        is_preferred: Optional[bool] = None,
        is_us_muni: Optional[bool] = None,
        is_callable: Optional[bool] = None,
        is_puttable: Optional[bool] = None,
        is_perpetual: Optional[bool] = None,
        is_sinkable: Optional[bool] = None,
        index_fixing_ric: Optional[str] = None,
        tax_status_description: Optional[str] = None,
        series: Optional[str] = None,
        industry_sub_sector: Optional[str] = None,
        accrued_calculation_method: Optional[str] = None,
        interest_calculation_method: Optional[str] = None,
        interest_payment_frequency: Optional[str] = None,
        index_reset_frequency: Optional[str] = None,
        projected_index_calculation_method: Optional[str] = None,
        percent_of_ust: Optional[float] = None,
        cash_or_percent_convention: Optional[str] = None,
        clean_or_dirty_convention: Optional[str] = None,
        price_quotation_date: Optional[datetime.datetime] = None,
        quotation_mode: Optional[str] = None,
        price_side: Optional[str] = None,
        price_source: Optional[str] = None,
        available_zccurves: Optional[List[str]] = None,
        ois_zc_benchmark_curve_name: Optional[str] = None,
        inflation_mode: Optional[str] = None,
        inflation_index_name: Optional[str] = None,
        inflation_index_base_reference: Optional[float] = None,
        inflation_index_lookback_tenor: Optional[str] = None,
        error_message: Optional[str] = None,
        error_code: Optional[str] = None,
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondEffectiveMeasures(_model_base.Model):
    """Effective measures Object.

    Attributes
    ----------
    option_adjusted_average_life : float
        The instrument's average life adjusted for an embedded option using the
        Hull-White model. Available for callable/puttable bonds.
    option_adjusted_duration : float
        The instrument's duration adjusted for an embedded option using the
        Hull-White model. Available for callable/puttable bonds.
    option_adjusted_modified_duration : float
        The modified duration adjusted for an embedded option using the Hull-
        White model. Available for callable/puttable bonds.
    option_adjusted_convexity : float
        The convexity adjusted for an embedded option using the Hull-White
        model. Available for callable/puttable bonds.
    option_adjusted_dv01_bp : float
        DV01Bp  adjusted for an embedded option using the Hull-White model.
        DV01Bp  is the absolute change in the price of the bond caused by a
        change of the yield by one basis point. Available for callable/puttable
        bonds.
    option_adjusted_dv01_amount_in_deal_ccy : float
        The DV01 amount adjusted for an embedded option using the Hull-White
        model.  DV01Bp  is the absolute change in the price of the bond caused
        by a change of the yield by one basis point. The value is expressed in
        the deal currency. Available for callable/puttable bonds.
    """

    option_adjusted_average_life: Optional[float] = rest_field(name="optionAdjustedAverageLife")
    """The instrument's average life adjusted for an embedded option using the Hull-White model.
     Available for callable/puttable bonds."""
    option_adjusted_duration: Optional[float] = rest_field(name="optionAdjustedDuration")
    """The instrument's duration adjusted for an embedded option using the Hull-White model. Available
     for callable/puttable bonds."""
    option_adjusted_modified_duration: Optional[float] = rest_field(name="optionAdjustedModifiedDuration")
    """The modified duration adjusted for an embedded option using the Hull-White model. Available for
     callable/puttable bonds."""
    option_adjusted_convexity: Optional[float] = rest_field(name="optionAdjustedConvexity")
    """The convexity adjusted for an embedded option using the Hull-White model. Available for
     callable/puttable bonds."""
    option_adjusted_dv01_bp: Optional[float] = rest_field(name="optionAdjustedDv01Bp")
    """DV01Bp  adjusted for an embedded option using the Hull-White model.  DV01Bp  is the absolute
     change in the price of the bond caused by a change of the yield by one basis point. Available
     for callable/puttable bonds."""
    option_adjusted_dv01_amount_in_deal_ccy: Optional[float] = rest_field(name="optionAdjustedDv01AmountInDealCcy")
    """The DV01 amount adjusted for an embedded option using the Hull-White model.  DV01Bp  is the
     absolute change in the price of the bond caused by a change of the yield by one basis point.
     The value is expressed in the deal currency. Available for callable/puttable bonds."""

    @overload
    def __init__(
        self,
        *,
        option_adjusted_average_life: Optional[float] = None,
        option_adjusted_duration: Optional[float] = None,
        option_adjusted_modified_duration: Optional[float] = None,
        option_adjusted_convexity: Optional[float] = None,
        option_adjusted_dv01_bp: Optional[float] = None,
        option_adjusted_dv01_amount_in_deal_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondFutureAnalyticsResponseData(_model_base.Model):
    """BondFutureAnalyticsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.BondFutureDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.BondFuturePricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.BondFutureAnalyticsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketDataQps
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.BondFutureDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.BondFuturePricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.BondFutureAnalyticsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketDataQps"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.BondFutureDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.BondFuturePricingParameters"] = None,
        analytics: Optional[List["_models.BondFutureAnalyticsResponseWithError"]] = None,
        market_data: Optional["_models.MarketDataQps"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondFutureAnalyticsResponseWithError(_model_base.Model):
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    tabular_data : ~analyticsapi.models.FinancialContractResponse
        Standard Financial Contract Analytics in tabular format.
    description : ~analyticsapi.models.BondFutureDescription
        Response categorized under Description.
    nominal_measures : ~analyticsapi.models.BondFutureNominalMeasures
        Response categorized under Nominal measures.
    pricing_analysis : ~analyticsapi.models.BondFuturePricingAnalysis
        Response categorized under Pricing analysis.
    valuation : ~analyticsapi.models.BondFutureValuation
        Response categorized under Valuation.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    tabular_data: Optional["_models.FinancialContractResponse"] = rest_field(name="tabularData")
    """Standard Financial Contract Analytics in tabular format."""
    description: Optional["_models.BondFutureDescription"] = rest_field()
    """Response categorized under Description."""
    nominal_measures: Optional["_models.BondFutureNominalMeasures"] = rest_field(name="nominalMeasures")
    """Response categorized under Nominal measures."""
    pricing_analysis: Optional["_models.BondFuturePricingAnalysis"] = rest_field(name="pricingAnalysis")
    """Response categorized under Pricing analysis."""
    valuation: Optional["_models.BondFutureValuation"] = rest_field()
    """Response categorized under Valuation."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        tabular_data: Optional["_models.FinancialContractResponse"] = None,
        description: Optional["_models.BondFutureDescription"] = None,
        nominal_measures: Optional["_models.BondFutureNominalMeasures"] = None,
        pricing_analysis: Optional["_models.BondFuturePricingAnalysis"] = None,
        valuation: Optional["_models.BondFutureValuation"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondFutureCalculationResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.BondFutureAnalyticsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.BondFutureAnalyticsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.BondFutureAnalyticsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class BondFutureDefinition(_model_base.Model):
    """BondFutureDefinition.

    Attributes
    ----------
    instrument_code : str
        The code (a RIC) used to define the instrument. Mandatory. No default
        value applies.
    instrument_tag : str
        A user-defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported. Optional. No default value applies.
    notional_amount : float
        The notional amount of the instrument. Note: notionalAmount,
        marketValueInDealCcy, and marketValueInReportCcy cannot be set at a
        time Optional. If not set by a user, it can be computed from
        MarketValueInDealCcy and Price. Otherwise, the default value is
        1,000,000.
    underlying_instruments : list[~analyticsapi.models.BondFutureUnderlyingContract]
        The definition of the underlying instruments, provided in the delivery
        basket. Optional. By default, the delivery basket properties are
        computed using the specific contract terms.  The default value is None,
        needs to be assigned before using.
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code (a RIC) used to define the instrument.
     Mandatory. No default value applies."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user-defined string to identify the instrument. It can be used to link output results to the
     instrument definition.
     Limited to 40 characters. Only alphabetic, numeric and '- _.#=@' characters are supported.
     Optional. No default value applies."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument.
     Note: notionalAmount, marketValueInDealCcy, and marketValueInReportCcy cannot be set at a time
     Optional. If not set by a user, it can be computed from MarketValueInDealCcy and Price.
     Otherwise, the default value is 1,000,000."""
    underlying_instruments: Optional[List["_models.BondFutureUnderlyingContract"]] = rest_field(
        name="underlyingInstruments"
    )
    """The definition of the underlying instruments, provided in the delivery basket.
     Optional. By default, the delivery basket properties are computed using the specific contract
     terms."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        notional_amount: Optional[float] = None,
        underlying_instruments: Optional[List["_models.BondFutureUnderlyingContract"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondFutureDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.BondFutureDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.BondFutureDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.BondFutureDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondFutureDescription(_model_base.Model):
    """Description Object.

    Attributes
    ----------
    instrument_tag : str
        A user-defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    instrument_code : str
        The code used to define the instrument. The possible values for each
        asset type are listed  here  .
    instrument_description : str
        The label that describes the instrument.
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    delivery_start_date : ~datetime.date
        The start date of the period, during which the cheapest to deliver bond
        (  CTD  ) is delivered. The value is expressed in ISO 8601 format:
        YYYY-MM-DD (e.g., ' 2021-01-01  ').
    delivery_end_date : ~datetime.date
        The end date of the period, during which the cheapest to deliver bond (
        CTD  ) is delivered. The value is expressed in ISO 8601 format: YYYY-
        MM-DD (e.g., ' 2021-01-01  ').
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g., '  USD  ').
    notional_amount : float
        The notional amount of the instrument.
    report_ccy : str
        The currency code set for the fields ending with '  xxxInReportCcy  '.
        The value is expressed in ISO 4217 alphabetical format (e.g., '  USD
        ').
    contract_size : float
        The contract size of the instrument. The value is expressed in units of
        NotionalCcy  .
    coupon_rate_percent : float
        The interest rate of the instrument. The value is expressed in
        percentages.
    error_code : str
        The code of  ErrorMessage.
    error_message : str
        The error message in case of a blocking error in calculation.
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user-defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument. The possible values for each asset type are listed
     here  ."""
    instrument_description: Optional[str] = rest_field(name="instrumentDescription")
    """The label that describes the instrument."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    delivery_start_date: Optional[datetime.date] = rest_field(name="deliveryStartDate")
    """The start date of the period, during which the cheapest to deliver bond (  CTD  ) is delivered.
     The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '  2021-01-01  ')."""
    delivery_end_date: Optional[datetime.date] = rest_field(name="deliveryEndDate")
    """The end date of the period, during which the cheapest to deliver bond (  CTD  ) is delivered.
     The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '  2021-01-01  ')."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g., '  USD  ')."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with '  xxxInReportCcy  '. The value is expressed
     in ISO 4217 alphabetical format (e.g., '  USD  ')."""
    contract_size: Optional[float] = rest_field(name="contractSize")
    """The contract size of the instrument. The value is expressed in units of  NotionalCcy  ."""
    coupon_rate_percent: Optional[float] = rest_field(name="couponRatePercent")
    """The interest rate of the instrument. The value is expressed in percentages."""
    error_code: Optional[str] = rest_field(name="errorCode")
    """The code of  ErrorMessage."""
    error_message: Optional[str] = rest_field(name="errorMessage")
    """The error message in case of a blocking error in calculation."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        instrument_tag: Optional[str] = None,
        instrument_code: Optional[str] = None,
        instrument_description: Optional[str] = None,
        end_date: Optional[datetime.datetime] = None,
        delivery_start_date: Optional[datetime.date] = None,
        delivery_end_date: Optional[datetime.date] = None,
        notional_ccy: Optional[str] = None,
        notional_amount: Optional[float] = None,
        report_ccy: Optional[str] = None,
        contract_size: Optional[float] = None,
        coupon_rate_percent: Optional[float] = None,
        error_code: Optional[str] = None,
        error_message: Optional[str] = None,
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondFutureNominalMeasures(_model_base.Model):
    """Nominal measures Object.

    Attributes
    ----------
    convexity : float
        The measure of the curvature in the relationship between the
        instrument's price and yield.
    dv01_bp : float
        The sensitivity of the market value to a  1 bp  parallel shift in the
        zero-coupon curve. The value is expressed in basis points.
    duration : float
        The weighted average maturity of all cash flows. The final cash flow
        includes the principal, which has a much greater weight than the
        intermediate cash flows.
    modified_duration : float
        The measure of price sensitivity to  100 basis points  change in the
        instrument's yield, or 1% parallel shift in the underlying zero-coupon
        curve in case of interest rate swap instruments. For a floating rate
        instrument, it is computed as time to next payment.
    """

    convexity: Optional[float] = rest_field()
    """The measure of the curvature in the relationship between the instrument's price and yield."""
    dv01_bp: Optional[float] = rest_field(name="dv01Bp")
    """The sensitivity of the market value to a  1 bp  parallel shift in the zero-coupon curve. The
     value is expressed in basis points."""
    duration: Optional[float] = rest_field()
    """The weighted average maturity of all cash flows. The final cash flow includes the principal,
     which has a much greater weight than the intermediate cash flows."""
    modified_duration: Optional[float] = rest_field(name="modifiedDuration")
    """The measure of price sensitivity to  100 basis points  change in the instrument's yield, or 1%
     parallel shift in the underlying zero-coupon curve in case of interest rate swap instruments.
     For a floating rate instrument, it is computed as time to next payment."""

    @overload
    def __init__(
        self,
        *,
        convexity: Optional[float] = None,
        dv01_bp: Optional[float] = None,
        duration: Optional[float] = None,
        modified_duration: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondFuturePricingAnalysis(_model_base.Model):
    """Pricing analysis Object.

    Attributes
    ----------
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    cheapest_to_deliver : str
        The instrument code of the cheapest to deliver bond (  CTD  ). The bond
        with the highest implied repo rate, and/or with the lowest net basis is
        the CTD bond.
    conversion_factor : float
        The conversion factor of the cheapest to deliver bond (  CTD  ). The
        conversion factor is used to equalize coupon and accrued interest
        differences of all deliverable bonds.
    price : float
        The price of the instrument quoted according to the market convention.
    fair_price : float
        The fair future price of the instrument quoted according to the market
        convention. It is usually fairFuture price of the cheapest to deliver
        bond (CTD). Note: Several conventions can exist to compute this value.
        For example, Australian Bond Future FairPrice is computed from the
        average of the forward yields of all bonds in the delivery basket.
    invoice_price : float
        The price paid by the buyer of the bond future contract to purchase the
        bond. It is computed as [  Price  x  ConversionFactor  ]. The value is
        expressed according to the market convention.
    yield_percent : float
        The yield of the instrument which comes from the market data. The value
        is expressed in percentages.
    implied_yield_percent : float
        The yield of the cheapest to deliver bond (  CTD  ) computed from
        InvoicePrice  . The value is expressed in percentages.
    delivery_basket : list[any]
        The data of bonds which are eligible for delivery. For the detailed
        breakdown please refer  here  .  The default value is None, needs to be
        assigned before using.
    """

    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    cheapest_to_deliver: Optional[str] = rest_field(name="cheapestToDeliver")
    """The instrument code of the cheapest to deliver bond (  CTD  ). The bond with the highest
     implied repo rate, and/or with the lowest net basis is the CTD bond."""
    conversion_factor: Optional[float] = rest_field(name="conversionFactor")
    """The conversion factor of the cheapest to deliver bond (  CTD  ). The conversion factor is used
     to equalize coupon and accrued interest differences of all deliverable bonds."""
    price: Optional[float] = rest_field()
    """The price of the instrument quoted according to the market convention."""
    fair_price: Optional[float] = rest_field(name="fairPrice")
    """The fair future price of the instrument quoted according to the market convention. It is
     usually fairFuture price of the cheapest to deliver bond (CTD).
     Note: Several conventions can exist to compute this value. For example, Australian Bond Future
     FairPrice is computed from the average of the forward yields of all bonds in the delivery
     basket."""
    invoice_price: Optional[float] = rest_field(name="invoicePrice")
    """The price paid by the buyer of the bond future contract to purchase the bond. It is computed as
     [  Price  x  ConversionFactor  ]. The value is expressed according to the market convention."""
    yield_percent: Optional[float] = rest_field(name="yieldPercent")
    """The yield of the instrument which comes from the market data. The value is expressed in
     percentages."""
    implied_yield_percent: Optional[float] = rest_field(name="impliedYieldPercent")
    """The yield of the cheapest to deliver bond (  CTD  ) computed from  InvoicePrice  . The value is
     expressed in percentages."""
    delivery_basket: Optional[List[Any]] = rest_field(name="deliveryBasket")
    """The data of bonds which are eligible for delivery. For the detailed breakdown please refer
     here  ."""

    @overload
    def __init__(
        self,
        *,
        market_data_date: Optional[datetime.datetime] = None,
        valuation_date: Optional[datetime.datetime] = None,
        cheapest_to_deliver: Optional[str] = None,
        conversion_factor: Optional[float] = None,
        price: Optional[float] = None,
        fair_price: Optional[float] = None,
        invoice_price: Optional[float] = None,
        yield_percent: Optional[float] = None,
        implied_yield_percent: Optional[float] = None,
        delivery_basket: Optional[List[Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondFuturePricingParameters(_model_base.Model):
    """BondFuturePricingParameters.

    Attributes
    ----------
    delivery_end_date : ~datetime.datetime
        The end date of the period, during which the cheapest to deliver bond
        (CTD) is delivered. The value is expressed in ISO 8601 format: YYYY-MM-
        DD (e.g., '2021-01-01'). Optional. If not provided in the request, it
        will be computed using the specific contract terms.
    delivery_start_date : ~datetime.datetime
        The start date of the period, during which the cheapest to deliver bond
        (CTD) is delivered. The value is expressed in ISO 8601 format: YYYY-MM-
        DD (e.g., '2021-01-01'). Optional. If not provided in the request, it
        will be computed using the specific contract terms.
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).
        Optional. By default, marketDataDate is valuationDate or today.
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency. Note: notionalAmount, marketValueInDealCcy, and
        marketValueInReportCcy cannot be set at a time. Optional. By default,
        the value is computed from the NotionalAmount and Price.
    market_value_in_report_ccy : float
        The market value of the instrument. The value is expressed in the
        reporting currency. Note: notionalAmount, marketValueInDealCcy, and
        marketValueInReportCcy cannot be set at a time. Optional. By default,
        the value is equal to marketValueInDealCcy.
    price : float
        The price of the instrument quoted according to the market convention.
        Optional. By default, the value is retrieved from the instrument
        quotation.
    price_side : str or ~analyticsapi.models.PriceSideEnum
        The price side of the instrument which comes from the instrument's
        quote or from the curve (derived from quotes) used to value the
        instrument. The possible values are:

        * Bid,
        * Ask,
        * Mid.

        Optional. The default value is 'Mid'. Known values are: "Mid", "Bid", "Ask", and "Last".
    repo_rate_percent : float
        The repo rate used to compute the forward price of the deliverable
        bond. The value is expressed in percentages. It is set at the same
        level for all deliverable bonds unless repoRatePercent in
        underlyingInstruments is specified for the delivery bond. Optional. By
        default, it is computed by interpolating a repo curve.
    report_ccy : str
        The currency code set for the fields ending with 'xxxInReportCcy'. The
        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
        Optional. No default value applies.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    """

    delivery_end_date: Optional[datetime.datetime] = rest_field(name="deliveryEndDate", format="rfc3339")
    """The end date of the period, during which the cheapest to deliver bond (CTD) is delivered. The
     value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
     Optional. If not provided in the request, it will be computed using the specific contract
     terms."""
    delivery_start_date: Optional[datetime.datetime] = rest_field(name="deliveryStartDate", format="rfc3339")
    """The start date of the period, during which the cheapest to deliver bond (CTD) is delivered. The
     value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
     Optional. If not provided in the request, it will be computed using the specific contract
     terms."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It should be less or equal to
     valuationDate).
     Optional. By default, marketDataDate is valuationDate or today."""
    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency.
     Note: notionalAmount, marketValueInDealCcy, and marketValueInReportCcy cannot be set at a time.
     Optional. By default, the value is computed from the NotionalAmount and Price."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value of the instrument. The value is expressed in the reporting currency.
     Note: notionalAmount, marketValueInDealCcy, and marketValueInReportCcy cannot be set at a time.
     Optional. By default, the value is equal to marketValueInDealCcy."""
    price: Optional[float] = rest_field()
    """The price of the instrument quoted according to the market convention.
     Optional. By default, the value is retrieved from the instrument quotation."""
    price_side: Optional[Union[str, "_models.PriceSideEnum"]] = rest_field(name="priceSide")
    """The price side of the instrument which comes from the instrument's quote or from the curve
     (derived from quotes) used to value the instrument.
     The possible values are:
     
     
     * Bid,
     * Ask,
     * Mid.
     
     Optional. The default value is 'Mid'. Known values are: \"Mid\", \"Bid\", \"Ask\", and
     \"Last\"."""
    repo_rate_percent: Optional[float] = rest_field(name="repoRatePercent")
    """The repo rate used to compute the forward price of the deliverable bond. The value is expressed
     in percentages.
     It is set at the same level for all deliverable bonds unless repoRatePercent in
     underlyingInstruments is specified for the delivery bond.
     Optional. By default, it is computed by interpolating a repo curve."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with 'xxxInReportCcy'. The value is expressed in
     ISO 4217 alphabetical format (e.g., 'USD').
     Optional. No default value applies."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""

    @overload
    def __init__(
        self,
        *,
        delivery_end_date: Optional[datetime.datetime] = None,
        delivery_start_date: Optional[datetime.datetime] = None,
        market_data_date: Optional[datetime.datetime] = None,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
        price: Optional[float] = None,
        price_side: Optional[Union[str, "_models.PriceSideEnum"]] = None,
        repo_rate_percent: Optional[float] = None,
        report_ccy: Optional[str] = None,
        valuation_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondFutureUnderlyingContract(_model_base.Model):
    """BondFutureUnderlyingContract.

    Attributes
    ----------
    instrument_definition : ~analyticsapi.models.BondDefinition
    instrument_type : str
        The type of instrument defined in the request.
    market_data_assignment : ~analyticsapi.models.MarketDataAssignments
    pricing_parameters : ~analyticsapi.models.BondPricingParameters
    """

    instrument_definition: Optional["_models.BondDefinition"] = rest_field(name="instrumentDefinition")
    instrument_type: Optional[str] = rest_field(name="instrumentType")
    """The type of instrument defined in the request."""
    market_data_assignment: Optional["_models.MarketDataAssignments"] = rest_field(name="marketDataAssignment")
    pricing_parameters: Optional["_models.BondPricingParameters"] = rest_field(name="pricingParameters")

    @overload
    def __init__(
        self,
        *,
        instrument_definition: Optional["_models.BondDefinition"] = None,
        instrument_type: Optional[str] = None,
        market_data_assignment: Optional["_models.MarketDataAssignments"] = None,
        pricing_parameters: Optional["_models.BondPricingParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondFutureValuation(_model_base.Model):
    """Valuation Object.

    Attributes
    ----------
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency.
    market_value_in_report_ccy : float
        The market value of the instrument. The value is expressed in the
        reporting currency.
    """

    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value of the instrument. The value is expressed in the reporting currency."""

    @overload
    def __init__(
        self,
        *,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondIndicRequest(_model_base.Model):
    """BondIndicRequest.

    Attributes
    ----------
    input : list[~analyticsapi.models.IdentifierInfo]
        Single identifier or a list of identifiers to search instruments by.
        The default value is None, needs to be assigned before using.
    keywords : list[str]
        List of keywords from the MappedResponseRefData to be exposed in the
        result data set.  The default value is None, needs to be assigned
        before using.
    """

    input: Optional[List["_models.IdentifierInfo"]] = rest_field()
    """Single identifier or a list of identifiers to search instruments by."""
    keywords: Optional[List[str]] = rest_field()
    """List of keywords from the MappedResponseRefData to be exposed in the result data set."""

    @overload
    def __init__(
        self,
        *,
        input: Optional[List["_models.IdentifierInfo"]] = None,
        keywords: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondInstrument(_model_base.Model):
    """BondInstrument.

    Attributes
    ----------
    fields : ~analyticsapi.models.CurvesAndSurfacesBidAskFields
    formula : str
        The formula used to adjust market data values of the instrument's Bid
        and Ask price side. For example, '100-marketPrice'.
    formula_parameters : list[~analyticsapi.models.FormulaParameter]
        The list of formula parameters used to adjust market data values of the
        instrument's Bid and Ask price side.  The default value is None, needs
        to be assigned before using.
    instrument_definition : ~analyticsapi.models.BondInstrumentDefinition
    """

    fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """The formula used to adjust market data values of the instrument's Bid and Ask price side. For
     example, '100-marketPrice'."""
    formula_parameters: Optional[List["_models.FormulaParameter"]] = rest_field(name="formulaParameters")
    """The list of formula parameters used to adjust market data values of the instrument's Bid and
     Ask price side."""
    instrument_definition: Optional["_models.BondInstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameter"]] = None,
        instrument_definition: Optional["_models.BondInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondInstrumentDefinition(_model_base.Model):
    """BondInstrumentDefinition.

    Attributes
    ----------
    end_date : ~datetime.date
        Maturity date of the bond.
    fixed_rate_percent : float
        Coupon rate of the bond in percent.
    instrument_code : str
        Code to define the instrument. Only RIC is supported.
    quotation_mode : str or ~analyticsapi.models.CurvesAndSurfacesQuotationModeEnum
        Quotation of the instrument. Known values are: "CashCleanPrice",
        "CashGrossPrice", "Discount", "DiscountMargin", "MoneyMarketYield",
        "Outright", "ParYield", "PercentCleanPrice", "PercentGrossPrice",
        "Price", "SimpleMargin", "Spread", "SwapPoint",
        "SwapPointInAbsoluteUnit", "Upfront", "Yield", and "ZeroCoupon".
    spread_bp : float
        Get spreadBp.
    start_date : ~datetime.date
        Get startDate.
    template : str
        A reference to a Adfin instrument contract or the Adfin detailed
        contract.
    weight : float
        Get weight.
    """

    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """Maturity date of the bond."""
    fixed_rate_percent: Optional[float] = rest_field(name="fixedRatePercent")
    """Coupon rate of the bond in percent."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Code to define the instrument. Only RIC is supported."""
    quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = rest_field(
        name="quotationMode"
    )
    """Quotation of the instrument. Known values are: \"CashCleanPrice\", \"CashGrossPrice\",
     \"Discount\", \"DiscountMargin\", \"MoneyMarketYield\", \"Outright\", \"ParYield\",
     \"PercentCleanPrice\", \"PercentGrossPrice\", \"Price\", \"SimpleMargin\", \"Spread\",
     \"SwapPoint\", \"SwapPointInAbsoluteUnit\", \"Upfront\", \"Yield\", and \"ZeroCoupon\"."""
    spread_bp: Optional[float] = rest_field(name="spreadBp")
    """Get spreadBp."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """Get startDate."""
    template: Optional[str] = rest_field()
    """A reference to a Adfin instrument contract or the Adfin detailed contract."""
    weight: Optional[float] = rest_field()
    """Get weight."""

    @overload
    def __init__(
        self,
        *,
        end_date: Optional[datetime.date] = None,
        fixed_rate_percent: Optional[float] = None,
        instrument_code: Optional[str] = None,
        quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = None,
        spread_bp: Optional[float] = None,
        start_date: Optional[datetime.date] = None,
        template: Optional[str] = None,
        weight: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondInstrumentDescription(_model_base.Model):
    """BondInstrumentDescription.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsDescription
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterDescription]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.BondInstrumentDefinition
    """

    fields: Optional["_models.BidAskFieldsDescription"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.BondInstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsDescription"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = None,
        instrument_definition: Optional["_models.BondInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondInstrumentOutput(_model_base.Model):
    """BondInstrumentOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.BondInstrumentDefinition
    status_message : str
        Get statusMessage.
    """

    fields: Optional["_models.BidAskFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.BondInstrumentDefinition"] = rest_field(name="instrumentDefinition")
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.BondInstrumentDefinition"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondNominalMeasures(_model_base.Model):
    """Nominal measures Object.

    Attributes
    ----------
    average_life : float
        The average remaining time to all principal instrument payments,
        weighted by the repayment amounts. It doesn't take into account
        interest payments. The value is expressed in years. For more details on
        the field calculation, please refer here.
    duration : float
        The weighted average maturity of all cash flows. The final cash flow
        includes the principal, which has a much greater weight than the
        intermediate cash flows. For more details on the field calculation,
        please refer here.
    modified_duration : float
        The measure of price sensitivity to 100 basis point change in the
        instrument's yield, or 1% parallel shift in the underlying zero-coupon
        curve in case of interest rate swap instruments. For a floating rate
        instrument, it is computed as time to next payment. For more details on
        the field calculation, please refer here.
    convexity : float
        The measure of the curvature in the relationship between the
        instrument's price and yield. For more details on the field
        calculation, please refer here.
    index_duration : float
        The measure of price sensitivity to a small change in index rates used
        to calculate payments on the instrument.
    spread_duration : float
        The measure of price sensitivity to a small change in the discount
        margin. Available only for floating rate instruments.
    dv01_bp : float
        The sensitivity of the market value to a 1bp parallel shift in the
        zero-coupon curve. The value is expressed in basis points. For more
        details on the field calculation, please refer here.
    dv01_amount_in_deal_ccy : float
        The sensitivity of the market value to a 1bp parallel shift in the
        zero-coupon curve. The value is expressed in the deal currency. For
        more details on the field calculation, please refer here.
    dv01_amount_in_report_ccy : float
        The sensitivity of the market value to a 1bp parallel shift in the
        zero-coupon curve. The value is expressed in the reporting currency.
    """

    average_life: Optional[float] = rest_field(name="averageLife")
    """The average remaining time to all principal instrument payments, weighted by the repayment
     amounts. It doesn't take into account interest payments. The value is expressed in years.
     For more details on the field calculation, please refer here."""
    duration: Optional[float] = rest_field()
    """The weighted average maturity of all cash flows. The final cash flow includes the principal,
     which has a much greater weight than the intermediate cash flows.
     For more details on the field calculation, please refer here."""
    modified_duration: Optional[float] = rest_field(name="modifiedDuration")
    """The measure of price sensitivity to 100 basis point change in the instrument's yield, or 1%
     parallel shift in the underlying zero-coupon curve in case of interest rate swap instruments.
     For a floating rate instrument, it is computed as time to next payment.
     For more details on the field calculation, please refer here."""
    convexity: Optional[float] = rest_field()
    """The measure of the curvature in the relationship between the instrument's price and yield.
     For more details on the field calculation, please refer here."""
    index_duration: Optional[float] = rest_field(name="indexDuration")
    """The measure of price sensitivity to a small change in index rates used to calculate payments on
     the instrument."""
    spread_duration: Optional[float] = rest_field(name="spreadDuration")
    """The measure of price sensitivity to a small change in the discount margin. Available only for
     floating rate instruments."""
    dv01_bp: Optional[float] = rest_field(name="dv01Bp")
    """The sensitivity of the market value to a 1bp parallel shift in the zero-coupon curve. The value
     is expressed in basis points.
     For more details on the field calculation, please refer here."""
    dv01_amount_in_deal_ccy: Optional[float] = rest_field(name="dv01AmountInDealCcy")
    """The sensitivity of the market value to a 1bp parallel shift in the zero-coupon curve. The value
     is expressed in the deal currency.
     For more details on the field calculation, please refer here."""
    dv01_amount_in_report_ccy: Optional[float] = rest_field(name="dv01AmountInReportCcy")
    """The sensitivity of the market value to a 1bp parallel shift in the zero-coupon curve. The value
     is expressed in the reporting currency."""

    @overload
    def __init__(
        self,
        *,
        average_life: Optional[float] = None,
        duration: Optional[float] = None,
        modified_duration: Optional[float] = None,
        convexity: Optional[float] = None,
        index_duration: Optional[float] = None,
        spread_duration: Optional[float] = None,
        dv01_bp: Optional[float] = None,
        dv01_amount_in_deal_ccy: Optional[float] = None,
        dv01_amount_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondPricingAnalysis(_model_base.Model):
    """Pricing analysis Object.

    Attributes
    ----------
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). The default value is  today  .
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    price : float
        The instrument's price quoted according to the market conventions.
    price_percent : float
        The instrument's price quoted according to the market convention
        defined by  CleanOrDirtyConvention  .
    net_price : float
        The instrument's price before deducting fees. The value is quoted
        according to the market convention defined by CashOrPercentConvention
        and CleanOrDirtyConvention. For more details on the field calculation,
        please refer here.
    net_price_percent : float
        The instrument's price before deducting fees. The value is expressed in
        percentages.
    clean_price : float
        The instrument's price excluding accrued interest. The value is quoted
        according to the market convention defined by  CashOrPercentConvention
        .
    clean_price_percent : float
        The price excluding accrued interest. The value is expressed in
        percentages. For more details on the field calculation, please refer
        here.
    dirty_price : float
        The price of the instrument, which includes accrued interest. The value
        is quoted according to the market convention defined by
        CashOrPercentConvention  .
    dirty_price_percent : float
        The price including accrued interest. The value is expressed in
        percentages. For more details on the field calculation, please refer
        here.
    neutral_price : float
        The price of the instrument, at which it moves neither up nor down over
        time. The value is quoted according to the market convention defined by
        CashOrPercentConvention  . Available only for floating rate
        instruments.
    yield_type : str
        The yield type specified in the yield calculation convention and used
        for the instrument rate model. The possible values are listed  here  .
    issue_yield_percent : float
        The yield computed from the issue price at the default redemption type.
        The value is expressed in percentages.  Default redemption types are: '
        RedemptionAtWorstDate  ' for callable bond, '  RedemptionAtBestDate  '
        for puttable bond or ' RedemptionAtMaturityDate  ' in other cases.
    yield_percent : float
        The yield, if it is not defined in the pricing parameter, that equates
        the present value of the instrument to its dirty price, assuming that
        the yield is constant over the life of the instrument. The value is
        expressed in percentages.
    net_yield_percent : float
        The yield of the bond at the redemption date computed from the net
        price. The value is expressed in percentages.
    redemption_date : ~datetime.date
        The date when the instrument can be redeemed. The notional of the
        instrument is also paid at this date. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2021-01-01').  RedemptionDate  is
        either defined in input pricing parameters or computed from
        RedemptionDateType  .
    redemption_price : float
        The price at which the instrument is redeemed.
    redemption_date_type : str
        The type defining the redemption date of the instrument. The possible
        values are listed  here  .
    redemption_yield_type : str
        The type of the redemption yield at which the bond has been priced. The
        possible values are listed  here  .
    yield_to_maturity_percent : float
        The yield that makes the present value of the bond equal to its dirty
        price, assuming that the yield is constant over the life of the bond
        and that the bond will be redeemed at maturity or perpetuity. The value
        is expressed in percentages.
    yield_to_worst_percent : float
        The lowest yield among all yields calculated at each possible
        redemption dates, among which the bond issuer may choose to call the
        bond from its holder. This is the most favorable yield of a callable
        bond. The value is expressed in percentages. Available for callable
        bonds.
    yield_to_worst_date : ~datetime.date
        The date at which  YieldToWorst  has been computed. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
        Available for callable bonds.
    yield_to_best_percent : float
        The highest yield among all yields calculated at each possible
        redemption dates, among which the bond holder may choose to put the
        bond to the issuer. This is the most favorable yield of a puttable
        bond. The value is expressed in percentages. Available for puttable
        bonds.
    yield_to_best_date : ~datetime.date
        The date at which  YieldToBest  has been computed. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
        Available for puttable bonds.
    yield_to_next_call_percent : float
        The yield that makes the present value of the bond equal to its dirty
        price, assuming that the yield is constant over the life of the bond
        and that the bond will be redeemed at the next call date. The value is
        expressed in percentages. Available for callable bonds.
    yield_to_next_call_date : ~datetime.date
        The date of the next call, when the bond issuer may choose to buy the
        bond from its holder. The value is expressed in ISO 8601 format: YYYY-
        MM-DD (e.g., '2021-01-01'). Available for callable bonds.
    yield_to_next_put_percent : float
        The yield that makes the present value of the bond equal to its dirty
        price, assuming that the yield is constant over the life of the bond
        and that the bond will be redeemed at next put date. The value is
        expressed in percentages. Available for puttable bonds.
    yield_to_next_put_date : ~datetime.date
        The date of the next put, when the bond holder may choose to sell the
        bond to its issuer. The value is expressed in ISO 8601 format: YYYY-MM-
        DD (e.g., '2021-01-01'). Available for puttable bonds.
    neutral_yield_percent : float
        The neutral yield of the instrument, at which its price moving neither
        up nor down over time. The value is expressed in basis points.
        Available only for floating rate instruments.
    strip_yield_percent : float
        The strip yield measures the return on only the debt portion of the
        instrument (removing the impact of any embedded options, or conversion
        rights, or accrued interest). The value is expressed in percentages.
    discount_percent : float
        A difference between the instrument's price paid for and its par value.
        The value is expressed in percentages.
    current_yield_percent : float
        The current yield of the instrument. The value is expressed in
        percentages. For more details on the field calculation, please refer
        here.
    annual_dividend : float
        The annual dividend. Available only for preferred stocks (IsPreferred =
        True). For more details on the field calculation, please refer here.
    redemption_dates_array : list[~datetime.date]
        The list of all possible dates, when the bond may be redeemed. This
        field is mainly used for bonds with options. Therefore, the bond may be
        redeemed at each call date.  The default value is None, needs to be
        assigned before using.
    redemption_yields_array : list[float]
        The list of yields computed for each redemption date. The Nth yield is
        the one computed for the Nth redemption date from  RedemptionDatesArray
        .  The default value is None, needs to be assigned before using.
    redemption_neutral_yields_array : list[float]
        The list of neutral yields computed for each redemption date. The Nth
        yield is the one computed for the Nth redemption date from
        RedemptionDatesArray . Available only for floating rate instruments.
        The default value is None, needs to be assigned before using.
    redemption_prices_array : list[float]
        The list of prices computed for each redemption date. The Nth price is
        the one computed for the Nth redemption date from  RedemptionDatesArray
        .  The default value is None, needs to be assigned before using.
    redemption_date_types_array : list[str]
        The list of redemption date types computed for each redemption date.
        The Nth redemption type is the one computed for the Nth redemption date
        from RedemptionDatesArray  . The possible values are listed  here  .
        The default value is None, needs to be assigned before using.
    redemption_yield_types_array : list[str]
        The list of redemption yield types computed for each redemption date.
        The Nth redemption type is the one computed for the Nth redemption date
        from RedemptionDatesArray  . The possible values are listed  here  .
        The default value is None, needs to be assigned before using.
    de_minimis_price : float
        The threshold price for tax purposes, at which a discount bond should
        be taxed as a capital gain rather than as an ordinary income.
    de_minimis_yield_percent : float
        The threshold yield for tax purposes. It is computed from
        DeMinimisPrice  .
    adjusted_price : float
        The clean price adjusted for the difference between the refinancing
        rate and the coupon rate during the partial first period. The value is
        quoted according to the market convention defined by
        CashOrPercentConvention and CleanOrDirtyConvention. Available only for
        floating rate instruments.
    adjusted_clean_price : float
        The clean price of the instrument adjusted by InflationIndexRatio. It
        is computed with [inflationMode = Adjusted]. The value is quoted
        according to the market convention defined by CashOrPercentConvention.
        Available only for inflation-linked instruments. For more details on
        the field calculation, please refer here.
    adjusted_dirty_price : float
        The dirty price of the instrument adjusted by InflationIndexRatio. It
        is computed with [inflationMode = Adjusted]. The value is quoted
        according to the market convention defined by CashOrPercentConvention.
        Available only for inflation-linked instruments. For more details on
        the field calculation, please refer here.
    adjusted_yield_percent : float
        The instrument yield computed with [  inflationMode  =  Adjusted ]. The
        value is expressed in percentages. Available only for inflation-linked
        instruments.
    adjusted_simple_margin_bp : float
        The average annual return of the floating rate instrument compared to
        its index rate. The measure is based on the adjusted clean price. The
        simple margin method does not take into account the current yield
        effect on the instrument's price, that is the value to the investor of
        buying an instrument below par or the cost of buying an instrument
        above par.  The value is expressed in basis points. Available only for
        floating rate instruments.
    adjusted_total_margin_bp : float
        The adjusted margin, which includes the additional or lost return
        realized if the price of the floating rate instrument is below or above
        par. The value is expressed in basis points. Available only for
        floating rate instruments.
    discount_margin_bp : float
        The margin that is earned in addition to the floating index rate value
        of the instrument. The value is expressed in basis points. Available
        only for floating rate instruments.
    simple_margin_bp : float
        The average cash return per year of the instrument compared with its
        index rate. The value is expressed in basis points. Available only for
        floating rate instruments.
    bond_option_free_price : float
        The bond's price minus the price of the embedded option. Available for
        callable/puttable bonds.
    bond_option_price : float
        The price of the embedded option evaluated using the Hull-White model.
        Available for callable/puttable bonds.
    quoted_price : float
        The instrument's price quoted according to the market convention
        defined by QuotationMode  .
    quoted_bid_price : float
        The quoted bid price on the market.
    quoted_ask_price : float
        The quoted ask price on the market.
    projected_index_percent : float
        The projected index rate value used for calculation of future cash
        flows of the instrument. By default, it is computed from market data
        according to the instrument convention. Usually the projected index is
        the last known value of the index. The value is expressed in
        percentages. Available only for floating rate instruments.
    fx_spot : float
        The spot value of the cross-currency pair, which is the instrument
        currency against the reporting currency. It is used to convert amount
        to the reporting currency.
    yield_to_maturity_spread_bp : float
        The difference between the yield to maturity of the floating rate
        instrument and the effective internal rate of return (IRR) of the
        underlying index. The IRR of the index is calculated as a series of
        short-term investments that pay interest rates equal to the projected
        index rates, using the same frequency and day count convention as
        floating rate instruments. Available only for floating rate
        instruments.
    inflation_index_ratio : float
        The value of the consumer price index (CPI) at the settlement date used
        to calculate the inflation-adjusted instrument price. Available only
        for inflation-linked instruments. For more details on the field
        calculation, please refer here.
    inflation_current_index : float
        The value of the consumer price index (  CPI  ) at the settlement date.
        Available only for inflation-linked instruments.
    break_even_inflation_rate_percent : float
        The market-based measure of expected inflation rate, expressed in
        percentages. It is computed from the yield of the inflation-linked
        instrument and the yield of a government benchmark instrument with the
        same maturity. This is an annual inflation rate. Two convention can be
        used to compute this breakeven inflation:

        * Japanese convention,
        * Common convention.

        Available only for inflation-linked instruments.
        For more details on the field calculation, please refer here.
    interpolated_break_even_inflation_rate_percent : float
        The breakeven inflation computed by using a benchmark yield that has
        been computed by an interpolation of the Government benchmark curve.
        Available only for inflation-linked instruments.
    tax_on_coupon_percent : float
        The tax rate on income. The value is expressed in percentages.
    tax_on_capital_gain_percent : float
        The tax rate on capital gain. The value is expressed in percentages.
    tax_on_yield_percent : float
        The tax rate applied to the yield of the bond for pricing. The value is
        expressed in percentages.
    tax_on_price_percent : float
        The reference price used for capital taxation. The tax on capital gain
        is levied on the excess of the par value over  TaxOnPricePercent  . The
        value is expressed in percentages.
    tax_equivalent_yield_percent : float
        The yield on a taxable instrument that an investor would earn to match
        the return on a comparable tax-exempt municipal bond. Available for
        municipal bonds. For more details on the field calculation, please
        refer here.
    tax_exempt_equivalent_yield_percent : float
        The yield on a tax-exempt municipal bond that an investor would earn to
        match the return on a comparable taxable instrument. Available for
        municipal bonds. For more details on the field calculation, please
        refer here.
    concession_fee : float
        The fee used to compute the net price of the bond. The value is
        expressed in the same units as the bond price (percentage or cash).
    current_index_percent : float
        The value of the index used to compute the current coupon. Available
        only for floating rate instruments.
    spread_over_index_percent : float
        The spread applied to the current index used to compute a coupon, also
        called a quoted margin. The value is expressed in basis percentages.
        Available only for floating rate instruments.
    """

    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). The default value is  today  ."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    price: Optional[float] = rest_field()
    """The instrument's price quoted according to the market conventions."""
    price_percent: Optional[float] = rest_field(name="pricePercent")
    """The instrument's price quoted according to the market convention defined by
     CleanOrDirtyConvention  ."""
    net_price: Optional[float] = rest_field(name="netPrice")
    """The instrument's price before deducting fees. The value is quoted according to the market
     convention defined by CashOrPercentConvention and CleanOrDirtyConvention.
     For more details on the field calculation, please refer here."""
    net_price_percent: Optional[float] = rest_field(name="netPricePercent")
    """The instrument's price before deducting fees. The value is expressed in percentages."""
    clean_price: Optional[float] = rest_field(name="cleanPrice")
    """The instrument's price excluding accrued interest. The value is quoted according to the market
     convention defined by  CashOrPercentConvention  ."""
    clean_price_percent: Optional[float] = rest_field(name="cleanPricePercent")
    """The price excluding accrued interest. The value is expressed in percentages.
     For more details on the field calculation, please refer here."""
    dirty_price: Optional[float] = rest_field(name="dirtyPrice")
    """The price of the instrument, which includes accrued interest. The value is quoted according to
     the market convention defined by  CashOrPercentConvention  ."""
    dirty_price_percent: Optional[float] = rest_field(name="dirtyPricePercent")
    """The price including accrued interest. The value is expressed in percentages.
     For more details on the field calculation, please refer here."""
    neutral_price: Optional[float] = rest_field(name="neutralPrice")
    """The price of the instrument, at which it moves neither up nor down over time. The value is
     quoted according to the market convention defined by  CashOrPercentConvention  . Available only
     for floating rate instruments."""
    yield_type: Optional[str] = rest_field(name="yieldType")
    """The yield type specified in the yield calculation convention and used for the instrument rate
     model. The possible values are listed  here  ."""
    issue_yield_percent: Optional[float] = rest_field(name="issueYieldPercent")
    """The yield computed from the issue price at the default redemption type. The value is expressed
     in percentages.  Default redemption types are: '  RedemptionAtWorstDate  ' for callable bond, '
     RedemptionAtBestDate  ' for puttable bond or '  RedemptionAtMaturityDate  ' in other cases."""
    yield_percent: Optional[float] = rest_field(name="yieldPercent")
    """The yield, if it is not defined in the pricing parameter, that equates the present value of the
     instrument to its dirty price, assuming that the yield is constant over the life of the
     instrument. The value is expressed in percentages."""
    net_yield_percent: Optional[float] = rest_field(name="netYieldPercent")
    """The yield of the bond at the redemption date computed from the net price. The value is
     expressed in percentages."""
    redemption_date: Optional[datetime.date] = rest_field(name="redemptionDate")
    """The date when the instrument can be redeemed. The notional of the instrument is also paid at
     this date. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
     RedemptionDate  is either defined in input pricing parameters or computed from
     RedemptionDateType  ."""
    redemption_price: Optional[float] = rest_field(name="redemptionPrice")
    """The price at which the instrument is redeemed."""
    redemption_date_type: Optional[str] = rest_field(name="redemptionDateType")
    """The type defining the redemption date of the instrument. The possible values are listed  here
     ."""
    redemption_yield_type: Optional[str] = rest_field(name="redemptionYieldType")
    """The type of the redemption yield at which the bond has been priced. The possible values are
     listed  here  ."""
    yield_to_maturity_percent: Optional[float] = rest_field(name="yieldToMaturityPercent")
    """The yield that makes the present value of the bond equal to its dirty price, assuming that the
     yield is constant over the life of the bond and that the bond will be redeemed at maturity or
     perpetuity. The value is expressed in percentages."""
    yield_to_worst_percent: Optional[float] = rest_field(name="yieldToWorstPercent")
    """The lowest yield among all yields calculated at each possible redemption dates, among which the
     bond issuer may choose to call the bond from its holder. This is the most favorable yield of a
     callable bond. The value is expressed in percentages. Available for callable bonds."""
    yield_to_worst_date: Optional[datetime.date] = rest_field(name="yieldToWorstDate")
    """The date at which  YieldToWorst  has been computed. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01'). Available for callable bonds."""
    yield_to_best_percent: Optional[float] = rest_field(name="yieldToBestPercent")
    """The highest yield among all yields calculated at each possible redemption dates, among which
     the bond holder may choose to put the bond to the issuer. This is the most favorable yield of a
     puttable bond. The value is expressed in percentages. Available for puttable bonds."""
    yield_to_best_date: Optional[datetime.date] = rest_field(name="yieldToBestDate")
    """The date at which  YieldToBest  has been computed. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01'). Available for puttable bonds."""
    yield_to_next_call_percent: Optional[float] = rest_field(name="yieldToNextCallPercent")
    """The yield that makes the present value of the bond equal to its dirty price, assuming that the
     yield is constant over the life of the bond and that the bond will be redeemed at the next call
     date. The value is expressed in percentages. Available for callable bonds."""
    yield_to_next_call_date: Optional[datetime.date] = rest_field(name="yieldToNextCallDate")
    """The date of the next call, when the bond issuer may choose to buy the bond from its holder. The
     value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Available for callable
     bonds."""
    yield_to_next_put_percent: Optional[float] = rest_field(name="yieldToNextPutPercent")
    """The yield that makes the present value of the bond equal to its dirty price, assuming that the
     yield is constant over the life of the bond and that the bond will be redeemed at next put
     date. The value is expressed in percentages. Available for puttable bonds."""
    yield_to_next_put_date: Optional[datetime.date] = rest_field(name="yieldToNextPutDate")
    """The date of the next put, when the bond holder may choose to sell the bond to its issuer. The
     value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Available for puttable
     bonds."""
    neutral_yield_percent: Optional[float] = rest_field(name="neutralYieldPercent")
    """The neutral yield of the instrument, at which its price moving neither up nor down over time.
     The value is expressed in basis points. Available only for floating rate instruments."""
    strip_yield_percent: Optional[float] = rest_field(name="stripYieldPercent")
    """The strip yield measures the return on only the debt portion of the instrument (removing the
     impact of any embedded options, or conversion rights, or accrued interest). The value is
     expressed in percentages."""
    discount_percent: Optional[float] = rest_field(name="discountPercent")
    """A difference between the instrument's price paid for and its par value. The value is expressed
     in percentages."""
    current_yield_percent: Optional[float] = rest_field(name="currentYieldPercent")
    """The current yield of the instrument. The value is expressed in percentages.
     For more details on the field calculation, please refer here."""
    annual_dividend: Optional[float] = rest_field(name="annualDividend")
    """The annual dividend. Available only for preferred stocks (IsPreferred = True).
     For more details on the field calculation, please refer here."""
    redemption_dates_array: Optional[List[datetime.date]] = rest_field(name="redemptionDatesArray")
    """The list of all possible dates, when the bond may be redeemed. This field is mainly used for
     bonds with options. Therefore, the bond may be redeemed at each call date."""
    redemption_yields_array: Optional[List[float]] = rest_field(name="redemptionYieldsArray")
    """The list of yields computed for each redemption date. The Nth yield is the one computed for the
     Nth redemption date from  RedemptionDatesArray  ."""
    redemption_neutral_yields_array: Optional[List[float]] = rest_field(name="redemptionNeutralYieldsArray")
    """The list of neutral yields computed for each redemption date. The Nth yield is the one computed
     for the Nth redemption date from  RedemptionDatesArray  . Available only for floating rate
     instruments."""
    redemption_prices_array: Optional[List[float]] = rest_field(name="redemptionPricesArray")
    """The list of prices computed for each redemption date. The Nth price is the one computed for the
     Nth redemption date from  RedemptionDatesArray  ."""
    redemption_date_types_array: Optional[List[str]] = rest_field(name="redemptionDateTypesArray")
    """The list of redemption date types computed for each redemption date. The Nth redemption type is
     the one computed for the Nth redemption date from  RedemptionDatesArray  . The possible values
     are listed  here  ."""
    redemption_yield_types_array: Optional[List[str]] = rest_field(name="redemptionYieldTypesArray")
    """The list of redemption yield types computed for each redemption date. The Nth redemption type
     is the one computed for the Nth redemption date from  RedemptionDatesArray  . The possible
     values are listed  here  ."""
    de_minimis_price: Optional[float] = rest_field(name="deMinimisPrice")
    """The threshold price for tax purposes, at which a discount bond should be taxed as a capital
     gain rather than as an ordinary income."""
    de_minimis_yield_percent: Optional[float] = rest_field(name="deMinimisYieldPercent")
    """The threshold yield for tax purposes. It is computed from  DeMinimisPrice  ."""
    adjusted_price: Optional[float] = rest_field(name="adjustedPrice")
    """The clean price adjusted for the difference between the refinancing rate and the coupon rate
     during the partial first period. The value is quoted according to the market convention defined
     by CashOrPercentConvention and CleanOrDirtyConvention. Available only for floating rate
     instruments."""
    adjusted_clean_price: Optional[float] = rest_field(name="adjustedCleanPrice")
    """The clean price of the instrument adjusted by InflationIndexRatio. It is computed with
     [inflationMode = Adjusted]. The value is quoted according to the market convention defined by
     CashOrPercentConvention. Available only for inflation-linked instruments.
     For more details on the field calculation, please refer here."""
    adjusted_dirty_price: Optional[float] = rest_field(name="adjustedDirtyPrice")
    """The dirty price of the instrument adjusted by InflationIndexRatio. It is computed with
     [inflationMode = Adjusted]. The value is quoted according to the market convention defined by
     CashOrPercentConvention. Available only for inflation-linked instruments.
     For more details on the field calculation, please refer here."""
    adjusted_yield_percent: Optional[float] = rest_field(name="adjustedYieldPercent")
    """The instrument yield computed with [  inflationMode  =  Adjusted  ]. The value is expressed in
     percentages. Available only for inflation-linked instruments."""
    adjusted_simple_margin_bp: Optional[float] = rest_field(name="adjustedSimpleMarginBp")
    """The average annual return of the floating rate instrument compared to its index rate. The
     measure is based on the adjusted clean price. The simple margin method does not take into
     account the current yield effect on the instrument's price, that is the value to the investor
     of buying an instrument below par or the cost of buying an instrument above par.  The value is
     expressed in basis points. Available only for floating rate instruments."""
    adjusted_total_margin_bp: Optional[float] = rest_field(name="adjustedTotalMarginBp")
    """The adjusted margin, which includes the additional or lost return realized if the price of the
     floating rate instrument is below or above par. The value is expressed in basis points.
     Available only for floating rate instruments."""
    discount_margin_bp: Optional[float] = rest_field(name="discountMarginBp")
    """The margin that is earned in addition to the floating index rate value of the instrument. The
     value is expressed in basis points. Available only for floating rate instruments."""
    simple_margin_bp: Optional[float] = rest_field(name="simpleMarginBp")
    """The average cash return per year of the instrument compared with its index rate. The value is
     expressed in basis points. Available only for floating rate instruments."""
    bond_option_free_price: Optional[float] = rest_field(name="bondOptionFreePrice")
    """The bond's price minus the price of the embedded option. Available for callable/puttable bonds."""
    bond_option_price: Optional[float] = rest_field(name="bondOptionPrice")
    """The price of the embedded option evaluated using the Hull-White model. Available for
     callable/puttable bonds."""
    quoted_price: Optional[float] = rest_field(name="quotedPrice")
    """The instrument's price quoted according to the market convention defined by  QuotationMode  ."""
    quoted_bid_price: Optional[float] = rest_field(name="quotedBidPrice")
    """The quoted bid price on the market."""
    quoted_ask_price: Optional[float] = rest_field(name="quotedAskPrice")
    """The quoted ask price on the market."""
    projected_index_percent: Optional[float] = rest_field(name="projectedIndexPercent")
    """The projected index rate value used for calculation of future cash flows of the instrument. By
     default, it is computed from market data according to the instrument convention. Usually the
     projected index is the last known value of the index. The value is expressed in percentages.
     Available only for floating rate instruments."""
    fx_spot: Optional[float] = rest_field(name="fxSpot")
    """The spot value of the cross-currency pair, which is the instrument currency against the
     reporting currency. It is used to convert amount to the reporting currency."""
    yield_to_maturity_spread_bp: Optional[float] = rest_field(name="yieldToMaturitySpreadBp")
    """The difference between the yield to maturity of the floating rate instrument and the effective
     internal rate of return (IRR) of the underlying index. The IRR of the index is calculated as a
     series of short-term investments that pay interest rates equal to the projected index rates,
     using the same frequency and day count convention as floating rate instruments. Available only
     for floating rate instruments."""
    inflation_index_ratio: Optional[float] = rest_field(name="inflationIndexRatio")
    """The value of the consumer price index (CPI) at the settlement date used to calculate the
     inflation-adjusted instrument price. Available only for inflation-linked instruments.
     For more details on the field calculation, please refer here."""
    inflation_current_index: Optional[float] = rest_field(name="inflationCurrentIndex")
    """The value of the consumer price index (  CPI  ) at the settlement date. Available only for
     inflation-linked instruments."""
    break_even_inflation_rate_percent: Optional[float] = rest_field(name="breakEvenInflationRatePercent")
    """The market-based measure of expected inflation rate, expressed in percentages. It is computed
     from the yield of the inflation-linked instrument and the yield of a government benchmark
     instrument with the same maturity. This is an annual inflation rate. Two convention can be used
     to compute this breakeven inflation:
     
     
     * Japanese convention,
     * Common convention.
     
     Available only for inflation-linked instruments.
     For more details on the field calculation, please refer here."""
    interpolated_break_even_inflation_rate_percent: Optional[float] = rest_field(
        name="interpolatedBreakEvenInflationRatePercent"
    )
    """The breakeven inflation computed by using a benchmark yield that has been computed by an
     interpolation of the Government benchmark curve. Available only for inflation-linked
     instruments."""
    tax_on_coupon_percent: Optional[float] = rest_field(name="taxOnCouponPercent")
    """The tax rate on income. The value is expressed in percentages."""
    tax_on_capital_gain_percent: Optional[float] = rest_field(name="taxOnCapitalGainPercent")
    """The tax rate on capital gain. The value is expressed in percentages."""
    tax_on_yield_percent: Optional[float] = rest_field(name="taxOnYieldPercent")
    """The tax rate applied to the yield of the bond for pricing. The value is expressed in
     percentages."""
    tax_on_price_percent: Optional[float] = rest_field(name="taxOnPricePercent")
    """The reference price used for capital taxation. The tax on capital gain is levied on the excess
     of the par value over  TaxOnPricePercent  . The value is expressed in percentages."""
    tax_equivalent_yield_percent: Optional[float] = rest_field(name="taxEquivalentYieldPercent")
    """The yield on a taxable instrument that an investor would earn to match the return on a
     comparable tax-exempt municipal bond. Available for municipal bonds.
     For more details on the field calculation, please refer here."""
    tax_exempt_equivalent_yield_percent: Optional[float] = rest_field(name="taxExemptEquivalentYieldPercent")
    """The yield on a tax-exempt municipal bond that an investor would earn to match the return on a
     comparable taxable instrument. Available for municipal bonds.
     For more details on the field calculation, please refer here."""
    concession_fee: Optional[float] = rest_field(name="concessionFee")
    """The fee used to compute the net price of the bond. The value is expressed in the same units as
     the bond price (percentage or cash)."""
    current_index_percent: Optional[float] = rest_field(name="currentIndexPercent")
    """The value of the index used to compute the current coupon. Available only for floating rate
     instruments."""
    spread_over_index_percent: Optional[float] = rest_field(name="spreadOverIndexPercent")
    """The spread applied to the current index used to compute a coupon, also called a quoted margin.
     The value is expressed in basis percentages. Available only for floating rate instruments."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        market_data_date: Optional[datetime.datetime] = None,
        valuation_date: Optional[datetime.datetime] = None,
        price: Optional[float] = None,
        price_percent: Optional[float] = None,
        net_price: Optional[float] = None,
        net_price_percent: Optional[float] = None,
        clean_price: Optional[float] = None,
        clean_price_percent: Optional[float] = None,
        dirty_price: Optional[float] = None,
        dirty_price_percent: Optional[float] = None,
        neutral_price: Optional[float] = None,
        yield_type: Optional[str] = None,
        issue_yield_percent: Optional[float] = None,
        yield_percent: Optional[float] = None,
        net_yield_percent: Optional[float] = None,
        redemption_date: Optional[datetime.date] = None,
        redemption_price: Optional[float] = None,
        redemption_date_type: Optional[str] = None,
        redemption_yield_type: Optional[str] = None,
        yield_to_maturity_percent: Optional[float] = None,
        yield_to_worst_percent: Optional[float] = None,
        yield_to_worst_date: Optional[datetime.date] = None,
        yield_to_best_percent: Optional[float] = None,
        yield_to_best_date: Optional[datetime.date] = None,
        yield_to_next_call_percent: Optional[float] = None,
        yield_to_next_call_date: Optional[datetime.date] = None,
        yield_to_next_put_percent: Optional[float] = None,
        yield_to_next_put_date: Optional[datetime.date] = None,
        neutral_yield_percent: Optional[float] = None,
        strip_yield_percent: Optional[float] = None,
        discount_percent: Optional[float] = None,
        current_yield_percent: Optional[float] = None,
        annual_dividend: Optional[float] = None,
        redemption_dates_array: Optional[List[datetime.date]] = None,
        redemption_yields_array: Optional[List[float]] = None,
        redemption_neutral_yields_array: Optional[List[float]] = None,
        redemption_prices_array: Optional[List[float]] = None,
        redemption_date_types_array: Optional[List[str]] = None,
        redemption_yield_types_array: Optional[List[str]] = None,
        de_minimis_price: Optional[float] = None,
        de_minimis_yield_percent: Optional[float] = None,
        adjusted_price: Optional[float] = None,
        adjusted_clean_price: Optional[float] = None,
        adjusted_dirty_price: Optional[float] = None,
        adjusted_yield_percent: Optional[float] = None,
        adjusted_simple_margin_bp: Optional[float] = None,
        adjusted_total_margin_bp: Optional[float] = None,
        discount_margin_bp: Optional[float] = None,
        simple_margin_bp: Optional[float] = None,
        bond_option_free_price: Optional[float] = None,
        bond_option_price: Optional[float] = None,
        quoted_price: Optional[float] = None,
        quoted_bid_price: Optional[float] = None,
        quoted_ask_price: Optional[float] = None,
        projected_index_percent: Optional[float] = None,
        fx_spot: Optional[float] = None,
        yield_to_maturity_spread_bp: Optional[float] = None,
        inflation_index_ratio: Optional[float] = None,
        inflation_current_index: Optional[float] = None,
        break_even_inflation_rate_percent: Optional[float] = None,
        interpolated_break_even_inflation_rate_percent: Optional[float] = None,
        tax_on_coupon_percent: Optional[float] = None,
        tax_on_capital_gain_percent: Optional[float] = None,
        tax_on_yield_percent: Optional[float] = None,
        tax_on_price_percent: Optional[float] = None,
        tax_equivalent_yield_percent: Optional[float] = None,
        tax_exempt_equivalent_yield_percent: Optional[float] = None,
        concession_fee: Optional[float] = None,
        current_index_percent: Optional[float] = None,
        spread_over_index_percent: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondPricingParameters(_model_base.Model):
    """Bond pricing parameters.

    Attributes
    ----------
    adjusted_clean_price : float
        The clean price of the instrument adjusted by InflationIndexRatio. It
        is computed with [inflationMode = Adjusted]. The value is quoted
        according to the market convention defined by CashOrPercentConvention.
        Available only for inflation-linked instruments. Optional. No default
        value applies.
    adjusted_dirty_price : float
        The dirty price of the instrument adjusted by InflationIndexRatio. It
        is computed with [inflationMode = Adjusted]. The value is quoted
        according to the market convention defined by CashOrPercentConvention.
        Available only for inflation-linked instruments. Optional. No default
        value applies.
    adjusted_yield_percent : float
        The instrument yield computed with [inflationMode = Adjusted]. The
        value is expressed in percentages. Available only for inflation-linked
        instruments. Optional. No default value applies.
    apply_tax_to_full_pricing : bool
        The indicator weather to apply tax rates for computations of pricing
        analysis, risk measure and spread measure fields. Optional. Default
        value is 'False'.
    asset_swap_spread_bp : float
        The spread over or under the reference rate (e.g., 'LIBOR') for a bond
        whose cash flows have been converted from fixed to floating via an
        interest rate swap. The value is expressed in basis points. Available
        for fixed-rate and floating-rate notes. Optional. No default value
        applies.
    benchmark_at_issue_price : float
        The price of the benchmark at issue, equivalent to the
        benchmarkAtIssueYieldPercent. Optional. By default, the price is
        computed or retrieved from the market data.
    benchmark_at_issue_ric : str
        The RIC of the benchmark at issue date of the instrument to be priced.
        Optional. No default value applies.
    benchmark_at_issue_spread_bp : float
        The spread applied to the yield of the benchmark at issue and used to
        compute the yield of the instrument to be priced. The value is
        expressed in basis points. Optional. No default value applies.
    benchmark_at_issue_yield_percent : float
        The yield percent of the benchmark at issue, used to compute the
        benchmarkAtIssueSpreadBp. The yield is computed using the nearest point
        or by interpolation of the benchmark curve (defined in pricing
        parameter benchmarkYieldSelectionMode). Optional. By default, the yield
        is computed or retrieved from the market data.
    benchmark_at_redemption_price : float
        The price of the benchmark at redemption date of the instrument to be
        priced, equivalent to the benchmarkAtRedemptionYieldPercent. Optional.
        By default, the price is computed or retrieved from the market data.
    benchmark_at_redemption_spread_bp : float
        The spread applied to the yield of the benchmark at redemption and used
        to compute the yield of the instrument to be priced. The value is
        expressed in basis points. Optional. No default value applies.
    benchmark_at_redemption_yield_percent : float
        The yield percent of the benchmark at redemption date of the instrument
        to be priced, used to compute the benchmarkAtRedemptionSpreadBp.
        Optional. By default,the yield is computed or retrieved from the market
        data.
    benchmark_yield_selection_mode : str or ~analyticsapi.models.BenchmarkYieldSelectionModeEnum
        The mode of benchmark yield selection for the instrument. Optional.
        Default value is 'Interpolate'. Known values are: "Interpolate" and
        "Nearest".
    bond_recovery_rate_percent : float
        The rate which defines the cash amount that a convertible bond holder
        receives in case of the convertible bonds default. It is expressed as
        a percentage of the bond's face value. Optiponal. The default value is
        40. Applicable for Convertible Bonds.
    cash_amount : float
        The cash amount of the instrument, computed as [DirtyPricePercent / 100
        * NormalizationFactor * DenominationMinimum]. Optional. No default
        value applies.
    cds_recovery_rate_percent : float
        The rate which defines the cash amount that a convertible bond holder
        receives in case of the convertible bonds default. The value is
        expressed as a percentage of the bond's face value. It is applicable
        when CreditSpreadType is equal to 'TermStructure'. Optional. The
        default value is retrieved from CDS curve, otherwise it defaults to 40.
        Applicable for Convertible Bonds.
    clean_price : float
        The instrument's price excluding accrued interest. The value is quoted
        according to the market convention defined by CashOrPercentConvention.
        Optional. No default value applies.
    compute_all_analytics_with_report_ccy : bool
        The indicator used to compute all analytics in the report currency. The
        possible values are:

        * True: the pricing will be done in the reporting currency using a FX forward curve,
        * False: the pricing will be done using notional currency.

        Optional. Default value is 'False'.
    compute_cash_flow_from_issue_date : bool
        The indicator defines the date, from which the cash flows will be
        computed. The possible values are:

        * True: from issueDate,
        * False: from tradeDate.

        Optional. Default value is 'False'.
    concession_fee : float
        The fee used to calculate the netPrice of the bond as [netPrice = price
        + concessionFee]. The value is expressed in the same units as the bond
        price (percentage or cash). Optional. Default value is '0'.
    credit_spread_type : str or ~analyticsapi.models.CreditSpreadTypeEnum
        The credit curve spread type used for the convertible bond pricing. The
        possible values are:

        * FlatSpread: the credit spread is fixed at the same level for the remaining life of
        convertible bond,
        * TermStructure: the credit spread is different for the remaining life of convertible bond.

        Optional. The default value is 'TermStructure' unless FlatCreditSpreadBp has been set : in that
        case default is 'FlatSpread' . If credit curve data is not available it defaults to
        'FlatSpread'.
        Applicable for Convertible Bonds. Known values are: "FlatSpread" and "TermStructure".
    current_yield_percent : float
        The current yield of the instrument, computed as [CouponRatePercent x
        PriceFactor / DirtyPrice]. The value is expressed in percentages.
        Optional. No default value applies.
    default_quote : ~analyticsapi.models.DefaultBondQuote
    dirty_price : float
        The instrument's price, which includes accrued interest. The value is
        quoted according to the market convention defined by
        CashOrPercentConvention. Optional. No default value applies.
    discount_margin_bp : float
        The margin that is earned in addition to the floating index rate value
        of the instrument. The value is expressed in basis points. Available
        only for floating rate instruments. Optional. No default value applies.
    discount_percent : float
        A difference between the instrument's price paid for and its par value.
        The value is expressed in percentages. Optional. No default value
        applies.
    dividend_type : str or ~analyticsapi.models.IPADividendTypeEnum
        The type of dividend of the underlying asset. Optional. The default
        value is derived from the bond structure. Applicable for Convertible
        Bonds. Known values are: "None", "ForecastTable", "HistoricalYield",
        "ForecastYield", "ImpliedYield", "ImpliedTable", and "Futures".
    dividend_yield_percent : float
        The ratio of annualized dividends to the underlying asset's price. The
        value is expressed in percentages. Optional. By default, the value is
        retrieved from the market data. If it is not available, the default
        value is 0. Applicable for Convertible Bonds.
    edsf_benchmark_curve_yield_percent : float
        The yield percent of the Euro-Dollar future benchmark curve, used to
        compute the edsfSpreadBp. The yield is computed at the instrument
        redemption date using the nearest point or by interpolation of the
        benchmark curve (defined in pricing parameter
        benchmarkYieldSelectionMode). Optional. By default, the yield is
        computed or retrieved from the market data.
    edsf_spread_bp : float
        The spread applied to the yield of the Euro-Dollar future benchmark
        curve and used to compute the yield of the instrument to be priced.
        This spread is computed for the USD bond whose maturity is under 2
        years. The mode of benchmark yield selection for the instrument
        redemption date is defined in pricing parameter
        benchmarkYieldSelectionMode. The value is expressed in basis points.
        Optional. No default value applies.
    efp_benchmark_price : float
        The price of the EFP benchmark in case of an Australian fixed rate
        bond. Optional. By default, the price is computed or retrieved from the
        market data.
    efp_benchmark_ric : str
        The RIC of the EFP benchmark, if the instrument to be priced is an
        Australian fixed rate bond. The RIC can only be YTTc1, YTTc2, YTCc1 or
        YTCc2. Optional. The default value is 'YTTc1'.
    efp_benchmark_yield_percent : float
        The yield percent of the EFP benchmark in case of an Australian fixed
        rate bond. Optional. By default,the yield is computed or retrieved from
        the market data.
    efp_spread_bp : float
        The spread applied to the yield of the Exchange of futures for physical
        (EFP) benchmark and used to compute the yield of the instrument to be
        priced in case of an Australian fixed rate bond. The value is expressed
        in basis points. Optional. No default value applies.
    flat_credit_spread_bp : float
        The flat credit spread used for pricing of the convertible bond. The
        value is expressed in basis points. It is applicable when
        CreditSpreadType is equal to 'Flat'. Optional. The default value is
        retrieved from flatCreditSpreadTenor point. If credit curve data is not
        available, the default value is 0. Applicable for Convertible Bonds.
    flat_credit_spread_tenor : str
        The code indicating the tenor on the credit curve of the convertible
        bond's issuer used to retrieve the value of FlatCreditSpreadBp (e.g.,
        '1Y'). It is applicable when CreditSpreadType is equal to 'FlatSpread'.
        The requested tenor must exist on the credit curve of the issuer which
        is used for the currency. Optional. The default value is '5Y'. If it
        does not exist, the first available tenor is used. Applicable for
        Convertible Bonds.
    fx_price_side : str or ~analyticsapi.models.FxPriceSideEnum
        FX price side to consider when retrieving FX rates (Mid, Bid, Ask,
        Last, Close). Known values are: "Mid", "Bid", "Ask", and "Last".
    fx_stock_correlation : float
        The correlation rate between the underlying stock's price and FX Spot
        of the currency in which the convertible bond is issued. The possible
        value ranges between -1 and 1. Optional. The default value is 0.
        Applicable for cross-currency Convertible Bonds.
    fx_volatility_percent : float
        The Fx Spot volatility used for pricing of the convertible bond. The
        value is expressed in percentages. It is available only for foreign
        currency convertible bonds (any convertible bond whose face value is
        issued in a currency different from issuing company's domestic
        currency). Optional. The default value is 0.
    fx_volatility_tenor : str
        The code indicating the Fx Spot volatility tenor used to retrieve the
        value of UnderlyingFxVolatilityPercent (e.g., '6M', '1Y'). The
        requested tenor must exist in the volatility surface which is used for
        the currency pair. It is available only for foreign currency
        convertible bonds. It is ignored if fxVolatilityPercent is specified.
        Optional. The default value is '1Y'. If it does not exist, the first
        available tenor is used.
    gov_country_benchmark_curve_price : float
        The price of the government country benchmark curve, equivalent to the
        govCountryBenchmarkCurveYieldPercent. Optional. By default, the price
        is computed or retrieved from the market data.
    gov_country_benchmark_curve_yield_percent : float
        The yield percent of the government country benchmark curve, used to
        compute the govCountrySpreadBp. The government country benchmark curve
        is computed from the country of the instrument. The yield is computed
        at the instrument redemption date using the nearest point or by
        interpolation of the benchmark curve (defined in pricing parameter
        benchmarkYieldSelectionMode). It is available only for European
        countries and USA (USA govCountry benchmark is US Treasuries).
        Optional. By default, the yield is computed or retrieved from the
        market data.
    gov_country_spread_bp : float
        The spread applied to the yield of the government country benchmark
        curve and used to compute the yield of the instrument to be priced. The
        government country benchmark curve is computed from the country of the
        instrument. It is available only for European countries and USA (USA
        govCountry benchmark is US Treasuries). The mode of benchmark yield
        selection for the instrument redemption date is defined in pricing
        parameter benchmarkYieldSelectionMode. The value is expressed in basis
        points. Optional. No default value applies.
    government_benchmark_curve_price : float
        The price of the government benchmark curve, equivalent to the
        governmentBenchmarkCurveYieldPercent. Optional. By default, the price
        is computed or retrieved from the market data.
    government_benchmark_curve_yield_percent : float
        The yield percent of the government benchmark curve used to compute the
        governmentSpreadBp. The government benchmark curve is computed from the
        currency of the instrument. For example, curve for Italian bond is a
        European benchmark. The yield is computed at the instrument redemption
        date using the nearest point or by interpolation of the benchmark curve
        (defined in pricing parameter benchmarkYieldSelectionMode). Optional.
        By default, the yield is computed or retrieved from the market data.
    government_spread_bp : float
        The spread applied to the yield of the government benchmark curve and
        used to compute the yield of the instrument to be priced. The
        government benchmark curve is computed from the currency of the
        instrument. The mode of benchmark yield selection for the instrument
        redemption date is defined in pricing parameter
        benchmarkYieldSelectionMode. The value is expressed in basis points.
        Optional. No default value applies.
    hull_white_parameters : ~analyticsapi.models.HullWhiteParameters
    inflation_mode : str or ~analyticsapi.models.InflationModeEnum
        The indicator used to define whether instrument parameters should be
        adjusted from inflation or not. Available only for inflation-linked
        instruments. Optional. By default, 'Default' is used. That means it
        depends on the instrument quotation convention. Known values are:
        "Unadjusted", "Adjusted", and "Default".
    is_coupon_payment_adjustedfor_leap_year : bool
        An indicator whether a fixed coupon market convention with 365.25 days
        in a year is used to calculate yield and margin. It can be requested if
        projectedIndexCalculationMethod = "ConstantCouponPayment". The possible
        values are:

        * True: the year fraction assumes 365.25 days,
        * False: the market convention is used.

        Optional. The default value is 'True'.
    issuer_benchmark_curve_yield_percent : float
        The yield percent of the issuer benchmark curve, used to compute the
        issuerSpreadBp. Optional. By default, the yield is computed or
        retrieved from the market data.
    issuer_spread_bp : float
        The spread applied to the yield of the issuer benchmark curve and used
        to compute the yield of the instrument to be priced. The value is
        expressed in basis points. Optional. No default value applies.
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).
        Optional. By default, marketDataDate is valuationDate or today.
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency. Optional. By default, the value is computed from the notional
        amount. (NotionalAmount, MarketValueInDealCcy and
        MarketValueInReportCcy cannot be defined at the same time).
    market_value_in_report_ccy : float
        The market value ot the instrument computed as [MarketValueInDealCcy x
        FxSpot]. The value is expressed in the reporting currency. Optional. By
        default, the value is computed from the notional amount (FxSpot,
        NotionalAmount, MarketValueInDealCcy and MarketValueInReportCcy cannot
        be defined at the same time).
    net_price : float
        The instrument's price before deducting fees. It is computed as [price
        + concessionFee]. The value is quoted according to the market
        convention defined by CashOrPercentConvention and
        CleanOrDirtyConvention. Optional. No default value applies.
    neutral_yield_percent : float
        The neutral yield of the instrument, at which its price moving neither
        up nor down over time. The value is expressed in basis points.
        Available only for floating rate instruments. Optional. No default
        value applies.
    next_coupon_rate_percent : float
        The annual rate of the next coupon. The coupon may be paid in kind
        (PIK) or in cash. The value is expressed in percentages. Available only
        for floating rate instruments. Optional. By default, the value is
        computed from the current index.
    ois_zc_benchmark_curve_yield_percent : float
        The yield percent of the overnight indexed swap (OIS) zero curve used
        to compute the oisZcSpreadBp. The OIS zero curve is computed from the
        pricing currency. The yield is computed at the instrument redemption
        date using the nearest point or by interpolation of the benchmark curve
        (defined in pricing parameter benchmarkYieldSelectionMode). Optional.
        By default, the yield is computed or retrieved from the market data.
    ois_zc_spread_bp : float
        The spread applied to the yield of the overnight indexed swap (OIS)
        zero curve and used to compute the yield of the instrument to be
        priced. The OIS zero curve is computed from the pricing currency. The
        value is expressed in basis points. Optional. No default value applies.
    option_adjusted_spread_bp : float
        The spread applied to the benchmark yield curve and used to compute the
        yield of the instrument to be priced, taking into account the embedded
        options. The value is expressed in basis points. Optional. No default
        value applies.
    price : float
        The instrument's price quoted according to the market convention
        defined by CashOrPercentConvention and CleanOrDirtyConvention.
        Optional. No default value applies.
    price_side : str or ~analyticsapi.models.PriceSideEnum
        The price side of the instrument which comes from the instrument's
        quote or from the curve (derived from quotes) used to value the
        instrument. The possible values are: Bid, Ask, Mid. Optional. Default
        value is 'Mid'. Known values are: "Mid", "Bid", "Ask", and "Last".
    projected_index_calculation_method : str or ~analyticsapi.models.ProjectedIndexCalculationMethodEnum
        The method used to define how the projected floating index rate value
        is computed for a floating rate instrument. The possible values are:

        * ConstantIndex: future index values are considered as constant and equal to the projected
        index value,
        * ForwardIndex: future index values are computed using a forward curve,
        * ConstantCouponPayment: coupon payments are computed based on fixed coupon market convention
        with the same index and accrued periods for every coupon period.

        Optional. Default values are:

        * 'ForwardIndex' for Preferreds and Brazilian Debenture bonds,
        * 'ConstantIndex' in other cases. Known values are: "ConstantIndex", "ForwardIndex", and
        "ConstantCouponPayment".
    projected_index_percent : float
        The projected index rate value used for calculation of future cash
        flows of the floating rate instrument. Usually the projected index is
        the last known value of the index. The value is expressed in
        percentage. This parameter can be used if the parameter
        projectedIndexCalculationMethod is set to ConstantIndex. Optional. By
        default, the projected index rate value is computed from the market
        data according to the instrument convention.
    quote_fallback_logic : str or ~analyticsapi.models.QuoteFallbackLogicEnum
        The indicator used to define the fallback logic for the quotation of
        the instrument. Optional. No default value applies. Known values are:
        "None" and "BestField".
    quoted_price : float
        The instrument's price quoted according to the market convention
        defined by QuotationMode. Optional. No default value applies.
    rating_benchmark_curve_yield_percent : float
        The yield percent of the rating benchmark curve used to compute the
        ratingSpreadBp. The yield is computed at the instrument redemption date
        using the nearest point or by interpolation of the benchmark curve
        (defined in pricing parameter benchmarkYieldSelectionMode). Optional.
        By default, the yield is computed or retrieved from the market data.
    rating_spread_bp : float
        The spread applied to the yield of the rating benchmark curve and used
        to compute the yield of the instrument to be priced. The mode of
        benchmark yield selection for the instrument redemption date is defined
        in pricing parameter benchmarkYieldSelectionMode. The value is
        expressed in basis points. Optional. No default value applies.
    redemption_date : ~datetime.datetime
        The date when the instrument can be redeemed. If it is set for the
        redeemable bond, the next available date from RedemptionDatesArray is
        returned. Otherwise, the defult value is returned. The notional of the
        instrument is also paid at this date. The value is expressed in ISO
        8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
        Optional. By default, the value is equal to endDate.
    redemption_date_type : str or ~analyticsapi.models.RedemptionDateTypeEnum
        The type defining the redemption date of the instrument. Optional. The
        value is derived from the rate structure of the bond. Default values
        are:

        * 'RedemptionAtWorstDate' for callable bond,
        * 'RedemptionAtBestDate' for puttable bond,
        * 'RedemptionAtMaturityDate' in other cases. Known values are: "RedemptionAtMaturityDate",
        "RedemptionAtCallDate", "RedemptionAtPutDate", "RedemptionAtWorstDate", "RedemptionAtBestDate",
        "RedemptionAtSinkDate", "RedemptionAtParDate", "RedemptionAtPremiumDate",
        "RedemptionAtPerpetuity", "RedemptionAtCustomDate", "RedemptionAtMakeWholeCallDate",
        "RedemptionAtAverageLife", "RedemptionAtPartialCallDate", "RedemptionAtPartialPutDate",
        "RedemptionAtNextDate", and "NativeRedemptionDate".
    report_ccy : str
        The currency code set for the fields ending with 'xxxInReportCcy'. The
        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
        Optional. No default value applies.
    rounding_parameters : ~analyticsapi.models.BondRoundingParameters
    sector_rating_benchmark_curve_yield_percent : float
        The yield percent of the sector rating benchmark curve used to compute
        the sectorRatingSpreadBp. The yield is computed at the instrument
        redemption date using the nearest point or by interpolation of the
        benchmark curve (defined in pricing parameter
        benchmarkYieldSelectionMode). Optional. By default, the yield is
        computed or retrieved from the market data.
    sector_rating_spread_bp : float
        The spread applied to the yield of the sector rating benchmark curve
        and used to compute the yield of the instrument to be priced. The mode
        of benchmark yield selection for the instrument redemption date is
        defined in pricing parameter benchmarkYieldSelectionMode. The value is
        expressed in basis points. Optional. No default value applies.
    settlement_convention : str
        The settlement tenor of the instrument (e.g., '1WD'), used to calculate
        SettlementDate. Only 'D' (days) and 'WD' (working days) are supported.
        If another period code is used, settlementConvention is set to '0WD'.
        Optional. If instrumentCode is defined, the value comes from the
        instrument reference data. Only two parameters out of
        settlementConvention, marketDataDate and valuationDate can be
        overridden at the same time.
    simple_margin_bp : float
        The average cash return per year of the instrument compared with its
        index rate. The value is expressed in basis points. Available only for
        floating rate instruments. Optional. No default value applies.
    stock_borrow_rate_percent : float
        The rate at which the underlying asset can be borrowed. The value is
        expressed in percentages. Optional. The default value is 0. Applicable
        for Convertible Bonds.
    stock_flat_volatility_percent : float
        The underlying asset's volatility used for pricing of the convertible
        bond. The value is expressed in percentages. It is applicable when
        VolatilityType is equal to 'Flat'. Optional. By default the value is
        retrieved from the market data and UnderlyingFlatVolatilityTenor. If
        the market data is empty, it defaults to 15. Applicable for Convertible
        Bonds.
    stock_flat_volatility_tenor : str
        The code indicating the underlying asset's volatility tenor used to
        retrieve the value of UnderlyingFlatVolatilityPercent (e.g., '90D',
        '1Y'). The requested tenor must exist in the volatility environment
        which is used for the currency. It is applicable when VolatilityType is
        equal to 'Flat'. It is ignored if stockFlatVolatilityPercent is
        specified. Optional. The default value is '200D'. If it is not
        available, the following values are used: '90D', then first available.
        Applicable for Convertible Bonds.
    stock_price_on_default : float
        The underlying asset's price agreed in the event of the convertible
        bond default. The value is expressed in the deal currency. Optional.
        The default value is 0. Applicable for Convertible Bonds.
    strip_yield_percent : float
        The strip yield measures the return on only the debt portion of the
        instrument (removing the impact of any embedded options, or conversion
        rights, or accrued interest). The value is expressed in percentage.
        Optional. No default value applies.
    swap_benchmark_curve_yield_percent : float
        The yield percent of the swap benchmark curve, which can be used to
        compute the swapSpreadBp. Optional. By default, the yield is computed
        or retrieved from the market data.
    swap_spread_bp : float
        The spread applied to the yield of the swap benchmark curve and used to
        compute the yield of the instrument to be priced. The value is
        expressed in basis points. Optional. No default value applies.
    swap_spread_tenor : str
        The code indicating the interest rate curve tenor used for SwapSpreadBp
        computations. The possible value is 'OIS'. Available for fixed-rate and
        floating-rate notes. Optional. If not provided, the discount curve
        basis is used as default value.
    tax_on_capital_gain_percent : float
        The tax rate on capital gain. The value is expressed in percentages.
        Optional. Default value is '0'.
    tax_on_coupon_percent : float
        The tax rate on income. The value is expressed in percentages.
        Optional. Default value is '0'.
    tax_on_price_percent : float
        The reference price used for capital taxation. The tax on capital gain
        is levied on the excess of the par value over TaxOnPricePercent. The
        value is expressed in percentages. Optional. Default value is '0'.
    tax_on_yield_percent : float
        The tax rate applied to the yield of the bond for pricing. The value is
        expressed in percentages. Optional. Default value is '0'.
    trade_date : ~datetime.datetime
        The date when the instrument is traded. The value is expressed in ISO
        8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
        Optional. By default, tradeDate is marketDataDate, use tradeDate to
        define a default valuationDate for future dates.
    use_settlement_date_from_quote : bool
        The indicator used to define whether to use the settlement date of the
        quote or one computed from marketDataDate. This option should be used
        only in real-time. The possible values are:

        * True: settlement date is used,
        * False: marketDataDate is used.

        Optional. Default value is 'False'.
    user_defined_benchmark_price : float
        The price of a user defined benchmark, equivalent to the
        userDefinedBenchmarkYieldPercent. Optional. By default, the price is
        computed or retrieved from the market data.
    user_defined_benchmark_yield_percent : float
        The yield percent of a user-defined benchmark used to compute the
        userDefinedSpreadBp. Optional. By default, the yield is computed or
        retrieved from the market data.
    user_defined_spread_bp : float
        The spread applied to the yield of user-defined benchmark and used to
        compute the yield of the instrument to be priced. The value is
        expressed in basis points. Optional. No default value applies.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    volatility_term_structure_type : str or ~analyticsapi.models.VolatilityTermStructureTypeEnum
        The type of the underlying asset's volatility term structure used in
        pricing. It applies when UnderlyingVolatilityType is equal to
        'TermStructure'. The possible values are:

        * Implied: the volatility anticipated for the underlying asset for the remaining life of the
        convertible bond (it cannot be used in historical request),
        * Historical: the volatility of the underlying asset during a period in the past (it cannot be
        used when volatilityType is set to 'TermStructure').

        Optional. The default values are:

        * Implied: for real-time request when volatilityType is set to 'TermStructure',
        * Historical: for other scenarios.

        Applicable for Convertible Bonds. Known values are: "Historical" and "Implied".
    volatility_type : str or ~analyticsapi.models.IPAVolatilityTypeEnum
        The type of underlying asset's volatility used for the convertible bond
        pricing. The possible values are:

        * Flat: the volatility is fixed at the same level for the remaining life of convertible bond,
        * TermStructure: the volatility is different for the remaining life of convertible bond.

        Optional. The default value is 'Flat'.
        Applicable for Convertible Bonds. Known values are: "Flat" and "TermStructure".
    yield_percent : float
        The yield of the instrument expressed in percentages. Optional. No
        default value applies.
    yield_type : str or ~analyticsapi.models.YieldTypeEnum
        The yield type specified in the yield calculation convention and used
        for the instrument rate model. Optional. Default value is 'Native' (no
        specific yield type is defined). Known values are: "Native", "UsGovt",
        "UsTBills", "Isma", "Euroland", "Discount_Actual_360",
        "Discount_Actual_365", "MoneyMarket_Actual_360",
        "MoneyMarket_Actual_365", "MoneyMarket_Actual_Actual",
        "Bond_Actual_364", "Japanese_Simple", "Japanese_Compounded",
        "Moosmueller", "Braess_Fangmeyer", "Weekend", "TurkishCompounded",
        "Annual_Equivalent", "Semiannual_Equivalent", "Quarterly_Equivalent",
        and "MarketReference".
    z_spread_bp : float
        Zero-volatility spread (Z-spread) computed as the constant spread that
        makes the price of the instrument equal to the present value of its
        cash flows when added to the yield at each point on Zero-curve where
        cash flow is received. The value is expressed in basis points.
        Optional. No default value applies.
    """

    adjusted_clean_price: Optional[float] = rest_field(name="adjustedCleanPrice")
    """The clean price of the instrument adjusted by InflationIndexRatio. It is computed with
     [inflationMode = Adjusted]. The value is quoted according to the market convention defined by
     CashOrPercentConvention. Available only for inflation-linked instruments.
     Optional. No default value applies."""
    adjusted_dirty_price: Optional[float] = rest_field(name="adjustedDirtyPrice")
    """The dirty price of the instrument adjusted by InflationIndexRatio. It is computed with
     [inflationMode = Adjusted]. The value is quoted according to the market convention defined by
     CashOrPercentConvention. Available only for inflation-linked instruments.
     Optional. No default value applies."""
    adjusted_yield_percent: Optional[float] = rest_field(name="adjustedYieldPercent")
    """The instrument yield computed with [inflationMode = Adjusted]. The value is expressed in
     percentages. Available only for inflation-linked instruments.
     Optional. No default value applies."""
    apply_tax_to_full_pricing: Optional[bool] = rest_field(name="applyTaxToFullPricing")
    """The indicator weather to apply tax rates for computations of pricing analysis, risk measure and
     spread measure fields.
     Optional. Default value is 'False'."""
    asset_swap_spread_bp: Optional[float] = rest_field(name="assetSwapSpreadBp")
    """The spread over or under the reference rate (e.g., 'LIBOR') for a bond whose cash flows have
     been converted from fixed to floating via an interest rate swap. The value is expressed in
     basis points. Available for fixed-rate and floating-rate notes.
     Optional. No default value applies."""
    benchmark_at_issue_price: Optional[float] = rest_field(name="benchmarkAtIssuePrice")
    """The price of the benchmark at issue, equivalent to the benchmarkAtIssueYieldPercent.
     Optional. By default, the price is computed or retrieved from the market data."""
    benchmark_at_issue_ric: Optional[str] = rest_field(name="benchmarkAtIssueRic")
    """The RIC of the benchmark at issue date of the instrument to be priced.
     Optional. No default value applies."""
    benchmark_at_issue_spread_bp: Optional[float] = rest_field(name="benchmarkAtIssueSpreadBp")
    """The spread applied to the yield of the benchmark at issue and used to compute the yield of the
     instrument to be priced. The value is expressed in basis points.
     Optional. No default value applies."""
    benchmark_at_issue_yield_percent: Optional[float] = rest_field(name="benchmarkAtIssueYieldPercent")
    """The yield percent of the benchmark at issue, used to compute the benchmarkAtIssueSpreadBp. The
     yield is computed using the nearest point or by interpolation of the benchmark curve (defined
     in pricing parameter benchmarkYieldSelectionMode).
     Optional. By default, the yield is computed or retrieved from the market data."""
    benchmark_at_redemption_price: Optional[float] = rest_field(name="benchmarkAtRedemptionPrice")
    """The price of the benchmark at redemption date of the instrument to be priced, equivalent to the
     benchmarkAtRedemptionYieldPercent.
     Optional. By default, the price is computed or retrieved from the market data."""
    benchmark_at_redemption_spread_bp: Optional[float] = rest_field(name="benchmarkAtRedemptionSpreadBp")
    """The spread applied to the yield of the benchmark at redemption and used to compute the yield of
     the instrument to be priced. The value is expressed in basis points.
     Optional. No default value applies."""
    benchmark_at_redemption_yield_percent: Optional[float] = rest_field(name="benchmarkAtRedemptionYieldPercent")
    """The yield percent of the benchmark at redemption date of the instrument to be priced, used to
     compute the benchmarkAtRedemptionSpreadBp.
     Optional. By default,the yield is computed or retrieved from the market data."""
    benchmark_yield_selection_mode: Optional[Union[str, "_models.BenchmarkYieldSelectionModeEnum"]] = rest_field(
        name="benchmarkYieldSelectionMode"
    )
    """The mode of benchmark yield selection for the instrument.
     Optional. Default value is 'Interpolate'. Known values are: \"Interpolate\" and \"Nearest\"."""
    bond_recovery_rate_percent: Optional[float] = rest_field(name="bondRecoveryRatePercent")
    """The rate which defines the cash amount that a convertible bond holder receives in case of the
     convertible bonds default.
     It is expressed as a percentage of the bond's face value.
     Optiponal. The default value is 40.
     Applicable for Convertible Bonds."""
    cash_amount: Optional[float] = rest_field(name="cashAmount")
    """The cash amount of the instrument, computed as [DirtyPricePercent / 100 * NormalizationFactor *
     DenominationMinimum].
     Optional. No default value applies."""
    cds_recovery_rate_percent: Optional[float] = rest_field(name="cdsRecoveryRatePercent")
    """The rate which defines the cash amount that a convertible bond holder receives in case of the
     convertible bonds default.
     The value is expressed as a percentage of the bond's face value. It is applicable when
     CreditSpreadType is equal to 'TermStructure'.
     Optional. The default value is retrieved from CDS curve, otherwise it defaults to 40.
     Applicable for Convertible Bonds."""
    clean_price: Optional[float] = rest_field(name="cleanPrice")
    """The instrument's price excluding accrued interest. The value is quoted according to the market
     convention defined by CashOrPercentConvention.
     Optional. No default value applies."""
    compute_all_analytics_with_report_ccy: Optional[bool] = rest_field(name="computeAllAnalyticsWithReportCcy")
    """The indicator used to compute all analytics in the report currency. The possible values are:
     
     
     * True: the pricing will be done in the reporting currency using a FX forward curve,
     * False: the pricing will be done using notional currency.
     
     Optional. Default value is 'False'."""
    compute_cash_flow_from_issue_date: Optional[bool] = rest_field(name="computeCashFlowFromIssueDate")
    """The indicator defines the date, from which the cash flows will be computed. The possible values
     are:
     
     
     * True: from issueDate,
     * False: from tradeDate.
     
     Optional. Default value is 'False'."""
    concession_fee: Optional[float] = rest_field(name="concessionFee")
    """The fee used to calculate the netPrice of the bond as [netPrice = price + concessionFee]. The
     value is expressed in the same units as the bond price (percentage or cash).
     Optional. Default value is '0'."""
    credit_spread_type: Optional[Union[str, "_models.CreditSpreadTypeEnum"]] = rest_field(name="creditSpreadType")
    """The credit curve spread type used for the convertible bond pricing. The possible values are:
     
     
     * FlatSpread: the credit spread is fixed at the same level for the remaining life of
     convertible bond,
     * TermStructure: the credit spread is different for the remaining life of convertible bond.
     
     Optional. The default value is 'TermStructure' unless FlatCreditSpreadBp has been set : in that
     case default is 'FlatSpread' . If credit curve data is not available it defaults to
     'FlatSpread'.
     Applicable for Convertible Bonds. Known values are: \"FlatSpread\" and \"TermStructure\"."""
    current_yield_percent: Optional[float] = rest_field(name="currentYieldPercent")
    """The current yield of the instrument, computed as [CouponRatePercent x PriceFactor /
     DirtyPrice]. The value is expressed in percentages.
     Optional. No default value applies."""
    default_quote: Optional["_models.DefaultBondQuote"] = rest_field(name="defaultQuote")
    dirty_price: Optional[float] = rest_field(name="dirtyPrice")
    """The instrument's price, which includes accrued interest. The value is quoted according to the
     market convention defined by CashOrPercentConvention.
     Optional. No default value applies."""
    discount_margin_bp: Optional[float] = rest_field(name="discountMarginBp")
    """The margin that is earned in addition to the floating index rate value of the instrument. The
     value is expressed in basis points. Available only for floating rate instruments.
     Optional. No default value applies."""
    discount_percent: Optional[float] = rest_field(name="discountPercent")
    """A difference between the instrument's price paid for and its par value. The value is expressed
     in percentages.
     Optional. No default value applies."""
    dividend_type: Optional[Union[str, "_models.IPADividendTypeEnum"]] = rest_field(name="dividendType")
    """The type of dividend of the underlying asset.
     Optional. The default value is derived from the bond structure.
     Applicable for Convertible Bonds. Known values are: \"None\", \"ForecastTable\",
     \"HistoricalYield\", \"ForecastYield\", \"ImpliedYield\", \"ImpliedTable\", and \"Futures\"."""
    dividend_yield_percent: Optional[float] = rest_field(name="dividendYieldPercent")
    """The ratio of annualized dividends to the underlying asset's price. The value is expressed in
     percentages.
     Optional. By default, the value is retrieved from the market data. If it is not available, the
     default value is 0.
     Applicable for Convertible Bonds."""
    edsf_benchmark_curve_yield_percent: Optional[float] = rest_field(name="edsfBenchmarkCurveYieldPercent")
    """The yield percent of the Euro-Dollar future benchmark curve, used to compute the edsfSpreadBp.
     The yield is computed at the instrument redemption date using the nearest point or by
     interpolation of the benchmark curve (defined in pricing parameter
     benchmarkYieldSelectionMode).
     Optional. By default, the yield is computed or retrieved from the market data."""
    edsf_spread_bp: Optional[float] = rest_field(name="edsfSpreadBp")
    """The spread applied to the yield of the Euro-Dollar future benchmark curve and used to compute
     the yield of the instrument to be priced. This spread is computed for the USD bond whose
     maturity is under 2 years. The mode of benchmark yield selection for the instrument redemption
     date is defined in pricing parameter benchmarkYieldSelectionMode. The value is expressed in
     basis points.
     Optional. No default value applies."""
    efp_benchmark_price: Optional[float] = rest_field(name="efpBenchmarkPrice")
    """The price of the EFP benchmark in case of an Australian fixed rate bond.
     Optional. By default, the price is computed or retrieved from the market data."""
    efp_benchmark_ric: Optional[str] = rest_field(name="efpBenchmarkRic")
    """The RIC of the EFP benchmark, if the instrument to be priced is an Australian fixed rate bond.
     The RIC can only be YTTc1, YTTc2, YTCc1 or YTCc2.
     Optional. The default value is 'YTTc1'."""
    efp_benchmark_yield_percent: Optional[float] = rest_field(name="efpBenchmarkYieldPercent")
    """The yield percent of the EFP benchmark in case of an Australian fixed rate bond.
     Optional. By default,the yield is computed or retrieved from the market data."""
    efp_spread_bp: Optional[float] = rest_field(name="efpSpreadBp")
    """The spread applied to the yield of the Exchange of futures for physical (EFP) benchmark and
     used to compute the yield of the instrument to be priced in case of an Australian fixed rate
     bond. The value is expressed in basis points.
     Optional. No default value applies."""
    flat_credit_spread_bp: Optional[float] = rest_field(name="flatCreditSpreadBp")
    """The flat credit spread used for pricing of the convertible bond. The value is expressed in
     basis points.
     It is applicable when CreditSpreadType is equal to 'Flat'.
     Optional. The default value is retrieved from flatCreditSpreadTenor point. If credit curve data
     is not available, the default value is 0.
     Applicable for Convertible Bonds."""
    flat_credit_spread_tenor: Optional[str] = rest_field(name="flatCreditSpreadTenor")
    """The code indicating the tenor on the credit curve of the convertible bond's issuer used to
     retrieve the value of FlatCreditSpreadBp (e.g., '1Y').
     It is applicable when CreditSpreadType is equal to 'FlatSpread'. The requested tenor must exist
     on the credit curve of the issuer which is used for the currency.
     Optional. The default value is '5Y'. If it does not exist, the first available tenor is used.
     Applicable for Convertible Bonds."""
    fx_price_side: Optional[Union[str, "_models.FxPriceSideEnum"]] = rest_field(name="fxPriceSide")
    """FX price side to consider when retrieving FX rates (Mid, Bid, Ask, Last, Close). Known values
     are: \"Mid\", \"Bid\", \"Ask\", and \"Last\"."""
    fx_stock_correlation: Optional[float] = rest_field(name="fxStockCorrelation")
    """The correlation rate between the underlying stock's price and FX Spot of the currency in which
     the convertible bond is issued.
     The possible value ranges between -1 and 1.
     Optional. The default value is 0.
     Applicable for cross-currency Convertible Bonds."""
    fx_volatility_percent: Optional[float] = rest_field(name="fxVolatilityPercent")
    """The Fx Spot volatility used for pricing of the convertible bond. The value is expressed in
     percentages.
     It is available only for foreign currency convertible bonds (any convertible bond whose face
     value is issued in a currency different from issuing company's domestic currency).
     Optional. The default value is 0."""
    fx_volatility_tenor: Optional[str] = rest_field(name="fxVolatilityTenor")
    """The code indicating the Fx Spot volatility tenor used to retrieve the value of
     UnderlyingFxVolatilityPercent (e.g., '6M', '1Y').
     The requested tenor must exist in the volatility surface which is used for the currency pair.
     It is available only for foreign currency convertible bonds. It is ignored if
     fxVolatilityPercent is specified.
     Optional. The default value is '1Y'. If it does not exist, the first available tenor is used."""
    gov_country_benchmark_curve_price: Optional[float] = rest_field(name="govCountryBenchmarkCurvePrice")
    """The price of the government country benchmark curve, equivalent to the
     govCountryBenchmarkCurveYieldPercent.
     Optional. By default, the price is computed or retrieved from the market data."""
    gov_country_benchmark_curve_yield_percent: Optional[float] = rest_field(name="govCountryBenchmarkCurveYieldPercent")
    """The yield percent of the government country benchmark curve, used to compute the
     govCountrySpreadBp. The government country benchmark curve is computed from the country of the
     instrument. The yield is computed at the instrument redemption date using the nearest point or
     by interpolation of the benchmark curve (defined in pricing parameter
     benchmarkYieldSelectionMode). It is available only for European countries and USA (USA
     govCountry benchmark is US Treasuries).
     Optional. By default, the yield is computed or retrieved from the market data."""
    gov_country_spread_bp: Optional[float] = rest_field(name="govCountrySpreadBp")
    """The spread applied to the yield of the government country benchmark curve and used to compute
     the yield of the instrument to be priced. The government country benchmark curve is computed
     from the country of the instrument. It is available only for European countries and USA (USA
     govCountry benchmark is US Treasuries). The mode of benchmark yield selection for the
     instrument redemption date is defined in pricing parameter benchmarkYieldSelectionMode. The
     value is expressed in basis points.
     Optional. No default value applies."""
    government_benchmark_curve_price: Optional[float] = rest_field(name="governmentBenchmarkCurvePrice")
    """The price of the government benchmark curve, equivalent to the
     governmentBenchmarkCurveYieldPercent.
     Optional. By default, the price is computed or retrieved from the market data."""
    government_benchmark_curve_yield_percent: Optional[float] = rest_field(name="governmentBenchmarkCurveYieldPercent")
    """The yield percent of the government benchmark curve used to compute the governmentSpreadBp. The
     government benchmark curve is computed from the currency of the instrument. For example, curve
     for Italian bond is a European benchmark. The yield is computed at the instrument redemption
     date using the nearest point or by interpolation of the benchmark curve (defined in pricing
     parameter benchmarkYieldSelectionMode).
     Optional. By default, the yield is computed or retrieved from the market data."""
    government_spread_bp: Optional[float] = rest_field(name="governmentSpreadBp")
    """The spread applied to the yield of the government benchmark curve and used to compute the yield
     of the instrument to be priced. The government benchmark curve is computed from the currency of
     the instrument. The mode of benchmark yield selection for the instrument redemption date is
     defined in pricing parameter benchmarkYieldSelectionMode. The value is expressed in basis
     points.
     Optional. No default value applies."""
    hull_white_parameters: Optional["_models.HullWhiteParameters"] = rest_field(name="hullWhiteParameters")
    inflation_mode: Optional[Union[str, "_models.InflationModeEnum"]] = rest_field(name="inflationMode")
    """The indicator used to define whether instrument parameters should be adjusted from inflation or
     not. Available only for inflation-linked instruments.
     Optional. By default, 'Default' is used. That means it depends on the instrument quotation
     convention. Known values are: \"Unadjusted\", \"Adjusted\", and \"Default\"."""
    is_coupon_payment_adjustedfor_leap_year: Optional[bool] = rest_field(name="isCouponPaymentAdjustedforLeapYear")
    """An indicator whether a fixed coupon market convention with 365.25 days in a year is used to
     calculate yield and margin.
     It can be requested if projectedIndexCalculationMethod = \"ConstantCouponPayment\". The
     possible values are:
     
     
     * True: the year fraction assumes 365.25 days,
     * False: the market convention is used.
     
     Optional. The default value is 'True'."""
    issuer_benchmark_curve_yield_percent: Optional[float] = rest_field(name="issuerBenchmarkCurveYieldPercent")
    """The yield percent of the issuer benchmark curve, used to compute the issuerSpreadBp.
     Optional. By default, the yield is computed or retrieved from the market data."""
    issuer_spread_bp: Optional[float] = rest_field(name="issuerSpreadBp")
    """The spread applied to the yield of the issuer benchmark curve and used to compute the yield of
     the instrument to be priced. The value is expressed in basis points.
     Optional. No default value applies."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It should be less or equal to
     valuationDate).
     Optional. By default, marketDataDate is valuationDate or today."""
    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency.
     Optional. By default, the value is computed from the notional amount. (NotionalAmount,
     MarketValueInDealCcy and MarketValueInReportCcy cannot be defined at the same time)."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value ot the instrument computed as [MarketValueInDealCcy x FxSpot]. The value is
     expressed in the reporting currency.
     Optional. By default, the value is computed from the notional amount (FxSpot, NotionalAmount,
     MarketValueInDealCcy and MarketValueInReportCcy cannot be defined at the same time)."""
    net_price: Optional[float] = rest_field(name="netPrice")
    """The instrument's price before deducting fees. It is computed as [price + concessionFee]. The
     value is quoted according to the market convention defined by CashOrPercentConvention and
     CleanOrDirtyConvention.
     Optional. No default value applies."""
    neutral_yield_percent: Optional[float] = rest_field(name="neutralYieldPercent")
    """The neutral yield of the instrument, at which its price moving neither up nor down over time.
     The value is expressed in basis points. Available only for floating rate instruments.
     Optional. No default value applies."""
    next_coupon_rate_percent: Optional[float] = rest_field(name="nextCouponRatePercent")
    """The annual rate of the next coupon. The coupon may be paid in kind (PIK) or in cash. The value
     is expressed in percentages. Available only for floating rate instruments.
     Optional. By default, the value is computed from the current index."""
    ois_zc_benchmark_curve_yield_percent: Optional[float] = rest_field(name="oisZcBenchmarkCurveYieldPercent")
    """The yield percent of the overnight indexed swap (OIS) zero curve used to compute the
     oisZcSpreadBp. The OIS zero curve is computed from the pricing currency. The yield is computed
     at the instrument redemption date using the nearest point or by interpolation of the benchmark
     curve (defined in pricing parameter benchmarkYieldSelectionMode).
     Optional. By default, the yield is computed or retrieved from the market data."""
    ois_zc_spread_bp: Optional[float] = rest_field(name="oisZcSpreadBp")
    """The spread applied to the yield of the overnight indexed swap (OIS) zero curve and used to
     compute the yield of the instrument to be priced. The OIS zero curve is computed from the
     pricing currency. The value is expressed in basis points.
     Optional. No default value applies."""
    option_adjusted_spread_bp: Optional[float] = rest_field(name="optionAdjustedSpreadBp")
    """The spread applied to the benchmark yield curve and used to compute the yield of the instrument
     to be priced, taking into account the embedded options. The value is expressed in basis points.
     Optional. No default value applies."""
    price: Optional[float] = rest_field()
    """The instrument's price quoted according to the market convention defined by
     CashOrPercentConvention and CleanOrDirtyConvention.
     Optional. No default value applies."""
    price_side: Optional[Union[str, "_models.PriceSideEnum"]] = rest_field(name="priceSide")
    """The price side of the instrument which comes from the instrument's quote or from the curve
     (derived from quotes) used to value the instrument.
     The possible values are: Bid, Ask, Mid.
     Optional. Default value is 'Mid'. Known values are: \"Mid\", \"Bid\", \"Ask\", and \"Last\"."""
    projected_index_calculation_method: Optional[Union[str, "_models.ProjectedIndexCalculationMethodEnum"]] = (
        rest_field(name="projectedIndexCalculationMethod")
    )
    """The method used to define how the projected floating index rate value is computed for a
     floating rate instrument.
     The possible values are:
     
     
     * ConstantIndex: future index values are considered as constant and equal to the projected
     index value,
     * ForwardIndex: future index values are computed using a forward curve,
     * ConstantCouponPayment: coupon payments are computed based on fixed coupon market convention
     with the same index and accrued periods for every coupon period.
     
     Optional. Default values are:
     
     
     * 'ForwardIndex' for Preferreds and Brazilian Debenture bonds,
     * 'ConstantIndex' in other cases. Known values are: \"ConstantIndex\", \"ForwardIndex\", and
     \"ConstantCouponPayment\"."""
    projected_index_percent: Optional[float] = rest_field(name="projectedIndexPercent")
    """The projected index rate value used for calculation of future cash flows of the floating rate
     instrument. Usually the projected index is the last known value of the index. The value is
     expressed in percentage. This parameter can be used if the parameter
     projectedIndexCalculationMethod is set to ConstantIndex.
     Optional. By default, the projected index rate value is computed from the market data according
     to the instrument convention."""
    quote_fallback_logic: Optional[Union[str, "_models.QuoteFallbackLogicEnum"]] = rest_field(name="quoteFallbackLogic")
    """The indicator used to define the fallback logic for the quotation of the instrument.
     Optional. No default value applies. Known values are: \"None\" and \"BestField\"."""
    quoted_price: Optional[float] = rest_field(name="quotedPrice")
    """The instrument's price quoted according to the market convention defined by QuotationMode.
     Optional. No default value applies."""
    rating_benchmark_curve_yield_percent: Optional[float] = rest_field(name="ratingBenchmarkCurveYieldPercent")
    """The yield percent of the rating benchmark curve used to compute the ratingSpreadBp. The yield
     is computed at the instrument redemption date using the nearest point or by interpolation of
     the benchmark curve (defined in pricing parameter benchmarkYieldSelectionMode).
     Optional. By default, the yield is computed or retrieved from the market data."""
    rating_spread_bp: Optional[float] = rest_field(name="ratingSpreadBp")
    """The spread applied to the yield of the rating benchmark curve and used to compute the yield of
     the instrument to be priced. The mode of benchmark yield selection for the instrument
     redemption date is defined in pricing parameter benchmarkYieldSelectionMode. The value is
     expressed in basis points.
     Optional. No default value applies."""
    redemption_date: Optional[datetime.datetime] = rest_field(name="redemptionDate", format="rfc3339")
    """The date when the instrument can be redeemed. If it is set for the redeemable bond, the next
     available date from RedemptionDatesArray is returned. Otherwise, the defult value is returned.
     The notional of the instrument is also paid at this date. The value is expressed in ISO 8601
     format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     Optional. By default, the value is equal to endDate."""
    redemption_date_type: Optional[Union[str, "_models.RedemptionDateTypeEnum"]] = rest_field(name="redemptionDateType")
    """The type defining the redemption date of the instrument.
     Optional. The value is derived from the rate structure of the bond.
     Default values are:
     
     
     * 'RedemptionAtWorstDate' for callable bond,
     * 'RedemptionAtBestDate' for puttable bond,
     * 'RedemptionAtMaturityDate' in other cases. Known values are: \"RedemptionAtMaturityDate\",
     \"RedemptionAtCallDate\", \"RedemptionAtPutDate\", \"RedemptionAtWorstDate\",
     \"RedemptionAtBestDate\", \"RedemptionAtSinkDate\", \"RedemptionAtParDate\",
     \"RedemptionAtPremiumDate\", \"RedemptionAtPerpetuity\", \"RedemptionAtCustomDate\",
     \"RedemptionAtMakeWholeCallDate\", \"RedemptionAtAverageLife\",
     \"RedemptionAtPartialCallDate\", \"RedemptionAtPartialPutDate\", \"RedemptionAtNextDate\", and
     \"NativeRedemptionDate\"."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with 'xxxInReportCcy'. The value is expressed in
     ISO 4217 alphabetical format (e.g., 'USD').
     Optional. No default value applies."""
    rounding_parameters: Optional["_models.BondRoundingParameters"] = rest_field(name="roundingParameters")
    sector_rating_benchmark_curve_yield_percent: Optional[float] = rest_field(
        name="sectorRatingBenchmarkCurveYieldPercent"
    )
    """The yield percent of the sector rating benchmark curve used to compute the
     sectorRatingSpreadBp. The yield is computed at the instrument redemption date using the nearest
     point or by interpolation of the benchmark curve (defined in pricing parameter
     benchmarkYieldSelectionMode).
     Optional. By default, the yield is computed or retrieved from the market data."""
    sector_rating_spread_bp: Optional[float] = rest_field(name="sectorRatingSpreadBp")
    """The spread applied to the yield of the sector rating benchmark curve and used to compute the
     yield of the instrument to be priced. The mode of benchmark yield selection for the instrument
     redemption date is defined in pricing parameter benchmarkYieldSelectionMode. The value is
     expressed in basis points.
     Optional. No default value applies."""
    settlement_convention: Optional[str] = rest_field(name="settlementConvention")
    """The settlement tenor of the instrument (e.g., '1WD'), used to calculate SettlementDate.
     Only 'D' (days) and 'WD' (working days) are supported. If another period code is used,
     settlementConvention is set to '0WD'.
     Optional. If instrumentCode is defined, the value comes from the instrument reference data.
     Only two parameters out of settlementConvention, marketDataDate and valuationDate can be
     overridden at the same time."""
    simple_margin_bp: Optional[float] = rest_field(name="simpleMarginBp")
    """The average cash return per year of the instrument compared with its index rate. The value is
     expressed in basis points. Available only for floating rate instruments.
     Optional. No default value applies."""
    stock_borrow_rate_percent: Optional[float] = rest_field(name="stockBorrowRatePercent")
    """The rate at which the underlying asset can be borrowed. The value is expressed in percentages.
     Optional. The default value is 0.
     Applicable for Convertible Bonds."""
    stock_flat_volatility_percent: Optional[float] = rest_field(name="stockFlatVolatilityPercent")
    """The underlying asset's volatility used for pricing of the convertible bond. The value is
     expressed in percentages.
     It is applicable when VolatilityType is equal to 'Flat'.
     Optional. By default the value is retrieved from the market data and
     UnderlyingFlatVolatilityTenor. If the market data is empty, it defaults to 15.
     Applicable for Convertible Bonds."""
    stock_flat_volatility_tenor: Optional[str] = rest_field(name="stockFlatVolatilityTenor")
    """The code indicating the underlying asset's volatility tenor used to retrieve the value of
     UnderlyingFlatVolatilityPercent (e.g., '90D', '1Y').
     The requested tenor must exist in the volatility environment which is used for the currency.
     It is applicable when VolatilityType is equal to 'Flat'. It is ignored if
     stockFlatVolatilityPercent is specified.
     Optional. The default value is '200D'. If it is not available, the following values are used:
     '90D', then first available.
     Applicable for Convertible Bonds."""
    stock_price_on_default: Optional[float] = rest_field(name="stockPriceOnDefault")
    """The underlying asset's price agreed in the event of the convertible bond default. The value is
     expressed in the deal currency.
     Optional. The default value is 0.
     Applicable for Convertible Bonds."""
    strip_yield_percent: Optional[float] = rest_field(name="stripYieldPercent")
    """The strip yield measures the return on only the debt portion of the instrument (removing the
     impact of any embedded options, or conversion rights, or accrued interest).
     The value is expressed in percentage. Optional. No default value applies."""
    swap_benchmark_curve_yield_percent: Optional[float] = rest_field(name="swapBenchmarkCurveYieldPercent")
    """The yield percent of the swap benchmark curve, which can be used to compute the swapSpreadBp.
     Optional. By default, the yield is computed or retrieved from the market data."""
    swap_spread_bp: Optional[float] = rest_field(name="swapSpreadBp")
    """The spread applied to the yield of the swap benchmark curve and used to compute the yield of
     the instrument to be priced. The value is expressed in basis points.
     Optional. No default value applies."""
    swap_spread_tenor: Optional[str] = rest_field(name="swapSpreadTenor")
    """The code indicating the interest rate curve tenor used for SwapSpreadBp computations. The
     possible value is 'OIS'. Available for fixed-rate and floating-rate notes.
     Optional. If not provided, the discount curve basis is used as default value."""
    tax_on_capital_gain_percent: Optional[float] = rest_field(name="taxOnCapitalGainPercent")
    """The tax rate on capital gain. The value is expressed in percentages.
     Optional. Default value is '0'."""
    tax_on_coupon_percent: Optional[float] = rest_field(name="taxOnCouponPercent")
    """The tax rate on income. The value is expressed in percentages.
     Optional. Default value is '0'."""
    tax_on_price_percent: Optional[float] = rest_field(name="taxOnPricePercent")
    """The reference price used for capital taxation. The tax on capital gain is levied on the excess
     of the par value over TaxOnPricePercent. The value is expressed in percentages.
     Optional. Default value is '0'."""
    tax_on_yield_percent: Optional[float] = rest_field(name="taxOnYieldPercent")
    """The tax rate applied to the yield of the bond for pricing. The value is expressed in
     percentages.
     Optional. Default value is '0'."""
    trade_date: Optional[datetime.datetime] = rest_field(name="tradeDate", format="rfc3339")
    """The date when the instrument is traded. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     Optional. By default, tradeDate is marketDataDate, use tradeDate to define a default
     valuationDate for future dates."""
    use_settlement_date_from_quote: Optional[bool] = rest_field(name="useSettlementDateFromQuote")
    """The indicator used to define whether to use the settlement date of the quote or one computed
     from marketDataDate. This option should be used only in real-time. The possible values are:
     
     
     * True: settlement date is used,
     * False: marketDataDate is used.
     
     Optional. Default value is 'False'."""
    user_defined_benchmark_price: Optional[float] = rest_field(name="userDefinedBenchmarkPrice")
    """The price of a user defined benchmark, equivalent to the userDefinedBenchmarkYieldPercent.
     Optional. By default, the price is computed or retrieved from the market data."""
    user_defined_benchmark_yield_percent: Optional[float] = rest_field(name="userDefinedBenchmarkYieldPercent")
    """The yield percent of a user-defined benchmark used to compute the userDefinedSpreadBp.
     Optional. By default, the yield is computed or retrieved from the market data."""
    user_defined_spread_bp: Optional[float] = rest_field(name="userDefinedSpreadBp")
    """The spread applied to the yield of user-defined benchmark and used to compute the yield of the
     instrument to be priced. The value is expressed in basis points.
     Optional. No default value applies."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""
    volatility_term_structure_type: Optional[Union[str, "_models.VolatilityTermStructureTypeEnum"]] = rest_field(
        name="volatilityTermStructureType"
    )
    """The type of the underlying asset's volatility term structure used in pricing. It applies when
     UnderlyingVolatilityType is equal to 'TermStructure'. The possible values are:
     
     
     * Implied: the volatility anticipated for the underlying asset for the remaining life of the
     convertible bond (it cannot be used in historical request),
     * Historical: the volatility of the underlying asset during a period in the past (it cannot be
     used when volatilityType is set to 'TermStructure').
     
     Optional. The default values are:
     
     
     * Implied: for real-time request when volatilityType is set to 'TermStructure',
     * Historical: for other scenarios.
     
     Applicable for Convertible Bonds. Known values are: \"Historical\" and \"Implied\"."""
    volatility_type: Optional[Union[str, "_models.IPAVolatilityTypeEnum"]] = rest_field(name="volatilityType")
    """The type of underlying asset's volatility used for the convertible bond pricing. The possible
     values are:
     
     
     * Flat: the volatility is fixed at the same level for the remaining life of convertible bond,
     * TermStructure: the volatility is different for the remaining life of convertible bond.
     
     Optional. The default value is 'Flat'.
     Applicable for Convertible Bonds. Known values are: \"Flat\" and \"TermStructure\"."""
    yield_percent: Optional[float] = rest_field(name="yieldPercent")
    """The yield of the instrument expressed in percentages. Optional. No default value applies."""
    yield_type: Optional[Union[str, "_models.YieldTypeEnum"]] = rest_field(name="yieldType")
    """The yield type specified in the yield calculation convention and used for the instrument rate
     model.
     Optional. Default value is 'Native' (no specific yield type is defined). Known values are:
     \"Native\", \"UsGovt\", \"UsTBills\", \"Isma\", \"Euroland\", \"Discount_Actual_360\",
     \"Discount_Actual_365\", \"MoneyMarket_Actual_360\", \"MoneyMarket_Actual_365\",
     \"MoneyMarket_Actual_Actual\", \"Bond_Actual_364\", \"Japanese_Simple\",
     \"Japanese_Compounded\", \"Moosmueller\", \"Braess_Fangmeyer\", \"Weekend\",
     \"TurkishCompounded\", \"Annual_Equivalent\", \"Semiannual_Equivalent\",
     \"Quarterly_Equivalent\", and \"MarketReference\"."""
    z_spread_bp: Optional[float] = rest_field(name="zSpreadBp")
    """Zero-volatility spread (Z-spread) computed as the constant spread that makes the price of the
     instrument equal to the present value of its cash flows when added to the yield at each point
     on Zero-curve where cash flow is received. The value is expressed in basis points.
     Optional. No default value applies."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        adjusted_clean_price: Optional[float] = None,
        adjusted_dirty_price: Optional[float] = None,
        adjusted_yield_percent: Optional[float] = None,
        apply_tax_to_full_pricing: Optional[bool] = None,
        asset_swap_spread_bp: Optional[float] = None,
        benchmark_at_issue_price: Optional[float] = None,
        benchmark_at_issue_ric: Optional[str] = None,
        benchmark_at_issue_spread_bp: Optional[float] = None,
        benchmark_at_issue_yield_percent: Optional[float] = None,
        benchmark_at_redemption_price: Optional[float] = None,
        benchmark_at_redemption_spread_bp: Optional[float] = None,
        benchmark_at_redemption_yield_percent: Optional[float] = None,
        benchmark_yield_selection_mode: Optional[Union[str, "_models.BenchmarkYieldSelectionModeEnum"]] = None,
        bond_recovery_rate_percent: Optional[float] = None,
        cash_amount: Optional[float] = None,
        cds_recovery_rate_percent: Optional[float] = None,
        clean_price: Optional[float] = None,
        compute_all_analytics_with_report_ccy: Optional[bool] = None,
        compute_cash_flow_from_issue_date: Optional[bool] = None,
        concession_fee: Optional[float] = None,
        credit_spread_type: Optional[Union[str, "_models.CreditSpreadTypeEnum"]] = None,
        current_yield_percent: Optional[float] = None,
        default_quote: Optional["_models.DefaultBondQuote"] = None,
        dirty_price: Optional[float] = None,
        discount_margin_bp: Optional[float] = None,
        discount_percent: Optional[float] = None,
        dividend_type: Optional[Union[str, "_models.IPADividendTypeEnum"]] = None,
        dividend_yield_percent: Optional[float] = None,
        edsf_benchmark_curve_yield_percent: Optional[float] = None,
        edsf_spread_bp: Optional[float] = None,
        efp_benchmark_price: Optional[float] = None,
        efp_benchmark_ric: Optional[str] = None,
        efp_benchmark_yield_percent: Optional[float] = None,
        efp_spread_bp: Optional[float] = None,
        flat_credit_spread_bp: Optional[float] = None,
        flat_credit_spread_tenor: Optional[str] = None,
        fx_price_side: Optional[Union[str, "_models.FxPriceSideEnum"]] = None,
        fx_stock_correlation: Optional[float] = None,
        fx_volatility_percent: Optional[float] = None,
        fx_volatility_tenor: Optional[str] = None,
        gov_country_benchmark_curve_price: Optional[float] = None,
        gov_country_benchmark_curve_yield_percent: Optional[float] = None,
        gov_country_spread_bp: Optional[float] = None,
        government_benchmark_curve_price: Optional[float] = None,
        government_benchmark_curve_yield_percent: Optional[float] = None,
        government_spread_bp: Optional[float] = None,
        hull_white_parameters: Optional["_models.HullWhiteParameters"] = None,
        inflation_mode: Optional[Union[str, "_models.InflationModeEnum"]] = None,
        is_coupon_payment_adjustedfor_leap_year: Optional[bool] = None,
        issuer_benchmark_curve_yield_percent: Optional[float] = None,
        issuer_spread_bp: Optional[float] = None,
        market_data_date: Optional[datetime.datetime] = None,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
        net_price: Optional[float] = None,
        neutral_yield_percent: Optional[float] = None,
        next_coupon_rate_percent: Optional[float] = None,
        ois_zc_benchmark_curve_yield_percent: Optional[float] = None,
        ois_zc_spread_bp: Optional[float] = None,
        option_adjusted_spread_bp: Optional[float] = None,
        price: Optional[float] = None,
        price_side: Optional[Union[str, "_models.PriceSideEnum"]] = None,
        projected_index_calculation_method: Optional[Union[str, "_models.ProjectedIndexCalculationMethodEnum"]] = None,
        projected_index_percent: Optional[float] = None,
        quote_fallback_logic: Optional[Union[str, "_models.QuoteFallbackLogicEnum"]] = None,
        quoted_price: Optional[float] = None,
        rating_benchmark_curve_yield_percent: Optional[float] = None,
        rating_spread_bp: Optional[float] = None,
        redemption_date: Optional[datetime.datetime] = None,
        redemption_date_type: Optional[Union[str, "_models.RedemptionDateTypeEnum"]] = None,
        report_ccy: Optional[str] = None,
        rounding_parameters: Optional["_models.BondRoundingParameters"] = None,
        sector_rating_benchmark_curve_yield_percent: Optional[float] = None,
        sector_rating_spread_bp: Optional[float] = None,
        settlement_convention: Optional[str] = None,
        simple_margin_bp: Optional[float] = None,
        stock_borrow_rate_percent: Optional[float] = None,
        stock_flat_volatility_percent: Optional[float] = None,
        stock_flat_volatility_tenor: Optional[str] = None,
        stock_price_on_default: Optional[float] = None,
        strip_yield_percent: Optional[float] = None,
        swap_benchmark_curve_yield_percent: Optional[float] = None,
        swap_spread_bp: Optional[float] = None,
        swap_spread_tenor: Optional[str] = None,
        tax_on_capital_gain_percent: Optional[float] = None,
        tax_on_coupon_percent: Optional[float] = None,
        tax_on_price_percent: Optional[float] = None,
        tax_on_yield_percent: Optional[float] = None,
        trade_date: Optional[datetime.datetime] = None,
        use_settlement_date_from_quote: Optional[bool] = None,
        user_defined_benchmark_price: Optional[float] = None,
        user_defined_benchmark_yield_percent: Optional[float] = None,
        user_defined_spread_bp: Optional[float] = None,
        valuation_date: Optional[datetime.datetime] = None,
        volatility_term_structure_type: Optional[Union[str, "_models.VolatilityTermStructureTypeEnum"]] = None,
        volatility_type: Optional[Union[str, "_models.IPAVolatilityTypeEnum"]] = None,
        yield_percent: Optional[float] = None,
        yield_type: Optional[Union[str, "_models.YieldTypeEnum"]] = None,
        z_spread_bp: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondRoundingParameters(_model_base.Model):
    """BondRoundingParameters.

    Attributes
    ----------
    accrued_rounding : str or ~analyticsapi.models.AccruedRoundingEnum
        The number of digits to apply for accrued rounding fields, expressed in
        percentages. Rounding of fields, expressed in currencies, depends on
        notional amount. The possible values are: Zero, One, Two, Three, Four,
        Five, Six, Seven, Eight, Default, Unrounded. Optional. Default value is
        derived from the instrument reference data. Known values are: "Zero",
        "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight",
        "Default", and "Unrounded".
    accrued_rounding_type : str or ~analyticsapi.models.AccruedRoundingTypeEnum
        The type of rounding for accrued rounding. Optional. Default value is
        derived from the instrument reference data. Otherwise, default value is
        'Near'. Known values are: "Near", "Up", "Down", "Floor", "Ceil",
        "FaceNear", "FaceDown", "FaceUp", and "Default".
    price_rounding : str or ~analyticsapi.models.PriceRoundingEnum
        The number of digits to apply for price rounding. Rounding of market
        value fields depends on notional amount. The possible values are: Zero,
        One, Two, Three, Four, Five, Six, Seven, Eight, Default, Unrounded.
        Only the computed fields can be rounded. A field cannot be rounded if
        its value is overridden or retrieved from market data. Optional.
        Default value is derived from the instrument reference data. Known
        values are: "Zero", "One", "Two", "Three", "Four", "Five", "Six",
        "Seven", "Eight", "Default", and "Unrounded".
    price_rounding_type : str or ~analyticsapi.models.PriceRoundingTypeEnum
        The type of rounding for price rounding. Optional. Default value is
        derived from the instrument reference data. Otherwise, default value is
        'Near'. Known values are: "Near", "Up", "Down", "Floor", "Ceil",
        "FaceNear", "FaceDown", "FaceUp", and "Default".
    spread_rounding : str or ~analyticsapi.models.SpreadRoundingEnum
        The number of digits to apply for spread rounding. Note that spread
        rounding is done directly on the base point value. Optional. Default
        value is derived from the instrument reference data. Known values are:
        "Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight",
        "Default", and "Unrounded".
    spread_rounding_type : str or ~analyticsapi.models.SpreadRoundingTypeEnum
        Known values are: "Near", "Up", "Down", "Floor", "Ceil", "FaceNear",
        "FaceDown", "FaceUp", and "Default".
    yield_rounding : str or ~analyticsapi.models.YieldRoundingEnum
        The number of digits to apply for yield and spread rounding. When the
        spread is the difference between two yields, there are two digits less.
        When the spread is computed from a curve, then the rounding defined by
        user is applied. Only computed fields can be rounded. A field cannot be
        rounded if its value is overridden or retrieved from market data.
        Optional. Default value is derived from the instrument reference data.
        Known values are: "Zero", "One", "Two", "Three", "Four", "Five", "Six",
        "Seven", "Eight", "Default", and "Unrounded".
    yield_rounding_type : str or ~analyticsapi.models.YieldRoundingTypeEnum
        The type of rounding for yield rounding. Optional. Default value is
        derived from the instrument reference data. Otherwise, default value is
        'Near'. Known values are: "Near", "Up", "Down", "Floor", "Ceil",
        "FaceNear", "FaceDown", "FaceUp", and "Default".
    """

    accrued_rounding: Optional[Union[str, "_models.AccruedRoundingEnum"]] = rest_field(name="accruedRounding")
    """The number of digits to apply for accrued rounding fields, expressed in percentages. Rounding
     of fields, expressed in currencies, depends on notional amount.
     The possible values are: Zero, One, Two, Three, Four, Five, Six, Seven, Eight, Default,
     Unrounded.
     Optional. Default value is derived from the instrument reference data. Known values are:
     \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",
     \"Default\", and \"Unrounded\"."""
    accrued_rounding_type: Optional[Union[str, "_models.AccruedRoundingTypeEnum"]] = rest_field(
        name="accruedRoundingType"
    )
    """The type of rounding for accrued rounding.
     Optional. Default value is derived from the instrument reference data. Otherwise, default value
     is 'Near'. Known values are: \"Near\", \"Up\", \"Down\", \"Floor\", \"Ceil\", \"FaceNear\",
     \"FaceDown\", \"FaceUp\", and \"Default\"."""
    price_rounding: Optional[Union[str, "_models.PriceRoundingEnum"]] = rest_field(name="priceRounding")
    """The number of digits to apply for price rounding. Rounding of market value fields depends on
     notional amount.
     The possible values are: Zero, One, Two, Three, Four, Five, Six, Seven, Eight, Default,
     Unrounded.
     Only the computed fields can be rounded. A field cannot be rounded if its value is overridden
     or retrieved from market data.
     Optional. Default value is derived from the instrument reference data. Known values are:
     \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",
     \"Default\", and \"Unrounded\"."""
    price_rounding_type: Optional[Union[str, "_models.PriceRoundingTypeEnum"]] = rest_field(name="priceRoundingType")
    """The type of rounding for price rounding.
     Optional. Default value is derived from the instrument reference data. Otherwise, default value
     is 'Near'. Known values are: \"Near\", \"Up\", \"Down\", \"Floor\", \"Ceil\", \"FaceNear\",
     \"FaceDown\", \"FaceUp\", and \"Default\"."""
    spread_rounding: Optional[Union[str, "_models.SpreadRoundingEnum"]] = rest_field(name="spreadRounding")
    """The number of digits to apply for spread rounding. Note that spread rounding is done directly
     on the base point value.
     Optional. Default value is derived from the instrument reference data. Known values are:
     \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",
     \"Default\", and \"Unrounded\"."""
    spread_rounding_type: Optional[Union[str, "_models.SpreadRoundingTypeEnum"]] = rest_field(name="spreadRoundingType")
    """Known values are: \"Near\", \"Up\", \"Down\", \"Floor\", \"Ceil\", \"FaceNear\", \"FaceDown\",
     \"FaceUp\", and \"Default\"."""
    yield_rounding: Optional[Union[str, "_models.YieldRoundingEnum"]] = rest_field(name="yieldRounding")
    """The number of digits to apply for yield and spread rounding.
     When the spread is the difference between two yields, there are two digits less.
     When the spread is computed from a curve, then the rounding defined by user is applied.
     Only computed fields can be rounded. A field cannot be rounded if its value is overridden or
     retrieved from market data.
     Optional. Default value is derived from the instrument reference data. Known values are:
     \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",
     \"Default\", and \"Unrounded\"."""
    yield_rounding_type: Optional[Union[str, "_models.YieldRoundingTypeEnum"]] = rest_field(name="yieldRoundingType")
    """The type of rounding for yield rounding.
     Optional. Default value is derived from the instrument reference data. Otherwise, default value
     is 'Near'. Known values are: \"Near\", \"Up\", \"Down\", \"Floor\", \"Ceil\", \"FaceNear\",
     \"FaceDown\", \"FaceUp\", and \"Default\"."""

    @overload
    def __init__(
        self,
        *,
        accrued_rounding: Optional[Union[str, "_models.AccruedRoundingEnum"]] = None,
        accrued_rounding_type: Optional[Union[str, "_models.AccruedRoundingTypeEnum"]] = None,
        price_rounding: Optional[Union[str, "_models.PriceRoundingEnum"]] = None,
        price_rounding_type: Optional[Union[str, "_models.PriceRoundingTypeEnum"]] = None,
        spread_rounding: Optional[Union[str, "_models.SpreadRoundingEnum"]] = None,
        spread_rounding_type: Optional[Union[str, "_models.SpreadRoundingTypeEnum"]] = None,
        yield_rounding: Optional[Union[str, "_models.YieldRoundingEnum"]] = None,
        yield_rounding_type: Optional[Union[str, "_models.YieldRoundingTypeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondSearchCriteria(_model_base.Model):
    """BondSearchCriteria.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    keyword : str
        The search keyword parameter. E.g. "Currency". Required. Is one of the
        following types: Literal["Ticker"], Literal["IssuerTicker"],
        Literal["ClassName"], Literal["CurrentCoupon"], Literal["DatedDate"],
        Literal["MaturityDate"], Literal["Description"],
        Literal["SecurityType"], Literal["Currency"], Literal["Country"],
        Literal["Moody"], Literal["SP"], Literal["Fitch"]
    condition : str
        The keyword condition.  E.g. "=". Required. Is one of the following
        types: Literal["="], Literal[">="], Literal["<="]
    value : str
        The search keyword condition value. E.g. "USD". Required.
    """

    keyword: Literal[
        "Ticker",
        "IssuerTicker",
        "ClassName",
        "CurrentCoupon",
        "DatedDate",
        "MaturityDate",
        "Description",
        "SecurityType",
        "Currency",
        "Country",
        "Moody",
        "SP",
        "Fitch",
    ] = rest_field()
    """The search keyword parameter. E.g. \"Currency\". Required. Is one of the following types:
     Literal[\"Ticker\"], Literal[\"IssuerTicker\"], Literal[\"ClassName\"],
     Literal[\"CurrentCoupon\"], Literal[\"DatedDate\"], Literal[\"MaturityDate\"],
     Literal[\"Description\"], Literal[\"SecurityType\"], Literal[\"Currency\"],
     Literal[\"Country\"], Literal[\"Moody\"], Literal[\"SP\"], Literal[\"Fitch\"]"""
    condition: Literal["=", ">=", "<="] = rest_field()
    """The keyword condition.  E.g. \"=\". Required. Is one of the following types: Literal[\"=\"],
     Literal[\">=\"], Literal[\"<=\"]"""
    value: str = rest_field()
    """The search keyword condition value. E.g. \"USD\". Required."""

    @overload
    def __init__(
        self,
        *,
        keyword: Literal[
            "Ticker",
            "IssuerTicker",
            "ClassName",
            "CurrentCoupon",
            "DatedDate",
            "MaturityDate",
            "Description",
            "SecurityType",
            "Currency",
            "Country",
            "Moody",
            "SP",
            "Fitch",
        ],
        condition: Literal["=", ">=", "<="],
        value: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondSearchRequest(_model_base.Model):
    """BondSearchRequest.

    Attributes
    ----------
    identifier : str
        Security reference ID.
    include_matured_bonds : bool
        Optional, if true, the search will also include called and matured
        securities. This can increase search times.
    include_muni : bool
        Optional, if true, the search will also include municipal bonds. This
        can increase search times.
    search_criteria : list[~analyticsapi.models.BondSearchCriteria]
        The default value is None, needs to be assigned before using.
    """

    identifier: Optional[str] = rest_field()
    """Security reference ID."""
    include_matured_bonds: Optional[bool] = rest_field(name="includeMaturedBonds")
    """Optional, if true, the search will also include called and matured securities. This can
     increase search times."""
    include_muni: Optional[bool] = rest_field(name="includeMuni")
    """Optional, if true, the search will also include municipal bonds. This can increase search
     times."""
    search_criteria: Optional[List["_models.BondSearchCriteria"]] = rest_field(name="searchCriteria")

    @overload
    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        include_matured_bonds: Optional[bool] = None,
        include_muni: Optional[bool] = None,
        search_criteria: Optional[List["_models.BondSearchCriteria"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondSpreadMeasures(_model_base.Model):
    """Spread measures Object.

    Attributes
    ----------
    benchmark_yield_selection_mode : str
        The mode of benchmark yield selection for the instrument. The possible
        values are:

        * Nearest - uses the nearest point to find the reference yield,
        * Interpolate - interpolates the yield curve to compute the reference yield.

        Default value is 'Interpolate'.
    zspread_bp : float
        The zero volatility spread (  Z-spread  ) computed as the constant
        spread that makes the price of the instrument equal to the present
        value of its cash flows when added to the yield at each point on the
        zero curve where cash flow is received. The value is expressed in basis
        points.
    option_adjusted_spread_bp : float
        The spread applied to the benchmark yield curve and used to compute the
        yield of the instrument, taking into account the embedded options. The
        value is expressed in basis points.
    zero_volatility_option_adjusted_spread_bp : float
        The option-adjusted spread computed with a flat volatility equal to
        zero. The value is expressed in basis points.
    asset_swap_spread_amount : float
        The amount equivalent to  AssetSwapSpreadBp  . The value is expressed
        in units of the bond currency. Available for fixed-rate and floating-
        rate notes.
    upfront_spread_amount : float
        The amount that makes the bond price par, using the current or forward
        reference rates from the zero curve. The value is expressed in units of
        the bond currency. For more details on the field calculation, please
        refer here.
    upfront_spread_bp : float
        The spread applied to the current or forward reference rates from the
        zero curve to make the bond price par. The value is expressed in basis
        points.
    asset_swap_spread_bp : float
        The spread over or under the reference rate (e.g., '  LIBOR  ') for a
        bond whose cash flows have been converted from fixed to floating via an
        interest rate swap. The value is expressed in basis points. Available
        for fixed-rate and floating-rate notes.
    swap_spread_tenor : str
        The code indicating the interest rate curve tenor used for SwapSpreadBp
        computations. The possible value is 'OIS'.
    swap_spread_bp : float
        The spread applied to the yield of the swap benchmark curve and used to
        compute the yield of the instrument to be priced. The mode of benchmark
        yield selection for the instrument redemption date is defined in
        pricing parameter benchmarkYieldSelectionMode. The value is expressed
        in basis points. For more details on the field calculation, please
        refer here.
    swap_benchmark_curve_yield_percent : float
        The yield percent of the swap benchmark curve used to compute
        SwapSpreadBp  . The yield is computed at the instrument redemption date
        using the nearest point or by interpolation of the benchmark curve
        (defined in pricing parameter benchmarkYieldSelectionMode  ).
    swap_benchmark_curve_name : str
        The name of the swap benchmark curve used to compute SwapSpreadBp  .
    swap_benchmark_curve_nearest_ric : str
        The RIC of the point of the swap benchmark curve that is the nearest to
        the instrument redemption date.
    swap_benchmark_curve_lower_ric : str
        The RIC of the point of the swap benchmark curve that is lower to the
        instrument redemption date.
    swap_benchmark_curve_upper_ric : str
        The RIC of the point of the swap benchmark curve that is upper to the
        instrument redemption date.
    government_spread_bp : float
        The spread applied to the yield of the government benchmark curve and
        used to compute the yield of the instrument to be priced. The
        government benchmark curve is computed from the currency of the
        instrument. The mode of benchmark yield selection for the instrument
        redemption date is defined in pricing parameter
        benchmarkYieldSelectionMode. The value is expressed in basis points.
        For more details on the field calculation, please refer here.
    government_nearest_spread_bp : float
        The spread applied to the yield of the government benchmark curve
        computed using the nearest point of this curve to the instrument
        redemption date. The value is expressed in basis points.
    government_benchmark_curve_yield_percent : float
        The yield percent of the government benchmark curve used to compute
        GovernmentSpreadBp  . The government benchmark curve is defined by the
        currency of the instrument. The yield is computed at the instrument
        redemption date using the nearest point or by interpolation of the
        benchmark curve (defined in pricing parameter
        benchmarkYieldSelectionMode  ).
    government_benchmark_curve_name : str
        The name of the government benchmark curve used to compute
        GovernmentSpreadBp  .
    government_benchmark_curve_nearest_ric : str
        The RIC of the point of the government benchmark curve that is the
        nearest to the instrument redemption date.
    government_benchmark_curve_lower_ric : str
        The RIC of the point of the government benchmark curve that is lower to
        the instrument redemption date.
    government_benchmark_curve_upper_ric : str
        The RIC of the point of the government benchmark curve that is upper to
        the instrument redemption date.
    gov_country_spread_bp : float
        The spread applied to the yield of the government country benchmark
        curve and used to compute the yield of the instrument to be priced. The
        government country benchmark curve is defined by the country of the
        instrument. It is available only for European countries and USA (USA
        govCountry benchmark is US Treasuries). The mode of benchmark yield
        selection for the instrument redemption date is defined in pricing
        parameter benchmarkYieldSelectionMode. The value is expressed in basis
        points. For more details on the field calculation, please refer here.
    gov_country_benchmark_curve_yield_percent : float
        The yield percent of the government country benchmark curve used to
        compute  GovCountrySpreadBp  . The government country benchmark curve
        is defined by the country of the instrument. It is available only for
        European countries and USA (USA govCountry benchmark is US Treasuries).
        The yield is computed at the instrument redemption date using the
        nearest point or by interpolation of the benchmark curve (defined in
        pricing parameter  benchmarkYieldSelectionMode  ).
    gov_country_benchmark_curve_name : str
        The name of the government country benchmark curve used to compute
        GovCountrySpreadBp  .
    gov_country_benchmark_curve_nearest_ric : str
        The RIC of the point of the government country benchmark curve that is
        the nearest to the instrument redemption date.
    gov_country_benchmark_curve_lower_ric : str
        The RIC of the point of the government country benchmark curve that is
        lower to the instrument redemption date.
    gov_country_benchmark_curve_upper_ric : str
        The RIC of the point of the government country benchmark curve that is
        upper to the instrument redemption date.
    cds_spread_bp : float
        The spread applied to the yield of the CDS benchmark curve and used to
        compute the yield of the instrument to be priced. The mode of benchmark
        yield selection for the instrument redemption date is defined in
        pricing parameter  benchmarkYieldSelectionMode  . The value is
        expressed in basis points.
    cds_basis_bp : float
        The difference between CdsSpreadBp and the spread of the instrument
        (ZSpreadBp for the fixed rate instrument or DiscountMarginBp for the
        floating rate instrument). The value is expressed in basis points. For
        more details on the field calculation, please refer here.
    cds_nearest_spread_bp : float
        The spread of the CDS benchmark curve at the nearest point to the
        instrument redemption date.
    cds_nearest_basis_bp : float
        The difference between  CdsNearestSpreadBp  and the spread of the
        instrument (  ZSpreadBp  for the fixed rate instrument or
        DiscountMarginBp  for the floating rate instrument). The value ie
        expressed in basis points.
    cds_benchmark_curve_name : str
        The name of the CDS benchmark curve used to compute CdsSpreadBp  .
    cds_benchmark_curve_nearest_ric : str
        The RIC of the point of the CDS curve that is the nearest to the
        instrument redemption date.
    rating_spread_bp : float
        The spread applied to the yield of the rating benchmark curve and used
        to compute the yield of the instrument to be priced. The rating
        benchmark curve is the curve with same currency and rating as the
        instrument. The mode of benchmark yield selection for the instrument
        redemption date is defined in pricing parameter
        benchmarkYieldSelectionMode. The value is expressed in basis points.
        For more details on the field calculation, please refer here.
    rating_benchmark_curve_yield_percent : float
        The yield percent of the rating benchmark curve used to compute
        RatingSpreadBp  . The yield is computed at the instrument redemption
        date using the nearest point or by interpolation of the benchmark curve
        (defined in pricing parameter  benchmarkYieldSelectionMode  ).
    rating_benchmark_curve_name : str
        The name of the rating benchmark curve used to compute RatingSpreadBp
        .
    rating_benchmark_curve_nearest_ric : str
        The RIC of the point of the rating benchmark curve that is the nearest
        to the instrument redemption date.
    rating_benchmark_curve_lower_ric : str
        The RIC of the point of the rating benchmark curve that is lower to the
        instrument redemption date.
    rating_benchmark_curve_upper_ric : str
        The RIC of the point of the rating benchmark curve that is upper to the
        instrument redemption date.
    sector_rating_spread_bp : float
        The spread applied to the yield of the sector rating benchmark curve
        and used to compute the yield of the instrument to be priced. The
        sector rating benchmark curve is the curve with same currency, rating
        and sector as the instrument. The mode of benchmark yield selection for
        the instrument redemption date is defined in pricing parameter
        benchmarkYieldSelectionMode. The value is expressed in basis points.
        For more details on the field calculation, please refer here.
    sector_rating_benchmark_curve_yield_percent : float
        The yield percent of the sector rating benchmark curve used to compute
        SectorRatingSpreadBp  . The yield is computed at the instrument
        redemption date using the nearest point or by interpolation of the
        benchmark curve (defined in pricing parameter
        benchmarkYieldSelectionMode  ).
    sector_rating_benchmark_curve_name : str
        The name of the sector rating benchmark curve used to compute
        SectorRatingSpreadBp  .
    sector_rating_benchmark_curve_nearest_ric : str
        The RIC of the point of the sector rating benchmark curve that is the
        nearest to the instrument redemption date.
    sector_rating_benchmark_curve_lower_ric : str
        The RIC of the point of the sector rating benchmark curve that is lower
        to the instrument redemption date.
    sector_rating_benchmark_curve_upper_ric : str
        The RIC of the point of the sector rating benchmark curve that is upper
        to the instrument redemption date.
    benchmark_at_issue_spread_bp : float
        The spread applied to the yield of the benchmark at issue and used to
        compute the yield of the instrument to be priced. The value is
        expressed in basis points. For more details on the field calculation,
        please refer here.
    benchmark_at_issue_ric : str
        The RIC of the benchmark at the instrument issue date.
    benchmark_at_issue_price : float
        The price of the benchmark at the instrument issue date, equivalent to
        BenchmarkAtIssueYieldPercent  .
    benchmark_at_issue_yield_percent : float
        The yield percent of the benchmark at the instrument issue date used to
        compute  BenchmarkAtIssueSpreadBp  .
    benchmark_at_redemption_spread_bp : float
        The spread applied to the yield of the benchmark defined for the
        current instrument at redemption date and used to compute the yield of
        the instrument to be priced. The value is expressed in basis points.
        For more details on the field calculation, please refer here.
    benchmark_at_redemption_ric : str
        The RIC of the benchmark at the instrument current redemption date.
    benchmark_at_redemption_price : float
        The price of the benchmark at the instrument current redemption date,
        equivalent to  BenchmarkAtRedemptionYieldPercent  .
    benchmark_at_redemption_yield_percent : float
        The yield percent of the benchmark at the instrument current redemption
        date used to compute  BenchmarkAtRedemptionSpreadBp  .
    efp_spread_bp : float
        The spread applied to the yield of the Exchange of futures for physical
        (EFP) benchmark, computed at the instrument redemption date and used to
        compute the yield of the instrument to be priced. The value is
        expressed in basis points. Available only for Australian fixed rate
        bonds. For more details on the field calculation, please refer here.
    efp_benchmark_price : float
        The price of the Exchange of futures for physical (  EFP  ) benchmark,
        equivalent to  EfpBenchmarkYieldPercent  . Available only for
        Australian fixed rate bonds.
    efp_benchmark_yield_percent : float
        The yield percent of the Exchange of futures for physical ( EFP  )
        benchmark used to compute  EfpSpreadBp  . The yield is computed at the
        instrument redemption date. Available only for Australian fixed rate
        bonds.
    efp_benchmark_ric : str
        The RIC of the Exchange of futures for physical (  EFP  ) benchmark.
        The RIC can only be '  YTTc1  ' or '  YTCc1  '  .  Available only for
        Australian fixed rate bonds.
    edsf_spread_bp : float
        The spread applied to the yield of the Euro-Dollar future benchmark
        curve and used to compute the yield of the instrument to be priced.
        This spread is computed for the USD bond whose maturity is under 2
        years. The mode of benchmark yield selection for the instrument
        redemption date is defined in pricing parameter
        benchmarkYieldSelectionMode. The value is expressed in basis points.
        For more details on the field calculation, please refer here.
    edsf_benchmark_curve_yield_percent : float
        The yield percent of the Euro-Dollar future benchmark curve, used to
        compute  EdsfSpreadBp  . The yield is computed at the instrument
        redemption date using the nearest point or by interpolation of the
        benchmark curve (defined in pricing parameter
        benchmarkYieldSelectionMode  ).
    issuer_spread_bp : float
        The spread applied to the yield of the issuer benchmark curve and used
        to compute the yield of the instrument to be priced. The value is
        expressed in basis points. For more details on the field calculation,
        please refer here.
    issuer_benchmark_curve_yield_percent : float
        The yield percent of the issuer benchmark curve, used to compute
        IssuerSpreadBp  .
    ois_zc_benchmark_curve_yield_percent : float
        The yield percent of the overnight indexed swap ( OIS  ) zero curve
        used to compute  OisZcSpreadBp  . The OIS zero curve is computed from
        the pricing currency. The yield is computed at the instrument
        redemption date using the nearest point or by interpolation of the
        benchmark curve (defined in pricing parameter
        benchmarkYieldSelectionMode  ).
    ois_zc_spread_bp : float
        The spread applied to the yield of the overnight indexed swap (OIS)
        zero curve and used to compute the yield of the instrument to be
        priced. The OIS zero curve is computed from the pricing currency. The
        mode of benchmark yield selection for the instrument redemption date is
        defined in pricing parameter benchmarkYieldSelectionMode. The value is
        expressed in basis points. For more details on the field calculation,
        please refer here.
    """

    benchmark_yield_selection_mode: Optional[str] = rest_field(name="benchmarkYieldSelectionMode")
    """The mode of benchmark yield selection for the instrument. The possible values are:
     
     
     * Nearest - uses the nearest point to find the reference yield,
     * Interpolate - interpolates the yield curve to compute the reference yield.
     
     Default value is 'Interpolate'."""
    zspread_bp: Optional[float] = rest_field(name="zspreadBp")
    """The zero volatility spread (  Z-spread  ) computed as the constant spread that makes the price
     of the instrument equal to the present value of its cash flows when added to the yield at each
     point on the zero curve where cash flow is received. The value is expressed in basis points."""
    option_adjusted_spread_bp: Optional[float] = rest_field(name="optionAdjustedSpreadBp")
    """The spread applied to the benchmark yield curve and used to compute the yield of the
     instrument, taking into account the embedded options. The value is expressed in basis points."""
    zero_volatility_option_adjusted_spread_bp: Optional[float] = rest_field(name="zeroVolatilityOptionAdjustedSpreadBp")
    """The option-adjusted spread computed with a flat volatility equal to zero. The value is
     expressed in basis points."""
    asset_swap_spread_amount: Optional[float] = rest_field(name="assetSwapSpreadAmount")
    """The amount equivalent to  AssetSwapSpreadBp  . The value is expressed in units of the bond
     currency. Available for fixed-rate and floating-rate notes."""
    upfront_spread_amount: Optional[float] = rest_field(name="upfrontSpreadAmount")
    """The amount that makes the bond price par, using the current or forward reference rates from the
     zero curve. The value is expressed in units of the bond currency.
     For more details on the field calculation, please refer here."""
    upfront_spread_bp: Optional[float] = rest_field(name="upfrontSpreadBp")
    """The spread applied to the current or forward reference rates from the zero curve to make the
     bond price par. The value is expressed in basis points."""
    asset_swap_spread_bp: Optional[float] = rest_field(name="assetSwapSpreadBp")
    """The spread over or under the reference rate (e.g., '  LIBOR  ') for a bond whose cash flows
     have been converted from fixed to floating via an interest rate swap. The value is expressed in
     basis points. Available for fixed-rate and floating-rate notes."""
    swap_spread_tenor: Optional[str] = rest_field(name="swapSpreadTenor")
    """The code indicating the interest rate curve tenor used for  SwapSpreadBp  computations. The
     possible value is 'OIS'."""
    swap_spread_bp: Optional[float] = rest_field(name="swapSpreadBp")
    """The spread applied to the yield of the swap benchmark curve and used to compute the yield of
     the instrument to be priced. The mode of benchmark yield selection for the instrument
     redemption date is defined in pricing parameter benchmarkYieldSelectionMode. The value is
     expressed in basis points.
     For more details on the field calculation, please refer here."""
    swap_benchmark_curve_yield_percent: Optional[float] = rest_field(name="swapBenchmarkCurveYieldPercent")
    """The yield percent of the swap benchmark curve used to compute  SwapSpreadBp  . The yield is
     computed at the instrument redemption date using the nearest point or by interpolation of the
     benchmark curve (defined in pricing parameter  benchmarkYieldSelectionMode  )."""
    swap_benchmark_curve_name: Optional[str] = rest_field(name="swapBenchmarkCurveName")
    """The name of the swap benchmark curve used to compute  SwapSpreadBp  ."""
    swap_benchmark_curve_nearest_ric: Optional[str] = rest_field(name="swapBenchmarkCurveNearestRic")
    """The RIC of the point of the swap benchmark curve that is the nearest to the instrument
     redemption date."""
    swap_benchmark_curve_lower_ric: Optional[str] = rest_field(name="swapBenchmarkCurveLowerRic")
    """The RIC of the point of the swap benchmark curve that is lower to the instrument redemption
     date."""
    swap_benchmark_curve_upper_ric: Optional[str] = rest_field(name="swapBenchmarkCurveUpperRic")
    """The RIC of the point of the swap benchmark curve that is upper to the instrument redemption
     date."""
    government_spread_bp: Optional[float] = rest_field(name="governmentSpreadBp")
    """The spread applied to the yield of the government benchmark curve and used to compute the yield
     of the instrument to be priced. The government benchmark curve is computed from the currency of
     the instrument. The mode of benchmark yield selection for the instrument redemption date is
     defined in pricing parameter benchmarkYieldSelectionMode. The value is expressed in basis
     points.
     For more details on the field calculation, please refer here."""
    government_nearest_spread_bp: Optional[float] = rest_field(name="governmentNearestSpreadBp")
    """The spread applied to the yield of the government benchmark curve computed using the nearest
     point of this curve to the instrument redemption date. The value is expressed in basis points."""
    government_benchmark_curve_yield_percent: Optional[float] = rest_field(name="governmentBenchmarkCurveYieldPercent")
    """The yield percent of the government benchmark curve used to compute  GovernmentSpreadBp  . The
     government benchmark curve is defined by the currency of the instrument. The yield is computed
     at the instrument redemption date using the nearest point or by interpolation of the benchmark
     curve (defined in pricing parameter  benchmarkYieldSelectionMode  )."""
    government_benchmark_curve_name: Optional[str] = rest_field(name="governmentBenchmarkCurveName")
    """The name of the government benchmark curve used to compute  GovernmentSpreadBp  ."""
    government_benchmark_curve_nearest_ric: Optional[str] = rest_field(name="governmentBenchmarkCurveNearestRic")
    """The RIC of the point of the government benchmark curve that is the nearest to the instrument
     redemption date."""
    government_benchmark_curve_lower_ric: Optional[str] = rest_field(name="governmentBenchmarkCurveLowerRic")
    """The RIC of the point of the government benchmark curve that is lower to the instrument
     redemption date."""
    government_benchmark_curve_upper_ric: Optional[str] = rest_field(name="governmentBenchmarkCurveUpperRic")
    """The RIC of the point of the government benchmark curve that is upper to the instrument
     redemption date."""
    gov_country_spread_bp: Optional[float] = rest_field(name="govCountrySpreadBp")
    """The spread applied to the yield of the government country benchmark curve and used to compute
     the yield of the instrument to be priced. The government country benchmark curve is defined by
     the country of the instrument. It is available only for European countries and USA (USA
     govCountry benchmark is US Treasuries). The mode of benchmark yield selection for the
     instrument redemption date is defined in pricing parameter benchmarkYieldSelectionMode. The
     value is expressed in basis points.
     For more details on the field calculation, please refer here."""
    gov_country_benchmark_curve_yield_percent: Optional[float] = rest_field(name="govCountryBenchmarkCurveYieldPercent")
    """The yield percent of the government country benchmark curve used to compute  GovCountrySpreadBp
     . The government country benchmark curve is defined by the country of the instrument. It is
     available only for European countries and USA (USA govCountry benchmark is US Treasuries). The
     yield is computed at the instrument redemption date using the nearest point or by interpolation
     of the benchmark curve (defined in pricing parameter  benchmarkYieldSelectionMode  )."""
    gov_country_benchmark_curve_name: Optional[str] = rest_field(name="govCountryBenchmarkCurveName")
    """The name of the government country benchmark curve used to compute  GovCountrySpreadBp  ."""
    gov_country_benchmark_curve_nearest_ric: Optional[str] = rest_field(name="govCountryBenchmarkCurveNearestRic")
    """The RIC of the point of the government country benchmark curve that is the nearest to the
     instrument redemption date."""
    gov_country_benchmark_curve_lower_ric: Optional[str] = rest_field(name="govCountryBenchmarkCurveLowerRic")
    """The RIC of the point of the government country benchmark curve that is lower to the instrument
     redemption date."""
    gov_country_benchmark_curve_upper_ric: Optional[str] = rest_field(name="govCountryBenchmarkCurveUpperRic")
    """The RIC of the point of the government country benchmark curve that is upper to the instrument
     redemption date."""
    cds_spread_bp: Optional[float] = rest_field(name="cdsSpreadBp")
    """The spread applied to the yield of the CDS benchmark curve and used to compute the yield of the
     instrument to be priced. The mode of benchmark yield selection for the instrument redemption
     date is defined in pricing parameter  benchmarkYieldSelectionMode  . The value is expressed in
     basis points."""
    cds_basis_bp: Optional[float] = rest_field(name="cdsBasisBp")
    """The difference between CdsSpreadBp and the spread of the instrument (ZSpreadBp for the fixed
     rate instrument or DiscountMarginBp for the floating rate instrument). The value is expressed
     in basis points.
     For more details on the field calculation, please refer here."""
    cds_nearest_spread_bp: Optional[float] = rest_field(name="cdsNearestSpreadBp")
    """The spread of the CDS benchmark curve at the nearest point to the instrument redemption date."""
    cds_nearest_basis_bp: Optional[float] = rest_field(name="cdsNearestBasisBp")
    """The difference between  CdsNearestSpreadBp  and the spread of the instrument (  ZSpreadBp  for
     the fixed rate instrument or  DiscountMarginBp  for the floating rate instrument). The value ie
     expressed in basis points."""
    cds_benchmark_curve_name: Optional[str] = rest_field(name="cdsBenchmarkCurveName")
    """The name of the CDS benchmark curve used to compute  CdsSpreadBp  ."""
    cds_benchmark_curve_nearest_ric: Optional[str] = rest_field(name="cdsBenchmarkCurveNearestRic")
    """The RIC of the point of the CDS curve that is the nearest to the instrument redemption date."""
    rating_spread_bp: Optional[float] = rest_field(name="ratingSpreadBp")
    """The spread applied to the yield of the rating benchmark curve and used to compute the yield of
     the instrument to be priced. The rating benchmark curve is the curve with same currency and
     rating as the instrument. The mode of benchmark yield selection for the instrument redemption
     date is defined in pricing parameter benchmarkYieldSelectionMode. The value is expressed in
     basis points.
     For more details on the field calculation, please refer here."""
    rating_benchmark_curve_yield_percent: Optional[float] = rest_field(name="ratingBenchmarkCurveYieldPercent")
    """The yield percent of the rating benchmark curve used to compute  RatingSpreadBp  . The yield is
     computed at the instrument redemption date using the nearest point or by interpolation of the
     benchmark curve (defined in pricing parameter  benchmarkYieldSelectionMode  )."""
    rating_benchmark_curve_name: Optional[str] = rest_field(name="ratingBenchmarkCurveName")
    """The name of the rating benchmark curve used to compute  RatingSpreadBp  ."""
    rating_benchmark_curve_nearest_ric: Optional[str] = rest_field(name="ratingBenchmarkCurveNearestRic")
    """The RIC of the point of the rating benchmark curve that is the nearest to the instrument
     redemption date."""
    rating_benchmark_curve_lower_ric: Optional[str] = rest_field(name="ratingBenchmarkCurveLowerRic")
    """The RIC of the point of the rating benchmark curve that is lower to the instrument redemption
     date."""
    rating_benchmark_curve_upper_ric: Optional[str] = rest_field(name="ratingBenchmarkCurveUpperRic")
    """The RIC of the point of the rating benchmark curve that is upper to the instrument redemption
     date."""
    sector_rating_spread_bp: Optional[float] = rest_field(name="sectorRatingSpreadBp")
    """The spread applied to the yield of the sector rating benchmark curve and used to compute the
     yield of the instrument to be priced. The sector rating benchmark curve is the curve with same
     currency, rating and sector as the instrument. The mode of benchmark yield selection for the
     instrument redemption date is defined in pricing parameter benchmarkYieldSelectionMode. The
     value is expressed in basis points.
     For more details on the field calculation, please refer here."""
    sector_rating_benchmark_curve_yield_percent: Optional[float] = rest_field(
        name="sectorRatingBenchmarkCurveYieldPercent"
    )
    """The yield percent of the sector rating benchmark curve used to compute  SectorRatingSpreadBp  .
     The yield is computed at the instrument redemption date using the nearest point or by
     interpolation of the benchmark curve (defined in pricing parameter  benchmarkYieldSelectionMode
     )."""
    sector_rating_benchmark_curve_name: Optional[str] = rest_field(name="sectorRatingBenchmarkCurveName")
    """The name of the sector rating benchmark curve used to compute  SectorRatingSpreadBp  ."""
    sector_rating_benchmark_curve_nearest_ric: Optional[str] = rest_field(name="sectorRatingBenchmarkCurveNearestRic")
    """The RIC of the point of the sector rating benchmark curve that is the nearest to the instrument
     redemption date."""
    sector_rating_benchmark_curve_lower_ric: Optional[str] = rest_field(name="sectorRatingBenchmarkCurveLowerRic")
    """The RIC of the point of the sector rating benchmark curve that is lower to the instrument
     redemption date."""
    sector_rating_benchmark_curve_upper_ric: Optional[str] = rest_field(name="sectorRatingBenchmarkCurveUpperRic")
    """The RIC of the point of the sector rating benchmark curve that is upper to the instrument
     redemption date."""
    benchmark_at_issue_spread_bp: Optional[float] = rest_field(name="benchmarkAtIssueSpreadBp")
    """The spread applied to the yield of the benchmark at issue and used to compute the yield of the
     instrument to be priced. The value is expressed in basis points.
     For more details on the field calculation, please refer here."""
    benchmark_at_issue_ric: Optional[str] = rest_field(name="benchmarkAtIssueRic")
    """The RIC of the benchmark at the instrument issue date."""
    benchmark_at_issue_price: Optional[float] = rest_field(name="benchmarkAtIssuePrice")
    """The price of the benchmark at the instrument issue date, equivalent to
     BenchmarkAtIssueYieldPercent  ."""
    benchmark_at_issue_yield_percent: Optional[float] = rest_field(name="benchmarkAtIssueYieldPercent")
    """The yield percent of the benchmark at the instrument issue date used to compute
     BenchmarkAtIssueSpreadBp  ."""
    benchmark_at_redemption_spread_bp: Optional[float] = rest_field(name="benchmarkAtRedemptionSpreadBp")
    """The spread applied to the yield of the benchmark defined for the current instrument at
     redemption date and used to compute the yield of the instrument to be priced. The value is
     expressed in basis points.
     For more details on the field calculation, please refer here."""
    benchmark_at_redemption_ric: Optional[str] = rest_field(name="benchmarkAtRedemptionRic")
    """The RIC of the benchmark at the instrument current redemption date."""
    benchmark_at_redemption_price: Optional[float] = rest_field(name="benchmarkAtRedemptionPrice")
    """The price of the benchmark at the instrument current redemption date, equivalent to
     BenchmarkAtRedemptionYieldPercent  ."""
    benchmark_at_redemption_yield_percent: Optional[float] = rest_field(name="benchmarkAtRedemptionYieldPercent")
    """The yield percent of the benchmark at the instrument current redemption date used to compute
     BenchmarkAtRedemptionSpreadBp  ."""
    efp_spread_bp: Optional[float] = rest_field(name="efpSpreadBp")
    """The spread applied to the yield of the Exchange of futures for physical (EFP) benchmark,
     computed at the instrument redemption date and used to compute the yield of the instrument to
     be priced. The value is expressed in basis points. Available only for Australian fixed rate
     bonds.
     For more details on the field calculation, please refer here."""
    efp_benchmark_price: Optional[float] = rest_field(name="efpBenchmarkPrice")
    """The price of the Exchange of futures for physical (  EFP  ) benchmark, equivalent to
     EfpBenchmarkYieldPercent  . Available only for Australian fixed rate bonds."""
    efp_benchmark_yield_percent: Optional[float] = rest_field(name="efpBenchmarkYieldPercent")
    """The yield percent of the Exchange of futures for physical (  EFP  ) benchmark used to compute
     EfpSpreadBp  . The yield is computed at the instrument redemption date. Available only for
     Australian fixed rate bonds."""
    efp_benchmark_ric: Optional[str] = rest_field(name="efpBenchmarkRic")
    """The RIC of the Exchange of futures for physical (  EFP  ) benchmark. The RIC can only be '
     YTTc1  ' or '  YTCc1  '  .  Available only for Australian fixed rate bonds."""
    edsf_spread_bp: Optional[float] = rest_field(name="edsfSpreadBp")
    """The spread applied to the yield of the Euro-Dollar future benchmark curve and used to compute
     the yield of the instrument to be priced. This spread is computed for the USD bond whose
     maturity is under 2 years. The mode of benchmark yield selection for the instrument redemption
     date is defined in pricing parameter benchmarkYieldSelectionMode. The value is expressed in
     basis points.
     For more details on the field calculation, please refer here."""
    edsf_benchmark_curve_yield_percent: Optional[float] = rest_field(name="edsfBenchmarkCurveYieldPercent")
    """The yield percent of the Euro-Dollar future benchmark curve, used to compute  EdsfSpreadBp  .
     The yield is computed at the instrument redemption date using the nearest point or by
     interpolation of the benchmark curve (defined in pricing parameter  benchmarkYieldSelectionMode
     )."""
    issuer_spread_bp: Optional[float] = rest_field(name="issuerSpreadBp")
    """The spread applied to the yield of the issuer benchmark curve and used to compute the yield of
     the instrument to be priced. The value is expressed in basis points.
     For more details on the field calculation, please refer here."""
    issuer_benchmark_curve_yield_percent: Optional[float] = rest_field(name="issuerBenchmarkCurveYieldPercent")
    """The yield percent of the issuer benchmark curve, used to compute  IssuerSpreadBp  ."""
    ois_zc_benchmark_curve_yield_percent: Optional[float] = rest_field(name="oisZcBenchmarkCurveYieldPercent")
    """The yield percent of the overnight indexed swap (  OIS  ) zero curve used to compute
     OisZcSpreadBp  . The OIS zero curve is computed from the pricing currency. The yield is
     computed at the instrument redemption date using the nearest point or by interpolation of the
     benchmark curve (defined in pricing parameter  benchmarkYieldSelectionMode  )."""
    ois_zc_spread_bp: Optional[float] = rest_field(name="oisZcSpreadBp")
    """The spread applied to the yield of the overnight indexed swap (OIS) zero curve and used to
     compute the yield of the instrument to be priced. The OIS zero curve is computed from the
     pricing currency. The mode of benchmark yield selection for the instrument redemption date is
     defined in pricing parameter benchmarkYieldSelectionMode. The value is expressed in basis
     points.
     For more details on the field calculation, please refer here."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        benchmark_yield_selection_mode: Optional[str] = None,
        zspread_bp: Optional[float] = None,
        option_adjusted_spread_bp: Optional[float] = None,
        zero_volatility_option_adjusted_spread_bp: Optional[float] = None,
        asset_swap_spread_amount: Optional[float] = None,
        upfront_spread_amount: Optional[float] = None,
        upfront_spread_bp: Optional[float] = None,
        asset_swap_spread_bp: Optional[float] = None,
        swap_spread_tenor: Optional[str] = None,
        swap_spread_bp: Optional[float] = None,
        swap_benchmark_curve_yield_percent: Optional[float] = None,
        swap_benchmark_curve_name: Optional[str] = None,
        swap_benchmark_curve_nearest_ric: Optional[str] = None,
        swap_benchmark_curve_lower_ric: Optional[str] = None,
        swap_benchmark_curve_upper_ric: Optional[str] = None,
        government_spread_bp: Optional[float] = None,
        government_nearest_spread_bp: Optional[float] = None,
        government_benchmark_curve_yield_percent: Optional[float] = None,
        government_benchmark_curve_name: Optional[str] = None,
        government_benchmark_curve_nearest_ric: Optional[str] = None,
        government_benchmark_curve_lower_ric: Optional[str] = None,
        government_benchmark_curve_upper_ric: Optional[str] = None,
        gov_country_spread_bp: Optional[float] = None,
        gov_country_benchmark_curve_yield_percent: Optional[float] = None,
        gov_country_benchmark_curve_name: Optional[str] = None,
        gov_country_benchmark_curve_nearest_ric: Optional[str] = None,
        gov_country_benchmark_curve_lower_ric: Optional[str] = None,
        gov_country_benchmark_curve_upper_ric: Optional[str] = None,
        cds_spread_bp: Optional[float] = None,
        cds_basis_bp: Optional[float] = None,
        cds_nearest_spread_bp: Optional[float] = None,
        cds_nearest_basis_bp: Optional[float] = None,
        cds_benchmark_curve_name: Optional[str] = None,
        cds_benchmark_curve_nearest_ric: Optional[str] = None,
        rating_spread_bp: Optional[float] = None,
        rating_benchmark_curve_yield_percent: Optional[float] = None,
        rating_benchmark_curve_name: Optional[str] = None,
        rating_benchmark_curve_nearest_ric: Optional[str] = None,
        rating_benchmark_curve_lower_ric: Optional[str] = None,
        rating_benchmark_curve_upper_ric: Optional[str] = None,
        sector_rating_spread_bp: Optional[float] = None,
        sector_rating_benchmark_curve_yield_percent: Optional[float] = None,
        sector_rating_benchmark_curve_name: Optional[str] = None,
        sector_rating_benchmark_curve_nearest_ric: Optional[str] = None,
        sector_rating_benchmark_curve_lower_ric: Optional[str] = None,
        sector_rating_benchmark_curve_upper_ric: Optional[str] = None,
        benchmark_at_issue_spread_bp: Optional[float] = None,
        benchmark_at_issue_ric: Optional[str] = None,
        benchmark_at_issue_price: Optional[float] = None,
        benchmark_at_issue_yield_percent: Optional[float] = None,
        benchmark_at_redemption_spread_bp: Optional[float] = None,
        benchmark_at_redemption_ric: Optional[str] = None,
        benchmark_at_redemption_price: Optional[float] = None,
        benchmark_at_redemption_yield_percent: Optional[float] = None,
        efp_spread_bp: Optional[float] = None,
        efp_benchmark_price: Optional[float] = None,
        efp_benchmark_yield_percent: Optional[float] = None,
        efp_benchmark_ric: Optional[str] = None,
        edsf_spread_bp: Optional[float] = None,
        edsf_benchmark_curve_yield_percent: Optional[float] = None,
        issuer_spread_bp: Optional[float] = None,
        issuer_benchmark_curve_yield_percent: Optional[float] = None,
        ois_zc_benchmark_curve_yield_percent: Optional[float] = None,
        ois_zc_spread_bp: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BondValuation(_model_base.Model):
    """Valuation Object.

    Attributes
    ----------
    cash_amount : float
        The cash amount of the instrument. For more details on the field
        calculation, please refer here.
    lft_factor : float
        The cumulative Selic factor computed for Brazilian LFT (Letras
        Financeiras do Tesouro). It is based on the daily Selic interest rate
        set by Brazilian Central Bank accumulated since the reference date
        (2000-07-01). For more details on the field calculation, please refer
        here.
    lft_vna : float
        The nominal value (or VNA - Valor Nominal Acumulado) adjusted by the
        LftFactor. It is available for Brazilian LFT (Letras Financeiras do
        Tesouro) only. For more details on the field calculation, please refer
        here.
    par_rate_percent : float
        A fixed interest rate at which the theoretical par value is 100 (when
        CouponRate = YieldPercent and Price=100). The value is expressed in
        percentages.
    accrued_days : int
        The number of days since the last interest payment date or since the
        dated date of the instrument.
    accrued_percent : float
        The accrued interest amount, which is accumulated but not paid out. The
        value is expressed in percentages. For more details on the field
        calculation, please refer here.
    accrued : float
        The accrued interest amount, which is accumulated but not paid out. The
        value is expressed in bond quotation units (percentage or cash). For
        more details on the field calculation, please refer here.
    trade_date_accrued : float
        The accrued interest amount, which is accumulated on the trade date but
        not paid out. The value is expressed in bond quotation units
        (percentage or cash). The field calculation is the same as for Accrued.
    trade_date_accrued_percent : float
        The accrued interest amount, which is accumulated on the trade date but
        not paid out. The value is expressed in percentages. The field
        calculation is the same as for AccruedPercent.
    adjusted_accrued : float
        The instrument Accrued computed with [inflationMode = Adjusted]. The
        value is expressed in bond quotation units (percentage or cash).
        Available only for inflation-linked instruments. For more details on
        the field calculation, please refer here.
    accrued_amount_in_deal_ccy : float
        The accrued interest amount. It is computed from the accrued percent
        and the notional amount. The value is expressed in the deal currency.
        For more details on the field calculation, please refer here.
    accrued_amount_in_report_ccy : float
        The accrued interest amount. It is computed from the accrued percent
        and the notional amount. The value is expressed in the reporting
        currency.
    capitalized_accrued_amount_in_deal_ccy : float
        The amount of capitalized accrued interest. The value is expressed in
        the deal currency.
    capitalized_accrued_amount_in_report_ccy : float
        The amount of capitalized accrued interest. The value is expressed in
        the reporting currency.
    total_accrued_in_deal_ccy : float
        The total accrued interest amount. The value is expressed in the deal
        currency. For more details on the field calculation, please refer here.
    total_accrued_in_report_ccy : float
        The total accrued amount. The value is expressed in the reporting
        currency.
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency. For more details on the field calculation, please refer here.
    market_value_in_report_ccy : float
        The market value of the instrument. The value is expressed in the
        reporting currency.
    clean_market_value_in_deal_ccy : float
        The market value of the instrument less any accrued interest. The value
        is expressed in the deal currency. For more details on the field
        calculation, please refer here.
    clean_market_value_in_report_ccy : float
        The market value of the instrument less any accrued interest and fees.
        The value is expressed in the reporting currency.
    position_in_deal_ccy : float
        The initial position of the instrument expressed in the deal currency.
        For more details on the field calculation, please refer here.
    position_in_report_ccy : float
        The initial position of the instrument expressed in the reporting
        currency.
    """

    cash_amount: Optional[float] = rest_field(name="cashAmount")
    """The cash amount of the instrument.
     For more details on the field calculation, please refer here."""
    lft_factor: Optional[float] = rest_field(name="lftFactor")
    """The cumulative Selic factor computed for Brazilian LFT (Letras Financeiras do Tesouro). It is
     based on the daily Selic interest rate set by Brazilian Central Bank accumulated since the
     reference date (2000-07-01).
     For more details on the field calculation, please refer here."""
    lft_vna: Optional[float] = rest_field(name="lftVna")
    """The nominal value (or VNA - Valor Nominal Acumulado) adjusted by the LftFactor. It is available
     for Brazilian LFT (Letras Financeiras do Tesouro) only.
     For more details on the field calculation, please refer here."""
    par_rate_percent: Optional[float] = rest_field(name="parRatePercent")
    """A fixed interest rate at which the theoretical par value is 100 (when CouponRate = YieldPercent
     and Price=100). The value is expressed in percentages."""
    accrued_days: Optional[int] = rest_field(name="accruedDays")
    """The number of days since the last interest payment date or since the dated date of the
     instrument."""
    accrued_percent: Optional[float] = rest_field(name="accruedPercent")
    """The accrued interest amount, which is accumulated but not paid out. The value is expressed in
     percentages.
     For more details on the field calculation, please refer here."""
    accrued: Optional[float] = rest_field()
    """The accrued interest amount, which is accumulated but not paid out. The value is expressed in
     bond quotation units (percentage or cash).
     For more details on the field calculation, please refer here."""
    trade_date_accrued: Optional[float] = rest_field(name="tradeDateAccrued")
    """The accrued interest amount, which is accumulated on the trade date but not paid out. The value
     is expressed in bond quotation units (percentage or cash).
     The field calculation is the same as for Accrued."""
    trade_date_accrued_percent: Optional[float] = rest_field(name="tradeDateAccruedPercent")
    """The accrued interest amount, which is accumulated on the trade date but not paid out. The value
     is expressed in percentages.
     The field calculation is the same as for AccruedPercent."""
    adjusted_accrued: Optional[float] = rest_field(name="adjustedAccrued")
    """The instrument Accrued computed with [inflationMode = Adjusted]. The value is expressed in bond
     quotation units (percentage or cash). Available only for inflation-linked instruments.
     For more details on the field calculation, please refer here."""
    accrued_amount_in_deal_ccy: Optional[float] = rest_field(name="accruedAmountInDealCcy")
    """The accrued interest amount. It is computed from the accrued percent and the notional amount.
     The value is expressed in the deal currency.
     For more details on the field calculation, please refer here."""
    accrued_amount_in_report_ccy: Optional[float] = rest_field(name="accruedAmountInReportCcy")
    """The accrued interest amount. It is computed from the accrued percent and the notional amount.
     The value is expressed in the reporting currency."""
    capitalized_accrued_amount_in_deal_ccy: Optional[float] = rest_field(name="capitalizedAccruedAmountInDealCcy")
    """The amount of capitalized accrued interest. The value is expressed in the deal currency."""
    capitalized_accrued_amount_in_report_ccy: Optional[float] = rest_field(name="capitalizedAccruedAmountInReportCcy")
    """The amount of capitalized accrued interest. The value is expressed in the reporting currency."""
    total_accrued_in_deal_ccy: Optional[float] = rest_field(name="totalAccruedInDealCcy")
    """The total accrued interest amount. The value is expressed in the deal currency.
     For more details on the field calculation, please refer here."""
    total_accrued_in_report_ccy: Optional[float] = rest_field(name="totalAccruedInReportCcy")
    """The total accrued amount. The value is expressed in the reporting currency."""
    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency.
     For more details on the field calculation, please refer here."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value of the instrument. The value is expressed in the reporting currency."""
    clean_market_value_in_deal_ccy: Optional[float] = rest_field(name="cleanMarketValueInDealCcy")
    """The market value of the instrument less any accrued interest. The value is expressed in the
     deal currency.
     For more details on the field calculation, please refer here."""
    clean_market_value_in_report_ccy: Optional[float] = rest_field(name="cleanMarketValueInReportCcy")
    """The market value of the instrument less any accrued interest and fees. The value is expressed
     in the reporting currency."""
    position_in_deal_ccy: Optional[float] = rest_field(name="positionInDealCcy")
    """The initial position of the instrument expressed in the deal currency.
     For more details on the field calculation, please refer here."""
    position_in_report_ccy: Optional[float] = rest_field(name="positionInReportCcy")
    """The initial position of the instrument expressed in the reporting currency."""

    @overload
    def __init__(
        self,
        *,
        cash_amount: Optional[float] = None,
        lft_factor: Optional[float] = None,
        lft_vna: Optional[float] = None,
        par_rate_percent: Optional[float] = None,
        accrued_days: Optional[int] = None,
        accrued_percent: Optional[float] = None,
        accrued: Optional[float] = None,
        trade_date_accrued: Optional[float] = None,
        trade_date_accrued_percent: Optional[float] = None,
        adjusted_accrued: Optional[float] = None,
        accrued_amount_in_deal_ccy: Optional[float] = None,
        accrued_amount_in_report_ccy: Optional[float] = None,
        capitalized_accrued_amount_in_deal_ccy: Optional[float] = None,
        capitalized_accrued_amount_in_report_ccy: Optional[float] = None,
        total_accrued_in_deal_ccy: Optional[float] = None,
        total_accrued_in_report_ccy: Optional[float] = None,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
        clean_market_value_in_deal_ccy: Optional[float] = None,
        clean_market_value_in_report_ccy: Optional[float] = None,
        position_in_deal_ccy: Optional[float] = None,
        position_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BuildResponse(_model_base.Model):
    """A model describing a single build response.

    Attributes
    ----------
    data : ~analyticsapi.models.FxForwardCurveDefinition
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.FxForwardCurveDefinition" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.FxForwardCurveDefinition",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BulkCompact(_model_base.Model):
    """BulkCompact.

    Attributes
    ----------
    path : str
        URL to which each individual request should be posted.i.e "/bond/py"
        for PY calculation.
    name_expr : str
        Name of each request. This can be a valid JSON path expression, i.e
        "concat($.CUSIP,"_PY")" will give each request the name CUSIP_PY. Name
        should be unique within a single job.
    body : str
        POST body associated with the calculation. This is specific to each
        request type. Refer to individual calculation section for more details.
    requests : list[dict[str, any]]
        List of key value pairs. This values provided will be used to update
        corresponding variables in the body of the request.  The default value
        is None, needs to be assigned before using.
    data_source : ~analyticsapi.models.BulkTemplateDataSource
    params : dict[str, any]
    """

    path: Optional[str] = rest_field()
    """URL to which each individual request should be posted.i.e \"/bond/py\" for PY calculation."""
    name_expr: Optional[str] = rest_field(name="nameExpr")
    """Name of each request. This can be a valid JSON path expression, i.e \"concat($.CUSIP,\"_PY\")\"
     will give each request the name CUSIP_PY. Name should be unique within a single job."""
    body: Optional[str] = rest_field()
    """POST body associated with the calculation. This is specific to each request type. Refer to
     individual calculation section for more details."""
    requests: Optional[List[Dict[str, Any]]] = rest_field()
    """List of key value pairs. This values provided will be used to update corresponding variables in
     the body of the request."""
    data_source: Optional["_models.BulkTemplateDataSource"] = rest_field(name="dataSource")
    params: Optional[Dict[str, Any]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        path: Optional[str] = None,
        name_expr: Optional[str] = None,
        body: Optional[str] = None,
        requests: Optional[List[Dict[str, Any]]] = None,
        data_source: Optional["_models.BulkTemplateDataSource"] = None,
        params: Optional[Dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BulkComposite(_model_base.Model):
    """BulkComposite.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    requests : list[~analyticsapi.models.BulkJsonInputItem]
        Required.  The default value is None, needs to be assigned before
        using.
    """

    requests: List["_models.BulkJsonInputItem"] = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        requests: List["_models.BulkJsonInputItem"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["requests"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class BulkDefaultSettings(_model_base.Model):
    """BulkDefaultSettings.

    Attributes
    ----------
    header : bool
    separator : str
    null_value : str
    error_value : str
    number_format : str
    date_format : str
    bool_true : str
    bool_false : str
    quote_char : str
    escape_char : str
    cond_quote : bool
    footer : str
    relaxed : bool
    num_prec : int
    num_scale : int
    str_width : int
    charset : str
    precision : int
    scale : int
    bom : bool
    """

    header: Optional[bool] = rest_field()
    separator: Optional[str] = rest_field()
    null_value: Optional[str] = rest_field(name="nullValue")
    error_value: Optional[str] = rest_field(name="errorValue")
    number_format: Optional[str] = rest_field(name="numberFormat")
    date_format: Optional[str] = rest_field(name="dateFormat")
    bool_true: Optional[str] = rest_field(name="boolTrue")
    bool_false: Optional[str] = rest_field(name="boolFalse")
    quote_char: Optional[str] = rest_field(name="quoteChar")
    escape_char: Optional[str] = rest_field(name="escapeChar")
    cond_quote: Optional[bool] = rest_field(name="condQuote")
    footer: Optional[str] = rest_field()
    relaxed: Optional[bool] = rest_field()
    num_prec: Optional[int] = rest_field(name="numPrec")
    num_scale: Optional[int] = rest_field(name="numScale")
    str_width: Optional[int] = rest_field(name="strWidth")
    charset: Optional[str] = rest_field()
    precision: Optional[int] = rest_field()
    scale: Optional[int] = rest_field()
    bom: Optional[bool] = rest_field()

    @overload
    def __init__(
        self,
        *,
        header: Optional[bool] = None,
        separator: Optional[str] = None,
        null_value: Optional[str] = None,
        error_value: Optional[str] = None,
        number_format: Optional[str] = None,
        date_format: Optional[str] = None,
        bool_true: Optional[str] = None,
        bool_false: Optional[str] = None,
        quote_char: Optional[str] = None,
        escape_char: Optional[str] = None,
        cond_quote: Optional[bool] = None,
        footer: Optional[str] = None,
        relaxed: Optional[bool] = None,
        num_prec: Optional[int] = None,
        num_scale: Optional[int] = None,
        str_width: Optional[int] = None,
        charset: Optional[str] = None,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
        bom: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BulkGlobalSettings(_model_base.Model):
    """BulkGlobalSettings.

    Attributes
    ----------
    sql_settings : ~analyticsapi.models.SqlSettings
    """

    sql_settings: Optional["_models.SqlSettings"] = rest_field(name="sqlSettings")

    @overload
    def __init__(
        self,
        sql_settings: Optional["_models.SqlSettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["sql_settings"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class BulkJsonInputItem(_model_base.Model):
    """BulkJsonInputItem.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    path : str
        Required.
    name : str
    priority : int
    dep : str
    visible : str
    parent_req : str
    tags : str
    body : str
    """

    path: str = rest_field()
    """Required."""
    name: Optional[str] = rest_field()
    priority: Optional[int] = rest_field()
    dep: Optional[str] = rest_field()
    visible: Optional[str] = rest_field()
    parent_req: Optional[str] = rest_field(name="parentReq")
    tags: Optional[str] = rest_field()
    body: Optional[str] = rest_field()

    @overload
    def __init__(
        self,
        *,
        path: str,
        name: Optional[str] = None,
        priority: Optional[int] = None,
        dep: Optional[str] = None,
        visible: Optional[str] = None,
        parent_req: Optional[str] = None,
        tags: Optional[str] = None,
        body: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BulkMeta(_model_base.Model):
    """BulkMeta.

    Attributes
    ----------
    request_id : str
    time_stamp : ~datetime.datetime
    status : str
        Is one of the following types: Literal["NEW"], Literal["WAITING"],
        Literal["PENDING"], Literal["RUNNING"], Literal["ABORTING"],
        Literal["DONE"], Literal["ERROR"], Literal["SKIPPED"],
        Literal["ABORTED"]
    correlation_id : str
    response_type : str
        Is one of the following types: Literal["BOND_INDIC"],
        Literal["BOND_SEARCH"], Literal["CURVE_POINTS"],
        Literal["MARKET_SETTINGS"], Literal["MBS_HISTORY"], Literal["PY_CALC"],
        Literal["COLLATERAL_DETAILS"], Literal["CALC_SETTINGS"],
        Literal["MORTGAGE_MODEL"], Literal["ACTUAL_VS_PROJECTED"],
        Literal["WAL_SENSITIVITY"], Literal["SCENARIO_CALC"],
        Literal["MATRIX_PY"], Literal["HISTORICAL_DATA"], Literal["CASHFLOW"],
        Literal["VOLATILITY"], Literal["TEST"], Literal["SCENARIO_SETUPS"],
        Literal["XMLAPI"], Literal["BULK_ZIP"], Literal["BULK_COMPOSITE"],
        Literal["FORWARD_PRICING"], Literal["CALC_STATUS"],
        Literal["DELIMITED"], Literal["COMPACT"], Literal["BULK"],
        Literal["FX_FWDS"], Literal["USER_CURVE"], Literal["WAIT"],
        Literal["RETURNS_CALC"], Literal["TABLE"], Literal["PREPAY_DIALS"],
        Literal["USER_VOL"], Literal["YBPORT_USER_BONDS"], Literal["ESG_PCR"]
    job_id : str
    """

    request_id: Optional[str] = rest_field(name="requestId")
    time_stamp: Optional[datetime.datetime] = rest_field(name="timeStamp", format="rfc3339")
    status: Optional[
        Literal["NEW", "WAITING", "PENDING", "RUNNING", "ABORTING", "DONE", "ERROR", "SKIPPED", "ABORTED"]
    ] = rest_field()
    """Is one of the following types: Literal[\"NEW\"], Literal[\"WAITING\"], Literal[\"PENDING\"],
     Literal[\"RUNNING\"], Literal[\"ABORTING\"], Literal[\"DONE\"], Literal[\"ERROR\"],
     Literal[\"SKIPPED\"], Literal[\"ABORTED\"]"""
    correlation_id: Optional[str] = rest_field(name="correlationId")
    response_type: Optional[
        Literal[
            "BOND_INDIC",
            "BOND_SEARCH",
            "CURVE_POINTS",
            "MARKET_SETTINGS",
            "MBS_HISTORY",
            "PY_CALC",
            "COLLATERAL_DETAILS",
            "CALC_SETTINGS",
            "MORTGAGE_MODEL",
            "ACTUAL_VS_PROJECTED",
            "WAL_SENSITIVITY",
            "SCENARIO_CALC",
            "MATRIX_PY",
            "HISTORICAL_DATA",
            "CASHFLOW",
            "VOLATILITY",
            "TEST",
            "SCENARIO_SETUPS",
            "XMLAPI",
            "BULK_ZIP",
            "BULK_COMPOSITE",
            "FORWARD_PRICING",
            "CALC_STATUS",
            "DELIMITED",
            "COMPACT",
            "BULK",
            "FX_FWDS",
            "USER_CURVE",
            "WAIT",
            "RETURNS_CALC",
            "TABLE",
            "PREPAY_DIALS",
            "USER_VOL",
            "YBPORT_USER_BONDS",
            "ESG_PCR",
        ]
    ] = rest_field(name="responseType")
    """Is one of the following types: Literal[\"BOND_INDIC\"], Literal[\"BOND_SEARCH\"],
     Literal[\"CURVE_POINTS\"], Literal[\"MARKET_SETTINGS\"], Literal[\"MBS_HISTORY\"],
     Literal[\"PY_CALC\"], Literal[\"COLLATERAL_DETAILS\"], Literal[\"CALC_SETTINGS\"],
     Literal[\"MORTGAGE_MODEL\"], Literal[\"ACTUAL_VS_PROJECTED\"], Literal[\"WAL_SENSITIVITY\"],
     Literal[\"SCENARIO_CALC\"], Literal[\"MATRIX_PY\"], Literal[\"HISTORICAL_DATA\"],
     Literal[\"CASHFLOW\"], Literal[\"VOLATILITY\"], Literal[\"TEST\"],
     Literal[\"SCENARIO_SETUPS\"], Literal[\"XMLAPI\"], Literal[\"BULK_ZIP\"],
     Literal[\"BULK_COMPOSITE\"], Literal[\"FORWARD_PRICING\"], Literal[\"CALC_STATUS\"],
     Literal[\"DELIMITED\"], Literal[\"COMPACT\"], Literal[\"BULK\"], Literal[\"FX_FWDS\"],
     Literal[\"USER_CURVE\"], Literal[\"WAIT\"], Literal[\"RETURNS_CALC\"], Literal[\"TABLE\"],
     Literal[\"PREPAY_DIALS\"], Literal[\"USER_VOL\"], Literal[\"YBPORT_USER_BONDS\"],
     Literal[\"ESG_PCR\"]"""
    job_id: Optional[str] = rest_field(name="jobId")

    @overload
    def __init__(
        self,
        *,
        request_id: Optional[str] = None,
        time_stamp: Optional[datetime.datetime] = None,
        status: Optional[
            Literal["NEW", "WAITING", "PENDING", "RUNNING", "ABORTING", "DONE", "ERROR", "SKIPPED", "ABORTED"]
        ] = None,
        correlation_id: Optional[str] = None,
        response_type: Optional[
            Literal[
                "BOND_INDIC",
                "BOND_SEARCH",
                "CURVE_POINTS",
                "MARKET_SETTINGS",
                "MBS_HISTORY",
                "PY_CALC",
                "COLLATERAL_DETAILS",
                "CALC_SETTINGS",
                "MORTGAGE_MODEL",
                "ACTUAL_VS_PROJECTED",
                "WAL_SENSITIVITY",
                "SCENARIO_CALC",
                "MATRIX_PY",
                "HISTORICAL_DATA",
                "CASHFLOW",
                "VOLATILITY",
                "TEST",
                "SCENARIO_SETUPS",
                "XMLAPI",
                "BULK_ZIP",
                "BULK_COMPOSITE",
                "FORWARD_PRICING",
                "CALC_STATUS",
                "DELIMITED",
                "COMPACT",
                "BULK",
                "FX_FWDS",
                "USER_CURVE",
                "WAIT",
                "RETURNS_CALC",
                "TABLE",
                "PREPAY_DIALS",
                "USER_VOL",
                "YBPORT_USER_BONDS",
                "ESG_PCR",
            ]
        ] = None,
        job_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BulkResultItem(_model_base.Model):
    """BulkResultItem.

    Attributes
    ----------
    source : str
    id : str
    status : int
    description : str
    target : str
    priority : int
    """

    source: Optional[str] = rest_field()
    id: Optional[str] = rest_field()
    status: Optional[int] = rest_field()
    description: Optional[str] = rest_field()
    target: Optional[str] = rest_field()
    priority: Optional[int] = rest_field()

    @overload
    def __init__(
        self,
        *,
        source: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        status: Optional[int] = None,
        description: Optional[str] = None,
        target: Optional[str] = None,
        priority: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BulkResultRequest(_model_base.Model):
    """BulkResultRequest.

    Attributes
    ----------
    default_settings : ~analyticsapi.models.BulkDefaultSettings
    global_settings : ~analyticsapi.models.BulkGlobalSettings
    fields : list[~analyticsapi.models.ColumnDetail]
        The default value is None, needs to be assigned before using.
    """

    default_settings: Optional["_models.BulkDefaultSettings"] = rest_field(name="defaultSettings")
    global_settings: Optional["_models.BulkGlobalSettings"] = rest_field(name="globalSettings")
    fields: Optional[List["_models.ColumnDetail"]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        default_settings: Optional["_models.BulkDefaultSettings"] = None,
        global_settings: Optional["_models.BulkGlobalSettings"] = None,
        fields: Optional[List["_models.ColumnDetail"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BulkTemplateDataSource(_model_base.Model):
    """BulkTemplateDataSource.

    Attributes
    ----------
    request_id : str
        Reference to data source, this can be request id or request name.
    filter : str
        This is condition that can be provided to filter data from the data
        source.
    name_prefix : str
    name_suffix : str
    """

    request_id: Optional[str] = rest_field(name="requestId")
    """Reference to data source, this can be request id or request name."""
    filter: Optional[str] = rest_field()
    """This is condition that can be provided to filter data from the data source."""
    name_prefix: Optional[str] = rest_field(name="namePrefix")
    name_suffix: Optional[str] = rest_field(name="nameSuffix")

    @overload
    def __init__(
        self,
        *,
        request_id: Optional[str] = None,
        filter: Optional[str] = None,  # pylint: disable=redefined-builtin
        name_prefix: Optional[str] = None,
        name_suffix: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class BusinessDayAdjustmentDefinition(_model_base.Model):
    """An object that defines the business day adjustment convention.

    Attributes
    ----------
    calendars : list[str]
        An array of calendar identifiers (GUID or URI) to use for the business
        days adjustment. Typically the calendars are derived based on the
        instrument currency or cross-currency code. Note that a URI must be at
        least 2 and at most 102 characters long, start with an alphanumeric
        character, and contain only alphanumeric characters, slashes and
        underscores. Required.  The default value is None, needs to be assigned
        before using.
    convention : str or ~analyticsapi.models.DateMovingConvention
        The method to adjust a date to working days when it falls on a non-
        business day. Required. Known values are: "ModifiedFollowing",
        "NextBusinessDay", "PreviousBusinessDay", "NoMoving",
        "EveryThirdWednesday", and "BbswModifiedFollowing".
    """

    calendars: List[str] = rest_field()
    """An array of calendar identifiers (GUID or URI) to use for the business days adjustment.
     Typically the calendars are derived based on the instrument currency or cross-currency code.
     Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
     character, and contain only alphanumeric characters, slashes and underscores. Required."""
    convention: Union[str, "_models.DateMovingConvention"] = rest_field()
    """The method to adjust a date to working days when it falls on a non-business day. Required.
     Known values are: \"ModifiedFollowing\", \"NextBusinessDay\", \"PreviousBusinessDay\",
     \"NoMoving\", \"EveryThirdWednesday\", and \"BbswModifiedFollowing\"."""

    @overload
    def __init__(
        self,
        *,
        calendars: List[str],
        convention: Union[str, "_models.DateMovingConvention"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ButterflyShift(_model_base.Model):
    """ButterflyShift.

    Attributes
    ----------
    amount : float
        Amount of shifting, applied to points depending on shift method
        selected. Can be measured in basis points/percents/future price based
        points. Also can be expressed as multiplier for relative shift type.
    ignore_quotation_scale : bool
    pivot_tenor : str
        The code indicating the curve point which is not shifted (e.g., '1M',
        '6M', '4Y').
    shift_type : str or ~analyticsapi.models.ShiftTypeEnum
        The type of shifting. The possible values are:   * Additive: the amount
        of shifting is added to the corresponding curve point,   * Relative:
        the curve point is multiplied by the amount of shifting (e.g., if
        amount = 1, the curve point value will be doubled),   * Scaled: the
        curve point is scaled by the value of the shifting amount (e.g., if
        amount = 1.1, the curve point value will multiplied by this value).
        Known values are: "Additive", "Relative", and "Scaled".
    shift_unit : str or ~analyticsapi.models.ShiftUnitEnum
        The unit that describes the amount of shifting. The possible values
        are:   * Absolute: the amount of shifting is expressed in absolute
        value.   * Bp: the amount of shifting is expressed in basis points,   *
        Percent: the amount of shifting is expressed in percentages,. Known
        values are: "Absolute", "Bp", and "Percent".
    """

    amount: Optional[float] = rest_field()
    """Amount of shifting, applied to points depending on shift method selected. Can be measured in
     basis points/percents/future price based points. Also can be expressed as multiplier for
     relative shift type."""
    ignore_quotation_scale: Optional[bool] = rest_field(name="ignoreQuotationScale")
    pivot_tenor: Optional[str] = rest_field(name="pivotTenor")
    """The code indicating the curve point which is not shifted (e.g., '1M', '6M', '4Y')."""
    shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = rest_field(name="shiftType")
    """The type of shifting. The possible values are:   * Additive: the amount of shifting is added to
     the corresponding curve point,   * Relative: the curve point is multiplied by the amount of
     shifting (e.g., if amount = 1, the curve point value will be doubled),   * Scaled: the curve
     point is scaled by the value of the shifting amount (e.g., if amount = 1.1, the curve point
     value will multiplied by this value). Known values are: \"Additive\", \"Relative\", and
     \"Scaled\"."""
    shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = rest_field(name="shiftUnit")
    """The unit that describes the amount of shifting. The possible values are:   * Absolute: the
     amount of shifting is expressed in absolute value.   * Bp: the amount of shifting is expressed
     in basis points,   * Percent: the amount of shifting is expressed in percentages,. Known values
     are: \"Absolute\", \"Bp\", and \"Percent\"."""

    @overload
    def __init__(
        self,
        *,
        amount: Optional[float] = None,
        ignore_quotation_scale: Optional[bool] = None,
        pivot_tenor: Optional[str] = None,
        shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = None,
        shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Calendar(_model_base.Model):
    """Calendar resource including calendar definition and description.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.CALENDAR
        Property defining the type of the resource.
    id : str
        Unique identifier of the Calendar.
    location : ~analyticsapi.models.Location
        Object defining the location of the Calendar in the platform. Required.
    description : ~analyticsapi.models.Description
        Object defining metadata for the Calendar.
    definition : ~analyticsapi.models.CalendarDefinition
        Object defining the Calendar. Required.
    """

    type: Optional[Literal[ResourceType.CALENDAR]] = rest_field(visibility=["read"], default=ResourceType.CALENDAR)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the Calendar."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining the location of the Calendar in the platform. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining metadata for the Calendar."""
    definition: "_models.CalendarDefinition" = rest_field()
    """Object defining the Calendar. Required."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        definition: "_models.CalendarDefinition",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CalendarCollectionLinks(_model_base.Model):
    """Object defining the links available for one or more Calendars.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    generate_holidays : ~analyticsapi.models.LinkRef
        Required.
    compute_dates : ~analyticsapi.models.LinkRef
        Required.
    generate_date_schedule : ~analyticsapi.models.LinkRef
        Required.
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()
    generate_holidays: "_models.LinkRef" = rest_field(name="generateHolidays")
    """Required."""
    compute_dates: "_models.LinkRef" = rest_field(name="computeDates")
    """Required."""
    generate_date_schedule: "_models.LinkRef" = rest_field(name="generateDateSchedule")
    """Required."""

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        generate_holidays: "_models.LinkRef",
        compute_dates: "_models.LinkRef",
        generate_date_schedule: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CalendarCollectionResponse(_model_base.Model):
    """Object defining the paged response for a collection of Calendars.

    Attributes
    ----------
    data : list[~analyticsapi.models.CalendarInfo]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.CalendarCollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.CalendarInfo"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.CalendarCollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.CalendarInfo"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.CalendarCollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CalendarDefinition(_model_base.Model):
    """An object to define the Calendar resource. The list type properties will not be initialized as
    empty list by default. A list of objects should be assigned first before adding new elements.

    Attributes
    ----------
    rest_days : list[~analyticsapi.models.RestDays]
        An array of objects to determine rest days for the calendar.  The
        default value is None, needs to be assigned before using.
    first_day_of_week : str or ~analyticsapi.models.WeekDay
        The first day of the week set for the calendar. Known values are:
        "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", and
        "Sunday".
    holiday_rules : list[~analyticsapi.models.HolidayRule]
        An array of objects to set holiday rules for the calendar.  The default
        value is None, needs to be assigned before using.
    holiday_exception_rules : list[~analyticsapi.models.HolidayRule]
        An array of objects to determine exceptions from the holiday rules set
        for the calendar.  The default value is None, needs to be assigned
        before using.
    """

    rest_days: Optional[List["_models.RestDays"]] = rest_field(name="restDays")
    """An array of objects to determine rest days for the calendar."""
    first_day_of_week: Optional[Union[str, "_models.WeekDay"]] = rest_field(name="firstDayOfWeek")
    """The first day of the week set for the calendar. Known values are: \"Monday\", \"Tuesday\",
     \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\"."""
    holiday_rules: Optional[List["_models.HolidayRule"]] = rest_field(name="holidayRules")
    """An array of objects to set holiday rules for the calendar."""
    holiday_exception_rules: Optional[List["_models.HolidayRule"]] = rest_field(name="holidayExceptionRules")
    """An array of objects to determine exceptions from the holiday rules set for the calendar."""

    @overload
    def __init__(
        self,
        *,
        rest_days: Optional[List["_models.RestDays"]] = None,
        first_day_of_week: Optional[Union[str, "_models.WeekDay"]] = None,
        holiday_rules: Optional[List["_models.HolidayRule"]] = None,
        holiday_exception_rules: Optional[List["_models.HolidayRule"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CalendarInfo(_model_base.Model):
    """Object defining the links available on a Calendar resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.CALENDAR
        Property defining the type of the resource.
    id : str
        Unique identifier of the Calendar.
    location : ~analyticsapi.models.Location
        Object defining metadata for the Calendar. Required.
    description : ~analyticsapi.models.Description
        Object defining the Calendar.
    """

    type: Optional[Literal[ResourceType.CALENDAR]] = rest_field(visibility=["read"], default=ResourceType.CALENDAR)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the Calendar."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining metadata for the Calendar. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining the Calendar."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CalendarResponse(_model_base.Model):
    """Object defining the response for a single Calendar.

    Attributes
    ----------
    data : ~analyticsapi.models.Calendar
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.Calendar" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.Calendar",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Calibration(_model_base.Model):
    """Calibration.

    Attributes
    ----------
    calendar : str
        The calendar used in the calibration.
    calibration_type : str or ~analyticsapi.models.CalibrationTypeEnum
        The type of calibration applied to solve for model parameters. The
        possible values are:

        * Bootstrap,
        * Optimize,
        * Global. Known values are: "Bootstrap", "Optimize", and "Global".
    end_date : ~datetime.datetime
        The end date of the calibration process. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Usually coincides with
        the end date of the contract to price.
    frequency : str
        The frequency of the calibration. Usually it coincides with the
        frequency of the contract to price.
    parameter : str
        The generic parameter name to solve for during calibration process. The
        possible values are:

        * Correlation,
        * Factors,
        * MeanReversion,
        * MeanReversionSpread,
        * Shift,Tenor,
        * Volatility,
        * VolatilityRatio,
        * Alpha.
    product_type : str or ~analyticsapi.models.ProductTypeEnum
        Product type to use during the calibration process.  The possible
        values are:

        * Cap,
        * Swaption. Known values are: "Cap" and "Swaption".
    start_date : ~datetime.datetime
        The start date of the calibration process. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Usually coincides
        with the start date of the contract to price or valuation date.
    strike : str
        The strike on which the model should be calibrated. It can be symbolic
        (e.g 'ATM') or numeric.
    tenor : str
        The tenor of the calibration portfolio. In case of a CMS spread
        contract, it defines the first tenor.
    user_tenor : str
        An additional custom tenor. In case of a CMS spread contract, it
        defines the second tenor. If not used, an empty string should be
        passed.
    """

    calendar: Optional[str] = rest_field()
    """The calendar used in the calibration."""
    calibration_type: Optional[Union[str, "_models.CalibrationTypeEnum"]] = rest_field(name="calibrationType")
    """The type of calibration applied to solve for model parameters. The possible values are:
     
     
     * Bootstrap,
     * Optimize,
     * Global. Known values are: \"Bootstrap\", \"Optimize\", and \"Global\"."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The end date of the calibration process. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., '2021-01-01').
     Usually coincides with the end date of the contract to price."""
    frequency: Optional[str] = rest_field()
    """The frequency of the calibration. Usually it coincides with the frequency of the contract to
     price."""
    parameter: Optional[str] = rest_field()
    """The generic parameter name to solve for during calibration process. The possible values are:
     
     
     * Correlation,
     * Factors,
     * MeanReversion,
     * MeanReversionSpread,
     * Shift,Tenor,
     * Volatility,
     * VolatilityRatio,
     * Alpha."""
    product_type: Optional[Union[str, "_models.ProductTypeEnum"]] = rest_field(name="productType")
    """Product type to use during the calibration process.  The possible values are:
     
     
     * Cap,
     * Swaption. Known values are: \"Cap\" and \"Swaption\"."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the calibration process. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01').
     Usually coincides with the start date of the contract to price or valuation date."""
    strike: Optional[str] = rest_field()
    """The strike on which the model should be calibrated. It can be symbolic (e.g 'ATM') or numeric."""
    tenor: Optional[str] = rest_field()
    """The tenor of the calibration portfolio.
     In case of a CMS spread contract, it defines the first tenor."""
    user_tenor: Optional[str] = rest_field(name="userTenor")
    """An additional custom tenor.
     In case of a CMS spread contract, it defines the second tenor. If not used, an empty string
     should be passed."""

    @overload
    def __init__(
        self,
        *,
        calendar: Optional[str] = None,
        calibration_type: Optional[Union[str, "_models.CalibrationTypeEnum"]] = None,
        end_date: Optional[datetime.datetime] = None,
        frequency: Optional[str] = None,
        parameter: Optional[str] = None,
        product_type: Optional[Union[str, "_models.ProductTypeEnum"]] = None,
        start_date: Optional[datetime.datetime] = None,
        strike: Optional[str] = None,
        tenor: Optional[str] = None,
        user_tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CalibrationParameters(_model_base.Model):
    """CalibrationParameters.

    Attributes
    ----------
    extrapolation_points_number : int
        Get extrapolationPointsNumber.
    extrapolation_type : str or ~analyticsapi.models.ExtrapolationTypeEnum
        Get extrapolationType. Known values are: "ExtrapolationBothDerivative",
        "ExtrapolationBothFlat", "ExtrapolationLeftDerivative",
        "ExtrapolationLeftFlat", "ExtrapolationRightDerivative", and
        "ExtrapolationRightFlat".
    is_monotonic : bool
    """

    extrapolation_points_number: Optional[int] = rest_field(name="extrapolationPointsNumber")
    """Get extrapolationPointsNumber."""
    extrapolation_type: Optional[Union[str, "_models.ExtrapolationTypeEnum"]] = rest_field(name="extrapolationType")
    """Get extrapolationType. Known values are: \"ExtrapolationBothDerivative\",
     \"ExtrapolationBothFlat\", \"ExtrapolationLeftDerivative\", \"ExtrapolationLeftFlat\",
     \"ExtrapolationRightDerivative\", and \"ExtrapolationRightFlat\"."""
    is_monotonic: Optional[bool] = rest_field(name="isMonotonic")

    @overload
    def __init__(
        self,
        *,
        extrapolation_points_number: Optional[int] = None,
        extrapolation_type: Optional[Union[str, "_models.ExtrapolationTypeEnum"]] = None,
        is_monotonic: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CancellableDefinition(_model_base.Model):
    """CancellableDefinition.

    Attributes
    ----------
    exercise_frequency_tenor : str
        Exercise frequency tenor used to complete the exercice schedule,
        possible values : 1M, 1Y...
    exercise_schedule : list[~datetime.datetime]
        An array of exercise dates in order to cancel the swap.  The default
        value is None, needs to be assigned before using.
    notification_days : int
        The number of days the owner of the option has to notify the writer
        about the swap being canceled. The default value is '0'.
    option_owner : str or ~analyticsapi.models.OptionOwnerEnum
        The owner of the bermudan swaption. Possible values:

        * SelfEntity : the Holder of the contract has the right to call the swap in order to stop.
        * Counterparty : the Seller of the contract has the right to call the swap in order to stop.
        Known values are: "SelfEntity" and "Counterparty".
    """

    exercise_frequency_tenor: Optional[str] = rest_field(name="exerciseFrequencyTenor")
    """Exercise frequency tenor used to complete the exercice schedule, possible values : 1M, 1Y..."""
    exercise_schedule: Optional[List[datetime.datetime]] = rest_field(name="exerciseSchedule", format="rfc3339")
    """An array of exercise dates in order to cancel the swap."""
    notification_days: Optional[int] = rest_field(name="notificationDays")
    """The number of days the owner of the option has to notify the writer about the swap being
     canceled.
     The default value is '0'."""
    option_owner: Optional[Union[str, "_models.OptionOwnerEnum"]] = rest_field(name="optionOwner")
    """The owner of the bermudan swaption. Possible values:
     
     
     * SelfEntity : the Holder of the contract has the right to call the swap in order to stop.
     * Counterparty : the Seller of the contract has the right to call the swap in order to stop.
     Known values are: \"SelfEntity\" and \"Counterparty\"."""

    @overload
    def __init__(
        self,
        *,
        exercise_frequency_tenor: Optional[str] = None,
        exercise_schedule: Optional[List[datetime.datetime]] = None,
        notification_days: Optional[int] = None,
        option_owner: Optional[Union[str, "_models.OptionOwnerEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapFloorAnalyticsResponseData(_model_base.Model):
    """CapFloorAnalyticsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.IPACapFloorDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.CapFloorPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.CapFloorAnalyticsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketDataQps
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.IPACapFloorDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.CapFloorPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.CapFloorAnalyticsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketDataQps"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.IPACapFloorDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.CapFloorPricingParameters"] = None,
        analytics: Optional[List["_models.CapFloorAnalyticsResponseWithError"]] = None,
        market_data: Optional["_models.MarketDataQps"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapFloorAnalyticsResponseWithError(_model_base.Model):
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    tabular_data : ~analyticsapi.models.FinancialContractResponse
        Standard Financial Contract Analytics in tabular format.
    cashflows : ~analyticsapi.models.CapFloorCashflows
        Response categorized under Cashflows.
    description : ~analyticsapi.models.CapFloorDescription
        Response categorized under Description.
    greeks : ~analyticsapi.models.CapFloorGreeks
        Response categorized under Greeks.
    pricing_analysis : ~analyticsapi.models.CapFloorPricingAnalysis
        Response categorized under Pricing analysis.
    valuation : ~analyticsapi.models.CapFloorValuation
        Response categorized under Valuation.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    tabular_data: Optional["_models.FinancialContractResponse"] = rest_field(name="tabularData")
    """Standard Financial Contract Analytics in tabular format."""
    cashflows: Optional["_models.CapFloorCashflows"] = rest_field()
    """Response categorized under Cashflows."""
    description: Optional["_models.CapFloorDescription"] = rest_field()
    """Response categorized under Description."""
    greeks: Optional["_models.CapFloorGreeks"] = rest_field()
    """Response categorized under Greeks."""
    pricing_analysis: Optional["_models.CapFloorPricingAnalysis"] = rest_field(name="pricingAnalysis")
    """Response categorized under Pricing analysis."""
    valuation: Optional["_models.CapFloorValuation"] = rest_field()
    """Response categorized under Valuation."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        tabular_data: Optional["_models.FinancialContractResponse"] = None,
        cashflows: Optional["_models.CapFloorCashflows"] = None,
        description: Optional["_models.CapFloorDescription"] = None,
        greeks: Optional["_models.CapFloorGreeks"] = None,
        pricing_analysis: Optional["_models.CapFloorPricingAnalysis"] = None,
        valuation: Optional["_models.CapFloorValuation"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapFloorCalculationResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.CapFloorAnalyticsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.CapFloorAnalyticsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.CapFloorAnalyticsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CapFloorCashflows(_model_base.Model):
    """Cashflows Object.

    Attributes
    ----------
    caplets_start_dates_array : list[~datetime.date]
        An array of start dates for each caplet/floorlet. The dates are
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '  2021-01-01  ').  The
        default value is None, needs to be assigned before using.
    caplets_end_dates_array : list[~datetime.date]
        An array of end dates for each caplet/floorlet. The dates are expressed
        in ISO 8601 format: YYYY-MM-DD (e.g., '  2021-01-01  ').  The default
        value is None, needs to be assigned before using.
    caplets_strike_percent_array : list[float]
        An array of strike rates for each caplet. The values are expressed in
        percentages.  The default value is None, needs to be assigned before
        using.
    floorlets_strike_percent_array : list[float]
        An array of strike rates for each floorlet. The values are expressed in
        percentages.  The default value is None, needs to be assigned before
        using.
    caplets_forward_rate_percent_array : list[float]
        An array of forward rates for each caplet/floorlet. The values are
        expressed in percentages.  The default value is None, needs to be
        assigned before using.
    amortization_amounts_in_deal_ccy_array : list[float]
        An array of the notional amortization amounts for each cash flow date.
        The values are expressed in the deal currency.  The default value is
        None, needs to be assigned before using.
    caplets_remaining_notional_amounts_in_deal_ccy_array : list[float]
        An array of the remaining notional amounts for each caplet/floorlet.
        The values are expressed in the deal currency.  The default value is
        None, needs to be assigned before using.
    caplets_payoff_amounts_in_deal_ccy_array : list[float]
        An array of historical payoffs for each caplet/floorlet. The values are
        expressed in the deal currency.  The default value is None, needs to be
        assigned before using.
    cash_flows : list[any]
        The information on the contract's cash flows during its lifetime. It
        consists of the following properties:

        * instrumentType: the instrument type for which cash flows are computed,
        * payments: the array of properties which define all instruments cash flows (paid and
        received) during its lifetime.

        For more details please refer here.  The default value is None, needs to be assigned before
        using.
    """

    caplets_start_dates_array: Optional[List[datetime.date]] = rest_field(name="capletsStartDatesArray")
    """An array of start dates for each caplet/floorlet. The dates are expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '  2021-01-01  ')."""
    caplets_end_dates_array: Optional[List[datetime.date]] = rest_field(name="capletsEndDatesArray")
    """An array of end dates for each caplet/floorlet. The dates are expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '  2021-01-01  ')."""
    caplets_strike_percent_array: Optional[List[float]] = rest_field(name="capletsStrikePercentArray")
    """An array of strike rates for each caplet. The values are expressed in percentages."""
    floorlets_strike_percent_array: Optional[List[float]] = rest_field(name="floorletsStrikePercentArray")
    """An array of strike rates for each floorlet. The values are expressed in percentages."""
    caplets_forward_rate_percent_array: Optional[List[float]] = rest_field(name="capletsForwardRatePercentArray")
    """An array of forward rates for each caplet/floorlet. The values are expressed in percentages."""
    amortization_amounts_in_deal_ccy_array: Optional[List[float]] = rest_field(name="amortizationAmountsInDealCcyArray")
    """An array of the notional amortization amounts for each cash flow date. The values are expressed
     in the deal currency."""
    caplets_remaining_notional_amounts_in_deal_ccy_array: Optional[List[float]] = rest_field(
        name="capletsRemainingNotionalAmountsInDealCcyArray"
    )
    """An array of the remaining notional amounts for each caplet/floorlet. The values are expressed
     in the deal currency."""
    caplets_payoff_amounts_in_deal_ccy_array: Optional[List[float]] = rest_field(
        name="capletsPayoffAmountsInDealCcyArray"
    )
    """An array of historical payoffs for each caplet/floorlet. The values are expressed in the deal
     currency."""
    cash_flows: Optional[List[Any]] = rest_field(name="cashFlows")
    """The information on the contract's cash flows during its lifetime. It consists of the following
     properties:
     
     
     * instrumentType: the instrument type for which cash flows are computed,
     * payments: the array of properties which define all instruments cash flows (paid and
     received) during its lifetime.
     
     For more details please refer here."""

    @overload
    def __init__(
        self,
        *,
        caplets_start_dates_array: Optional[List[datetime.date]] = None,
        caplets_end_dates_array: Optional[List[datetime.date]] = None,
        caplets_strike_percent_array: Optional[List[float]] = None,
        floorlets_strike_percent_array: Optional[List[float]] = None,
        caplets_forward_rate_percent_array: Optional[List[float]] = None,
        amortization_amounts_in_deal_ccy_array: Optional[List[float]] = None,
        caplets_remaining_notional_amounts_in_deal_ccy_array: Optional[List[float]] = None,
        caplets_payoff_amounts_in_deal_ccy_array: Optional[List[float]] = None,
        cash_flows: Optional[List[Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapFloorDefinition(_model_base.Model):
    """An object that defines a cap or a floor option.

    Attributes
    ----------
    rate : ~analyticsapi.models.Rate
        An object that defines the cap or floor rate value. Required.
    effective_date : ~datetime.date
        The start date of the cap or floor period. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Required.
    type : str or ~analyticsapi.models.CapFloorTypeEnum
        The type of a cap or floor option. Known values are: "Standard",
        "Periodic", "LifeTime", and "FirstPeriod".
    """

    rate: "_models.Rate" = rest_field()
    """An object that defines the cap or floor rate value. Required."""
    effective_date: datetime.date = rest_field(name="effectiveDate")
    """The start date of the cap or floor period. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01'). Required."""
    type: Optional[Union[str, "_models.CapFloorTypeEnum"]] = rest_field(default="None")
    """The type of a cap or floor option. Known values are: \"Standard\", \"Periodic\", \"LifeTime\",
     and \"FirstPeriod\"."""

    @overload
    def __init__(
        self,
        *,
        rate: "_models.Rate",
        effective_date: datetime.date,
        type: Optional[Union[str, "_models.CapFloorTypeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapFloorDescription(_model_base.Model):
    """Description Object.

    Attributes
    ----------
    instrument_type : str
        The type of instrument defined in the request. The possible values are
        listed here.
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    instrument_description : str
        The label that describes the instrument.
    option_type : str
        The type of the Cap/Floor. The possible values are:

        * Cap: the instrument is a cap,
        * Floor: the instrument is a floor,
        * Collar: the instrument is a collar.
    start_date : ~datetime.datetime
        The start date of the instrument. This value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ').
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    tenor : str
        The code indicating the period between  StartDate  and  EndDate  of the
        instrument (e.g., '  5M  ').
    notional_amount : float
        The notional amount of the instrument.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g., '  USD  ').
    report_ccy : str
        The currency code set for the fields ending with '  xxxInReportCcy  '.
        The value is expressed in ISO 4217 alphabetical format (e.g., '  USD
        ').
    underlying_ccy : str
        The currency of the underlying asset. The value is expressed in ISO
        4217 alphabetical format (e.g., '  USD  ').
    interest_calculation_method : str
        The day count basis method used to calculate the interest payments. The
        possible values are listed  here  .
    interest_payment_frequency : str
        The interest payment frequency. The possible values are listed  here  .
        Either  indexResetFrequency  or  InterestPaymentFrequency  must be
        provided.
    first_regular_payment_date : ~datetime.datetime
        The first regular interest payment date used for the odd first interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z).
    last_regular_payment_date : ~datetime.datetime
        The last regular interest payment date used for the odd last interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z).
    skip_first_cap_floorlet : bool
        An indicator if the first caplet is to be taken into consideration. The
        possible values are:

        * True: the first caplet is ignored,
        * False: the first caplet is included.
    floor_strike_percent : float
        The contractual strike rate of the floor. The value is expressed in
        percentages.
    price_side : str
        The price side of the instrument which comes from the instrument's
        quote or from the curve (derived from quotes) used to value the
        instrument. The possible values are:

        * Bid,
        * Ask,
        * Mid.
    index_price_side : str
        The quoted price side of the floating rate index that applies to legs
        or the instrument. The possible values are:

        * Bid,
        * Ask,
        * Mid.
    index_name : str
        The name of the floating rate index (e.g.,  'EURIBOR  '). The possible
        values depending on the currency are listed  here  .
    index_tenor : str
        The period code indicating the tenor of the underlying floating rate
        index (e.g., '  1M  ', '  1Y  ').
    index_fixing_lag : int
        The number of working days between the fixing date of the index and the
        start of the coupon period  ('InAdvance')  or the end of the coupon
        period  ('InArrears').  The '  InAdvance  ' or '  InArrears  ' mode is
        set in the  indexResetType  parameter.
    index_fixing_ric : str
        The RIC that carries the fixing value if the instrument has a floating
        interest.
    index_reset_frequency : str
        The reset frequency for the floating instrument. The possible values
        are listed  here  .
    index_reset_type : str
        The reset type indicating if the floating rate index is reset before
        the coupon period starts or at the end of the coupon period. The
        possible values are:

        * InAdvance: resets the index before the start of the interest period,
        * InArrears: resets the index at the end of the interest period.
    index_convexity_adjustment_method : str
        The convexity adjustment method. The possible values are:

        * None,
        * BlackScholes,
        * LinearSwapModel,
        * Replication.
    discount_curve_id : str
        The identifier of the zero-coupon curve used to discount the
        instrument's future payments.
    discount_curve_name : str
        The name of the zero-coupon curve used to discount the instrument's
        cash flows.  Specifying data for this curve can be set using the market
        data section. By default, the discount curve is found from the
        instrument's currency and frequency.
    forward_curve_id : str
        The identifier of the zero-coupon curve used to derive forward index
        values for the instrument.
    forward_curve_name : str
        The name of the zero-coupon curve used to derive forward index values
        for the instrument. Examples could be as follows:

        * EUR EURIBOR 6M: a zero-coupon curve bootstrapped from EURIBOR 6M swaps,
        * USD LIBOR OIS disc. COP COIBR OIS: a cross-currency curve COP COIBR OIS discounted by USD
        LIBOR OIS.
    error_code : str
        The code of  ErrorMessage  .
    error_message : str
        The error message in case of a blocking error in calculation.
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    instrument_type: Optional[str] = rest_field(name="instrumentType")
    """The type of instrument defined in the request. The possible values are listed here."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    instrument_description: Optional[str] = rest_field(name="instrumentDescription")
    """The label that describes the instrument."""
    option_type: Optional[str] = rest_field(name="optionType")
    """The type of the Cap/Floor. The possible values are:
     
     
     * Cap: the instrument is a cap,
     * Floor: the instrument is a floor,
     * Collar: the instrument is a collar."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. This value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between  StartDate  and  EndDate  of the instrument (e.g., '  5M
     ')."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g., '  USD  ')."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with '  xxxInReportCcy  '. The value is expressed
     in ISO 4217 alphabetical format (e.g., '  USD  ')."""
    underlying_ccy: Optional[str] = rest_field(name="underlyingCcy")
    """The currency of the underlying asset. The value is expressed in ISO 4217 alphabetical format
     (e.g., '  USD  ')."""
    interest_calculation_method: Optional[str] = rest_field(name="interestCalculationMethod")
    """The day count basis method used to calculate the interest payments. The possible values are
     listed  here  ."""
    interest_payment_frequency: Optional[str] = rest_field(name="interestPaymentFrequency")
    """The interest payment frequency. The possible values are listed  here  . Either
     indexResetFrequency  or  InterestPaymentFrequency  must be provided."""
    first_regular_payment_date: Optional[datetime.datetime] = rest_field(
        name="firstRegularPaymentDate", format="rfc3339"
    )
    """The first regular interest payment date used for the odd first interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z)."""
    last_regular_payment_date: Optional[datetime.datetime] = rest_field(name="lastRegularPaymentDate", format="rfc3339")
    """The last regular interest payment date used for the odd last interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z)."""
    skip_first_cap_floorlet: Optional[bool] = rest_field(name="skipFirstCapFloorlet")
    """An indicator if the first caplet is to be taken into consideration. The possible values are:
     
     
     * True: the first caplet is ignored,
     * False: the first caplet is included."""
    floor_strike_percent: Optional[float] = rest_field(name="floorStrikePercent")
    """The contractual strike rate of the floor. The value is expressed in percentages."""
    price_side: Optional[str] = rest_field(name="priceSide")
    """The price side of the instrument which comes from the instrument's quote or from the curve
     (derived from quotes) used to value the instrument. The possible values are:
     
     
     * Bid,
     * Ask,
     * Mid."""
    index_price_side: Optional[str] = rest_field(name="indexPriceSide")
    """The quoted price side of the floating rate index that applies to legs or the instrument. The
     possible values are:
     
     
     * Bid,
     * Ask,
     * Mid."""
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g.,  'EURIBOR  '). The possible values depending on the
     currency are listed  here  ."""
    index_tenor: Optional[str] = rest_field(name="indexTenor")
    """The period code indicating the tenor of the underlying floating rate index (e.g., '  1M  ', '
     1Y  ')."""
    index_fixing_lag: Optional[int] = rest_field(name="indexFixingLag")
    """The number of working days between the fixing date of the index and the start of the coupon
     period  ('InAdvance')  or the end of the coupon period  ('InArrears').  The '  InAdvance  ' or
     '  InArrears  ' mode is set in the  indexResetType  parameter."""
    index_fixing_ric: Optional[str] = rest_field(name="indexFixingRic")
    """The RIC that carries the fixing value if the instrument has a floating interest."""
    index_reset_frequency: Optional[str] = rest_field(name="indexResetFrequency")
    """The reset frequency for the floating instrument. The possible values are listed  here  ."""
    index_reset_type: Optional[str] = rest_field(name="indexResetType")
    """The reset type indicating if the floating rate index is reset before the coupon period starts
     or at the end of the coupon period. The possible values are:
     
     
     * InAdvance: resets the index before the start of the interest period,
     * InArrears: resets the index at the end of the interest period."""
    index_convexity_adjustment_method: Optional[str] = rest_field(name="indexConvexityAdjustmentMethod")
    """The convexity adjustment method. The possible values are:
     
     
     * None,
     * BlackScholes,
     * LinearSwapModel,
     * Replication."""
    discount_curve_id: Optional[str] = rest_field(name="discountCurveId")
    """The identifier of the zero-coupon curve used to discount the instrument's future payments."""
    discount_curve_name: Optional[str] = rest_field(name="discountCurveName")
    """The name of the zero-coupon curve used to discount the instrument's cash flows.  Specifying
     data for this curve can be set using the market data section. By default, the discount curve is
     found from the instrument's currency and frequency."""
    forward_curve_id: Optional[str] = rest_field(name="forwardCurveId")
    """The identifier of the zero-coupon curve used to derive forward index values for the instrument."""
    forward_curve_name: Optional[str] = rest_field(name="forwardCurveName")
    """The name of the zero-coupon curve used to derive forward index values for the instrument.
     Examples could be as follows:
     
     
     * EUR EURIBOR 6M: a zero-coupon curve bootstrapped from EURIBOR 6M swaps,
     * USD LIBOR OIS disc. COP COIBR OIS: a cross-currency curve COP COIBR OIS discounted by USD
     LIBOR OIS."""
    error_code: Optional[str] = rest_field(name="errorCode")
    """The code of  ErrorMessage  ."""
    error_message: Optional[str] = rest_field(name="errorMessage")
    """The error message in case of a blocking error in calculation."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        instrument_type: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        instrument_description: Optional[str] = None,
        option_type: Optional[str] = None,
        start_date: Optional[datetime.datetime] = None,
        end_date: Optional[datetime.datetime] = None,
        tenor: Optional[str] = None,
        notional_amount: Optional[float] = None,
        notional_ccy: Optional[str] = None,
        report_ccy: Optional[str] = None,
        underlying_ccy: Optional[str] = None,
        interest_calculation_method: Optional[str] = None,
        interest_payment_frequency: Optional[str] = None,
        first_regular_payment_date: Optional[datetime.datetime] = None,
        last_regular_payment_date: Optional[datetime.datetime] = None,
        skip_first_cap_floorlet: Optional[bool] = None,
        floor_strike_percent: Optional[float] = None,
        price_side: Optional[str] = None,
        index_price_side: Optional[str] = None,
        index_name: Optional[str] = None,
        index_tenor: Optional[str] = None,
        index_fixing_lag: Optional[int] = None,
        index_fixing_ric: Optional[str] = None,
        index_reset_frequency: Optional[str] = None,
        index_reset_type: Optional[str] = None,
        index_convexity_adjustment_method: Optional[str] = None,
        discount_curve_id: Optional[str] = None,
        discount_curve_name: Optional[str] = None,
        forward_curve_id: Optional[str] = None,
        forward_curve_name: Optional[str] = None,
        error_code: Optional[str] = None,
        error_message: Optional[str] = None,
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapFloorGreeks(_model_base.Model):
    """Greeks Object.

    Attributes
    ----------
    dv01_amount_in_deal_ccy : float
        The sensitivity of the market value to a 1bp parallel shift in the
        zero-coupon curve. The value is expressed in the deal currency.
    dv01_amount_in_report_ccy : float
        The sensitivity of the market value to a 1bp parallel shift in the
        zero-coupon curve. The value is expressed in the reporting currency.
    delta_percent : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in percentages.
    forward_delta_percent : float
        The change in the price of an option caused by a one-unit change in the
        forward price of the underlying asset. The value is expressed in
        percentages.
    gamma_amount_in_deal_ccy : float
        The change in the option's delta or DV01 per a one-unit change in the
        price of the underlying asset, or 1 unit parallel shift in the curve
        representing the instrument. The value is expressed in the deal
        currency.
    gamma_amount_in_report_ccy : float
        The change in the option's delta or DV01 per a one-unit change in the
        price of the underlying asset, or 1 unit parallel shift in the curve
        representing the instrument. The value is expressed in the reporting
        currency.
    theta_amount_in_deal_ccy : float
        The change in the instrument's price or market value caused by a one-
        day decrease in its time to expiration. The value is expressed in the
        deal currency  .
    theta_amount_in_report_ccy : float
        The change in the instrument's price or market value caused by a one-
        day decrease in its time to expiration. The value is expressed in the
        reporting currency.
    vega_amount_in_deal_ccy : float
        The change in the price of an option per 1bp change in the normal
        volatility (1% in the lognormal volatility) of the underlying asset.
        The value is expressed in the deal currency  .
    vega_amount_in_report_ccy : float
        The change in the price of an option per 1bp change in the normal
        volatility (1% in the lognormal volatility) of the underlying asset.
        The value is expressed in the reporting currency.
    caplets_delta_percent_array : list[float]
        An array of delta amounts for each caplet/floorlet. The values are
        expressed in percentages.  The default value is None, needs to be
        assigned before using.
    caplets_forward_delta_percent_array : list[float]
        An array of forward delta amounts for each caplet/floorlet. The values
        are expressed in percentages.  The default value is None, needs to be
        assigned before using.
    caplets_dv01_amounts_in_deal_ccy_array : list[float]
        An array of  DV01  amounts for each caplet/floorlet. The values are
        expressed in the deal currency.  The default value is None, needs to be
        assigned before using.
    caplets_gamma_amounts_in_deal_ccy_array : list[float]
        An array of 1bp gamma amounts for each caplet/floorlet. The values are
        expressed in the deal currency.  The default value is None, needs to be
        assigned before using.
    caplets_theta_amounts_in_deal_ccy_array : list[float]
        An array of theta amounts for each caplet/floorlet. The values are
        expressed in the deal currency.  The default value is None, needs to be
        assigned before using.
    caplets_vega_amounts_in_deal_ccy_array : list[float]
        An array of vega amounts for each caplet/floorlet. The values are
        expressed in the deal currency.  The default value is None, needs to be
        assigned before using.
    """

    dv01_amount_in_deal_ccy: Optional[float] = rest_field(name="dv01AmountInDealCcy")
    """The sensitivity of the market value to a 1bp parallel shift in the zero-coupon curve. The value
     is expressed in the deal currency."""
    dv01_amount_in_report_ccy: Optional[float] = rest_field(name="dv01AmountInReportCcy")
    """The sensitivity of the market value to a 1bp parallel shift in the zero-coupon curve. The value
     is expressed in the reporting currency."""
    delta_percent: Optional[float] = rest_field(name="deltaPercent")
    """The change in the instrument's price or market value caused by a one-unit change in the price
     of the underlying asset, or by 1bp change in the swap rate for a swaption, or by 100bp change
     in the outright for FX instruments. The value is expressed in percentages."""
    forward_delta_percent: Optional[float] = rest_field(name="forwardDeltaPercent")
    """The change in the price of an option caused by a one-unit change in the forward price of the
     underlying asset. The value is expressed in percentages."""
    gamma_amount_in_deal_ccy: Optional[float] = rest_field(name="gammaAmountInDealCcy")
    """The change in the option's delta or DV01 per a one-unit change in the price of the underlying
     asset, or 1 unit parallel shift in the curve representing the instrument. The value is
     expressed in the deal currency."""
    gamma_amount_in_report_ccy: Optional[float] = rest_field(name="gammaAmountInReportCcy")
    """The change in the option's delta or DV01 per a one-unit change in the price of the underlying
     asset, or 1 unit parallel shift in the curve representing the instrument. The value is
     expressed in the reporting currency."""
    theta_amount_in_deal_ccy: Optional[float] = rest_field(name="thetaAmountInDealCcy")
    """The change in the instrument's price or market value caused by a one-day decrease in its time
     to expiration. The value is expressed in the deal currency  ."""
    theta_amount_in_report_ccy: Optional[float] = rest_field(name="thetaAmountInReportCcy")
    """The change in the instrument's price or market value caused by a one-day decrease in its time
     to expiration. The value is expressed in the reporting currency."""
    vega_amount_in_deal_ccy: Optional[float] = rest_field(name="vegaAmountInDealCcy")
    """The change in the price of an option per 1bp change in the normal volatility (1% in the
     lognormal volatility) of the underlying asset. The value is expressed in the deal currency  ."""
    vega_amount_in_report_ccy: Optional[float] = rest_field(name="vegaAmountInReportCcy")
    """The change in the price of an option per 1bp change in the normal volatility (1% in the
     lognormal volatility) of the underlying asset. The value is expressed in the reporting
     currency."""
    caplets_delta_percent_array: Optional[List[float]] = rest_field(name="capletsDeltaPercentArray")
    """An array of delta amounts for each caplet/floorlet. The values are expressed in percentages."""
    caplets_forward_delta_percent_array: Optional[List[float]] = rest_field(name="capletsForwardDeltaPercentArray")
    """An array of forward delta amounts for each caplet/floorlet. The values are expressed in
     percentages."""
    caplets_dv01_amounts_in_deal_ccy_array: Optional[List[float]] = rest_field(name="capletsDv01AmountsInDealCcyArray")
    """An array of  DV01  amounts for each caplet/floorlet. The values are expressed in the deal
     currency."""
    caplets_gamma_amounts_in_deal_ccy_array: Optional[List[float]] = rest_field(
        name="capletsGammaAmountsInDealCcyArray"
    )
    """An array of 1bp gamma amounts for each caplet/floorlet. The values are expressed in the deal
     currency."""
    caplets_theta_amounts_in_deal_ccy_array: Optional[List[float]] = rest_field(
        name="capletsThetaAmountsInDealCcyArray"
    )
    """An array of theta amounts for each caplet/floorlet. The values are expressed in the deal
     currency."""
    caplets_vega_amounts_in_deal_ccy_array: Optional[List[float]] = rest_field(name="capletsVegaAmountsInDealCcyArray")
    """An array of vega amounts for each caplet/floorlet. The values are expressed in the deal
     currency."""

    @overload
    def __init__(
        self,
        *,
        dv01_amount_in_deal_ccy: Optional[float] = None,
        dv01_amount_in_report_ccy: Optional[float] = None,
        delta_percent: Optional[float] = None,
        forward_delta_percent: Optional[float] = None,
        gamma_amount_in_deal_ccy: Optional[float] = None,
        gamma_amount_in_report_ccy: Optional[float] = None,
        theta_amount_in_deal_ccy: Optional[float] = None,
        theta_amount_in_report_ccy: Optional[float] = None,
        vega_amount_in_deal_ccy: Optional[float] = None,
        vega_amount_in_report_ccy: Optional[float] = None,
        caplets_delta_percent_array: Optional[List[float]] = None,
        caplets_forward_delta_percent_array: Optional[List[float]] = None,
        caplets_dv01_amounts_in_deal_ccy_array: Optional[List[float]] = None,
        caplets_gamma_amounts_in_deal_ccy_array: Optional[List[float]] = None,
        caplets_theta_amounts_in_deal_ccy_array: Optional[List[float]] = None,
        caplets_vega_amounts_in_deal_ccy_array: Optional[List[float]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapFloorPricingAnalysis(_model_base.Model):
    """Pricing analysis Object.

    Attributes
    ----------
    cap_strike_percent : float
        The contractual strike rate of the cap. The value is expressed in
        percentages.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    atm_strike_percent : float
        The at-the-money strike rate of the option. The value is expressed in
        percentages.
    implied_volatility_percent : float
        The implied volatility of the option at the expiration of the option
        extracted from Black-Scholes Model. The value is expressed in
        percentages.
    implied_volatility_bp : float
        The implied volatility of the option extracted from the Normal
        Bachelier Model. The value is expressed in basis points.
    spread_equivalent_bp : float
        The cap/floor premium spread over the cap/floor lifetime. The value is
        expressed in basis points.
    caplets_volatility_bp_array : list[float]
        An array of the implied volatility for each caplet/floorlet. The
        volatility is extracted from the Normal Bachelier Model and expressed
        in basis points.  The default value is None, needs to be assigned
        before using.
    caplets_volatility_percent_array : list[float]
        An array of the implied volatility for each caplet/floorlet. The
        volatility is extracted from the Lognormal Black Model and expressed in
        percentages.  The default value is None, needs to be assigned before
        using.
    caplets_swap_level_array : list[float]
        An array of forward CMS rates for each CMS caplet/floorlet. The values
        are expressed in percentages.  The default value is None, needs to be
        assigned before using.
    caplets_swaption_price_array : list[float]
        An array of swaption prices for each CMS caplet/floorlet. The default
        value is None, needs to be assigned before using.
    implied_cap_strike_percent : float
        The cap strike rate implied in the market value defined by the pricing
        parameter  MarketValueInDealCcy  , if provided. Available only for a
        cap or a collar. The value is expressed in percentages.
    implied_floor_strike_percent : float
        The floor strike rate implied in the market value defined by the
        pricing parameter  MarketValueInDealCcy  , if provided. Available only
        for a floor or a collar. The value is expressed in percentages.
    legs : list[any]
        When the user requests a single-line presentation mode for outputs
        ('reference the input that trigger this'), the field Legs contains an
        array of outputs values for each corresponding leg.  The default value
        is None, needs to be assigned before using.
    """

    cap_strike_percent: Optional[float] = rest_field(name="capStrikePercent")
    """The contractual strike rate of the cap. The value is expressed in percentages."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    atm_strike_percent: Optional[float] = rest_field(name="atmStrikePercent")
    """The at-the-money strike rate of the option. The value is expressed in percentages."""
    implied_volatility_percent: Optional[float] = rest_field(name="impliedVolatilityPercent")
    """The implied volatility of the option at the expiration of the option extracted from
     Black-Scholes Model. The value is expressed in percentages."""
    implied_volatility_bp: Optional[float] = rest_field(name="impliedVolatilityBp")
    """The implied volatility of the option extracted from the Normal Bachelier Model. The value is
     expressed in basis points."""
    spread_equivalent_bp: Optional[float] = rest_field(name="spreadEquivalentBp")
    """The cap/floor premium spread over the cap/floor lifetime. The value is expressed in basis
     points."""
    caplets_volatility_bp_array: Optional[List[float]] = rest_field(name="capletsVolatilityBpArray")
    """An array of the implied volatility for each caplet/floorlet. The volatility is extracted from
     the Normal Bachelier Model and expressed in basis points."""
    caplets_volatility_percent_array: Optional[List[float]] = rest_field(name="capletsVolatilityPercentArray")
    """An array of the implied volatility for each caplet/floorlet. The volatility is extracted from
     the Lognormal Black Model and expressed in percentages."""
    caplets_swap_level_array: Optional[List[float]] = rest_field(name="capletsSwapLevelArray")
    """An array of forward CMS rates for each CMS caplet/floorlet. The values are expressed in
     percentages."""
    caplets_swaption_price_array: Optional[List[float]] = rest_field(name="capletsSwaptionPriceArray")
    """An array of swaption prices for each CMS caplet/floorlet."""
    implied_cap_strike_percent: Optional[float] = rest_field(name="impliedCapStrikePercent")
    """The cap strike rate implied in the market value defined by the pricing parameter
     MarketValueInDealCcy  , if provided. Available only for a cap or a collar. The value is
     expressed in percentages."""
    implied_floor_strike_percent: Optional[float] = rest_field(name="impliedFloorStrikePercent")
    """The floor strike rate implied in the market value defined by the pricing parameter
     MarketValueInDealCcy  , if provided. Available only for a floor or a collar. The value is
     expressed in percentages."""
    legs: Optional[List[Any]] = rest_field()
    """When the user requests a single-line presentation mode for outputs ('reference the input that
     trigger this'), the field Legs contains an array of outputs values for each corresponding
     leg."""

    @overload
    def __init__(
        self,
        *,
        cap_strike_percent: Optional[float] = None,
        valuation_date: Optional[datetime.datetime] = None,
        market_data_date: Optional[datetime.datetime] = None,
        atm_strike_percent: Optional[float] = None,
        implied_volatility_percent: Optional[float] = None,
        implied_volatility_bp: Optional[float] = None,
        spread_equivalent_bp: Optional[float] = None,
        caplets_volatility_bp_array: Optional[List[float]] = None,
        caplets_volatility_percent_array: Optional[List[float]] = None,
        caplets_swap_level_array: Optional[List[float]] = None,
        caplets_swaption_price_array: Optional[List[float]] = None,
        implied_cap_strike_percent: Optional[float] = None,
        implied_floor_strike_percent: Optional[float] = None,
        legs: Optional[List[Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapFloorPricingParameters(_model_base.Model):
    """CapFloorPricingParameters.

    Attributes
    ----------
    implied_volatility_bp : float
        The implied normal volatility, expressed in basis points. Only one
        parameter out of marketValueInDealCcy, impliedVolatilityPercent, and
        impliedVolatilityBp can be set at a time. By default, it is computed
        from the instrument definition and relevant market data.
    implied_volatility_percent : float
        The implied lognormal volatility, expressed in percentages. Only one
        parameter out of marketValueInDealCcy, impliedVolatilityPercent, and
        impliedVolatilityBp can be set at a time. By default, it is computed
        from the instrument definition and relevant market data.
    index_convexity_adjustment_integration_method : str or ~analyticsapi.models.IndexConvexityAdjustmentIntegrationMethodEnum
        The integration method used for static replication method. The possible
        values are: RiemannSum, RungeKutta. Optional. The default value is
        'RiemannSum'. Known values are: "RiemannSum" and "RungeKutta".
    index_convexity_adjustment_method : str or ~analyticsapi.models.IndexConvexityAdjustmentMethodEnum
        The convexity adjustment method. The possible values are: None,
        BlackScholes, LinearSwapModel, Replication. Optional. The default value
        is 'BlackScholes'. Known values are: "None", "BlackScholes",
        "Replication", and "LinearSwapModel".
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).
        Optional. By default, marketDataDate is valuationDate or today.
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency. Only one parameter out of marketValueInDealCcy,
        impliedVolatilityPercent, and impliedVolatilityBp can be set at a time.
        Optional. No default value applies.
    price_side : str or ~analyticsapi.models.PriceSideEnum
        The price side of the instrument which comes from the instrument's
        quote or from the curve (derived from quotes) used to value the
        instrument. The possible values are: Bid, Ask, Mid. Optional. Default
        value is 'Mid'. Known values are: "Mid", "Bid", "Ask", and "Last".
    report_ccy : str
        The reporting currency code, expressed in ISO 4217 alphabetical format
        (e.g. 'USD'). It is set for the fields ending with 'xxxInReportCcy'.
        Optional. No default value applies.
    skip_first_cap_floorlet : bool
        An indicator if the first caplet is to be taken into consideration. The
        possible values are: True: the first caplet is ignored, False: the
        first caplet is included. Optional. The default value is 'False'.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    """

    implied_volatility_bp: Optional[float] = rest_field(name="impliedVolatilityBp")
    """The implied normal volatility, expressed in basis points.
     Only one parameter out of marketValueInDealCcy, impliedVolatilityPercent, and
     impliedVolatilityBp can be set at a time.
     By default, it is computed from the instrument definition and relevant market data."""
    implied_volatility_percent: Optional[float] = rest_field(name="impliedVolatilityPercent")
    """The implied lognormal volatility, expressed in percentages.
     Only one parameter out of marketValueInDealCcy, impliedVolatilityPercent, and
     impliedVolatilityBp can be set at a time.
     By default, it is computed from the instrument definition and relevant market data."""
    index_convexity_adjustment_integration_method: Optional[
        Union[str, "_models.IndexConvexityAdjustmentIntegrationMethodEnum"]
    ] = rest_field(name="indexConvexityAdjustmentIntegrationMethod")
    """The integration method used for static replication method. The possible values are:
     RiemannSum,
     RungeKutta.
     Optional. The default value is 'RiemannSum'. Known values are: \"RiemannSum\" and
     \"RungeKutta\"."""
    index_convexity_adjustment_method: Optional[Union[str, "_models.IndexConvexityAdjustmentMethodEnum"]] = rest_field(
        name="indexConvexityAdjustmentMethod"
    )
    """The convexity adjustment method. The possible values are:
     None,
     BlackScholes,
     LinearSwapModel,
     Replication.
     Optional. The default value is 'BlackScholes'. Known values are: \"None\", \"BlackScholes\",
     \"Replication\", and \"LinearSwapModel\"."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It should be less or equal to
     valuationDate).
     Optional. By default, marketDataDate is valuationDate or today."""
    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency.
     Only one parameter out of marketValueInDealCcy, impliedVolatilityPercent, and
     impliedVolatilityBp can be set at a time.
     Optional. No default value applies."""
    price_side: Optional[Union[str, "_models.PriceSideEnum"]] = rest_field(name="priceSide")
    """The price side of the instrument which comes from the instrument's quote or from the curve
     (derived from quotes) used to value the instrument.
     The possible values are: Bid, Ask, Mid.
     Optional. Default value is 'Mid'. Known values are: \"Mid\", \"Bid\", \"Ask\", and \"Last\"."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The reporting currency code, expressed in ISO 4217 alphabetical format (e.g. 'USD'). It is set
     for the fields ending with 'xxxInReportCcy'.
     Optional. No default value applies."""
    skip_first_cap_floorlet: Optional[bool] = rest_field(name="skipFirstCapFloorlet")
    """An indicator if the first caplet is to be taken into consideration. The possible values are:
     True: the first caplet is ignored,
     False: the first caplet is included.
     Optional. The default value is 'False'."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""

    @overload
    def __init__(
        self,
        *,
        implied_volatility_bp: Optional[float] = None,
        implied_volatility_percent: Optional[float] = None,
        index_convexity_adjustment_integration_method: Optional[
            Union[str, "_models.IndexConvexityAdjustmentIntegrationMethodEnum"]
        ] = None,
        index_convexity_adjustment_method: Optional[Union[str, "_models.IndexConvexityAdjustmentMethodEnum"]] = None,
        market_data_date: Optional[datetime.datetime] = None,
        market_value_in_deal_ccy: Optional[float] = None,
        price_side: Optional[Union[str, "_models.PriceSideEnum"]] = None,
        report_ccy: Optional[str] = None,
        skip_first_cap_floorlet: Optional[bool] = None,
        valuation_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapFloorValuation(_model_base.Model):
    """Valuation Object.

    Attributes
    ----------
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency.
    market_value_in_report_ccy : float
        The market value of the instrument. The value is expressed in the
        reporting currency.
    caplets_market_values_in_deal_ccy_array : list[float]
        An array of market values, which are the caplet/floorlet premiums. The
        values are expressed in the deal currency.  The default value is None,
        needs to be assigned before using.
    cap_floor_premium_schedule : list[any]
        An array of forward premium payments as the price of the cap/floor is
        often spread over the contract lifetime.  The default value is None,
        needs to be assigned before using.
    premium_percent : float
        The premium paid by the option buyer to the option seller. The value is
        expressed in percentages. For more details on the field calculation,
        please refer here.
    premium_bp : float
        The price of an option computed as [  PremiumPercent  *  100  ]. The
        value is expressed in basis points.
    """

    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value of the instrument. The value is expressed in the reporting currency."""
    caplets_market_values_in_deal_ccy_array: Optional[List[float]] = rest_field(
        name="capletsMarketValuesInDealCcyArray"
    )
    """An array of market values, which are the caplet/floorlet premiums. The values are expressed in
     the deal currency."""
    cap_floor_premium_schedule: Optional[List[Any]] = rest_field(name="capFloorPremiumSchedule")
    """An array of forward premium payments as the price of the cap/floor is often spread over the
     contract lifetime."""
    premium_percent: Optional[float] = rest_field(name="premiumPercent")
    """The premium paid by the option buyer to the option seller. The value is expressed in
     percentages.
     For more details on the field calculation, please refer here."""
    premium_bp: Optional[float] = rest_field(name="premiumBp")
    """The price of an option computed as [  PremiumPercent  *  100  ]. The value is expressed in
     basis points."""

    @overload
    def __init__(
        self,
        *,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
        caplets_market_values_in_deal_ccy_array: Optional[List[float]] = None,
        cap_floor_premium_schedule: Optional[List[Any]] = None,
        premium_percent: Optional[float] = None,
        premium_bp: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapletsStrippingDefinition(_model_base.Model):
    """CapletsStrippingDefinition.

    Attributes
    ----------
    discounting_type : str or ~analyticsapi.models.DiscountingTypeEnum
        The discounting type of the interest rate volatility model. The default
        value is selected based on 'instrumentCode'. Known values are:
        "LiborDiscounting" and "OisDiscounting".
    index_name : str
        Underlying index name.
    instrument_code : str
        The Currency of the interest rate volatility model.
    reference_caplet_tenor : str
        Reference caplet payment or index tenor. ex: 1M, 3M, 6M, 1Y.
    """

    discounting_type: Optional[Union[str, "_models.DiscountingTypeEnum"]] = rest_field(name="discountingType")
    """The discounting type of the interest rate volatility model.
     The default value is selected based on 'instrumentCode'. Known values are: \"LiborDiscounting\"
     and \"OisDiscounting\"."""
    index_name: Optional[str] = rest_field(name="indexName")
    """Underlying index name."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The Currency of the interest rate volatility model."""
    reference_caplet_tenor: Optional[str] = rest_field(name="referenceCapletTenor")
    """Reference caplet payment or index tenor. ex: 1M, 3M, 6M, 1Y."""

    @overload
    def __init__(
        self,
        *,
        discounting_type: Optional[Union[str, "_models.DiscountingTypeEnum"]] = None,
        index_name: Optional[str] = None,
        instrument_code: Optional[str] = None,
        reference_caplet_tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapletsStrippingSurfaceParameters(_model_base.Model):
    """CapletsStrippingSurfaceParameters.

    Attributes
    ----------
    calculation_date : ~datetime.datetime
        The date the volatility surface is generated.
    filters : ~analyticsapi.models.SurfaceFilters
    input_volatility_type : str or ~analyticsapi.models.InputVolatilityTypeEnum
        user can specify whether calibration is based on Normal or Lognorma
        vol. However it would be preferrable to let the service determine the
        most appropriate one. Known values are: "Implied",
        "LogNormalVolatility", "NormalVolatility", "Quoted", and "Settle".
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        Specifies whether bid, ask, mid or settle is used to build the surface.
        If not precised, default to mid. Known values are: "Ask", "Bid",
        "Last", and "Mid".
    shift_percent : float
        Shift applied to calibrated strikes allowing negative rates. The value
        is expressed in percentages. The default value is selected based on
        instrumentCode.
    source : str
        Requested volatility data contributor.
    stripping_shift_percent : float
        Shift value applied to strikes allowing the stripped caplets surface to
        include volatility even when some strikes are negative. The value is
        expressed in percentages. The default value is '0.0'.
    time_stamp : str or ~analyticsapi.models.CurvesAndSurfacesTimeStampEnum
        Define how the timestamp is selected:

        * Open: the opening value of the valuationDate or if not available the close of the previous
        day is used.
        * Default: the latest snapshot is used when valuationDate is today, the close price when
        valuationDate is in the past. Known values are: "Close", "Default", "Open", and "Settle".
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    volatility_adjustment_type : str or ~analyticsapi.models.VolatilityAdjustmentTypeEnum
        Volatility adjustment method applied to caplets surface before
        stripping. The default value is 'ConstantCap'. Known values are:
        "ConstantCap", "ConstantCaplet", "NormalizedCap", "NormalizedCaplet",
        and "ShiftedCap".
    x_axis : str or ~analyticsapi.models.XAxisEnum
        The enumerate that specifies the unit for the x axis. Known values are:
        "Date", "Delta", "Expiry", "Moneyness", "Strike", and "Tenor".
    y_axis : str or ~analyticsapi.models.YAxisEnum
        The enumerate that specifies the unit for the y axis. Known values are:
        "Date", "Delta", "Expiry", "Moneyness", "Strike", and "Tenor".
    z_axis : str or ~analyticsapi.models.ZAxisEnum
        Specifies the unit for the z axis (e.g. Strike, Expiry, Tenor). This
        applies to swaption SABR cube. Known values are: "Date", "Delta",
        "Expiry", "Moneyness", "Strike", and "Tenor".
    """

    calculation_date: Optional[datetime.datetime] = rest_field(name="calculationDate", format="rfc3339")
    """The date the volatility surface is generated."""
    filters: Optional["_models.SurfaceFilters"] = rest_field()
    input_volatility_type: Optional[Union[str, "_models.InputVolatilityTypeEnum"]] = rest_field(
        name="inputVolatilityType"
    )
    """user can specify whether calibration is based on Normal or Lognorma vol. However it would be
     preferrable to let the service determine the most appropriate one. Known values are:
     \"Implied\", \"LogNormalVolatility\", \"NormalVolatility\", \"Quoted\", and \"Settle\"."""
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """Specifies whether bid, ask, mid or settle is used to build the surface. If not precised,
     default to mid. Known values are: \"Ask\", \"Bid\", \"Last\", and \"Mid\"."""
    shift_percent: Optional[float] = rest_field(name="shiftPercent")
    """Shift applied to calibrated strikes allowing negative rates. The value is expressed in
     percentages.
     The default value is selected based on instrumentCode."""
    source: Optional[str] = rest_field()
    """Requested volatility data contributor."""
    stripping_shift_percent: Optional[float] = rest_field(name="strippingShiftPercent")
    """Shift value applied to strikes allowing the stripped caplets surface to include volatility even
     when some strikes are negative. The value is expressed in percentages.
     The default value is '0.0'."""
    time_stamp: Optional[Union[str, "_models.CurvesAndSurfacesTimeStampEnum"]] = rest_field(name="timeStamp")
    """Define how the timestamp is selected:
     
     
     * Open: the opening value of the valuationDate or if not available the close of the previous
     day is used.
     * Default: the latest snapshot is used when valuationDate is today, the close price when
     valuationDate is in the past. Known values are: \"Close\", \"Default\", \"Open\", and
     \"Settle\"."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""
    volatility_adjustment_type: Optional[Union[str, "_models.VolatilityAdjustmentTypeEnum"]] = rest_field(
        name="volatilityAdjustmentType"
    )
    """Volatility adjustment method applied to caplets surface before stripping.
     The default value is 'ConstantCap'. Known values are: \"ConstantCap\", \"ConstantCaplet\",
     \"NormalizedCap\", \"NormalizedCaplet\", and \"ShiftedCap\"."""
    x_axis: Optional[Union[str, "_models.XAxisEnum"]] = rest_field(name="xAxis")
    """The enumerate that specifies the unit for the x axis. Known values are: \"Date\", \"Delta\",
     \"Expiry\", \"Moneyness\", \"Strike\", and \"Tenor\"."""
    y_axis: Optional[Union[str, "_models.YAxisEnum"]] = rest_field(name="yAxis")
    """The enumerate that specifies the unit for the y axis. Known values are: \"Date\", \"Delta\",
     \"Expiry\", \"Moneyness\", \"Strike\", and \"Tenor\"."""
    z_axis: Optional[Union[str, "_models.ZAxisEnum"]] = rest_field(name="zAxis")
    """Specifies the unit for the z axis (e.g. Strike, Expiry, Tenor). This applies to swaption SABR
     cube. Known values are: \"Date\", \"Delta\", \"Expiry\", \"Moneyness\", \"Strike\", and
     \"Tenor\"."""

    @overload
    def __init__(
        self,
        *,
        calculation_date: Optional[datetime.datetime] = None,
        filters: Optional["_models.SurfaceFilters"] = None,
        input_volatility_type: Optional[Union[str, "_models.InputVolatilityTypeEnum"]] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        shift_percent: Optional[float] = None,
        source: Optional[str] = None,
        stripping_shift_percent: Optional[float] = None,
        time_stamp: Optional[Union[str, "_models.CurvesAndSurfacesTimeStampEnum"]] = None,
        valuation_date: Optional[datetime.datetime] = None,
        volatility_adjustment_type: Optional[Union[str, "_models.VolatilityAdjustmentTypeEnum"]] = None,
        x_axis: Optional[Union[str, "_models.XAxisEnum"]] = None,
        y_axis: Optional[Union[str, "_models.YAxisEnum"]] = None,
        z_axis: Optional[Union[str, "_models.ZAxisEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapletsStrippingSurfaceRequestItem(_model_base.Model):
    """CapletsStrippingSurfaceRequestItem.

    Attributes
    ----------
    surface_layout : ~analyticsapi.models.SurfaceOutput
    surface_parameters : ~analyticsapi.models.CapletsStrippingSurfaceParameters
    surface_tag : str
    underlying_definition : ~analyticsapi.models.CapletsStrippingDefinition
    underlying_type : str or ~analyticsapi.models.CurvesAndSurfacesUnderlyingTypeEnum
        The type of the underlying used to generate the volatility surface.
        Known values are: "Cap", "Eti", "Fx", and "Swaption".
    """

    surface_layout: Optional["_models.SurfaceOutput"] = rest_field(name="surfaceLayout")
    surface_parameters: Optional["_models.CapletsStrippingSurfaceParameters"] = rest_field(name="surfaceParameters")
    surface_tag: Optional[str] = rest_field(name="surfaceTag")
    underlying_definition: Optional["_models.CapletsStrippingDefinition"] = rest_field(name="underlyingDefinition")
    underlying_type: Optional[Union[str, "_models.CurvesAndSurfacesUnderlyingTypeEnum"]] = rest_field(
        name="underlyingType"
    )
    """The type of the underlying used to generate the volatility surface. Known values are: \"Cap\",
     \"Eti\", \"Fx\", and \"Swaption\"."""

    @overload
    def __init__(
        self,
        *,
        surface_layout: Optional["_models.SurfaceOutput"] = None,
        surface_parameters: Optional["_models.CapletsStrippingSurfaceParameters"] = None,
        surface_tag: Optional[str] = None,
        underlying_definition: Optional["_models.CapletsStrippingDefinition"] = None,
        underlying_type: Optional[Union[str, "_models.CurvesAndSurfacesUnderlyingTypeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapVolatility(_model_base.Model):
    """CapVolatility.

    Attributes
    ----------
    value_type : str
        Is either a Literal["ABS"] type or a Literal["REL"] type.
    values_property : list[~analyticsapi.models.CapVolItem]
        The default value is None, needs to be assigned before using.
    """

    value_type: Optional[Literal["ABS", "REL"]] = rest_field(name="valueType")
    """Is either a Literal[\"ABS\"] type or a Literal[\"REL\"] type."""
    values_property: Optional[List["_models.CapVolItem"]] = rest_field(name="values")

    @overload
    def __init__(
        self,
        *,
        value_type: Optional[Literal["ABS", "REL"]] = None,
        values_property: Optional[List["_models.CapVolItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CapVolItem(_model_base.Model):
    """CapVolItem.

    Attributes
    ----------
    expiration : ~decimal.Decimal
    value : ~decimal.Decimal
    """

    expiration: Optional[decimal.Decimal] = rest_field()
    value: Optional[decimal.Decimal] = rest_field()

    @overload
    def __init__(
        self,
        *,
        expiration: Optional[decimal.Decimal] = None,
        value: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Cashflow(ABC, _model_base.Model):
    """The information on the intrument related cashflows during its lifetime.
    It consists of payment types such as Interest, IncomeTax, Payoff, Premium, Principal,
    Settlement which define the payment events (paid and received) during an instrument lifetime.
    This information is presented separately for each leg.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    IncomeTaxCashflow, InterestCashflow, PayoffCashflow, PremiumCashflow, PrincipalCashflow,
    SettlementCashflow

    Attributes
    ----------
    date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the payment
        date.
    amount : ~analyticsapi.models.Amount
        An object that defines the amount and currency of a payment. Required.
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that makes the payment. Required. Known
        values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that receives the payment. Required. Known
        values are: "Party1" and "Party2".
    payment_type : str or ~analyticsapi.models.CashFlowPaymentTypeEnum
        The type of amount paid or received depending on instrument type.
        Required. Known values are: "Interest", "IncomeTax", "Payoff",
        "Premium", "Principal", and "Settlement".
    occurrence : str or ~analyticsapi.models.PaymentOccurrenceEnum
        The timeline of the transaction. The possible values are: Historical:
        the cash flow date is earlier than the valuation date, Future: the cash
        flow date follows the valuation date and the cash flow is known,
        Projected: the cash flow date follows the valuation date and the cash
        flow is not set by the contract but estimated. Required. Known values
        are: "Historical", "Future", and "Projected".
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    date: Optional["_models.Date"] = rest_field()
    """An object that contains properties to define and adjust the payment date."""
    amount: "_models.Amount" = rest_field()
    """An object that defines the amount and currency of a payment. Required."""
    payer: Union[str, "_models.PartyEnum"] = rest_field()
    """The party (Party1 or Party2) that makes the payment. Required. Known values are: \"Party1\" and
     \"Party2\"."""
    receiver: Union[str, "_models.PartyEnum"] = rest_field()
    """The party (Party1 or Party2) that receives the payment. Required. Known values are: \"Party1\"
     and \"Party2\"."""
    payment_type: str = rest_discriminator(name="paymentType")
    """The type of amount paid or received depending on instrument type. Required. Known values are:
     \"Interest\", \"IncomeTax\", \"Payoff\", \"Premium\", \"Principal\", and \"Settlement\"."""
    occurrence: Union[str, "_models.PaymentOccurrenceEnum"] = rest_field()
    """The timeline of the transaction. The possible values are:
     Historical: the cash flow date is earlier than the valuation date,
     Future: the cash flow date follows the valuation date and the cash flow is known,
     Projected: the cash flow date follows the valuation date and the cash flow is not set by the
     contract but estimated. Required. Known values are: \"Historical\", \"Future\", and
     \"Projected\"."""

    @overload
    def __init__(
        self,
        *,
        amount: "_models.Amount",
        payer: Union[str, "_models.PartyEnum"],
        receiver: Union[str, "_models.PartyEnum"],
        payment_type: str,
        occurrence: Union[str, "_models.PaymentOccurrenceEnum"],
        date: Optional["_models.Date"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CashflowFloaterSettings(_model_base.Model):
    """Optional. Used for securities that float or have collateral that floats.

    Attributes
    ----------
    use_forward_index : bool
        Optional. If false, do not use forwardIndexRate or forwardIndexVector.
    forward_index_rate : float
        Optional. Spread over Forward Index. If used, do not use
        forwardIndexVector.
    forward_index_vector : ~analyticsapi.models.Vector
        Optional. Used for fix-to-float bonds.
    calculate_to_maturity : bool
    """

    use_forward_index: Optional[bool] = rest_field(name="useForwardIndex")
    """Optional. If false, do not use forwardIndexRate or forwardIndexVector."""
    forward_index_rate: Optional[float] = rest_field(name="forwardIndexRate")
    """Optional. Spread over Forward Index. If used, do not use forwardIndexVector."""
    forward_index_vector: Optional["_models.Vector"] = rest_field(name="forwardIndexVector")
    """Optional. Used for fix-to-float bonds."""
    calculate_to_maturity: Optional[bool] = rest_field(name="calculateToMaturity")

    @overload
    def __init__(
        self,
        *,
        use_forward_index: Optional[bool] = None,
        forward_index_rate: Optional[float] = None,
        forward_index_vector: Optional["_models.Vector"] = None,
        calculate_to_maturity: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CashFlowGlobalSettings(_model_base.Model):
    """CashFlowGlobalSettings.

    Attributes
    ----------
    pricing_date : ~datetime.date
        One of pricingDate, usePreviousClose, or useLiveData is required. This
        selects the date of the pricing curve.
    use_previous_close : bool
        One of pricingDate, usePreviousClose, or useLiveData is required. This
        selects the date of the pricing curve.
    use_live_data : bool
        One of pricingDate, usePreviousClose, or useLiveData is required. This
        selects the date of the pricing curve.
    volatility : ~analyticsapi.models.CashflowVolatility
    retrieve_ppm_projection : bool
        Optional. Retrieves monthly prepayment projections.
    use_non_qm_collateral : bool
        Optional, if true, Non-QM collateral is used for non-agency RMBS model
        calls, otherwise Alt-A collateral is used. This flag only applies to
        prepay type v97. If this flag is set to true, you must also set
        'coreLogicCollateral' to 'USE'.
    core_logic_collateral : str
        Optional, for Non-Agency. Enables model to be run using from CoreLogic
        collateral data. Is one of the following types: Literal["DEFAULT"],
        Literal["USE"], Literal["IGNORE"]
    clo_dials : ~analyticsapi.models.JsonRef
    clo_dials_ref : str
    """

    pricing_date: Optional[datetime.date] = rest_field(name="pricingDate")
    """One of pricingDate, usePreviousClose, or useLiveData is required. This selects the date of the
     pricing curve."""
    use_previous_close: Optional[bool] = rest_field(name="usePreviousClose")
    """One of pricingDate, usePreviousClose, or useLiveData is required. This selects the date of the
     pricing curve."""
    use_live_data: Optional[bool] = rest_field(name="useLiveData")
    """One of pricingDate, usePreviousClose, or useLiveData is required. This selects the date of the
     pricing curve."""
    volatility: Optional["_models.CashflowVolatility"] = rest_field()
    retrieve_ppm_projection: Optional[bool] = rest_field(name="retrievePPMProjection")
    """Optional. Retrieves monthly prepayment projections."""
    use_non_qm_collateral: Optional[bool] = rest_field(name="useNonQMCollateral")
    """Optional, if true, Non-QM collateral is used for non-agency RMBS model calls, otherwise Alt-A
     collateral is used. This flag only applies to prepay type v97. If this flag is set to true, you
     must also set 'coreLogicCollateral' to 'USE'."""
    core_logic_collateral: Optional[Literal["DEFAULT", "USE", "IGNORE"]] = rest_field(name="coreLogicCollateral")
    """Optional, for Non-Agency. Enables model to be run using from CoreLogic collateral data. Is one
     of the following types: Literal[\"DEFAULT\"], Literal[\"USE\"], Literal[\"IGNORE\"]"""
    clo_dials: Optional["_models.JsonRef"] = rest_field(name="cloDials")
    clo_dials_ref: Optional[str] = rest_field(name="cloDials.$ref")

    @overload
    def __init__(
        self,
        *,
        pricing_date: Optional[datetime.date] = None,
        use_previous_close: Optional[bool] = None,
        use_live_data: Optional[bool] = None,
        volatility: Optional["_models.CashflowVolatility"] = None,
        retrieve_ppm_projection: Optional[bool] = None,
        use_non_qm_collateral: Optional[bool] = None,
        core_logic_collateral: Optional[Literal["DEFAULT", "USE", "IGNORE"]] = None,
        clo_dials: Optional["_models.JsonRef"] = None,
        clo_dials_ref: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CashFlowInput(_model_base.Model):
    """CashFlowInput.

    Attributes
    ----------
    identifier : str
        Security Reference ID.
    id_type : str or ~analyticsapi.models.IdTypeEnum
        Known values are: "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN",
        "REGSISIN", "SEDOL", "Identifier", "ChinaInterbankCode",
        "ShanghaiExchangeCode", "ShenzhenExchangeCode", and "MXTickerID".
    user_instrument : ~analyticsapi.models.JsonRef
        User Instrument reference.
    user_tag : str
        Optional. User supplied value will show up again on the response side.
    curve : ~analyticsapi.models.CurveTypeAndCurrency
    settlement_type : str
        Is one of the following types: Literal["MARKET"], Literal["INDEX"],
        Literal["CUSTOM"]
    settlement_date : ~datetime.date
        Optional. If settlementType is CUSTOM, user can choose between
        settlementDate and customSettlement. Recommend using settlementDate.
    custom_settlement : str
        Optional. If settlementType is CUSTOM, user can choose between
        settlementDate and customSettlement. Example of customSettlement (T +
        2), where T is the pricing date. Recommend using settlementDate.
    par_amount : str
    loss_settings : ~analyticsapi.models.LossSettings
    prepay : ~analyticsapi.models.CashflowPrepaySettings
    floater_settings : ~analyticsapi.models.CashflowFloaterSettings
    muni_settings : ~analyticsapi.models.MuniSettings
    mbs_settings : ~analyticsapi.models.CashflowMbsSettings
    clo_settings : ~analyticsapi.models.CloSettings
    modification : ~analyticsapi.models.JsonRef
    """

    identifier: Optional[str] = rest_field()
    """Security Reference ID."""
    id_type: Optional[Union[str, "_models.IdTypeEnum"]] = rest_field(name="idType")
    """Known values are: \"SecurityIDEntry\", \"SecurityID\", \"CUSIP\", \"ISIN\", \"REGSISIN\",
     \"SEDOL\", \"Identifier\", \"ChinaInterbankCode\", \"ShanghaiExchangeCode\",
     \"ShenzhenExchangeCode\", and \"MXTickerID\"."""
    user_instrument: Optional["_models.JsonRef"] = rest_field(name="userInstrument")
    """User Instrument reference."""
    user_tag: Optional[str] = rest_field(name="userTag")
    """Optional. User supplied value will show up again on the response side."""
    curve: Optional["_models.CurveTypeAndCurrency"] = rest_field()
    settlement_type: Optional[Literal["MARKET", "INDEX", "CUSTOM"]] = rest_field(name="settlementType")
    """Is one of the following types: Literal[\"MARKET\"], Literal[\"INDEX\"], Literal[\"CUSTOM\"]"""
    settlement_date: Optional[datetime.date] = rest_field(name="settlementDate")
    """Optional. If settlementType is CUSTOM, user can choose between settlementDate and
     customSettlement. Recommend using settlementDate."""
    custom_settlement: Optional[str] = rest_field(name="customSettlement")
    """Optional. If settlementType is CUSTOM, user can choose between settlementDate and
     customSettlement. Example of customSettlement (T + 2), where T is the pricing date. Recommend
     using settlementDate."""
    par_amount: Optional[str] = rest_field(name="parAmount")
    loss_settings: Optional["_models.LossSettings"] = rest_field(name="lossSettings")
    prepay: Optional["_models.CashflowPrepaySettings"] = rest_field()
    floater_settings: Optional["_models.CashflowFloaterSettings"] = rest_field(name="floaterSettings")
    muni_settings: Optional["_models.MuniSettings"] = rest_field(name="muniSettings")
    mbs_settings: Optional["_models.CashflowMbsSettings"] = rest_field(name="mbsSettings")
    clo_settings: Optional["_models.CloSettings"] = rest_field(name="cloSettings")
    modification: Optional["_models.JsonRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        id_type: Optional[Union[str, "_models.IdTypeEnum"]] = None,
        user_instrument: Optional["_models.JsonRef"] = None,
        user_tag: Optional[str] = None,
        curve: Optional["_models.CurveTypeAndCurrency"] = None,
        settlement_type: Optional[Literal["MARKET", "INDEX", "CUSTOM"]] = None,
        settlement_date: Optional[datetime.date] = None,
        custom_settlement: Optional[str] = None,
        par_amount: Optional[str] = None,
        loss_settings: Optional["_models.LossSettings"] = None,
        prepay: Optional["_models.CashflowPrepaySettings"] = None,
        floater_settings: Optional["_models.CashflowFloaterSettings"] = None,
        muni_settings: Optional["_models.MuniSettings"] = None,
        mbs_settings: Optional["_models.CashflowMbsSettings"] = None,
        clo_settings: Optional["_models.CloSettings"] = None,
        modification: Optional["_models.JsonRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CashflowMbsSettings(_model_base.Model):
    """Additional settings for mortgage backed securities.

    Attributes
    ----------
    use_roll_info : bool
        Optional, for adjustable rate mortgages (ARMS). If the ARM has roll
        Information, one can choose to assume the ARM has one reset date or use
        the Roll Information. Note, OAS will not calculate if roll information
        is used.
    assume_call : bool
    step_down_fail : bool
    show_collateral_cash_flow : bool
    """

    use_roll_info: Optional[bool] = rest_field(name="useRollInfo")
    """Optional, for adjustable rate mortgages (ARMS). If the ARM has roll Information, one can choose
     to assume the ARM has one reset date or use the Roll Information. Note, OAS will not calculate
     if roll information is used."""
    assume_call: Optional[bool] = rest_field(name="assumeCall")
    step_down_fail: Optional[bool] = rest_field(name="stepDownFail")
    show_collateral_cash_flow: Optional[bool] = rest_field(name="showCollateralCashFlow")

    @overload
    def __init__(
        self,
        *,
        use_roll_info: Optional[bool] = None,
        assume_call: Optional[bool] = None,
        step_down_fail: Optional[bool] = None,
        show_collateral_cash_flow: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CashflowPrepaySettings(_model_base.Model):
    """Optional. Used for securities that allow principal prepayment.

    Attributes
    ----------
    type : str
        Required. Is one of the following types: Literal["Model"],
        Literal["CurrentModel"], Literal["NewModel"], Literal["OldModel"],
        Literal["PreExpModel"], Literal["OldExpModel"], Literal["ExpModel"],
        Literal["CPR"], Literal["MHP"], Literal["HEP"], Literal["ABS"],
        Literal["CPB"], Literal["HPC"], Literal["CPJ"], Literal["CPY"],
        Literal["VPR"], Literal["PPV"], Literal["PSJ"], Literal["PSA"]
    rate : float
        Prepayment speed. Either rate or values is required.
    values_property : list[~analyticsapi.models.MonthRatePair]
        The default value is None, needs to be assigned before using.
    """

    type: Optional[
        Literal[
            "Model",
            "CurrentModel",
            "NewModel",
            "OldModel",
            "PreExpModel",
            "OldExpModel",
            "ExpModel",
            "CPR",
            "MHP",
            "HEP",
            "ABS",
            "CPB",
            "HPC",
            "CPJ",
            "CPY",
            "VPR",
            "PPV",
            "PSJ",
            "PSA",
        ]
    ] = rest_field(default=None)
    """Required. Is one of the following types: Literal[\"Model\"], Literal[\"CurrentModel\"],
     Literal[\"NewModel\"], Literal[\"OldModel\"], Literal[\"PreExpModel\"],
     Literal[\"OldExpModel\"], Literal[\"ExpModel\"], Literal[\"CPR\"], Literal[\"MHP\"],
     Literal[\"HEP\"], Literal[\"ABS\"], Literal[\"CPB\"], Literal[\"HPC\"], Literal[\"CPJ\"],
     Literal[\"CPY\"], Literal[\"VPR\"], Literal[\"PPV\"], Literal[\"PSJ\"], Literal[\"PSA\"]"""
    rate: Optional[float] = rest_field()
    """Prepayment speed. Either rate or values is required."""
    values_property: Optional[List["_models.MonthRatePair"]] = rest_field(name="values")

    @overload
    def __init__(
        self,
        *,
        type: Optional[
            Literal[
                "Model",
                "CurrentModel",
                "NewModel",
                "OldModel",
                "PreExpModel",
                "OldExpModel",
                "ExpModel",
                "CPR",
                "MHP",
                "HEP",
                "ABS",
                "CPB",
                "HPC",
                "CPJ",
                "CPY",
                "VPR",
                "PPV",
                "PSJ",
                "PSA",
            ]
        ] = None,
        rate: Optional[float] = None,
        values_property: Optional[List["_models.MonthRatePair"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CashFlowRequestData(_model_base.Model):
    """CashFlowRequestData.

    Attributes
    ----------
    global_settings : ~analyticsapi.models.CashFlowGlobalSettings
    input : list[~analyticsapi.models.CashFlowInput]
        The default value is None, needs to be assigned before using.
    keywords : list[str]
        Optional. Used to specify the keywords a user will retrieve in the
        response. All keywords are returned by default.  The default value is
        None, needs to be assigned before using.
    """

    global_settings: Optional["_models.CashFlowGlobalSettings"] = rest_field(name="globalSettings")
    input: Optional[List["_models.CashFlowInput"]] = rest_field()
    keywords: Optional[List[str]] = rest_field()
    """Optional. Used to specify the keywords a user will retrieve in the response. All keywords are
     returned by default."""

    @overload
    def __init__(
        self,
        *,
        global_settings: Optional["_models.CashFlowGlobalSettings"] = None,
        input: Optional[List["_models.CashFlowInput"]] = None,
        keywords: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CashflowVolatility(_model_base.Model):
    """Required.

    Attributes
    ----------
    type : str
        Term structure model selection. Is one of the following types:
        Literal["Single"], Literal["Long"], Literal["Market"],
        Literal["Historical"], Literal["MarketWSkew"], Literal["MatrixWSkew"],
        Literal["Matrix"], Literal["1-Factor"], Literal["1FMeanReversion"],
        Literal["1FNormal"], Literal["LMMSkew"], Literal["LMMSkewOIS"],
        Literal["LMMSkewOld"], Literal["LMMDL"], Literal["LMMDLMOD"],
        Literal["LMMDD"], Literal["LMMCMI"], Literal["LMMCMI2"],
        Literal["LMMALTDD"], Literal["LMMSOFR"], Literal["LMMSOFR2"],
        Literal["LMMSOFRFLAT"], Literal["LMMSCMI2"], Literal["LMMTONAR"],
        Literal["Default"], Literal["1FMeanReversionLogNormal"],
        Literal["1FMeanReversionNormal"]
    rate : float
        Volatility rate input, only needed if type selection is SINGLE.
    """

    type: Optional[
        Literal[
            "Single",
            "Long",
            "Market",
            "Historical",
            "MarketWSkew",
            "MatrixWSkew",
            "Matrix",
            "1-Factor",
            "1FMeanReversion",
            "1FNormal",
            "LMMSkew",
            "LMMSkewOIS",
            "LMMSkewOld",
            "LMMDL",
            "LMMDLMOD",
            "LMMDD",
            "LMMCMI",
            "LMMCMI2",
            "LMMALTDD",
            "LMMSOFR",
            "LMMSOFR2",
            "LMMSOFRFLAT",
            "LMMSCMI2",
            "LMMTONAR",
            "Default",
            "1FMeanReversionLogNormal",
            "1FMeanReversionNormal",
        ]
    ] = rest_field(default=None)
    """Term structure model selection. Is one of the following types: Literal[\"Single\"],
     Literal[\"Long\"], Literal[\"Market\"], Literal[\"Historical\"], Literal[\"MarketWSkew\"],
     Literal[\"MatrixWSkew\"], Literal[\"Matrix\"], Literal[\"1-Factor\"],
     Literal[\"1FMeanReversion\"], Literal[\"1FNormal\"], Literal[\"LMMSkew\"],
     Literal[\"LMMSkewOIS\"], Literal[\"LMMSkewOld\"], Literal[\"LMMDL\"], Literal[\"LMMDLMOD\"],
     Literal[\"LMMDD\"], Literal[\"LMMCMI\"], Literal[\"LMMCMI2\"], Literal[\"LMMALTDD\"],
     Literal[\"LMMSOFR\"], Literal[\"LMMSOFR2\"], Literal[\"LMMSOFRFLAT\"], Literal[\"LMMSCMI2\"],
     Literal[\"LMMTONAR\"], Literal[\"Default\"], Literal[\"1FMeanReversionLogNormal\"],
     Literal[\"1FMeanReversionNormal\"]"""
    rate: Optional[float] = rest_field()
    """Volatility rate input, only needed if type selection is SINGLE."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[
            Literal[
                "Single",
                "Long",
                "Market",
                "Historical",
                "MarketWSkew",
                "MatrixWSkew",
                "Matrix",
                "1-Factor",
                "1FMeanReversion",
                "1FNormal",
                "LMMSkew",
                "LMMSkewOIS",
                "LMMSkewOld",
                "LMMDL",
                "LMMDLMOD",
                "LMMDD",
                "LMMCMI",
                "LMMCMI2",
                "LMMALTDD",
                "LMMSOFR",
                "LMMSOFR2",
                "LMMSOFRFLAT",
                "LMMSCMI2",
                "LMMTONAR",
                "Default",
                "1FMeanReversionLogNormal",
                "1FMeanReversionNormal",
            ]
        ] = None,
        rate: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CdsAnalyticsResponseData(_model_base.Model):
    """CdsAnalyticsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.CdsDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.CdsPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.CdsAnalyticsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketDataQps
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.CdsDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.CdsPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.CdsAnalyticsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketDataQps"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.CdsDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.CdsPricingParameters"] = None,
        analytics: Optional[List["_models.CdsAnalyticsResponseWithError"]] = None,
        market_data: Optional["_models.MarketDataQps"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CdsAnalyticsResponseWithError(_model_base.Model):
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    tabular_data : ~analyticsapi.models.FinancialContractResponse
        Standard Financial Contract Analytics in tabular format.
    cashflows : ~analyticsapi.models.CdsCashflows
        Response categorized under Cashflows.
    description : ~analyticsapi.models.CdsDescription
        Response categorized under Description.
    nominal_measures : ~analyticsapi.models.CdsNominalMeasures
        Response categorized under Nominal measures.
    pricing_analysis : ~analyticsapi.models.CdsPricingAnalysis
        Response categorized under Pricing analysis.
    spread_measures : ~analyticsapi.models.CdsSpreadMeasures
        Response categorized under Spread measures.
    valuation : ~analyticsapi.models.CdsValuation
        Response categorized under Valuation.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    tabular_data: Optional["_models.FinancialContractResponse"] = rest_field(name="tabularData")
    """Standard Financial Contract Analytics in tabular format."""
    cashflows: Optional["_models.CdsCashflows"] = rest_field()
    """Response categorized under Cashflows."""
    description: Optional["_models.CdsDescription"] = rest_field()
    """Response categorized under Description."""
    nominal_measures: Optional["_models.CdsNominalMeasures"] = rest_field(name="nominalMeasures")
    """Response categorized under Nominal measures."""
    pricing_analysis: Optional["_models.CdsPricingAnalysis"] = rest_field(name="pricingAnalysis")
    """Response categorized under Pricing analysis."""
    spread_measures: Optional["_models.CdsSpreadMeasures"] = rest_field(name="spreadMeasures")
    """Response categorized under Spread measures."""
    valuation: Optional["_models.CdsValuation"] = rest_field()
    """Response categorized under Valuation."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        tabular_data: Optional["_models.FinancialContractResponse"] = None,
        cashflows: Optional["_models.CdsCashflows"] = None,
        description: Optional["_models.CdsDescription"] = None,
        nominal_measures: Optional["_models.CdsNominalMeasures"] = None,
        pricing_analysis: Optional["_models.CdsPricingAnalysis"] = None,
        spread_measures: Optional["_models.CdsSpreadMeasures"] = None,
        valuation: Optional["_models.CdsValuation"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CdsCalculationResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.CdsAnalyticsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.CdsAnalyticsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.CdsAnalyticsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CdsCashflows(_model_base.Model):
    """Cashflows Object.

    Attributes
    ----------
    next_coupon_date : ~datetime.date
        The first regular interest payment date following SettlementDate. If
        the settlement date is after the last regular coupon, then this field
        shows the instrument maturity date. The value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., '2021-01-01'). Note: NextCouponDate is equal
        to firstRegularPaymentDate if it is defined in request.
    cash_amount_in_deal_ccy : float
        The amount which should be paid by the protection buyer to the
        protection seller on  SettlementDate  , including the accrued amount.
        If not specified, it is computed as [  UpfrontAmountInDealCcy  +
        AccruedAmountInDealCcy  ]. The value is expressed in the deal currency.
    cash_amount_in_report_ccy : float
        The amount which should be paid by the protection buyer to the
        protection seller on  SettlementDate  , including the accrued amount.
        The value is expressed in the reporting currency.
    cash_flow_dates_array : list[~datetime.date]
        The dates of the future cash flows payments.  The default value is
        None, needs to be assigned before using.
    cash_flow_total_amounts_in_deal_ccy_array : list[float]
        The total (interest + principal) payments for each cash flow date. The
        values are expressed in the deal currency.  The default value is None,
        needs to be assigned before using.
    cash_flow_discount_factors_array : list[float]
        The array of discount factors used to calculate the present value of
        future cash flow for each cash flow date.  The default value is None,
        needs to be assigned before using.
    cash_flow_survival_probabilities_array : list[float]
        The array of probabilities that the issuer will be able to repay its
        debt calculated for each cash flow date. At maturity, it is calculated
        as [1 -  DefaultProbability  ].  The default value is None, needs to be
        assigned before using.
    """

    next_coupon_date: Optional[datetime.date] = rest_field(name="nextCouponDate")
    """The first regular interest payment date following SettlementDate. If the settlement date is
     after the last regular coupon, then this field shows the instrument maturity date. The value is
     expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
     Note: NextCouponDate is equal to firstRegularPaymentDate if it is defined in request."""
    cash_amount_in_deal_ccy: Optional[float] = rest_field(name="cashAmountInDealCcy")
    """The amount which should be paid by the protection buyer to the protection seller on
     SettlementDate  , including the accrued amount. If not specified, it is computed as [
     UpfrontAmountInDealCcy  +  AccruedAmountInDealCcy  ]. The value is expressed in the deal
     currency."""
    cash_amount_in_report_ccy: Optional[float] = rest_field(name="cashAmountInReportCcy")
    """The amount which should be paid by the protection buyer to the protection seller on
     SettlementDate  , including the accrued amount. The value is expressed in the reporting
     currency."""
    cash_flow_dates_array: Optional[List[datetime.date]] = rest_field(name="cashFlowDatesArray")
    """The dates of the future cash flows payments."""
    cash_flow_total_amounts_in_deal_ccy_array: Optional[List[float]] = rest_field(
        name="cashFlowTotalAmountsInDealCcyArray"
    )
    """The total (interest + principal) payments for each cash flow date. The values are expressed in
     the deal currency."""
    cash_flow_discount_factors_array: Optional[List[float]] = rest_field(name="cashFlowDiscountFactorsArray")
    """The array of discount factors used to calculate the present value of future cash flow for each
     cash flow date."""
    cash_flow_survival_probabilities_array: Optional[List[float]] = rest_field(
        name="cashFlowSurvivalProbabilitiesArray"
    )
    """The array of probabilities that the issuer will be able to repay its debt calculated for each
     cash flow date. At maturity, it is calculated as [1 -  DefaultProbability  ]."""

    @overload
    def __init__(
        self,
        *,
        next_coupon_date: Optional[datetime.date] = None,
        cash_amount_in_deal_ccy: Optional[float] = None,
        cash_amount_in_report_ccy: Optional[float] = None,
        cash_flow_dates_array: Optional[List[datetime.date]] = None,
        cash_flow_total_amounts_in_deal_ccy_array: Optional[List[float]] = None,
        cash_flow_discount_factors_array: Optional[List[float]] = None,
        cash_flow_survival_probabilities_array: Optional[List[float]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CdsDefinition(_model_base.Model):
    """CdsDefinition.

    Attributes
    ----------
    accrued_begin_date : ~datetime.datetime
        The date when the instrument starts accruing interest. The value is
        expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). Optional. If cdsConvention is 'ISDA', default
        value is the nearest IMM date (March 20, June 20, September 20 or
        December 20) before valuationDate. If cdsConvention is 'UserDefined':

        * if startDate is defined, default value is startDate,
        * if startDate is not defined, default value is the nearest IMM date before valuationDate.
    adjust_to_isda_end_date : bool
        An indicator of whether the end date is adjusted to ISDA convention if
        computed from the defined start date and tenor. The possible values
        are:

        * true: the endDate is an IMM date computed according to ISDA rules,
        * false: the endDate is computed according to endDateMovingConvention.

        Optional. By default, it is true if cdsConvention='ISDA', otherwise false.
    cds_convention : str or ~analyticsapi.models.CdsConventionEnum
        The CDS convention used. Possible values are:

        * ISDA: ISDA CDS Standard Model is used (startDate defaults to accruedBeginDate, endDate is
        adjusted to IMM Date),
        * UserDefined: non-standard model is used (startDate defaults to stepInDate, endDate is not
        adjusted).

        Optional. The default value is 'ISDA'. Known values are: "ISDA" and "UserDefined".
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). If instrumentCode is not defined, either
        endDate or tenor must be provided. If instrumentCode is defined, the
        value comes from the instrument reference data.
    end_date_moving_convention : str or ~analyticsapi.models.EndDateMovingConventionEnum
        The method to adjust the endDate of the instrument. The possible values
        are:

        * ModifiedFollowing: dates are adjusted to the next business day convention unless it goes into
        the next month. In such case, the 'PreviousBusinessDay' convention is used,
        * NextBusinessDay: dates are moved to the following working day,
        * PreviousBusinessDay: dates are moved to the preceding working day,
        * NoMoving: dates are not adjusted,
        * BbswModifiedFollowing: dates are adjusted to the next business day convention unless it goes
        into the next month, or crosses mid-month (15th). In such case, the 'PreviousBusinessDay'
        convention is used.

        Optional. The default value is 'NoMoving'. Known values are: "ModifiedFollowing",
        "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
        "BbswModifiedFollowing".
    instrument_code : str
        The code (RIC) used to define the instrument. Optional. If not defined,
        both the protectionLeg and the premiumLeg  must be provided.
    instrument_tag : str
        User defined string to identify the instrument.It can be used to link
        output results to the instrument definition. Only alphabetic, numeric
        and '- _.#=@' characters are supported. Optional.
    premium_leg : ~analyticsapi.models.PremiumLegDefinition
    protection_leg : ~analyticsapi.models.ProtectionLegDefinition
    start_date : ~datetime.datetime
        The start date of the instrument. The value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
        Optional. By default, it is AccruedBeginDate if cdsConvention = 'ISDA',
        otherwise StepInDate.
    start_date_moving_convention : str or ~analyticsapi.models.StartDateMovingConventionEnum
        The method to adjust the start date of the instrument. The possible
        values are:

        * ModifiedFollowing: dates are adjusted to the next business day convention unless it goes into
        the next month. In such case, the 'PreviousBusinessDay' convention is used,
        * NextBusinessDay: dates are moved to the following working day,
        * PreviousBusinessDay: dates are moved to the preceding working day,
        * NoMoving: dates are not adjusted,
        * BbswModifiedFollowing: dates are adjusted to the next business day convention unless it goes
        into the next month, or crosses mid-month (15th). In such case, the 'PreviousBusinessDay'
        convention is used.

        Optional. The default value is 'NextBusinessDay'. Known values are: "ModifiedFollowing",
        "NextBusinessDay", "PreviousBusinessDay", "NoMoving", "EveryThirdWednesday", and
        "BbswModifiedFollowing".
    step_in_date : ~datetime.datetime
        The date when the protection comes into effect. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        2021-01-01T00:00:00Z). Optional. By default, it is tradeDate + 1
        calendar day.
    tenor : str
        The code indicating the period between StartDate and EndDate of the
        instrument (e.g., '6M', '1Y'). If instrumentCode is not defined, either
        endDate or tenor must be provided. If instrumentCode is defined, the
        value comes from the instrument reference data.
    trade_date : ~datetime.datetime
        The date when the instrument is traded. The value is expressed in ISO
        8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z).
        Optional. By default, it equals valuation date.
    """

    accrued_begin_date: Optional[datetime.datetime] = rest_field(name="accruedBeginDate", format="rfc3339")
    """The date when the instrument starts accruing interest. The value is expressed in ISO 8601
     format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     Optional. If cdsConvention is 'ISDA', default value is the nearest IMM date (March 20, June 20,
     September 20 or December 20) before valuationDate.
     If cdsConvention is 'UserDefined':
     
     
     * if startDate is defined, default value is startDate,
     * if startDate is not defined, default value is the nearest IMM date before valuationDate."""
    adjust_to_isda_end_date: Optional[bool] = rest_field(name="adjustToIsdaEndDate")
    """An indicator of whether the end date is adjusted to ISDA convention if computed from the
     defined start date and tenor. The possible values are:
     
     
     * true: the endDate is an IMM date computed according to ISDA rules,
     * false: the endDate is computed according to endDateMovingConvention.
     
     Optional. By default, it is true if cdsConvention='ISDA', otherwise false."""
    cds_convention: Optional[Union[str, "_models.CdsConventionEnum"]] = rest_field(name="cdsConvention")
    """The CDS convention used. Possible values are:
     
     
     * ISDA: ISDA CDS Standard Model is used (startDate defaults to accruedBeginDate, endDate is
     adjusted to IMM Date),
     * UserDefined: non-standard model is used (startDate defaults to stepInDate, endDate is not
     adjusted).
     
     Optional. The default value is 'ISDA'. Known values are: \"ISDA\" and \"UserDefined\"."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     If instrumentCode is not defined, either endDate or tenor must be provided. If instrumentCode
     is defined, the value comes from the instrument reference data."""
    end_date_moving_convention: Optional[Union[str, "_models.EndDateMovingConventionEnum"]] = rest_field(
        name="endDateMovingConvention"
    )
    """The method to adjust the endDate of the instrument. The possible values are:
     
     
     * ModifiedFollowing: dates are adjusted to the next business day convention unless it goes into
     the next month. In such case, the 'PreviousBusinessDay' convention is used,
     * NextBusinessDay: dates are moved to the following working day,
     * PreviousBusinessDay: dates are moved to the preceding working day,
     * NoMoving: dates are not adjusted,
     * BbswModifiedFollowing: dates are adjusted to the next business day convention unless it goes
     into the next month, or crosses mid-month (15th). In such case, the 'PreviousBusinessDay'
     convention is used.
     
     Optional. The default value is 'NoMoving'. Known values are: \"ModifiedFollowing\",
     \"NextBusinessDay\", \"PreviousBusinessDay\", \"NoMoving\", \"EveryThirdWednesday\", and
     \"BbswModifiedFollowing\"."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code (RIC) used to define the instrument.
     Optional. If not defined, both the protectionLeg and the premiumLeg  must be provided."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """User defined string to identify the instrument.It can be used to link output results to the
     instrument definition.
     Only alphabetic, numeric and '- _.#=@' characters are supported.
     Optional."""
    premium_leg: Optional["_models.PremiumLegDefinition"] = rest_field(name="premiumLeg")
    protection_leg: Optional["_models.ProtectionLegDefinition"] = rest_field(name="protectionLeg")
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     Optional. By default, it is AccruedBeginDate if cdsConvention = 'ISDA', otherwise StepInDate."""
    start_date_moving_convention: Optional[Union[str, "_models.StartDateMovingConventionEnum"]] = rest_field(
        name="startDateMovingConvention"
    )
    """The method to adjust the start date of the instrument. The possible values are:
     
     
     * ModifiedFollowing: dates are adjusted to the next business day convention unless it goes into
     the next month. In such case, the 'PreviousBusinessDay' convention is used,
     * NextBusinessDay: dates are moved to the following working day,
     * PreviousBusinessDay: dates are moved to the preceding working day,
     * NoMoving: dates are not adjusted,
     * BbswModifiedFollowing: dates are adjusted to the next business day convention unless it goes
     into the next month, or crosses mid-month (15th). In such case, the 'PreviousBusinessDay'
     convention is used.
     
     Optional. The default value is 'NextBusinessDay'. Known values are: \"ModifiedFollowing\",
     \"NextBusinessDay\", \"PreviousBusinessDay\", \"NoMoving\", \"EveryThirdWednesday\", and
     \"BbswModifiedFollowing\"."""
    step_in_date: Optional[datetime.datetime] = rest_field(name="stepInDate", format="rfc3339")
    """The date when the protection comes into effect. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z).
     Optional. By default, it is tradeDate + 1 calendar day."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between StartDate and EndDate of the instrument (e.g., '6M',
     '1Y').
     If instrumentCode is not defined, either endDate or tenor must be provided. If instrumentCode
     is defined, the value comes from the instrument reference data."""
    trade_date: Optional[datetime.datetime] = rest_field(name="tradeDate", format="rfc3339")
    """The date when the instrument is traded. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z).
     Optional. By default, it equals valuation date."""

    @overload
    def __init__(
        self,
        *,
        accrued_begin_date: Optional[datetime.datetime] = None,
        adjust_to_isda_end_date: Optional[bool] = None,
        cds_convention: Optional[Union[str, "_models.CdsConventionEnum"]] = None,
        end_date: Optional[datetime.datetime] = None,
        end_date_moving_convention: Optional[Union[str, "_models.EndDateMovingConventionEnum"]] = None,
        instrument_code: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        premium_leg: Optional["_models.PremiumLegDefinition"] = None,
        protection_leg: Optional["_models.ProtectionLegDefinition"] = None,
        start_date: Optional[datetime.datetime] = None,
        start_date_moving_convention: Optional[Union[str, "_models.StartDateMovingConventionEnum"]] = None,
        step_in_date: Optional[datetime.datetime] = None,
        tenor: Optional[str] = None,
        trade_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CdsDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.CdsDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.CdsDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.CdsDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CdsDescription(_model_base.Model):
    """Description Object.

    Attributes
    ----------
    instrument_type : str
        The type of instrument defined in the request. The possible values are
        listed here.
    instrument_code : str
        The code used to define the instrument. The possible values for each
        asset type are listed  here  .
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    instrument_description : str
        The label that describes the instrument.
    reference_entity : str
        The identifier of the issuer of the debt that is insured by a CDS. The
        possible values are:

        * for Single Name CDS: Red Code, Org Id, RIC,
        * for the CDS Index: Red Code, Short Name, Common Name.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g., 'USD').
    notional_amount : float
        The notional amount of the instrument.
    report_ccy : str
        The currency code set for the fields ending with '  xxxInReportCcy  '.
        The value is expressed in ISO 4217 alphabetical format (e.g., '  USD
        ').
    settlement_convention : str
        The settlement tenor of the instrument (e.g., '1WD'), used to calculate
        SettlementDate  .
    settlement_date : ~datetime.date
        The date on which payments are made to settle a trade. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    trade_date : ~datetime.datetime
        The date when the instrument is traded. The value is expressed in ISO
        8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
    step_in_date : ~datetime.datetime
        The date when protection comes into effect. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        2021-01-01T00:00:00Z).
    start_date : ~datetime.datetime
        The start date of the instrument. The value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    tenor : str
        The code indicating the period between  StartDate  and  EndDate  of the
        instrument (e.g., '6M', '1Y').
    first_accrual_date : ~datetime.date
        The date from which the interest starts accruing. The value is
        expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    first_regular_payment_date : ~datetime.datetime
        The first regular interest payment date used for the odd first interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
    last_regular_payment_date : ~datetime.datetime
        The last regular interest payment date used for the odd last interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
    interest_payment_frequency : str
        The interest payment frequency. The possible values are listed  here  .
    interest_calculation_method : str
        The day count basis method used to calculate the interest payments. The
        possible values are listed  here  .
    accrued_calculation_method : str
        The day count basis method used to calculate the accrued interest
        payments. The possible values are listed  here  .
    payment_business_day_convention : str
        The method to adjust dates to a working day. The possible values are
        listed  here  .
    payment_business_days : str
        A list of comma-separated calendar codes to adjust dates (e.g., 'EMU'
        or  'USA').  The possible values are listed  here  .
    discount_curve_id : str
        The identifier of the zero-coupon curve used to discount the
        instrument's future payments.
    forward_curve_id : str
        The identifier of the zero-coupon curve used to derive forward index
        values for the instrument.
    credit_curve_id : str
        The identifier of the credit curve used to derive the default
        probability values for the instrument.
    seniority : str
        The order of repayment in the case of a credit event for Single Name
        CDS. The possible values are:

        * Secured: Secured Debt (Corporate/Financial) or Domestic Currency Sovereign Debt (Government),
        * SeniorUnsecured: Senior Unsecured Debt (Corporate/Financial) or Foreign Currency Sovereign
        Debt (Government),
        * Subordinated: Subordinated or Lower Tier 2 Debt (Banks),
        * JuniorSubordinated: Junior Subordinated or Upper Tier 2 Debt (Banks),
        * Preference: Preference Shares or Tier 1 Capital (Banks).
    doc_clause : str
        The restructuring clause or a credit event for Single Name CDS. The
        possible values are:

        * CumRestruct14,
        * ModifiedRestruct14,
        * ModModRestruct14,
        * ExRestruct14,
        * CumRestruct03,
        * ModifiedRestruct03,
        * ModModRestruct03,
        * ExRestruct03.
    index_factor : float
        The factor that is applied to the notional amount if a credit event
        happens in one of the constituents of the  CDS Index  . It is ignored
        for Single Name CDS.
    error_code : str
        The code of  ErrorMessage  .
    error_message : str
        The error message in case of a blocking error in calculation.
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    instrument_type: Optional[str] = rest_field(name="instrumentType")
    """The type of instrument defined in the request. The possible values are listed here."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument. The possible values for each asset type are listed
     here  ."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    instrument_description: Optional[str] = rest_field(name="instrumentDescription")
    """The label that describes the instrument."""
    reference_entity: Optional[str] = rest_field(name="referenceEntity")
    """The identifier of the issuer of the debt that is insured by a CDS. The possible values are:
     
     
     * for Single Name CDS: Red Code, Org Id, RIC,
     * for the CDS Index: Red Code, Short Name, Common Name."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g., 'USD')."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with '  xxxInReportCcy  '. The value is expressed
     in ISO 4217 alphabetical format (e.g., '  USD  ')."""
    settlement_convention: Optional[str] = rest_field(name="settlementConvention")
    """The settlement tenor of the instrument (e.g., '1WD'), used to calculate  SettlementDate  ."""
    settlement_date: Optional[datetime.date] = rest_field(name="settlementDate")
    """The date on which payments are made to settle a trade. The value is expressed in ISO 8601
     format: YYYY-MM-DD (e.g., '2021-01-01')."""
    trade_date: Optional[datetime.datetime] = rest_field(name="tradeDate", format="rfc3339")
    """The date when the instrument is traded. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    step_in_date: Optional[datetime.datetime] = rest_field(name="stepInDate", format="rfc3339")
    """The date when protection comes into effect. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z)."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between  StartDate  and  EndDate  of the instrument (e.g., '6M',
     '1Y')."""
    first_accrual_date: Optional[datetime.date] = rest_field(name="firstAccrualDate")
    """The date from which the interest starts accruing. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    first_regular_payment_date: Optional[datetime.datetime] = rest_field(
        name="firstRegularPaymentDate", format="rfc3339"
    )
    """The first regular interest payment date used for the odd first interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    last_regular_payment_date: Optional[datetime.datetime] = rest_field(name="lastRegularPaymentDate", format="rfc3339")
    """The last regular interest payment date used for the odd last interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    interest_payment_frequency: Optional[str] = rest_field(name="interestPaymentFrequency")
    """The interest payment frequency. The possible values are listed  here  ."""
    interest_calculation_method: Optional[str] = rest_field(name="interestCalculationMethod")
    """The day count basis method used to calculate the interest payments. The possible values are
     listed  here  ."""
    accrued_calculation_method: Optional[str] = rest_field(name="accruedCalculationMethod")
    """The day count basis method used to calculate the accrued interest payments. The possible values
     are listed  here  ."""
    payment_business_day_convention: Optional[str] = rest_field(name="paymentBusinessDayConvention")
    """The method to adjust dates to a working day. The possible values are listed  here  ."""
    payment_business_days: Optional[str] = rest_field(name="paymentBusinessDays")
    """A list of comma-separated calendar codes to adjust dates (e.g.,  'EMU'  or  'USA').  The
     possible values are listed  here  ."""
    discount_curve_id: Optional[str] = rest_field(name="discountCurveId")
    """The identifier of the zero-coupon curve used to discount the instrument's future payments."""
    forward_curve_id: Optional[str] = rest_field(name="forwardCurveId")
    """The identifier of the zero-coupon curve used to derive forward index values for the instrument."""
    credit_curve_id: Optional[str] = rest_field(name="creditCurveId")
    """The identifier of the credit curve used to derive the default probability values for the
     instrument."""
    seniority: Optional[str] = rest_field()
    """The order of repayment in the case of a credit event for Single Name CDS. The possible values
     are:
     
     
     * Secured: Secured Debt (Corporate/Financial) or Domestic Currency Sovereign Debt (Government),
     * SeniorUnsecured: Senior Unsecured Debt (Corporate/Financial) or Foreign Currency Sovereign
     Debt (Government),
     * Subordinated: Subordinated or Lower Tier 2 Debt (Banks),
     * JuniorSubordinated: Junior Subordinated or Upper Tier 2 Debt (Banks),
     * Preference: Preference Shares or Tier 1 Capital (Banks)."""
    doc_clause: Optional[str] = rest_field(name="docClause")
    """The restructuring clause or a credit event for Single Name CDS. The possible values are:
     
     
     * CumRestruct14,
     * ModifiedRestruct14,
     * ModModRestruct14,
     * ExRestruct14,
     * CumRestruct03,
     * ModifiedRestruct03,
     * ModModRestruct03,
     * ExRestruct03."""
    index_factor: Optional[float] = rest_field(name="indexFactor")
    """The factor that is applied to the notional amount if a credit event happens in one of the
     constituents of the  CDS Index  . It is ignored for Single Name CDS."""
    error_code: Optional[str] = rest_field(name="errorCode")
    """The code of  ErrorMessage  ."""
    error_message: Optional[str] = rest_field(name="errorMessage")
    """The error message in case of a blocking error in calculation."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        instrument_type: Optional[str] = None,
        instrument_code: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        instrument_description: Optional[str] = None,
        reference_entity: Optional[str] = None,
        notional_ccy: Optional[str] = None,
        notional_amount: Optional[float] = None,
        report_ccy: Optional[str] = None,
        settlement_convention: Optional[str] = None,
        settlement_date: Optional[datetime.date] = None,
        trade_date: Optional[datetime.datetime] = None,
        step_in_date: Optional[datetime.datetime] = None,
        start_date: Optional[datetime.datetime] = None,
        end_date: Optional[datetime.datetime] = None,
        tenor: Optional[str] = None,
        first_accrual_date: Optional[datetime.date] = None,
        first_regular_payment_date: Optional[datetime.datetime] = None,
        last_regular_payment_date: Optional[datetime.datetime] = None,
        interest_payment_frequency: Optional[str] = None,
        interest_calculation_method: Optional[str] = None,
        accrued_calculation_method: Optional[str] = None,
        payment_business_day_convention: Optional[str] = None,
        payment_business_days: Optional[str] = None,
        discount_curve_id: Optional[str] = None,
        forward_curve_id: Optional[str] = None,
        credit_curve_id: Optional[str] = None,
        seniority: Optional[str] = None,
        doc_clause: Optional[str] = None,
        index_factor: Optional[float] = None,
        error_code: Optional[str] = None,
        error_message: Optional[str] = None,
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CdsNominalMeasures(_model_base.Model):
    """Nominal measures Object.

    Attributes
    ----------
    cr01_bp : float
        The sensitivity of the market value to a 1bp shift in the credit curve.
        The value is expressed in basis points.
    cr01_amount_in_deal_ccy : float
        The sensitivity of the market value to a 1bp shift in the credit curve.
        The value is expressed in the deal currency.
    cr01_amount_in_report_ccy : float
        The sensitivity of the market value to a 1bp shift in the credit curve.
        The value is expressed in the reporting currency.
    dv01_bp : float
        The sensitivity of the market value to a 1bp parallel shift in the
        zero-coupon curve. The value is expressed in basis points.
    dv01_amount_in_deal_ccy : float
        The sensitivity of the market value to a 1bp parallel shift in the
        zero-coupon curve. The value is expressed in the deal currency. For
        more details on the field calculation, please refer here.
    dv01_amount_in_report_ccy : float
        The sensitivity of the market value to a 1bp parallel shift in the
        zero-coupon curve. The value is expressed in the reporting currency.
    rr01_bp : float
        The sensitivity of the market value to a 1% shift in the recovery
        assumption. The value is expressed in basis points.
    rr01_amount_in_deal_ccy : float
        The sensitivity of the market value to a 1% shift in the recovery
        assumption. The value is expressed in the deal currency.
    rr01_amount_in_report_ccy : float
        The sensitivity of the market value to a 1% shift in the recovery
        assumption. The value is expressed in the reporting currency.
    jump_to_default_bp : float
        The cash amount that can be potentially lost or gained due to an
        instantaneous credit event using an assumed recovery. The value is
        expressed in basis points.
    jump_to_default_amount_in_deal_ccy : float
        The cash amount that can be potentially lost or gained due to an
        instantaneous credit event using an assumed recovery. The value is
        expressed in the deal currency.
    jump_to_default_amount_in_report_ccy : float
        The cash amount that can be potentially lost or gained due to an
        instantaneous credit event using an assumed recovery. The value is
        expressed in the reporting currency.
    default_probability : float
        The probability of default of the debt issuer on the maturity date.
    """

    cr01_bp: Optional[float] = rest_field(name="cr01Bp")
    """The sensitivity of the market value to a 1bp shift in the credit curve. The value is expressed
     in basis points."""
    cr01_amount_in_deal_ccy: Optional[float] = rest_field(name="cr01AmountInDealCcy")
    """The sensitivity of the market value to a 1bp shift in the credit curve. The value is expressed
     in the deal currency."""
    cr01_amount_in_report_ccy: Optional[float] = rest_field(name="cr01AmountInReportCcy")
    """The sensitivity of the market value to a 1bp shift in the credit curve. The value is expressed
     in the reporting currency."""
    dv01_bp: Optional[float] = rest_field(name="dv01Bp")
    """The sensitivity of the market value to a 1bp parallel shift in the zero-coupon curve. The value
     is expressed in basis points."""
    dv01_amount_in_deal_ccy: Optional[float] = rest_field(name="dv01AmountInDealCcy")
    """The sensitivity of the market value to a 1bp parallel shift in the zero-coupon curve. The value
     is expressed in the deal currency.
     For more details on the field calculation, please refer here."""
    dv01_amount_in_report_ccy: Optional[float] = rest_field(name="dv01AmountInReportCcy")
    """The sensitivity of the market value to a 1bp parallel shift in the zero-coupon curve. The value
     is expressed in the reporting currency."""
    rr01_bp: Optional[float] = rest_field(name="rr01Bp")
    """The sensitivity of the market value to a 1% shift in the recovery assumption. The value is
     expressed in basis points."""
    rr01_amount_in_deal_ccy: Optional[float] = rest_field(name="rr01AmountInDealCcy")
    """The sensitivity of the market value to a 1% shift in the recovery assumption. The value is
     expressed in the deal currency."""
    rr01_amount_in_report_ccy: Optional[float] = rest_field(name="rr01AmountInReportCcy")
    """The sensitivity of the market value to a 1% shift in the recovery assumption. The value is
     expressed in the reporting currency."""
    jump_to_default_bp: Optional[float] = rest_field(name="jumpToDefaultBp")
    """The cash amount that can be potentially lost or gained due to an instantaneous credit event
     using an assumed recovery. The value is expressed in basis points."""
    jump_to_default_amount_in_deal_ccy: Optional[float] = rest_field(name="jumpToDefaultAmountInDealCcy")
    """The cash amount that can be potentially lost or gained due to an instantaneous credit event
     using an assumed recovery. The value is expressed in the deal currency."""
    jump_to_default_amount_in_report_ccy: Optional[float] = rest_field(name="jumpToDefaultAmountInReportCcy")
    """The cash amount that can be potentially lost or gained due to an instantaneous credit event
     using an assumed recovery. The value is expressed in the reporting currency."""
    default_probability: Optional[float] = rest_field(name="defaultProbability")
    """The probability of default of the debt issuer on the maturity date."""

    @overload
    def __init__(
        self,
        *,
        cr01_bp: Optional[float] = None,
        cr01_amount_in_deal_ccy: Optional[float] = None,
        cr01_amount_in_report_ccy: Optional[float] = None,
        dv01_bp: Optional[float] = None,
        dv01_amount_in_deal_ccy: Optional[float] = None,
        dv01_amount_in_report_ccy: Optional[float] = None,
        rr01_bp: Optional[float] = None,
        rr01_amount_in_deal_ccy: Optional[float] = None,
        rr01_amount_in_report_ccy: Optional[float] = None,
        jump_to_default_bp: Optional[float] = None,
        jump_to_default_amount_in_deal_ccy: Optional[float] = None,
        jump_to_default_amount_in_report_ccy: Optional[float] = None,
        default_probability: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CdsPricingAnalysis(_model_base.Model):
    """Pricing analysis Object.

    Attributes
    ----------
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    fixed_rate_percent : float
        The interest rate used to derive future fixed interest payments of the
        instrument. The value is expressed in percentages.
    recovery_rate_percent : float
        The rate of the issuer's debt recovery in case of a credit event. The
        value is expressed in percentages.
    upfront_percent : float
        The amount (premium) that is paid upfront to reduce the credit risk.
        The value is expressed as a percentage of the notional amount.
    price_percent : float
        The instrument's price expressed in percentages.
    clean_price_percent : float
        The price excluding accrued interest. The value is expressed in
        percentages. For more details on the field calculation, please refer
        here.
    deal_spread_bp : float
        The annual amount that the protection buyer must pay to the protection
        seller. The value is expressed in basis points. It is retrieved from
        InstrumentCode  or calculated as [  FixedRatePercent  x 100].
    par_spread_bp : float
        The spread for which the NPV of the CDS equals to  0  . The value is
        expressed in basis points.
    """

    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    fixed_rate_percent: Optional[float] = rest_field(name="fixedRatePercent")
    """The interest rate used to derive future fixed interest payments of the instrument. The value is
     expressed in percentages."""
    recovery_rate_percent: Optional[float] = rest_field(name="recoveryRatePercent")
    """The rate of the issuer's debt recovery in case of a credit event. The value is expressed in
     percentages."""
    upfront_percent: Optional[float] = rest_field(name="upfrontPercent")
    """The amount (premium) that is paid upfront to reduce the credit risk. The value is expressed as
     a percentage of the notional amount."""
    price_percent: Optional[float] = rest_field(name="pricePercent")
    """The instrument's price expressed in percentages."""
    clean_price_percent: Optional[float] = rest_field(name="cleanPricePercent")
    """The price excluding accrued interest. The value is expressed in percentages.
     For more details on the field calculation, please refer here."""
    deal_spread_bp: Optional[float] = rest_field(name="dealSpreadBp")
    """The annual amount that the protection buyer must pay to the protection seller. The value is
     expressed in basis points. It is retrieved from  InstrumentCode  or calculated as [
     FixedRatePercent  x 100]."""
    par_spread_bp: Optional[float] = rest_field(name="parSpreadBp")
    """The spread for which the NPV of the CDS equals to  0  . The value is expressed in basis points."""

    @overload
    def __init__(
        self,
        *,
        market_data_date: Optional[datetime.datetime] = None,
        valuation_date: Optional[datetime.datetime] = None,
        fixed_rate_percent: Optional[float] = None,
        recovery_rate_percent: Optional[float] = None,
        upfront_percent: Optional[float] = None,
        price_percent: Optional[float] = None,
        clean_price_percent: Optional[float] = None,
        deal_spread_bp: Optional[float] = None,
        par_spread_bp: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CdsPricingParameters(_model_base.Model):
    """CdsPricingParameters.

    Attributes
    ----------
    cash_amount_in_deal_ccy : float
        The amount which should be paid by the protection buyer to the
        protection seller on SettlementDate, including the accrued amount. The
        value is expressed in the deal currency. Optional. No override is
        applied by default. Note that only one out of five pricing inputs
        should be defined.
    clean_price_percent : float
        The instrument's price excluding accrued interest. The value is
        expressed in percentages. Optional. No override is applied by default.
        Note that only one out of five pricing inputs should be defined.
    conventional_spread_bp : float
        The spread for which the NPV of the CDS equals to the upfront amount
        for a given coupon. The value is expressed in basis points. Optional.
        No override is applied by default. Note that only one out of five
        pricing inputs should be defined.
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).
        Optional. By default, marketDataDate is valuationDate or today.
    report_ccy : str
        The currency code set for the fields ending with 'xxxInReportCcy'. The
        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
        Optional. No default value applies.
    upfront_amount_in_deal_ccy : float
        The amount which should be paid by the protection buyer to the
        protection seller on SettlementDate, excluding the accrued amount. The
        value is expressed in the deal currency. Optional. No override is
        applied by default. Note that only one out of five pricing inputs
        should be defined.
    upfront_percent : float
        The amount (premium), that is paid upfront to reduce the credit risk.
        The value is expressed as a percentage of the notional amount.
        Optional. No override is applied by default. Note that only one out of
        five pricing inputs should be defined.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    """

    cash_amount_in_deal_ccy: Optional[float] = rest_field(name="cashAmountInDealCcy")
    """The amount which should be paid by the protection buyer to the protection seller on
     SettlementDate, including the accrued amount. The value is expressed in the deal currency.
     Optional. No override is applied by default. Note that only one out of five pricing inputs
     should be defined."""
    clean_price_percent: Optional[float] = rest_field(name="cleanPricePercent")
    """The instrument's price excluding accrued interest. The value is expressed in percentages.
     Optional. No override is applied by default. Note that only one out of five pricing inputs
     should be defined."""
    conventional_spread_bp: Optional[float] = rest_field(name="conventionalSpreadBp")
    """The spread for which the NPV of the CDS equals to the upfront amount for a given coupon. The
     value is expressed in basis points.
     Optional. No override is applied by default. Note that only one out of five pricing inputs
     should be defined."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It should be less or equal to
     valuationDate).
     Optional. By default, marketDataDate is valuationDate or today."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with 'xxxInReportCcy'. The value is expressed in
     ISO 4217 alphabetical format (e.g., 'USD').
     Optional. No default value applies."""
    upfront_amount_in_deal_ccy: Optional[float] = rest_field(name="upfrontAmountInDealCcy")
    """The amount which should be paid by the protection buyer to the protection seller on
     SettlementDate, excluding the accrued amount. The value is expressed in the deal currency.
     Optional. No override is applied by default. Note that only one out of five pricing inputs
     should be defined."""
    upfront_percent: Optional[float] = rest_field(name="upfrontPercent")
    """The amount (premium), that is paid upfront to reduce the credit risk. The value is expressed as
     a percentage of the notional amount.
     Optional. No override is applied by default. Note that only one out of five pricing inputs
     should be defined."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""

    @overload
    def __init__(
        self,
        *,
        cash_amount_in_deal_ccy: Optional[float] = None,
        clean_price_percent: Optional[float] = None,
        conventional_spread_bp: Optional[float] = None,
        market_data_date: Optional[datetime.datetime] = None,
        report_ccy: Optional[str] = None,
        upfront_amount_in_deal_ccy: Optional[float] = None,
        upfront_percent: Optional[float] = None,
        valuation_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CdsSpreadMeasures(_model_base.Model):
    """Spread measures Object.

    Attributes
    ----------
    conventional_spread_bp : float
        The spread for which the NPV of the CDS equals to the upfront amount
        for a given coupon. The value is expressed in basis points.
    """

    conventional_spread_bp: Optional[float] = rest_field(name="conventionalSpreadBp")
    """The spread for which the NPV of the CDS equals to the upfront amount for a given coupon. The
     value is expressed in basis points."""

    @overload
    def __init__(
        self,
        conventional_spread_bp: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["conventional_spread_bp"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CdsValuation(_model_base.Model):
    """Valuation Object.

    Attributes
    ----------
    accrued_days : int
        The number of days since the last interest payment date or since the
        dated date of the instrument.
    accrued_percent : float
        The accrued interest amount, which is accumulated, but not paid out.
        The value is expressed in percentages.
    accrued_amount_in_deal_ccy : float
        The accrued interest amount. It is computed from the accrued percent
        and the notional amount. The value is expressed in the deal currency.
    accrued_amount_in_report_ccy : float
        The accrued interest amount. It is computed from the accrued percent
        and the notional amount. The value is expressed in the reporting
        currency.
    upfront_amount_in_deal_ccy : float
        The amount (premium) which should be paid by the protection buyer to
        the protection seller on  SettlementDate  , excluding the accrued
        amount. If not specified, it is computed as [(100 -  CleanPricePercent
        ) / 100 x  NotionalAmount  ]. The value is expressed in the deal
        currency.
    upfront_amount_in_report_ccy : float
        The amount (premium) which should be paid by the protection buyer to
        the protection seller on  SettlementDate  , excluding the accrued
        amount. The value is expressed in the reporting currency.
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency.
    market_value_in_report_ccy : float
        The market value of the instrument. The value is expressed in the
        reporting currency.
    clean_market_value_in_deal_ccy : float
        The market value of the instrument less any accrued interest. The value
        is expressed in the deal currency.
    clean_market_value_in_report_ccy : float
        The market value of the instrument less any accrued amounts. The value
        is expressed in the reporting currency.
    """

    accrued_days: Optional[int] = rest_field(name="accruedDays")
    """The number of days since the last interest payment date or since the dated date of the
     instrument."""
    accrued_percent: Optional[float] = rest_field(name="accruedPercent")
    """The accrued interest amount, which is accumulated, but not paid out. The value is expressed in
     percentages."""
    accrued_amount_in_deal_ccy: Optional[float] = rest_field(name="accruedAmountInDealCcy")
    """The accrued interest amount. It is computed from the accrued percent and the notional amount.
     The value is expressed in the deal currency."""
    accrued_amount_in_report_ccy: Optional[float] = rest_field(name="accruedAmountInReportCcy")
    """The accrued interest amount. It is computed from the accrued percent and the notional amount.
     The value is expressed in the reporting currency."""
    upfront_amount_in_deal_ccy: Optional[float] = rest_field(name="upfrontAmountInDealCcy")
    """The amount (premium) which should be paid by the protection buyer to the protection seller on
     SettlementDate  , excluding the accrued amount. If not specified, it is computed as [(100 -
     CleanPricePercent  ) / 100 x  NotionalAmount  ]. The value is expressed in the deal currency."""
    upfront_amount_in_report_ccy: Optional[float] = rest_field(name="upfrontAmountInReportCcy")
    """The amount (premium) which should be paid by the protection buyer to the protection seller on
     SettlementDate  , excluding the accrued amount. The value is expressed in the reporting
     currency."""
    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value of the instrument. The value is expressed in the reporting currency."""
    clean_market_value_in_deal_ccy: Optional[float] = rest_field(name="cleanMarketValueInDealCcy")
    """The market value of the instrument less any accrued interest. The value is expressed in the
     deal currency."""
    clean_market_value_in_report_ccy: Optional[float] = rest_field(name="cleanMarketValueInReportCcy")
    """The market value of the instrument less any accrued amounts. The value is expressed in the
     reporting currency."""

    @overload
    def __init__(
        self,
        *,
        accrued_days: Optional[int] = None,
        accrued_percent: Optional[float] = None,
        accrued_amount_in_deal_ccy: Optional[float] = None,
        accrued_amount_in_report_ccy: Optional[float] = None,
        upfront_amount_in_deal_ccy: Optional[float] = None,
        upfront_amount_in_report_ccy: Optional[float] = None,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
        clean_market_value_in_deal_ccy: Optional[float] = None,
        clean_market_value_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CloCallInfo(_model_base.Model):
    """CloCallInfo.

    Attributes
    ----------
    date : ~datetime.date
    months_after : int
    type : str
        Is one of the following types: Literal["DATE"], Literal["NEXTCALL"],
        Literal["DELAY_NONCALL"], Literal["DELAY_REINVESTMENT"],
        Literal["CLEANUP"]
    """

    date: Optional[datetime.date] = rest_field()
    months_after: Optional[int] = rest_field(name="monthsAfter")
    type: Optional[Literal["DATE", "NEXTCALL", "DELAY_NONCALL", "DELAY_REINVESTMENT", "CLEANUP"]] = rest_field(
        default=None
    )
    """Is one of the following types: Literal[\"DATE\"], Literal[\"NEXTCALL\"],
     Literal[\"DELAY_NONCALL\"], Literal[\"DELAY_REINVESTMENT\"], Literal[\"CLEANUP\"]"""

    @overload
    def __init__(
        self,
        *,
        date: Optional[datetime.date] = None,
        months_after: Optional[int] = None,
        type: Optional[Literal["DATE", "NEXTCALL", "DELAY_NONCALL", "DELAY_REINVESTMENT", "CLEANUP"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CloSettings(_model_base.Model):
    """CloSettings.

    Attributes
    ----------
    assume_call : ~analyticsapi.models.CloCallInfo
    """

    assume_call: Optional["_models.CloCallInfo"] = rest_field(name="assumeCall")

    @overload
    def __init__(
        self,
        assume_call: Optional["_models.CloCallInfo"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["assume_call"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CmbsPrepayment(_model_base.Model):
    """CmbsPrepayment.

    Attributes
    ----------
    rate_during_yield_to_maturity : float
        Prepayment speed during the yield maintenance period.
    rate_after_yield_to_maturity : float
        Prepayment speed after the yield maintenance period.
    rate_during_premium : float
        Prepayment speed during the premium period.
    """

    rate_during_yield_to_maturity: Optional[float] = rest_field(name="rateDuringYieldToMaturity")
    """Prepayment speed during the yield maintenance period."""
    rate_after_yield_to_maturity: Optional[float] = rest_field(name="rateAfterYieldToMaturity")
    """Prepayment speed after the yield maintenance period."""
    rate_during_premium: Optional[float] = rest_field(name="rateDuringPremium")
    """Prepayment speed during the premium period."""

    @overload
    def __init__(
        self,
        *,
        rate_during_yield_to_maturity: Optional[float] = None,
        rate_after_yield_to_maturity: Optional[float] = None,
        rate_during_premium: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CmbsSettings(_model_base.Model):
    """CmbsSettings.

    Attributes
    ----------
    pricing_scenarios : list[~analyticsapi.models.PricingScenario]
        Choose between type + rate, systemScenarioName, or specifing a full
        scenario using CustomScenario.  The default value is None, needs to be
        assigned before using.
    """

    pricing_scenarios: Optional[List["_models.PricingScenario"]] = rest_field(name="pricingScenarios")
    """Choose between type + rate, systemScenarioName, or specifing a full scenario using
     CustomScenario."""

    @overload
    def __init__(
        self,
        pricing_scenarios: Optional[List["_models.PricingScenario"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["pricing_scenarios"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CmdtyOptionVolSurfaceChoice(_model_base.Model):
    """The object to provide either a reference to a commodity volatility surface stored in the
    platform or 3rd party volatilities.

    Attributes
    ----------
    reference : str
        The reference to a volatility surface stored in the platform.
    surface : ~analyticsapi.models.CmdtyVolSurfaceInput
        The volatility surface data.
    """

    reference: Optional[str] = rest_field()
    """The reference to a volatility surface stored in the platform."""
    surface: Optional["_models.CmdtyVolSurfaceInput"] = rest_field()
    """The volatility surface data."""

    @overload
    def __init__(
        self,
        *,
        reference: Optional[str] = None,
        surface: Optional["_models.CmdtyVolSurfaceInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CmdtyVolSurfaceInput(_model_base.Model):
    """The object defining the 3rd party commodity volatility surface.

    Attributes
    ----------
    strike_type : str or ~analyticsapi.models.StrikeTypeEnum
        The property that defines the type of the strikes provided in the
        surface points. Required. Known values are: "Absolute", "BasisPoint",
        "Delta", "Moneyness", "Percent", and "Relative".
    model_type : str or ~analyticsapi.models.VolModelTypeEnum
        The property that defines the type of the model (Normal or LogNormal)
        of the volatilities provided in the surface points. Required. Known
        values are: "Normal" and "LogNormal".
    points : list[~analyticsapi.models.VolSurfacePoint]
        The list of volatility points. Required.  The default value is None,
        needs to be assigned before using.
    contract_code : str
        The contract code of the commodity. Required.
    """

    strike_type: Union[str, "_models.StrikeTypeEnum"] = rest_field(name="strikeType")
    """The property that defines the type of the strikes provided in the surface points. Required.
     Known values are: \"Absolute\", \"BasisPoint\", \"Delta\", \"Moneyness\", \"Percent\", and
     \"Relative\"."""
    model_type: Union[str, "_models.VolModelTypeEnum"] = rest_field(name="modelType")
    """The property that defines the type of the model (Normal or LogNormal) of the volatilities
     provided in the surface points. Required. Known values are: \"Normal\" and \"LogNormal\"."""
    points: List["_models.VolSurfacePoint"] = rest_field()
    """The list of volatility points. Required."""
    contract_code: str = rest_field(name="contractCode")
    """The contract code of the commodity. Required."""

    @overload
    def __init__(
        self,
        *,
        strike_type: Union[str, "_models.StrikeTypeEnum"],
        model_type: Union[str, "_models.VolModelTypeEnum"],
        points: List["_models.VolSurfacePoint"],
        contract_code: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CMOModification(_model_base.Model):
    """CMOModification.

    Attributes
    ----------
    collateral : dict[str, ~analyticsapi.models.ModifyCollateral]
    class_property : ~analyticsapi.models.ModifyClass
    """

    collateral: Optional[Dict[str, "_models.ModifyCollateral"]] = rest_field()
    class_property: Optional["_models.ModifyClass"] = rest_field(name="class")

    @overload
    def __init__(
        self,
        *,
        collateral: Optional[Dict[str, "_models.ModifyCollateral"]] = None,
        class_property: Optional["_models.ModifyClass"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CollateralDetailsRequest(_model_base.Model):
    """CollateralDetailsRequest.

    Attributes
    ----------
    input : list[~analyticsapi.models.CollateralDetailsRequestInfo]
        The default value is None, needs to be assigned before using.
    """

    input: Optional[List["_models.CollateralDetailsRequestInfo"]] = rest_field()

    @overload
    def __init__(
        self,
        input: Optional[List["_models.CollateralDetailsRequestInfo"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["input"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CollateralDetailsRequestInfo(_model_base.Model):
    """CollateralDetailsRequestInfo.

    Attributes
    ----------
    identifier : str
    id_type : str or ~analyticsapi.models.IdTypeEnum
        Known values are: "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN",
        "REGSISIN", "SEDOL", "Identifier", "ChinaInterbankCode",
        "ShanghaiExchangeCode", "ShenzhenExchangeCode", and "MXTickerID".
    user_tag : str
    data_items : list[str]
        The default value is None, needs to be assigned before using.
    """

    identifier: Optional[str] = rest_field()
    id_type: Optional[Union[str, "_models.IdTypeEnum"]] = rest_field(name="idType")
    """Known values are: \"SecurityIDEntry\", \"SecurityID\", \"CUSIP\", \"ISIN\", \"REGSISIN\",
     \"SEDOL\", \"Identifier\", \"ChinaInterbankCode\", \"ShanghaiExchangeCode\",
     \"ShenzhenExchangeCode\", and \"MXTickerID\"."""
    user_tag: Optional[str] = rest_field(name="userTag")
    data_items: Optional[
        List[
            Literal[
                "COMMENTSINFO",
                "PRODUCTINFO",
                "SUMMARYINFO",
                "STRATSINFO",
                "GEOGRAPHICPREPAYINFO",
                "ORIGINATIONYEARINFO",
                "POOLINFO",
                "HAIRCUTINFO",
            ]
        ]
    ] = rest_field(name="dataItems")

    @overload
    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        id_type: Optional[Union[str, "_models.IdTypeEnum"]] = None,
        user_tag: Optional[str] = None,
        data_items: Optional[
            List[
                Literal[
                    "COMMENTSINFO",
                    "PRODUCTINFO",
                    "SUMMARYINFO",
                    "STRATSINFO",
                    "GEOGRAPHICPREPAYINFO",
                    "ORIGINATIONYEARINFO",
                    "POOLINFO",
                    "HAIRCUTINFO",
                ]
            ]
        ] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CollectionLinks(_model_base.Model):
    """CollectionLinks.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ColumnDetail(_model_base.Model):
    """ColumnDetail.

    Attributes
    ----------
    header : str
        Header to be used for the first row. Header should be limited to
        a-zA-Z0-9_ (regular identifiers). If header is omitted, the item is
        used.
    new_field : str
    field : str
    default_value : str
    format : str
    date_format : str
        Date format, e.g. 'yyyy-mm-dd', based on Java date formatting.
    num_scale : int
        Scale factor, multiply value by 10**scale. E.g., to show percent,
        scale=2. Applies to int as well.
    str_width : int
        Max width of output (string).
    bool_true : str
        Boolean format, see above - 'YES', 'Y', 'TRUE', 'T' (and their lower
        case values).
    bool_false : str
        See above.
    charset : str
    type : str
    lookup : ~analyticsapi.models.LookupDetails
    precision : int
    scale : int
    """

    header: Optional[str] = rest_field()
    """Header to be used for the first row. Header should be limited to a-zA-Z0-9_ (regular
     identifiers). If header is omitted, the item is used."""
    new_field: Optional[str] = rest_field(name="newField")
    field: Optional[str] = rest_field()
    default_value: Optional[str] = rest_field(name="defaultValue")
    format: Optional[str] = rest_field()
    date_format: Optional[str] = rest_field(name="dateFormat")
    """Date format, e.g. 'yyyy-mm-dd', based on Java date formatting."""
    num_scale: Optional[int] = rest_field(name="numScale")
    """Scale factor, multiply value by 10**scale. E.g., to show percent, scale=2. Applies to int as
     well."""
    str_width: Optional[int] = rest_field(name="strWidth")
    """Max width of output (string)."""
    bool_true: Optional[str] = rest_field(name="boolTrue")
    """Boolean format, see above - 'YES', 'Y', 'TRUE', 'T' (and their lower case values)."""
    bool_false: Optional[str] = rest_field(name="boolFalse")
    """See above."""
    charset: Optional[str] = rest_field()
    type: Optional[str] = rest_field(default="None")
    lookup: Optional["_models.LookupDetails"] = rest_field()
    precision: Optional[int] = rest_field()
    scale: Optional[int] = rest_field()

    @overload
    def __init__(
        self,
        *,
        header: Optional[str] = None,
        new_field: Optional[str] = None,
        field: Optional[str] = None,
        default_value: Optional[str] = None,
        format: Optional[str] = None,
        date_format: Optional[str] = None,
        num_scale: Optional[int] = None,
        str_width: Optional[int] = None,
        bool_true: Optional[str] = None,
        bool_false: Optional[str] = None,
        charset: Optional[str] = None,
        type: Optional[str] = None,
        lookup: Optional["_models.LookupDetails"] = None,
        precision: Optional[int] = None,
        scale: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CombinedShift(_model_base.Model):
    """CombinedShift.

    Attributes
    ----------
    amount : float
        Amount of shifting, applied to points depending on shift method
        selected. Can be measured in basis points/percents/future price based
        points. Also can be expressed as multiplier for relative shift type.
    end_tenor : str
        The code indicating the end tenor from which the combined shifts
        scenario is applied to curve points. When startTenor equals endTenor:
        * shift equals 0 for tenor less than startTenor,   * shift equals
        amount for tenor is equal and greater than endTenor. When startTenor
        less than endTenor:   * shift equals 0 for tenor which is less or equal
        startTenor, * shift rises from 0 to amount in period from startTenor to
        endTenor. Shift equals amount for tenor greater than endTenor.
    ignore_quotation_scale : bool
    shift_type : str or ~analyticsapi.models.ShiftTypeEnum
        The type of shifting. The possible values are:   * Additive: the amount
        of shifting is added to the corresponding curve point,   * Relative:
        the curve point is multiplied by the amount of shifting (e.g., if
        amount = 1, the curve point value will be doubled),   * Scaled: the
        curve point is scaled by the value of the shifting amount (e.g., if
        amount = 1.1, the curve point value will multiplied by this value).
        Known values are: "Additive", "Relative", and "Scaled".
    shift_unit : str or ~analyticsapi.models.ShiftUnitEnum
        The unit that describes the amount of shifting. The possible values
        are:   * Absolute: the amount of shifting is expressed in absolute
        value.   * Bp: the amount of shifting is expressed in basis points,   *
        Percent: the amount of shifting is expressed in percentages,. Known
        values are: "Absolute", "Bp", and "Percent".
    start_tenor : str
        The code indicating the start tenor from which the combined shifts
        scenario is applied to curve points. When startTenor equals endTenor:
        * shift equals 0 for tenor less than startTenor,   * shift equals
        amount for tenor is equal and greater than endTenor. When startTenor
        less than endTenor:   * shift equals 0 for tenor which is less or equal
        startTenor, * shift rises from 0 to amount in period from startTenor to
        endTenor. Shift equals amount for tenor greater than endTenor.
    """

    amount: Optional[float] = rest_field()
    """Amount of shifting, applied to points depending on shift method selected. Can be measured in
     basis points/percents/future price based points. Also can be expressed as multiplier for
     relative shift type."""
    end_tenor: Optional[str] = rest_field(name="endTenor")
    """The code indicating the end tenor from which the combined shifts scenario is applied to curve
     points. When startTenor equals endTenor:   * shift equals 0 for tenor less than startTenor,   *
     shift equals amount for tenor is equal and greater than endTenor. When startTenor less than
     endTenor:   * shift equals 0 for tenor which is less or equal startTenor,   * shift rises from
     0 to amount in period from startTenor to endTenor. Shift equals amount for tenor greater than
     endTenor."""
    ignore_quotation_scale: Optional[bool] = rest_field(name="ignoreQuotationScale")
    shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = rest_field(name="shiftType")
    """The type of shifting. The possible values are:   * Additive: the amount of shifting is added to
     the corresponding curve point,   * Relative: the curve point is multiplied by the amount of
     shifting (e.g., if amount = 1, the curve point value will be doubled),   * Scaled: the curve
     point is scaled by the value of the shifting amount (e.g., if amount = 1.1, the curve point
     value will multiplied by this value). Known values are: \"Additive\", \"Relative\", and
     \"Scaled\"."""
    shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = rest_field(name="shiftUnit")
    """The unit that describes the amount of shifting. The possible values are:   * Absolute: the
     amount of shifting is expressed in absolute value.   * Bp: the amount of shifting is expressed
     in basis points,   * Percent: the amount of shifting is expressed in percentages,. Known values
     are: \"Absolute\", \"Bp\", and \"Percent\"."""
    start_tenor: Optional[str] = rest_field(name="startTenor")
    """The code indicating the start tenor from which the combined shifts scenario is applied to curve
     points. When startTenor equals endTenor:   * shift equals 0 for tenor less than startTenor,   *
     shift equals amount for tenor is equal and greater than endTenor. When startTenor less than
     endTenor:   * shift equals 0 for tenor which is less or equal startTenor,   * shift rises from
     0 to amount in period from startTenor to endTenor. Shift equals amount for tenor greater than
     endTenor."""

    @overload
    def __init__(
        self,
        *,
        amount: Optional[float] = None,
        end_tenor: Optional[str] = None,
        ignore_quotation_scale: Optional[bool] = None,
        shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = None,
        shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = None,
        start_tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadFields(_model_base.Model):
    """CommoditiesCalendarSpreadFields.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldFormulaDoubleValue
    bid : ~analyticsapi.models.FieldFormulaDoubleValue
    bid_ask_time : ~analyticsapi.models.FieldTimeValue
    last : ~analyticsapi.models.FieldFormulaDoubleValue
    last_time : ~analyticsapi.models.FieldTimeValue
    settlement : ~analyticsapi.models.FieldFormulaDoubleValue
    settlement_date : ~analyticsapi.models.FieldDateValue
    trade_date : ~analyticsapi.models.FieldDateValue
    """

    ask: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    bid: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    bid_ask_time: Optional["_models.FieldTimeValue"] = rest_field(name="bidAskTime")
    last: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    last_time: Optional["_models.FieldTimeValue"] = rest_field(name="lastTime")
    settlement: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    settlement_date: Optional["_models.FieldDateValue"] = rest_field(name="settlementDate")
    trade_date: Optional["_models.FieldDateValue"] = rest_field(name="tradeDate")

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldFormulaDoubleValue"] = None,
        bid: Optional["_models.FieldFormulaDoubleValue"] = None,
        bid_ask_time: Optional["_models.FieldTimeValue"] = None,
        last: Optional["_models.FieldFormulaDoubleValue"] = None,
        last_time: Optional["_models.FieldTimeValue"] = None,
        settlement: Optional["_models.FieldFormulaDoubleValue"] = None,
        settlement_date: Optional["_models.FieldDateValue"] = None,
        trade_date: Optional["_models.FieldDateValue"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadFieldsDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesCalendarSpreadFieldsDescription.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldFormulaDescription
    bid : ~analyticsapi.models.FieldFormulaDescription
    bid_ask_time : ~analyticsapi.models.FieldDescription
    currency : ~analyticsapi.models.FieldDescription
    last : ~analyticsapi.models.FieldFormulaDescription
    last_time : ~analyticsapi.models.FieldDescription
    maturity_date : ~analyticsapi.models.FieldDescription
    settlement : ~analyticsapi.models.FieldFormulaDescription
    settlement_date : ~analyticsapi.models.FieldDescription
    tenor_date : ~analyticsapi.models.FieldDescription
    tick_value : ~analyticsapi.models.FieldDescription
    trade_date : ~analyticsapi.models.FieldDescription
    """

    ask: Optional["_models.FieldFormulaDescription"] = rest_field()
    bid: Optional["_models.FieldFormulaDescription"] = rest_field()
    bid_ask_time: Optional["_models.FieldDescription"] = rest_field(name="bidAskTime")
    currency: Optional["_models.FieldDescription"] = rest_field()
    last: Optional["_models.FieldFormulaDescription"] = rest_field()
    last_time: Optional["_models.FieldDescription"] = rest_field(name="lastTime")
    maturity_date: Optional["_models.FieldDescription"] = rest_field(name="maturityDate")
    settlement: Optional["_models.FieldFormulaDescription"] = rest_field()
    settlement_date: Optional["_models.FieldDescription"] = rest_field(name="settlementDate")
    tenor_date: Optional["_models.FieldDescription"] = rest_field(name="tenorDate")
    tick_value: Optional["_models.FieldDescription"] = rest_field(name="tickValue")
    trade_date: Optional["_models.FieldDescription"] = rest_field(name="tradeDate")

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldFormulaDescription"] = None,
        bid: Optional["_models.FieldFormulaDescription"] = None,
        bid_ask_time: Optional["_models.FieldDescription"] = None,
        currency: Optional["_models.FieldDescription"] = None,
        last: Optional["_models.FieldFormulaDescription"] = None,
        last_time: Optional["_models.FieldDescription"] = None,
        maturity_date: Optional["_models.FieldDescription"] = None,
        settlement: Optional["_models.FieldFormulaDescription"] = None,
        settlement_date: Optional["_models.FieldDescription"] = None,
        tenor_date: Optional["_models.FieldDescription"] = None,
        tick_value: Optional["_models.FieldDescription"] = None,
        trade_date: Optional["_models.FieldDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadFieldsFormulaDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesCalendarSpreadFieldsFormulaDescription.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldDescription
    bid : ~analyticsapi.models.FieldDescription
    last : ~analyticsapi.models.FieldDescription
    settlement : ~analyticsapi.models.FieldDescription
    """

    ask: Optional["_models.FieldDescription"] = rest_field()
    bid: Optional["_models.FieldDescription"] = rest_field()
    last: Optional["_models.FieldDescription"] = rest_field()
    settlement: Optional["_models.FieldDescription"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldDescription"] = None,
        bid: Optional["_models.FieldDescription"] = None,
        last: Optional["_models.FieldDescription"] = None,
        settlement: Optional["_models.FieldDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadFieldsOutput(_model_base.Model):
    """CommoditiesCalendarSpreadFieldsOutput.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldFormulaDoubleOutput
    bid : ~analyticsapi.models.FieldFormulaDoubleOutput
    bid_ask_time : ~analyticsapi.models.FieldTimeOutput
    last : ~analyticsapi.models.FieldFormulaDoubleOutput
    last_time : ~analyticsapi.models.FieldTimeOutput
    market_data_date : ~datetime.date
        Get marketDataDate.
    market_data_time : ~analyticsapi.models.MarketDataTime
    settlement : ~analyticsapi.models.FieldFormulaDoubleOutput
    settlement_date : ~analyticsapi.models.FieldDateOutput
    trade_date : ~analyticsapi.models.FieldDateOutput
    """

    ask: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    bid: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    bid_ask_time: Optional["_models.FieldTimeOutput"] = rest_field(name="bidAskTime")
    last: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    last_time: Optional["_models.FieldTimeOutput"] = rest_field(name="lastTime")
    market_data_date: Optional[datetime.date] = rest_field(name="marketDataDate")
    """Get marketDataDate."""
    market_data_time: Optional["_models.MarketDataTime"] = rest_field(name="marketDataTime")
    settlement: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    settlement_date: Optional["_models.FieldDateOutput"] = rest_field(name="settlementDate")
    trade_date: Optional["_models.FieldDateOutput"] = rest_field(name="tradeDate")

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldFormulaDoubleOutput"] = None,
        bid: Optional["_models.FieldFormulaDoubleOutput"] = None,
        bid_ask_time: Optional["_models.FieldTimeOutput"] = None,
        last: Optional["_models.FieldFormulaDoubleOutput"] = None,
        last_time: Optional["_models.FieldTimeOutput"] = None,
        market_data_date: Optional[datetime.date] = None,
        market_data_time: Optional["_models.MarketDataTime"] = None,
        settlement: Optional["_models.FieldFormulaDoubleOutput"] = None,
        settlement_date: Optional["_models.FieldDateOutput"] = None,
        trade_date: Optional["_models.FieldDateOutput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadFormulaFields(_model_base.Model):
    """CommoditiesCalendarSpreadFormulaFields.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldDoubleValue
    bid : ~analyticsapi.models.FieldDoubleValue
    last : ~analyticsapi.models.FieldDoubleValue
    settlement : ~analyticsapi.models.FieldDoubleValue
    """

    ask: Optional["_models.FieldDoubleValue"] = rest_field()
    bid: Optional["_models.FieldDoubleValue"] = rest_field()
    last: Optional["_models.FieldDoubleValue"] = rest_field()
    settlement: Optional["_models.FieldDoubleValue"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldDoubleValue"] = None,
        bid: Optional["_models.FieldDoubleValue"] = None,
        last: Optional["_models.FieldDoubleValue"] = None,
        settlement: Optional["_models.FieldDoubleValue"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadFormulaParameter(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesCalendarSpreadFormulaParameter.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesCalendarSpreadFormulaFields
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesCalendarSpreadFormulaFields"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesCalendarSpreadFormulaFields"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadFormulaParameterDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesCalendarSpreadFormulaParameterDescription.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesCalendarSpreadFieldsFormulaDescription
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesCalendarSpreadFieldsFormulaDescription"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesCalendarSpreadFieldsFormulaDescription"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadFormulaParameterOutput(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesCalendarSpreadFormulaParameterOutput.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesFieldsFormulaOutput
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesFieldsFormulaOutput"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesFieldsFormulaOutput"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadInstrument(_model_base.Model):
    """CommoditiesCalendarSpreadInstrument.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesCalendarSpreadFields
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.CommoditiesCalendarSpreadFormulaParameter]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CommoditiesCalendarSpreadInstrumentDefinition
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesCalendarSpreadFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.CommoditiesCalendarSpreadFormulaParameter"]] = rest_field(
        name="formulaParameters"
    )
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CommoditiesCalendarSpreadInstrumentDefinition"] = rest_field(
        name="instrumentDefinition"
    )

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesCalendarSpreadFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.CommoditiesCalendarSpreadFormulaParameter"]] = None,
        instrument_definition: Optional["_models.CommoditiesCalendarSpreadInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadInstrumentDefinition(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesCalendarSpreadInstrumentDefinition.

    Attributes
    ----------
    instrument_code : str
        Get instrumentCode.
    instrument_group_tag : str
        Get instrumentGroupTag.
    maturity_date : ~datetime.date
        Get maturityDate.
    priority_rank : int
        Get priorityRank.
    tenor_date : ~datetime.date
        Get tenorDate.
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_group_tag: Optional[str] = rest_field(name="instrumentGroupTag")
    """Get instrumentGroupTag."""
    maturity_date: Optional[datetime.date] = rest_field(name="maturityDate")
    """Get maturityDate."""
    priority_rank: Optional[int] = rest_field(name="priorityRank")
    """Get priorityRank."""
    tenor_date: Optional[datetime.date] = rest_field(name="tenorDate")
    """Get tenorDate."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        instrument_group_tag: Optional[str] = None,
        maturity_date: Optional[datetime.date] = None,
        priority_rank: Optional[int] = None,
        tenor_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadInstrumentDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesCalendarSpreadInstrumentDescription.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesCalendarSpreadFieldsDescription
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.CommoditiesCalendarSpreadFormulaParameterDescription]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CommoditiesInstrumentDefinitionDescription
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesCalendarSpreadFieldsDescription"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.CommoditiesCalendarSpreadFormulaParameterDescription"]] = rest_field(
        name="formulaParameters"
    )
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CommoditiesInstrumentDefinitionDescription"] = rest_field(
        name="instrumentDefinition"
    )

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesCalendarSpreadFieldsDescription"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.CommoditiesCalendarSpreadFormulaParameterDescription"]] = None,
        instrument_definition: Optional["_models.CommoditiesInstrumentDefinitionDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCalendarSpreadInstrumentOutput(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesCalendarSpreadInstrumentOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.CommoditiesCalendarSpreadFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.CommoditiesCalendarSpreadFormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CommoditiesCalendarSpreadInstrumentDefinition
    status_message : str
        Get statusMessage.
    """

    fields: Optional["_models.CommoditiesCalendarSpreadFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.CommoditiesCalendarSpreadFormulaParameterOutput"]] = rest_field(
        name="formulaParameters"
    )
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CommoditiesCalendarSpreadInstrumentDefinition"] = rest_field(
        name="instrumentDefinition"
    )
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.CommoditiesCalendarSpreadFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.CommoditiesCalendarSpreadFormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.CommoditiesCalendarSpreadInstrumentDefinition"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesChainSource(_model_base.Model):
    """CommoditiesChainSource.

    Attributes
    ----------
    chain_ric : str
        Get chainRic.
    skip : list[str]
        Array of item to remove from chain. could be single items: eg: 1 or
        range of items 1-3.  The default value is None, needs to be assigned
        before using.
    """

    chain_ric: Optional[str] = rest_field(name="chainRic")
    """Get chainRic."""
    skip: Optional[List[str]] = rest_field()
    """Array of item to remove from chain. could be single items: eg: 1 or range of items 1-3."""

    @overload
    def __init__(
        self,
        *,
        chain_ric: Optional[str] = None,
        skip: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveConstituents(_model_base.Model):
    """CommoditiesCurveConstituents.

    Attributes
    ----------
    commodities_instruments : dict[str, ~analyticsapi.models.CommoditiesInstrumentsRequest]
        Get commoditiesInstruments.
    """

    commodities_instruments: Optional[Dict[str, "_models.CommoditiesInstrumentsRequest"]] = rest_field(
        name="commoditiesInstruments"
    )
    """Get commoditiesInstruments."""

    @overload
    def __init__(
        self,
        commodities_instruments: Optional[Dict[str, "_models.CommoditiesInstrumentsRequest"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["commodities_instruments"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CommoditiesCurveConstituentsDescription(_model_base.Model):
    """CommoditiesCurveConstituentsDescription.

    Attributes
    ----------
    calendar_spreads : list[~analyticsapi.models.CommoditiesCalendarSpreadInstrumentDescription]
        Get calendarSpreads.  The default value is None, needs to be assigned
        before using.
    futures : list[~analyticsapi.models.CommoditiesFuturesInstrumentDescription]
        Get futures.  The default value is None, needs to be assigned before
        using.
    inter_product_spreads : list[~analyticsapi.models.CommoditiesInterProductSpreadInstrumentDescription]
        Get interProductSpreads.  The default value is None, needs to be
        assigned before using.
    """

    calendar_spreads: Optional[List["_models.CommoditiesCalendarSpreadInstrumentDescription"]] = rest_field(
        name="calendarSpreads"
    )
    """Get calendarSpreads."""
    futures: Optional[List["_models.CommoditiesFuturesInstrumentDescription"]] = rest_field()
    """Get futures."""
    inter_product_spreads: Optional[List["_models.CommoditiesInterProductSpreadInstrumentDescription"]] = rest_field(
        name="interProductSpreads"
    )
    """Get interProductSpreads."""

    @overload
    def __init__(
        self,
        *,
        calendar_spreads: Optional[List["_models.CommoditiesCalendarSpreadInstrumentDescription"]] = None,
        futures: Optional[List["_models.CommoditiesFuturesInstrumentDescription"]] = None,
        inter_product_spreads: Optional[List["_models.CommoditiesInterProductSpreadInstrumentDescription"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveConstituentsOutput(_model_base.Model):
    """CommoditiesCurveConstituentsOutput.

    Attributes
    ----------
    commodities_instruments : dict[str, ~analyticsapi.models.CommoditiesInstrumentsOutput]
        Get commoditiesInstruments.
    """

    commodities_instruments: Optional[Dict[str, "_models.CommoditiesInstrumentsOutput"]] = rest_field(
        name="commoditiesInstruments"
    )
    """Get commoditiesInstruments."""

    @overload
    def __init__(
        self,
        commodities_instruments: Optional[Dict[str, "_models.CommoditiesInstrumentsOutput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["commodities_instruments"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CommoditiesCurveCreateRequest(_model_base.Model):
    """Commodity & Energy curve definition.

    Attributes
    ----------
    curve_definition : ~analyticsapi.models.CommoditiesCurveDefinitionDescription
    segments : list[~analyticsapi.models.CommoditiesInstrumentsSegmentCreate]
        Get segments.  The default value is None, needs to be assigned before
        using.
    """

    curve_definition: Optional["_models.CommoditiesCurveDefinitionDescription"] = rest_field(name="curveDefinition")
    segments: Optional[List["_models.CommoditiesInstrumentsSegmentCreate"]] = rest_field()
    """Get segments."""

    @overload
    def __init__(
        self,
        *,
        curve_definition: Optional["_models.CommoditiesCurveDefinitionDescription"] = None,
        segments: Optional[List["_models.CommoditiesInstrumentsSegmentCreate"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveDefinition(_model_base.Model):
    """CommoditiesCurveDefinition.

    Attributes
    ----------
    currency : str
        The currency code of the commodity curve.
    definition_expiry_date : ~datetime.date
        Get definitionExpiryDate.
    first_historical_availability_date : ~datetime.date
        The date starting from which the definition of the curve can be used.
        The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01').
    id : str
        Id of the curve definition.
    name : str
        The name of the commodity and energy curve.
    product : str or ~analyticsapi.models.ProductEnum
        Commodities RCS product. Please note that not all products can be
        priced for now. Known values are: "ABSPlastic", "AceticAcid",
        "Acetone", "AcrylateEsters", "AcrylicAcid", "Acrylonitrile",
        "AdipicAcid", "AlfalfaHay", "AlfalfaMeal", "AlfalfaPellets",
        "AlfalfaSeed", "Almonds", "AlphaMethylstyrene", "AluminaBauxite",
        "Aluminium", "AmmoniaWater25Percent", "AmmoniumNitrate",
        "AnhydrousAmmonia", "AnhydrousSulfate", "AnthraceneFraction",
        "Antimony", "Arabica", "Arsenic", "Asphalt", "AssignedAmountUnit",
        "AvocadoOil", "BarleyBran", "Baseload", "Beef", "Beer", "Beeswax",
        "Benzene", "BeverageWaste", "Biodiesel", "BirdSeed", "Bismuth",
        "BisphenolA", "BlackSeed", "Block", "BoneMeal", "Brass", "BrazilNuts",
        "BrentCrudes", "Bronze", "Buckwheat", "BunkerFuel", "BurningKerosene",
        "Butadiene", "ButadieneLatexes", "ButadieneNitrileRubbers",
        "ButadieneStyreneLatexes", "ButadieneStyreneRubbers", "Butane",
        "Butanediol", "Butter", "ButylAcetate", "ButylRubbers", "Cadmium",
        "CanarySeed", "Caprolactam", "CarbamideFormaldehydeResins", "Cashews",
        "Cassava", "CastorOil", "CausticSoda", "CellulosicBiofuels",
        "CertifiedEmissionReduction", "Cheese", "Chestnuts", "Chromite",
        "Chromium", "CitrusPulp", "Clothing", "CloudCover", "Cobalt", "Cocoa",
        "CoconutOil", "CokingCoal", "Cola", "CoolingDegreeDays", "Copper",
        "CopperConcentrates", "CopperOre", "Copra", "CopraPellets", "CornOil",
        "Cornflour", "Cosmetics", "Cotton", "CottonYarn", "Cottonseed",
        "CottonseedMeal", "CottonseedOil", "Cramp", "Cumene", "Cyclohexane",
        "Detergents", "DiammoniumPhosphate", "Diamond", "Diesel",
        "Diethanolamine", "DiethyleneGlycol", "DimethylTerephthalate",
        "Dioctylphthalate", "DistillersDriedGrainsWithSolubles",
        "DivinylRubbers", "Drugs", "DryBulkSingleVoyage", "DryBulkTimeCharter",
        "DualPurposeKerosene", "DubaiCrude", "Dyes", "EdibleBarley",
        "EdibleWheat", "Egg", "ElectricalWire", "EmissionReductionUnit",
        "EmulsionPVC", "Epichlorohydrin", "EpoxyResins", "EssentialOils",
        "Ethane", "Ethanol", "EthylTertiaryButylEther", "Ethylbenzene",
        "Ethylene", "EthyleneDichloride", "EthyleneOxide",
        "EthylenePropyleneRubbers", "EthyleneVinylAcetate", "Ethylhexanol",
        "EuropeanAviationAllowanc", "EuropeanUnitAllowance",
        "ExpandablePolystyrene", "FatProducts", "FattyAcid", "FattyAlcohols",
        "FeatherMeal", "FeedBarley", "FeedConcentrate", "FeedCorn",
        "FeedWheat", "Ferroalloy", "Ferrochrome", "FiberProducts", "Fish",
        "FishMeal", "FishOil", "Flax", "Flour", "FrogLegs", "Fruit",
        "FurSkins", "Gallium", "Gasoline", "GasolineComponents", "Gelatine",
        "GeneralPurposePolystyren", "Germanium", "GlutenFeedPellets",
        "GlutenMeal", "Glycerine", "GlycolEthers", "GoatMeat", "GoldBullion",
        "GoldCoins", "GoldIngots", "Greaves", "GreenBeans",
        "GrowingDegreeDays", "Gum", "Gunmetal", "HazelNuts",
        "HeatingDegreeDays", "HeatingOilGasOil", "HeavyPyrolysisResins",
        "Hemp", "Hexane", "HighDensityPolyethylene", "HighImpactPolystyrene",
        "HighSulphurFuelOil", "HominyFeed", "Honey", "Hops", "Horticulture",
        "HydrochloricAcid", "Indium", "Iridium", "IronOre", "IsoButanol",
        "IsoPropanol", "Isocyanates", "IsophthalicAcid", "IsopreneRubbers",
        "JetFuel", "Jute", "LambMutton", "LardTallow", "Lead", "LeadOre",
        "Leather", "LinearAlkylbenzene", "LinearAlkylbenzeneSulpho",
        "LinearLowDensityPolyeth", "Linen", "LinseedFlaxseed", "LinseedOil",
        "LiquefiedNaturalGas", "LiquidPyrolysisProducts", "LiveCattle",
        "LivePigHog", "LiveSheepLamb", "LowDensityPolyethylene",
        "LowSulphurFuelOil", "LowSulphurWaxyResidue", "LubricatingOils",
        "Magnesium", "MaleicAnhydride", "Malt", "MaltingBarley",
        "MaltingWheat", "Manganese", "ManganeseOre", "MeatExtracts",
        "MeatMeal", "Melamine", "Mercury", "Methanol", "MethylEthylKetone",
        "MethylIsobutylKetone", "MethylMethacrylate",
        "MethylTertiaryButylEther", "MethyleneChloride", "Milk", "MilletBran",
        "MixedXylenes", "Molasses", "Molybdenum", "MonoAmmoniumPhosphate",
        "Monoethanolamine", "MonoethyleneGlycol", "MonopropyleneGlycol",
        "Mustard", "NButanol", "Naphtha", "NaturalGasLiquids", "Nickel",
        "NickelOre", "NitrogenFertilizers", "NitrogenPhosphorusPotassium",
        "NitrousOxide", "NorthAmericanSpecialAluminiumAlloy", "Nylon",
        "OXylene", "OatBran", "OffPeak", "Offal", "OliveOil", "Olives",
        "OrangeJuice", "OtherBran", "OtherCrudes", "OtherLPG", "OtherMeat",
        "OtherNaturalGas", "OtherNuts", "OtherOilCrops", "OtherRootCrops",
        "OtherSeedCrops", "PXylene", "PalladiumBullion", "PalladiumCoins",
        "PalladiumIngots", "PalmFruitOilBleachedAndNeutralized",
        "PalmFruitOilCrude", "PalmFruitOilOleinRefinedBleachedAndDeodorized",
        "PalmFruitStearinRefinedBleachedAndDeodorized", "PalmKernelMeal",
        "PalmKernelOilCrude", "PalmKernelOilProcesse", "PalmKernelPellets",
        "PalmKernelStearin", "Paper", "ParaffinWax", "Pasta", "Peakload",
        "PeanutMeal", "PeanutOil", "Peanuts", "Peas", "PetFood",
        "PetroleumSolvents", "Phenol", "PhosphateRock", "PhosphoricAcid",
        "PhthalicAnhydride", "Pistachios", "PlatinumBullion", "PlatinumCoins",
        "PlatinumIngots", "Polyacetals", "PolybutyleneTerephthalate",
        "Polycarbonate", "Polyester", "PolyetherPolyols",
        "PolyethyleneTerephthalate", "PolymethylMethacrylate", "Polyols",
        "PolypropyleneBlockCopolymer", "PolypropyleneHomopolymer",
        "PolypropyleneRandomCopolymer", "Pork", "Potash", "Potatoes",
        "Poultry", "Propane", "Propylene", "PropyleneGlycolEthers",
        "PropyleneOxide", "Pulp", "Quinoa", "RabbitMeat", "Rapemeal",
        "RapeseedCanola", "RapeseedCanolaOil", "RedBeans",
        "RenewableEnergyCertificate", "RenewableObligationCertificate",
        "Rhodium", "Robusta", "RoughRice", "Rubber", "Ruthenium", "Rye",
        "SANPlastic", "Safflower", "SafflowerOil", "Salt", "ScrapAluminum",
        "ScrapCopper", "ScrapIron", "ScrapLead", "ScrapNickel", "ScrapTin",
        "ScrapZinc", "SeedCorn", "Selenium", "Sesame", "SheaButter",
        "SheaNuts", "Shellfish", "Shrimp", "Silicon", "Silk", "SilverBullion",
        "SilverCoins", "SilverIngots", "Sisal", "SoapNoodles", "SodaAsh",
        "Sorbitol", "SorghumMilo", "Soybean", "SoybeanMeal", "SoybeanOil",
        "SoybeanPellets", "SpicesHerbs", "StainlessSteel", "Steel",
        "StraightRunFuelOil", "Styrene", "SugarBeetPulp", "SugarCane",
        "SulfuricAcid", "Sulphur", "SulphurDioxide", "Sunflower",
        "SunflowerOil", "SunflowerSeedMeal", "SuspensionPVC", "SweetPotatoes",
        "SyntheticSweetCrude", "TallOil", "TankerCleanSingleVoyage",
        "TankerCleanTimeCharter", "TankerDirtySingleVoyage",
        "TankerDirtyTimeCharter", "Tantalite", "TapiocaMeal", "Tea",
        "TerephthalicAcid", "ThermalCoal", "TimberLumber", "Tin", "TinOre",
        "Titanium", "TitaniumDioxide", "Tobacco", "Toluene", "Triethanolamine",
        "TriethyleneGlycol", "TripleSimplePhosphate", "Triticale", "TungOil",
        "Tungstate", "Tungsten", "USLightSweetCrudes", "Uranium", "Urea",
        "UreaAmmoniumNitrate", "Vanadium", "Veal", "VegetableOil",
        "VinylAcetate", "VinylChlorideMonomer", "VoluntaryCarbonUnit",
        "VoluntaryEmissionReduction", "Walnuts", "WheatBran", "WheatFlour",
        "WheatStarch", "Whey", "WhiteCertificate", "WhiteSpirit", "Wine",
        "Wolframite", "WoodProducts", "WoodyBiomass", "Wool", "Yoghurt",
        "Zinc", and "ZincOre".
    sector : str or ~analyticsapi.models.SectorEnum
        Commodities RCS sector. Please note that not all products can be priced
        for now. Known values are: "Agriculture", "Energy", "Metals", "Other",
        "Transportation", and "Weather".
    source : str
        Get source.
    sub_sector : str or ~analyticsapi.models.SubSectorEnum
        Commodities RCS sub-sector. Please note that not all products can be
        priced for now. Known values are: "BaseMetalsOres", "Biofuels",
        "Chemicals", "Cloud", "Coal", "Dairy", "DryBulkFreight", "Emissions",
        "Fertilizer", "ForestryFibre", "GasProducts", "Grains", "IronSteel",
        "Livestock", "MealsFeedsPulses", "MinorMetalsMinerals",
        "MiscellaneousAgriculture", "OilProducts", "Oilseeds",
        "Petrochemicals", "Power", "PreciousMetalsMinerals", "RenewableEnergy",
        "ScrapSecondaryAlloys", "Softs", "TankerFreight", and "Temperature".
    underlying_code : str
        The name of underlying defining the commodity and energy curve.
    """

    currency: Optional[str] = rest_field()
    """The currency code of the commodity curve."""
    definition_expiry_date: Optional[datetime.date] = rest_field(name="definitionExpiryDate")
    """Get definitionExpiryDate."""
    first_historical_availability_date: Optional[datetime.date] = rest_field(name="firstHistoricalAvailabilityDate")
    """The date starting from which the definition of the curve can be used.  The value is expressed
     in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    id: Optional[str] = rest_field()
    """Id of the curve definition."""
    name: Optional[str] = rest_field()
    """The name of the commodity and energy curve."""
    product: Optional[Union[str, "_models.ProductEnum"]] = rest_field()
    """Commodities RCS product. Please note that not all products can be priced for now. Known values
     are: \"ABSPlastic\", \"AceticAcid\", \"Acetone\", \"AcrylateEsters\", \"AcrylicAcid\",
     \"Acrylonitrile\", \"AdipicAcid\", \"AlfalfaHay\", \"AlfalfaMeal\", \"AlfalfaPellets\",
     \"AlfalfaSeed\", \"Almonds\", \"AlphaMethylstyrene\", \"AluminaBauxite\", \"Aluminium\",
     \"AmmoniaWater25Percent\", \"AmmoniumNitrate\", \"AnhydrousAmmonia\", \"AnhydrousSulfate\",
     \"AnthraceneFraction\", \"Antimony\", \"Arabica\", \"Arsenic\", \"Asphalt\",
     \"AssignedAmountUnit\", \"AvocadoOil\", \"BarleyBran\", \"Baseload\", \"Beef\", \"Beer\",
     \"Beeswax\", \"Benzene\", \"BeverageWaste\", \"Biodiesel\", \"BirdSeed\", \"Bismuth\",
     \"BisphenolA\", \"BlackSeed\", \"Block\", \"BoneMeal\", \"Brass\", \"BrazilNuts\",
     \"BrentCrudes\", \"Bronze\", \"Buckwheat\", \"BunkerFuel\", \"BurningKerosene\", \"Butadiene\",
     \"ButadieneLatexes\", \"ButadieneNitrileRubbers\", \"ButadieneStyreneLatexes\",
     \"ButadieneStyreneRubbers\", \"Butane\", \"Butanediol\", \"Butter\", \"ButylAcetate\",
     \"ButylRubbers\", \"Cadmium\", \"CanarySeed\", \"Caprolactam\",
     \"CarbamideFormaldehydeResins\", \"Cashews\", \"Cassava\", \"CastorOil\", \"CausticSoda\",
     \"CellulosicBiofuels\", \"CertifiedEmissionReduction\", \"Cheese\", \"Chestnuts\",
     \"Chromite\", \"Chromium\", \"CitrusPulp\", \"Clothing\", \"CloudCover\", \"Cobalt\",
     \"Cocoa\", \"CoconutOil\", \"CokingCoal\", \"Cola\", \"CoolingDegreeDays\", \"Copper\",
     \"CopperConcentrates\", \"CopperOre\", \"Copra\", \"CopraPellets\", \"CornOil\", \"Cornflour\",
     \"Cosmetics\", \"Cotton\", \"CottonYarn\", \"Cottonseed\", \"CottonseedMeal\",
     \"CottonseedOil\", \"Cramp\", \"Cumene\", \"Cyclohexane\", \"Detergents\",
     \"DiammoniumPhosphate\", \"Diamond\", \"Diesel\", \"Diethanolamine\", \"DiethyleneGlycol\",
     \"DimethylTerephthalate\", \"Dioctylphthalate\", \"DistillersDriedGrainsWithSolubles\",
     \"DivinylRubbers\", \"Drugs\", \"DryBulkSingleVoyage\", \"DryBulkTimeCharter\",
     \"DualPurposeKerosene\", \"DubaiCrude\", \"Dyes\", \"EdibleBarley\", \"EdibleWheat\", \"Egg\",
     \"ElectricalWire\", \"EmissionReductionUnit\", \"EmulsionPVC\", \"Epichlorohydrin\",
     \"EpoxyResins\", \"EssentialOils\", \"Ethane\", \"Ethanol\", \"EthylTertiaryButylEther\",
     \"Ethylbenzene\", \"Ethylene\", \"EthyleneDichloride\", \"EthyleneOxide\",
     \"EthylenePropyleneRubbers\", \"EthyleneVinylAcetate\", \"Ethylhexanol\",
     \"EuropeanAviationAllowanc\", \"EuropeanUnitAllowance\", \"ExpandablePolystyrene\",
     \"FatProducts\", \"FattyAcid\", \"FattyAlcohols\", \"FeatherMeal\", \"FeedBarley\",
     \"FeedConcentrate\", \"FeedCorn\", \"FeedWheat\", \"Ferroalloy\", \"Ferrochrome\",
     \"FiberProducts\", \"Fish\", \"FishMeal\", \"FishOil\", \"Flax\", \"Flour\", \"FrogLegs\",
     \"Fruit\", \"FurSkins\", \"Gallium\", \"Gasoline\", \"GasolineComponents\", \"Gelatine\",
     \"GeneralPurposePolystyren\", \"Germanium\", \"GlutenFeedPellets\", \"GlutenMeal\",
     \"Glycerine\", \"GlycolEthers\", \"GoatMeat\", \"GoldBullion\", \"GoldCoins\", \"GoldIngots\",
     \"Greaves\", \"GreenBeans\", \"GrowingDegreeDays\", \"Gum\", \"Gunmetal\", \"HazelNuts\",
     \"HeatingDegreeDays\", \"HeatingOilGasOil\", \"HeavyPyrolysisResins\", \"Hemp\", \"Hexane\",
     \"HighDensityPolyethylene\", \"HighImpactPolystyrene\", \"HighSulphurFuelOil\", \"HominyFeed\",
     \"Honey\", \"Hops\", \"Horticulture\", \"HydrochloricAcid\", \"Indium\", \"Iridium\",
     \"IronOre\", \"IsoButanol\", \"IsoPropanol\", \"Isocyanates\", \"IsophthalicAcid\",
     \"IsopreneRubbers\", \"JetFuel\", \"Jute\", \"LambMutton\", \"LardTallow\", \"Lead\",
     \"LeadOre\", \"Leather\", \"LinearAlkylbenzene\", \"LinearAlkylbenzeneSulpho\",
     \"LinearLowDensityPolyeth\", \"Linen\", \"LinseedFlaxseed\", \"LinseedOil\",
     \"LiquefiedNaturalGas\", \"LiquidPyrolysisProducts\", \"LiveCattle\", \"LivePigHog\",
     \"LiveSheepLamb\", \"LowDensityPolyethylene\", \"LowSulphurFuelOil\",
     \"LowSulphurWaxyResidue\", \"LubricatingOils\", \"Magnesium\", \"MaleicAnhydride\", \"Malt\",
     \"MaltingBarley\", \"MaltingWheat\", \"Manganese\", \"ManganeseOre\", \"MeatExtracts\",
     \"MeatMeal\", \"Melamine\", \"Mercury\", \"Methanol\", \"MethylEthylKetone\",
     \"MethylIsobutylKetone\", \"MethylMethacrylate\", \"MethylTertiaryButylEther\",
     \"MethyleneChloride\", \"Milk\", \"MilletBran\", \"MixedXylenes\", \"Molasses\",
     \"Molybdenum\", \"MonoAmmoniumPhosphate\", \"Monoethanolamine\", \"MonoethyleneGlycol\",
     \"MonopropyleneGlycol\", \"Mustard\", \"NButanol\", \"Naphtha\", \"NaturalGasLiquids\",
     \"Nickel\", \"NickelOre\", \"NitrogenFertilizers\", \"NitrogenPhosphorusPotassium\",
     \"NitrousOxide\", \"NorthAmericanSpecialAluminiumAlloy\", \"Nylon\", \"OXylene\", \"OatBran\",
     \"OffPeak\", \"Offal\", \"OliveOil\", \"Olives\", \"OrangeJuice\", \"OtherBran\",
     \"OtherCrudes\", \"OtherLPG\", \"OtherMeat\", \"OtherNaturalGas\", \"OtherNuts\",
     \"OtherOilCrops\", \"OtherRootCrops\", \"OtherSeedCrops\", \"PXylene\", \"PalladiumBullion\",
     \"PalladiumCoins\", \"PalladiumIngots\", \"PalmFruitOilBleachedAndNeutralized\",
     \"PalmFruitOilCrude\", \"PalmFruitOilOleinRefinedBleachedAndDeodorized\",
     \"PalmFruitStearinRefinedBleachedAndDeodorized\", \"PalmKernelMeal\", \"PalmKernelOilCrude\",
     \"PalmKernelOilProcesse\", \"PalmKernelPellets\", \"PalmKernelStearin\", \"Paper\",
     \"ParaffinWax\", \"Pasta\", \"Peakload\", \"PeanutMeal\", \"PeanutOil\", \"Peanuts\", \"Peas\",
     \"PetFood\", \"PetroleumSolvents\", \"Phenol\", \"PhosphateRock\", \"PhosphoricAcid\",
     \"PhthalicAnhydride\", \"Pistachios\", \"PlatinumBullion\", \"PlatinumCoins\",
     \"PlatinumIngots\", \"Polyacetals\", \"PolybutyleneTerephthalate\", \"Polycarbonate\",
     \"Polyester\", \"PolyetherPolyols\", \"PolyethyleneTerephthalate\", \"PolymethylMethacrylate\",
     \"Polyols\", \"PolypropyleneBlockCopolymer\", \"PolypropyleneHomopolymer\",
     \"PolypropyleneRandomCopolymer\", \"Pork\", \"Potash\", \"Potatoes\", \"Poultry\", \"Propane\",
     \"Propylene\", \"PropyleneGlycolEthers\", \"PropyleneOxide\", \"Pulp\", \"Quinoa\",
     \"RabbitMeat\", \"Rapemeal\", \"RapeseedCanola\", \"RapeseedCanolaOil\", \"RedBeans\",
     \"RenewableEnergyCertificate\", \"RenewableObligationCertificate\", \"Rhodium\", \"Robusta\",
     \"RoughRice\", \"Rubber\", \"Ruthenium\", \"Rye\", \"SANPlastic\", \"Safflower\",
     \"SafflowerOil\", \"Salt\", \"ScrapAluminum\", \"ScrapCopper\", \"ScrapIron\", \"ScrapLead\",
     \"ScrapNickel\", \"ScrapTin\", \"ScrapZinc\", \"SeedCorn\", \"Selenium\", \"Sesame\",
     \"SheaButter\", \"SheaNuts\", \"Shellfish\", \"Shrimp\", \"Silicon\", \"Silk\",
     \"SilverBullion\", \"SilverCoins\", \"SilverIngots\", \"Sisal\", \"SoapNoodles\", \"SodaAsh\",
     \"Sorbitol\", \"SorghumMilo\", \"Soybean\", \"SoybeanMeal\", \"SoybeanOil\",
     \"SoybeanPellets\", \"SpicesHerbs\", \"StainlessSteel\", \"Steel\", \"StraightRunFuelOil\",
     \"Styrene\", \"SugarBeetPulp\", \"SugarCane\", \"SulfuricAcid\", \"Sulphur\",
     \"SulphurDioxide\", \"Sunflower\", \"SunflowerOil\", \"SunflowerSeedMeal\", \"SuspensionPVC\",
     \"SweetPotatoes\", \"SyntheticSweetCrude\", \"TallOil\", \"TankerCleanSingleVoyage\",
     \"TankerCleanTimeCharter\", \"TankerDirtySingleVoyage\", \"TankerDirtyTimeCharter\",
     \"Tantalite\", \"TapiocaMeal\", \"Tea\", \"TerephthalicAcid\", \"ThermalCoal\",
     \"TimberLumber\", \"Tin\", \"TinOre\", \"Titanium\", \"TitaniumDioxide\", \"Tobacco\",
     \"Toluene\", \"Triethanolamine\", \"TriethyleneGlycol\", \"TripleSimplePhosphate\",
     \"Triticale\", \"TungOil\", \"Tungstate\", \"Tungsten\", \"USLightSweetCrudes\", \"Uranium\",
     \"Urea\", \"UreaAmmoniumNitrate\", \"Vanadium\", \"Veal\", \"VegetableOil\", \"VinylAcetate\",
     \"VinylChlorideMonomer\", \"VoluntaryCarbonUnit\", \"VoluntaryEmissionReduction\", \"Walnuts\",
     \"WheatBran\", \"WheatFlour\", \"WheatStarch\", \"Whey\", \"WhiteCertificate\",
     \"WhiteSpirit\", \"Wine\", \"Wolframite\", \"WoodProducts\", \"WoodyBiomass\", \"Wool\",
     \"Yoghurt\", \"Zinc\", and \"ZincOre\"."""
    sector: Optional[Union[str, "_models.SectorEnum"]] = rest_field()
    """Commodities RCS sector. Please note that not all products can be priced for now. Known values
     are: \"Agriculture\", \"Energy\", \"Metals\", \"Other\", \"Transportation\", and \"Weather\"."""
    source: Optional[str] = rest_field()
    """Get source."""
    sub_sector: Optional[Union[str, "_models.SubSectorEnum"]] = rest_field(name="subSector")
    """Commodities RCS sub-sector. Please note that not all products can be priced for now. Known
     values are: \"BaseMetalsOres\", \"Biofuels\", \"Chemicals\", \"Cloud\", \"Coal\", \"Dairy\",
     \"DryBulkFreight\", \"Emissions\", \"Fertilizer\", \"ForestryFibre\", \"GasProducts\",
     \"Grains\", \"IronSteel\", \"Livestock\", \"MealsFeedsPulses\", \"MinorMetalsMinerals\",
     \"MiscellaneousAgriculture\", \"OilProducts\", \"Oilseeds\", \"Petrochemicals\", \"Power\",
     \"PreciousMetalsMinerals\", \"RenewableEnergy\", \"ScrapSecondaryAlloys\", \"Softs\",
     \"TankerFreight\", and \"Temperature\"."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The name of underlying defining the commodity and energy curve."""

    @overload
    def __init__(
        self,
        *,
        currency: Optional[str] = None,
        definition_expiry_date: Optional[datetime.date] = None,
        first_historical_availability_date: Optional[datetime.date] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        product: Optional[Union[str, "_models.ProductEnum"]] = None,
        sector: Optional[Union[str, "_models.SectorEnum"]] = None,
        source: Optional[str] = None,
        sub_sector: Optional[Union[str, "_models.SubSectorEnum"]] = None,
        underlying_code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveDefinitionBase(_model_base.Model):
    """CommoditiesCurveDefinitionBase.

    Attributes
    ----------
    name : str
        The name of the commodity and energy curve.
    product : str or ~analyticsapi.models.ProductEnum
        Commodities RCS product. Please note that not all products can be
        priced for now. Known values are: "ABSPlastic", "AceticAcid",
        "Acetone", "AcrylateEsters", "AcrylicAcid", "Acrylonitrile",
        "AdipicAcid", "AlfalfaHay", "AlfalfaMeal", "AlfalfaPellets",
        "AlfalfaSeed", "Almonds", "AlphaMethylstyrene", "AluminaBauxite",
        "Aluminium", "AmmoniaWater25Percent", "AmmoniumNitrate",
        "AnhydrousAmmonia", "AnhydrousSulfate", "AnthraceneFraction",
        "Antimony", "Arabica", "Arsenic", "Asphalt", "AssignedAmountUnit",
        "AvocadoOil", "BarleyBran", "Baseload", "Beef", "Beer", "Beeswax",
        "Benzene", "BeverageWaste", "Biodiesel", "BirdSeed", "Bismuth",
        "BisphenolA", "BlackSeed", "Block", "BoneMeal", "Brass", "BrazilNuts",
        "BrentCrudes", "Bronze", "Buckwheat", "BunkerFuel", "BurningKerosene",
        "Butadiene", "ButadieneLatexes", "ButadieneNitrileRubbers",
        "ButadieneStyreneLatexes", "ButadieneStyreneRubbers", "Butane",
        "Butanediol", "Butter", "ButylAcetate", "ButylRubbers", "Cadmium",
        "CanarySeed", "Caprolactam", "CarbamideFormaldehydeResins", "Cashews",
        "Cassava", "CastorOil", "CausticSoda", "CellulosicBiofuels",
        "CertifiedEmissionReduction", "Cheese", "Chestnuts", "Chromite",
        "Chromium", "CitrusPulp", "Clothing", "CloudCover", "Cobalt", "Cocoa",
        "CoconutOil", "CokingCoal", "Cola", "CoolingDegreeDays", "Copper",
        "CopperConcentrates", "CopperOre", "Copra", "CopraPellets", "CornOil",
        "Cornflour", "Cosmetics", "Cotton", "CottonYarn", "Cottonseed",
        "CottonseedMeal", "CottonseedOil", "Cramp", "Cumene", "Cyclohexane",
        "Detergents", "DiammoniumPhosphate", "Diamond", "Diesel",
        "Diethanolamine", "DiethyleneGlycol", "DimethylTerephthalate",
        "Dioctylphthalate", "DistillersDriedGrainsWithSolubles",
        "DivinylRubbers", "Drugs", "DryBulkSingleVoyage", "DryBulkTimeCharter",
        "DualPurposeKerosene", "DubaiCrude", "Dyes", "EdibleBarley",
        "EdibleWheat", "Egg", "ElectricalWire", "EmissionReductionUnit",
        "EmulsionPVC", "Epichlorohydrin", "EpoxyResins", "EssentialOils",
        "Ethane", "Ethanol", "EthylTertiaryButylEther", "Ethylbenzene",
        "Ethylene", "EthyleneDichloride", "EthyleneOxide",
        "EthylenePropyleneRubbers", "EthyleneVinylAcetate", "Ethylhexanol",
        "EuropeanAviationAllowanc", "EuropeanUnitAllowance",
        "ExpandablePolystyrene", "FatProducts", "FattyAcid", "FattyAlcohols",
        "FeatherMeal", "FeedBarley", "FeedConcentrate", "FeedCorn",
        "FeedWheat", "Ferroalloy", "Ferrochrome", "FiberProducts", "Fish",
        "FishMeal", "FishOil", "Flax", "Flour", "FrogLegs", "Fruit",
        "FurSkins", "Gallium", "Gasoline", "GasolineComponents", "Gelatine",
        "GeneralPurposePolystyren", "Germanium", "GlutenFeedPellets",
        "GlutenMeal", "Glycerine", "GlycolEthers", "GoatMeat", "GoldBullion",
        "GoldCoins", "GoldIngots", "Greaves", "GreenBeans",
        "GrowingDegreeDays", "Gum", "Gunmetal", "HazelNuts",
        "HeatingDegreeDays", "HeatingOilGasOil", "HeavyPyrolysisResins",
        "Hemp", "Hexane", "HighDensityPolyethylene", "HighImpactPolystyrene",
        "HighSulphurFuelOil", "HominyFeed", "Honey", "Hops", "Horticulture",
        "HydrochloricAcid", "Indium", "Iridium", "IronOre", "IsoButanol",
        "IsoPropanol", "Isocyanates", "IsophthalicAcid", "IsopreneRubbers",
        "JetFuel", "Jute", "LambMutton", "LardTallow", "Lead", "LeadOre",
        "Leather", "LinearAlkylbenzene", "LinearAlkylbenzeneSulpho",
        "LinearLowDensityPolyeth", "Linen", "LinseedFlaxseed", "LinseedOil",
        "LiquefiedNaturalGas", "LiquidPyrolysisProducts", "LiveCattle",
        "LivePigHog", "LiveSheepLamb", "LowDensityPolyethylene",
        "LowSulphurFuelOil", "LowSulphurWaxyResidue", "LubricatingOils",
        "Magnesium", "MaleicAnhydride", "Malt", "MaltingBarley",
        "MaltingWheat", "Manganese", "ManganeseOre", "MeatExtracts",
        "MeatMeal", "Melamine", "Mercury", "Methanol", "MethylEthylKetone",
        "MethylIsobutylKetone", "MethylMethacrylate",
        "MethylTertiaryButylEther", "MethyleneChloride", "Milk", "MilletBran",
        "MixedXylenes", "Molasses", "Molybdenum", "MonoAmmoniumPhosphate",
        "Monoethanolamine", "MonoethyleneGlycol", "MonopropyleneGlycol",
        "Mustard", "NButanol", "Naphtha", "NaturalGasLiquids", "Nickel",
        "NickelOre", "NitrogenFertilizers", "NitrogenPhosphorusPotassium",
        "NitrousOxide", "NorthAmericanSpecialAluminiumAlloy", "Nylon",
        "OXylene", "OatBran", "OffPeak", "Offal", "OliveOil", "Olives",
        "OrangeJuice", "OtherBran", "OtherCrudes", "OtherLPG", "OtherMeat",
        "OtherNaturalGas", "OtherNuts", "OtherOilCrops", "OtherRootCrops",
        "OtherSeedCrops", "PXylene", "PalladiumBullion", "PalladiumCoins",
        "PalladiumIngots", "PalmFruitOilBleachedAndNeutralized",
        "PalmFruitOilCrude", "PalmFruitOilOleinRefinedBleachedAndDeodorized",
        "PalmFruitStearinRefinedBleachedAndDeodorized", "PalmKernelMeal",
        "PalmKernelOilCrude", "PalmKernelOilProcesse", "PalmKernelPellets",
        "PalmKernelStearin", "Paper", "ParaffinWax", "Pasta", "Peakload",
        "PeanutMeal", "PeanutOil", "Peanuts", "Peas", "PetFood",
        "PetroleumSolvents", "Phenol", "PhosphateRock", "PhosphoricAcid",
        "PhthalicAnhydride", "Pistachios", "PlatinumBullion", "PlatinumCoins",
        "PlatinumIngots", "Polyacetals", "PolybutyleneTerephthalate",
        "Polycarbonate", "Polyester", "PolyetherPolyols",
        "PolyethyleneTerephthalate", "PolymethylMethacrylate", "Polyols",
        "PolypropyleneBlockCopolymer", "PolypropyleneHomopolymer",
        "PolypropyleneRandomCopolymer", "Pork", "Potash", "Potatoes",
        "Poultry", "Propane", "Propylene", "PropyleneGlycolEthers",
        "PropyleneOxide", "Pulp", "Quinoa", "RabbitMeat", "Rapemeal",
        "RapeseedCanola", "RapeseedCanolaOil", "RedBeans",
        "RenewableEnergyCertificate", "RenewableObligationCertificate",
        "Rhodium", "Robusta", "RoughRice", "Rubber", "Ruthenium", "Rye",
        "SANPlastic", "Safflower", "SafflowerOil", "Salt", "ScrapAluminum",
        "ScrapCopper", "ScrapIron", "ScrapLead", "ScrapNickel", "ScrapTin",
        "ScrapZinc", "SeedCorn", "Selenium", "Sesame", "SheaButter",
        "SheaNuts", "Shellfish", "Shrimp", "Silicon", "Silk", "SilverBullion",
        "SilverCoins", "SilverIngots", "Sisal", "SoapNoodles", "SodaAsh",
        "Sorbitol", "SorghumMilo", "Soybean", "SoybeanMeal", "SoybeanOil",
        "SoybeanPellets", "SpicesHerbs", "StainlessSteel", "Steel",
        "StraightRunFuelOil", "Styrene", "SugarBeetPulp", "SugarCane",
        "SulfuricAcid", "Sulphur", "SulphurDioxide", "Sunflower",
        "SunflowerOil", "SunflowerSeedMeal", "SuspensionPVC", "SweetPotatoes",
        "SyntheticSweetCrude", "TallOil", "TankerCleanSingleVoyage",
        "TankerCleanTimeCharter", "TankerDirtySingleVoyage",
        "TankerDirtyTimeCharter", "Tantalite", "TapiocaMeal", "Tea",
        "TerephthalicAcid", "ThermalCoal", "TimberLumber", "Tin", "TinOre",
        "Titanium", "TitaniumDioxide", "Tobacco", "Toluene", "Triethanolamine",
        "TriethyleneGlycol", "TripleSimplePhosphate", "Triticale", "TungOil",
        "Tungstate", "Tungsten", "USLightSweetCrudes", "Uranium", "Urea",
        "UreaAmmoniumNitrate", "Vanadium", "Veal", "VegetableOil",
        "VinylAcetate", "VinylChlorideMonomer", "VoluntaryCarbonUnit",
        "VoluntaryEmissionReduction", "Walnuts", "WheatBran", "WheatFlour",
        "WheatStarch", "Whey", "WhiteCertificate", "WhiteSpirit", "Wine",
        "Wolframite", "WoodProducts", "WoodyBiomass", "Wool", "Yoghurt",
        "Zinc", and "ZincOre".
    source : str
        Get source.
    underlying_code : str
        The name of underlying defining the commodity and energy curve.
    """

    name: Optional[str] = rest_field()
    """The name of the commodity and energy curve."""
    product: Optional[Union[str, "_models.ProductEnum"]] = rest_field()
    """Commodities RCS product. Please note that not all products can be priced for now. Known values
     are: \"ABSPlastic\", \"AceticAcid\", \"Acetone\", \"AcrylateEsters\", \"AcrylicAcid\",
     \"Acrylonitrile\", \"AdipicAcid\", \"AlfalfaHay\", \"AlfalfaMeal\", \"AlfalfaPellets\",
     \"AlfalfaSeed\", \"Almonds\", \"AlphaMethylstyrene\", \"AluminaBauxite\", \"Aluminium\",
     \"AmmoniaWater25Percent\", \"AmmoniumNitrate\", \"AnhydrousAmmonia\", \"AnhydrousSulfate\",
     \"AnthraceneFraction\", \"Antimony\", \"Arabica\", \"Arsenic\", \"Asphalt\",
     \"AssignedAmountUnit\", \"AvocadoOil\", \"BarleyBran\", \"Baseload\", \"Beef\", \"Beer\",
     \"Beeswax\", \"Benzene\", \"BeverageWaste\", \"Biodiesel\", \"BirdSeed\", \"Bismuth\",
     \"BisphenolA\", \"BlackSeed\", \"Block\", \"BoneMeal\", \"Brass\", \"BrazilNuts\",
     \"BrentCrudes\", \"Bronze\", \"Buckwheat\", \"BunkerFuel\", \"BurningKerosene\", \"Butadiene\",
     \"ButadieneLatexes\", \"ButadieneNitrileRubbers\", \"ButadieneStyreneLatexes\",
     \"ButadieneStyreneRubbers\", \"Butane\", \"Butanediol\", \"Butter\", \"ButylAcetate\",
     \"ButylRubbers\", \"Cadmium\", \"CanarySeed\", \"Caprolactam\",
     \"CarbamideFormaldehydeResins\", \"Cashews\", \"Cassava\", \"CastorOil\", \"CausticSoda\",
     \"CellulosicBiofuels\", \"CertifiedEmissionReduction\", \"Cheese\", \"Chestnuts\",
     \"Chromite\", \"Chromium\", \"CitrusPulp\", \"Clothing\", \"CloudCover\", \"Cobalt\",
     \"Cocoa\", \"CoconutOil\", \"CokingCoal\", \"Cola\", \"CoolingDegreeDays\", \"Copper\",
     \"CopperConcentrates\", \"CopperOre\", \"Copra\", \"CopraPellets\", \"CornOil\", \"Cornflour\",
     \"Cosmetics\", \"Cotton\", \"CottonYarn\", \"Cottonseed\", \"CottonseedMeal\",
     \"CottonseedOil\", \"Cramp\", \"Cumene\", \"Cyclohexane\", \"Detergents\",
     \"DiammoniumPhosphate\", \"Diamond\", \"Diesel\", \"Diethanolamine\", \"DiethyleneGlycol\",
     \"DimethylTerephthalate\", \"Dioctylphthalate\", \"DistillersDriedGrainsWithSolubles\",
     \"DivinylRubbers\", \"Drugs\", \"DryBulkSingleVoyage\", \"DryBulkTimeCharter\",
     \"DualPurposeKerosene\", \"DubaiCrude\", \"Dyes\", \"EdibleBarley\", \"EdibleWheat\", \"Egg\",
     \"ElectricalWire\", \"EmissionReductionUnit\", \"EmulsionPVC\", \"Epichlorohydrin\",
     \"EpoxyResins\", \"EssentialOils\", \"Ethane\", \"Ethanol\", \"EthylTertiaryButylEther\",
     \"Ethylbenzene\", \"Ethylene\", \"EthyleneDichloride\", \"EthyleneOxide\",
     \"EthylenePropyleneRubbers\", \"EthyleneVinylAcetate\", \"Ethylhexanol\",
     \"EuropeanAviationAllowanc\", \"EuropeanUnitAllowance\", \"ExpandablePolystyrene\",
     \"FatProducts\", \"FattyAcid\", \"FattyAlcohols\", \"FeatherMeal\", \"FeedBarley\",
     \"FeedConcentrate\", \"FeedCorn\", \"FeedWheat\", \"Ferroalloy\", \"Ferrochrome\",
     \"FiberProducts\", \"Fish\", \"FishMeal\", \"FishOil\", \"Flax\", \"Flour\", \"FrogLegs\",
     \"Fruit\", \"FurSkins\", \"Gallium\", \"Gasoline\", \"GasolineComponents\", \"Gelatine\",
     \"GeneralPurposePolystyren\", \"Germanium\", \"GlutenFeedPellets\", \"GlutenMeal\",
     \"Glycerine\", \"GlycolEthers\", \"GoatMeat\", \"GoldBullion\", \"GoldCoins\", \"GoldIngots\",
     \"Greaves\", \"GreenBeans\", \"GrowingDegreeDays\", \"Gum\", \"Gunmetal\", \"HazelNuts\",
     \"HeatingDegreeDays\", \"HeatingOilGasOil\", \"HeavyPyrolysisResins\", \"Hemp\", \"Hexane\",
     \"HighDensityPolyethylene\", \"HighImpactPolystyrene\", \"HighSulphurFuelOil\", \"HominyFeed\",
     \"Honey\", \"Hops\", \"Horticulture\", \"HydrochloricAcid\", \"Indium\", \"Iridium\",
     \"IronOre\", \"IsoButanol\", \"IsoPropanol\", \"Isocyanates\", \"IsophthalicAcid\",
     \"IsopreneRubbers\", \"JetFuel\", \"Jute\", \"LambMutton\", \"LardTallow\", \"Lead\",
     \"LeadOre\", \"Leather\", \"LinearAlkylbenzene\", \"LinearAlkylbenzeneSulpho\",
     \"LinearLowDensityPolyeth\", \"Linen\", \"LinseedFlaxseed\", \"LinseedOil\",
     \"LiquefiedNaturalGas\", \"LiquidPyrolysisProducts\", \"LiveCattle\", \"LivePigHog\",
     \"LiveSheepLamb\", \"LowDensityPolyethylene\", \"LowSulphurFuelOil\",
     \"LowSulphurWaxyResidue\", \"LubricatingOils\", \"Magnesium\", \"MaleicAnhydride\", \"Malt\",
     \"MaltingBarley\", \"MaltingWheat\", \"Manganese\", \"ManganeseOre\", \"MeatExtracts\",
     \"MeatMeal\", \"Melamine\", \"Mercury\", \"Methanol\", \"MethylEthylKetone\",
     \"MethylIsobutylKetone\", \"MethylMethacrylate\", \"MethylTertiaryButylEther\",
     \"MethyleneChloride\", \"Milk\", \"MilletBran\", \"MixedXylenes\", \"Molasses\",
     \"Molybdenum\", \"MonoAmmoniumPhosphate\", \"Monoethanolamine\", \"MonoethyleneGlycol\",
     \"MonopropyleneGlycol\", \"Mustard\", \"NButanol\", \"Naphtha\", \"NaturalGasLiquids\",
     \"Nickel\", \"NickelOre\", \"NitrogenFertilizers\", \"NitrogenPhosphorusPotassium\",
     \"NitrousOxide\", \"NorthAmericanSpecialAluminiumAlloy\", \"Nylon\", \"OXylene\", \"OatBran\",
     \"OffPeak\", \"Offal\", \"OliveOil\", \"Olives\", \"OrangeJuice\", \"OtherBran\",
     \"OtherCrudes\", \"OtherLPG\", \"OtherMeat\", \"OtherNaturalGas\", \"OtherNuts\",
     \"OtherOilCrops\", \"OtherRootCrops\", \"OtherSeedCrops\", \"PXylene\", \"PalladiumBullion\",
     \"PalladiumCoins\", \"PalladiumIngots\", \"PalmFruitOilBleachedAndNeutralized\",
     \"PalmFruitOilCrude\", \"PalmFruitOilOleinRefinedBleachedAndDeodorized\",
     \"PalmFruitStearinRefinedBleachedAndDeodorized\", \"PalmKernelMeal\", \"PalmKernelOilCrude\",
     \"PalmKernelOilProcesse\", \"PalmKernelPellets\", \"PalmKernelStearin\", \"Paper\",
     \"ParaffinWax\", \"Pasta\", \"Peakload\", \"PeanutMeal\", \"PeanutOil\", \"Peanuts\", \"Peas\",
     \"PetFood\", \"PetroleumSolvents\", \"Phenol\", \"PhosphateRock\", \"PhosphoricAcid\",
     \"PhthalicAnhydride\", \"Pistachios\", \"PlatinumBullion\", \"PlatinumCoins\",
     \"PlatinumIngots\", \"Polyacetals\", \"PolybutyleneTerephthalate\", \"Polycarbonate\",
     \"Polyester\", \"PolyetherPolyols\", \"PolyethyleneTerephthalate\", \"PolymethylMethacrylate\",
     \"Polyols\", \"PolypropyleneBlockCopolymer\", \"PolypropyleneHomopolymer\",
     \"PolypropyleneRandomCopolymer\", \"Pork\", \"Potash\", \"Potatoes\", \"Poultry\", \"Propane\",
     \"Propylene\", \"PropyleneGlycolEthers\", \"PropyleneOxide\", \"Pulp\", \"Quinoa\",
     \"RabbitMeat\", \"Rapemeal\", \"RapeseedCanola\", \"RapeseedCanolaOil\", \"RedBeans\",
     \"RenewableEnergyCertificate\", \"RenewableObligationCertificate\", \"Rhodium\", \"Robusta\",
     \"RoughRice\", \"Rubber\", \"Ruthenium\", \"Rye\", \"SANPlastic\", \"Safflower\",
     \"SafflowerOil\", \"Salt\", \"ScrapAluminum\", \"ScrapCopper\", \"ScrapIron\", \"ScrapLead\",
     \"ScrapNickel\", \"ScrapTin\", \"ScrapZinc\", \"SeedCorn\", \"Selenium\", \"Sesame\",
     \"SheaButter\", \"SheaNuts\", \"Shellfish\", \"Shrimp\", \"Silicon\", \"Silk\",
     \"SilverBullion\", \"SilverCoins\", \"SilverIngots\", \"Sisal\", \"SoapNoodles\", \"SodaAsh\",
     \"Sorbitol\", \"SorghumMilo\", \"Soybean\", \"SoybeanMeal\", \"SoybeanOil\",
     \"SoybeanPellets\", \"SpicesHerbs\", \"StainlessSteel\", \"Steel\", \"StraightRunFuelOil\",
     \"Styrene\", \"SugarBeetPulp\", \"SugarCane\", \"SulfuricAcid\", \"Sulphur\",
     \"SulphurDioxide\", \"Sunflower\", \"SunflowerOil\", \"SunflowerSeedMeal\", \"SuspensionPVC\",
     \"SweetPotatoes\", \"SyntheticSweetCrude\", \"TallOil\", \"TankerCleanSingleVoyage\",
     \"TankerCleanTimeCharter\", \"TankerDirtySingleVoyage\", \"TankerDirtyTimeCharter\",
     \"Tantalite\", \"TapiocaMeal\", \"Tea\", \"TerephthalicAcid\", \"ThermalCoal\",
     \"TimberLumber\", \"Tin\", \"TinOre\", \"Titanium\", \"TitaniumDioxide\", \"Tobacco\",
     \"Toluene\", \"Triethanolamine\", \"TriethyleneGlycol\", \"TripleSimplePhosphate\",
     \"Triticale\", \"TungOil\", \"Tungstate\", \"Tungsten\", \"USLightSweetCrudes\", \"Uranium\",
     \"Urea\", \"UreaAmmoniumNitrate\", \"Vanadium\", \"Veal\", \"VegetableOil\", \"VinylAcetate\",
     \"VinylChlorideMonomer\", \"VoluntaryCarbonUnit\", \"VoluntaryEmissionReduction\", \"Walnuts\",
     \"WheatBran\", \"WheatFlour\", \"WheatStarch\", \"Whey\", \"WhiteCertificate\",
     \"WhiteSpirit\", \"Wine\", \"Wolframite\", \"WoodProducts\", \"WoodyBiomass\", \"Wool\",
     \"Yoghurt\", \"Zinc\", and \"ZincOre\"."""
    source: Optional[str] = rest_field()
    """Get source."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The name of underlying defining the commodity and energy curve."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        product: Optional[Union[str, "_models.ProductEnum"]] = None,
        source: Optional[str] = None,
        underlying_code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveDefinitionDescription(_model_base.Model):
    """CommoditiesCurveDefinitionDescription.

    Attributes
    ----------
    definition_expiry_date : ~datetime.date
        Get definitionExpiryDate.
    name : str
        The name of the commodity and energy curve.
    product : str or ~analyticsapi.models.ProductEnum
        Commodities RCS product. Please note that not all products can be
        priced for now. Known values are: "ABSPlastic", "AceticAcid",
        "Acetone", "AcrylateEsters", "AcrylicAcid", "Acrylonitrile",
        "AdipicAcid", "AlfalfaHay", "AlfalfaMeal", "AlfalfaPellets",
        "AlfalfaSeed", "Almonds", "AlphaMethylstyrene", "AluminaBauxite",
        "Aluminium", "AmmoniaWater25Percent", "AmmoniumNitrate",
        "AnhydrousAmmonia", "AnhydrousSulfate", "AnthraceneFraction",
        "Antimony", "Arabica", "Arsenic", "Asphalt", "AssignedAmountUnit",
        "AvocadoOil", "BarleyBran", "Baseload", "Beef", "Beer", "Beeswax",
        "Benzene", "BeverageWaste", "Biodiesel", "BirdSeed", "Bismuth",
        "BisphenolA", "BlackSeed", "Block", "BoneMeal", "Brass", "BrazilNuts",
        "BrentCrudes", "Bronze", "Buckwheat", "BunkerFuel", "BurningKerosene",
        "Butadiene", "ButadieneLatexes", "ButadieneNitrileRubbers",
        "ButadieneStyreneLatexes", "ButadieneStyreneRubbers", "Butane",
        "Butanediol", "Butter", "ButylAcetate", "ButylRubbers", "Cadmium",
        "CanarySeed", "Caprolactam", "CarbamideFormaldehydeResins", "Cashews",
        "Cassava", "CastorOil", "CausticSoda", "CellulosicBiofuels",
        "CertifiedEmissionReduction", "Cheese", "Chestnuts", "Chromite",
        "Chromium", "CitrusPulp", "Clothing", "CloudCover", "Cobalt", "Cocoa",
        "CoconutOil", "CokingCoal", "Cola", "CoolingDegreeDays", "Copper",
        "CopperConcentrates", "CopperOre", "Copra", "CopraPellets", "CornOil",
        "Cornflour", "Cosmetics", "Cotton", "CottonYarn", "Cottonseed",
        "CottonseedMeal", "CottonseedOil", "Cramp", "Cumene", "Cyclohexane",
        "Detergents", "DiammoniumPhosphate", "Diamond", "Diesel",
        "Diethanolamine", "DiethyleneGlycol", "DimethylTerephthalate",
        "Dioctylphthalate", "DistillersDriedGrainsWithSolubles",
        "DivinylRubbers", "Drugs", "DryBulkSingleVoyage", "DryBulkTimeCharter",
        "DualPurposeKerosene", "DubaiCrude", "Dyes", "EdibleBarley",
        "EdibleWheat", "Egg", "ElectricalWire", "EmissionReductionUnit",
        "EmulsionPVC", "Epichlorohydrin", "EpoxyResins", "EssentialOils",
        "Ethane", "Ethanol", "EthylTertiaryButylEther", "Ethylbenzene",
        "Ethylene", "EthyleneDichloride", "EthyleneOxide",
        "EthylenePropyleneRubbers", "EthyleneVinylAcetate", "Ethylhexanol",
        "EuropeanAviationAllowanc", "EuropeanUnitAllowance",
        "ExpandablePolystyrene", "FatProducts", "FattyAcid", "FattyAlcohols",
        "FeatherMeal", "FeedBarley", "FeedConcentrate", "FeedCorn",
        "FeedWheat", "Ferroalloy", "Ferrochrome", "FiberProducts", "Fish",
        "FishMeal", "FishOil", "Flax", "Flour", "FrogLegs", "Fruit",
        "FurSkins", "Gallium", "Gasoline", "GasolineComponents", "Gelatine",
        "GeneralPurposePolystyren", "Germanium", "GlutenFeedPellets",
        "GlutenMeal", "Glycerine", "GlycolEthers", "GoatMeat", "GoldBullion",
        "GoldCoins", "GoldIngots", "Greaves", "GreenBeans",
        "GrowingDegreeDays", "Gum", "Gunmetal", "HazelNuts",
        "HeatingDegreeDays", "HeatingOilGasOil", "HeavyPyrolysisResins",
        "Hemp", "Hexane", "HighDensityPolyethylene", "HighImpactPolystyrene",
        "HighSulphurFuelOil", "HominyFeed", "Honey", "Hops", "Horticulture",
        "HydrochloricAcid", "Indium", "Iridium", "IronOre", "IsoButanol",
        "IsoPropanol", "Isocyanates", "IsophthalicAcid", "IsopreneRubbers",
        "JetFuel", "Jute", "LambMutton", "LardTallow", "Lead", "LeadOre",
        "Leather", "LinearAlkylbenzene", "LinearAlkylbenzeneSulpho",
        "LinearLowDensityPolyeth", "Linen", "LinseedFlaxseed", "LinseedOil",
        "LiquefiedNaturalGas", "LiquidPyrolysisProducts", "LiveCattle",
        "LivePigHog", "LiveSheepLamb", "LowDensityPolyethylene",
        "LowSulphurFuelOil", "LowSulphurWaxyResidue", "LubricatingOils",
        "Magnesium", "MaleicAnhydride", "Malt", "MaltingBarley",
        "MaltingWheat", "Manganese", "ManganeseOre", "MeatExtracts",
        "MeatMeal", "Melamine", "Mercury", "Methanol", "MethylEthylKetone",
        "MethylIsobutylKetone", "MethylMethacrylate",
        "MethylTertiaryButylEther", "MethyleneChloride", "Milk", "MilletBran",
        "MixedXylenes", "Molasses", "Molybdenum", "MonoAmmoniumPhosphate",
        "Monoethanolamine", "MonoethyleneGlycol", "MonopropyleneGlycol",
        "Mustard", "NButanol", "Naphtha", "NaturalGasLiquids", "Nickel",
        "NickelOre", "NitrogenFertilizers", "NitrogenPhosphorusPotassium",
        "NitrousOxide", "NorthAmericanSpecialAluminiumAlloy", "Nylon",
        "OXylene", "OatBran", "OffPeak", "Offal", "OliveOil", "Olives",
        "OrangeJuice", "OtherBran", "OtherCrudes", "OtherLPG", "OtherMeat",
        "OtherNaturalGas", "OtherNuts", "OtherOilCrops", "OtherRootCrops",
        "OtherSeedCrops", "PXylene", "PalladiumBullion", "PalladiumCoins",
        "PalladiumIngots", "PalmFruitOilBleachedAndNeutralized",
        "PalmFruitOilCrude", "PalmFruitOilOleinRefinedBleachedAndDeodorized",
        "PalmFruitStearinRefinedBleachedAndDeodorized", "PalmKernelMeal",
        "PalmKernelOilCrude", "PalmKernelOilProcesse", "PalmKernelPellets",
        "PalmKernelStearin", "Paper", "ParaffinWax", "Pasta", "Peakload",
        "PeanutMeal", "PeanutOil", "Peanuts", "Peas", "PetFood",
        "PetroleumSolvents", "Phenol", "PhosphateRock", "PhosphoricAcid",
        "PhthalicAnhydride", "Pistachios", "PlatinumBullion", "PlatinumCoins",
        "PlatinumIngots", "Polyacetals", "PolybutyleneTerephthalate",
        "Polycarbonate", "Polyester", "PolyetherPolyols",
        "PolyethyleneTerephthalate", "PolymethylMethacrylate", "Polyols",
        "PolypropyleneBlockCopolymer", "PolypropyleneHomopolymer",
        "PolypropyleneRandomCopolymer", "Pork", "Potash", "Potatoes",
        "Poultry", "Propane", "Propylene", "PropyleneGlycolEthers",
        "PropyleneOxide", "Pulp", "Quinoa", "RabbitMeat", "Rapemeal",
        "RapeseedCanola", "RapeseedCanolaOil", "RedBeans",
        "RenewableEnergyCertificate", "RenewableObligationCertificate",
        "Rhodium", "Robusta", "RoughRice", "Rubber", "Ruthenium", "Rye",
        "SANPlastic", "Safflower", "SafflowerOil", "Salt", "ScrapAluminum",
        "ScrapCopper", "ScrapIron", "ScrapLead", "ScrapNickel", "ScrapTin",
        "ScrapZinc", "SeedCorn", "Selenium", "Sesame", "SheaButter",
        "SheaNuts", "Shellfish", "Shrimp", "Silicon", "Silk", "SilverBullion",
        "SilverCoins", "SilverIngots", "Sisal", "SoapNoodles", "SodaAsh",
        "Sorbitol", "SorghumMilo", "Soybean", "SoybeanMeal", "SoybeanOil",
        "SoybeanPellets", "SpicesHerbs", "StainlessSteel", "Steel",
        "StraightRunFuelOil", "Styrene", "SugarBeetPulp", "SugarCane",
        "SulfuricAcid", "Sulphur", "SulphurDioxide", "Sunflower",
        "SunflowerOil", "SunflowerSeedMeal", "SuspensionPVC", "SweetPotatoes",
        "SyntheticSweetCrude", "TallOil", "TankerCleanSingleVoyage",
        "TankerCleanTimeCharter", "TankerDirtySingleVoyage",
        "TankerDirtyTimeCharter", "Tantalite", "TapiocaMeal", "Tea",
        "TerephthalicAcid", "ThermalCoal", "TimberLumber", "Tin", "TinOre",
        "Titanium", "TitaniumDioxide", "Tobacco", "Toluene", "Triethanolamine",
        "TriethyleneGlycol", "TripleSimplePhosphate", "Triticale", "TungOil",
        "Tungstate", "Tungsten", "USLightSweetCrudes", "Uranium", "Urea",
        "UreaAmmoniumNitrate", "Vanadium", "Veal", "VegetableOil",
        "VinylAcetate", "VinylChlorideMonomer", "VoluntaryCarbonUnit",
        "VoluntaryEmissionReduction", "Walnuts", "WheatBran", "WheatFlour",
        "WheatStarch", "Whey", "WhiteCertificate", "WhiteSpirit", "Wine",
        "Wolframite", "WoodProducts", "WoodyBiomass", "Wool", "Yoghurt",
        "Zinc", and "ZincOre".
    source : str
        Get source.
    underlying_code : str
        The name of underlying defining the commodity and energy curve.
    """

    definition_expiry_date: Optional[datetime.date] = rest_field(name="definitionExpiryDate")
    """Get definitionExpiryDate."""
    name: Optional[str] = rest_field()
    """The name of the commodity and energy curve."""
    product: Optional[Union[str, "_models.ProductEnum"]] = rest_field()
    """Commodities RCS product. Please note that not all products can be priced for now. Known values
     are: \"ABSPlastic\", \"AceticAcid\", \"Acetone\", \"AcrylateEsters\", \"AcrylicAcid\",
     \"Acrylonitrile\", \"AdipicAcid\", \"AlfalfaHay\", \"AlfalfaMeal\", \"AlfalfaPellets\",
     \"AlfalfaSeed\", \"Almonds\", \"AlphaMethylstyrene\", \"AluminaBauxite\", \"Aluminium\",
     \"AmmoniaWater25Percent\", \"AmmoniumNitrate\", \"AnhydrousAmmonia\", \"AnhydrousSulfate\",
     \"AnthraceneFraction\", \"Antimony\", \"Arabica\", \"Arsenic\", \"Asphalt\",
     \"AssignedAmountUnit\", \"AvocadoOil\", \"BarleyBran\", \"Baseload\", \"Beef\", \"Beer\",
     \"Beeswax\", \"Benzene\", \"BeverageWaste\", \"Biodiesel\", \"BirdSeed\", \"Bismuth\",
     \"BisphenolA\", \"BlackSeed\", \"Block\", \"BoneMeal\", \"Brass\", \"BrazilNuts\",
     \"BrentCrudes\", \"Bronze\", \"Buckwheat\", \"BunkerFuel\", \"BurningKerosene\", \"Butadiene\",
     \"ButadieneLatexes\", \"ButadieneNitrileRubbers\", \"ButadieneStyreneLatexes\",
     \"ButadieneStyreneRubbers\", \"Butane\", \"Butanediol\", \"Butter\", \"ButylAcetate\",
     \"ButylRubbers\", \"Cadmium\", \"CanarySeed\", \"Caprolactam\",
     \"CarbamideFormaldehydeResins\", \"Cashews\", \"Cassava\", \"CastorOil\", \"CausticSoda\",
     \"CellulosicBiofuels\", \"CertifiedEmissionReduction\", \"Cheese\", \"Chestnuts\",
     \"Chromite\", \"Chromium\", \"CitrusPulp\", \"Clothing\", \"CloudCover\", \"Cobalt\",
     \"Cocoa\", \"CoconutOil\", \"CokingCoal\", \"Cola\", \"CoolingDegreeDays\", \"Copper\",
     \"CopperConcentrates\", \"CopperOre\", \"Copra\", \"CopraPellets\", \"CornOil\", \"Cornflour\",
     \"Cosmetics\", \"Cotton\", \"CottonYarn\", \"Cottonseed\", \"CottonseedMeal\",
     \"CottonseedOil\", \"Cramp\", \"Cumene\", \"Cyclohexane\", \"Detergents\",
     \"DiammoniumPhosphate\", \"Diamond\", \"Diesel\", \"Diethanolamine\", \"DiethyleneGlycol\",
     \"DimethylTerephthalate\", \"Dioctylphthalate\", \"DistillersDriedGrainsWithSolubles\",
     \"DivinylRubbers\", \"Drugs\", \"DryBulkSingleVoyage\", \"DryBulkTimeCharter\",
     \"DualPurposeKerosene\", \"DubaiCrude\", \"Dyes\", \"EdibleBarley\", \"EdibleWheat\", \"Egg\",
     \"ElectricalWire\", \"EmissionReductionUnit\", \"EmulsionPVC\", \"Epichlorohydrin\",
     \"EpoxyResins\", \"EssentialOils\", \"Ethane\", \"Ethanol\", \"EthylTertiaryButylEther\",
     \"Ethylbenzene\", \"Ethylene\", \"EthyleneDichloride\", \"EthyleneOxide\",
     \"EthylenePropyleneRubbers\", \"EthyleneVinylAcetate\", \"Ethylhexanol\",
     \"EuropeanAviationAllowanc\", \"EuropeanUnitAllowance\", \"ExpandablePolystyrene\",
     \"FatProducts\", \"FattyAcid\", \"FattyAlcohols\", \"FeatherMeal\", \"FeedBarley\",
     \"FeedConcentrate\", \"FeedCorn\", \"FeedWheat\", \"Ferroalloy\", \"Ferrochrome\",
     \"FiberProducts\", \"Fish\", \"FishMeal\", \"FishOil\", \"Flax\", \"Flour\", \"FrogLegs\",
     \"Fruit\", \"FurSkins\", \"Gallium\", \"Gasoline\", \"GasolineComponents\", \"Gelatine\",
     \"GeneralPurposePolystyren\", \"Germanium\", \"GlutenFeedPellets\", \"GlutenMeal\",
     \"Glycerine\", \"GlycolEthers\", \"GoatMeat\", \"GoldBullion\", \"GoldCoins\", \"GoldIngots\",
     \"Greaves\", \"GreenBeans\", \"GrowingDegreeDays\", \"Gum\", \"Gunmetal\", \"HazelNuts\",
     \"HeatingDegreeDays\", \"HeatingOilGasOil\", \"HeavyPyrolysisResins\", \"Hemp\", \"Hexane\",
     \"HighDensityPolyethylene\", \"HighImpactPolystyrene\", \"HighSulphurFuelOil\", \"HominyFeed\",
     \"Honey\", \"Hops\", \"Horticulture\", \"HydrochloricAcid\", \"Indium\", \"Iridium\",
     \"IronOre\", \"IsoButanol\", \"IsoPropanol\", \"Isocyanates\", \"IsophthalicAcid\",
     \"IsopreneRubbers\", \"JetFuel\", \"Jute\", \"LambMutton\", \"LardTallow\", \"Lead\",
     \"LeadOre\", \"Leather\", \"LinearAlkylbenzene\", \"LinearAlkylbenzeneSulpho\",
     \"LinearLowDensityPolyeth\", \"Linen\", \"LinseedFlaxseed\", \"LinseedOil\",
     \"LiquefiedNaturalGas\", \"LiquidPyrolysisProducts\", \"LiveCattle\", \"LivePigHog\",
     \"LiveSheepLamb\", \"LowDensityPolyethylene\", \"LowSulphurFuelOil\",
     \"LowSulphurWaxyResidue\", \"LubricatingOils\", \"Magnesium\", \"MaleicAnhydride\", \"Malt\",
     \"MaltingBarley\", \"MaltingWheat\", \"Manganese\", \"ManganeseOre\", \"MeatExtracts\",
     \"MeatMeal\", \"Melamine\", \"Mercury\", \"Methanol\", \"MethylEthylKetone\",
     \"MethylIsobutylKetone\", \"MethylMethacrylate\", \"MethylTertiaryButylEther\",
     \"MethyleneChloride\", \"Milk\", \"MilletBran\", \"MixedXylenes\", \"Molasses\",
     \"Molybdenum\", \"MonoAmmoniumPhosphate\", \"Monoethanolamine\", \"MonoethyleneGlycol\",
     \"MonopropyleneGlycol\", \"Mustard\", \"NButanol\", \"Naphtha\", \"NaturalGasLiquids\",
     \"Nickel\", \"NickelOre\", \"NitrogenFertilizers\", \"NitrogenPhosphorusPotassium\",
     \"NitrousOxide\", \"NorthAmericanSpecialAluminiumAlloy\", \"Nylon\", \"OXylene\", \"OatBran\",
     \"OffPeak\", \"Offal\", \"OliveOil\", \"Olives\", \"OrangeJuice\", \"OtherBran\",
     \"OtherCrudes\", \"OtherLPG\", \"OtherMeat\", \"OtherNaturalGas\", \"OtherNuts\",
     \"OtherOilCrops\", \"OtherRootCrops\", \"OtherSeedCrops\", \"PXylene\", \"PalladiumBullion\",
     \"PalladiumCoins\", \"PalladiumIngots\", \"PalmFruitOilBleachedAndNeutralized\",
     \"PalmFruitOilCrude\", \"PalmFruitOilOleinRefinedBleachedAndDeodorized\",
     \"PalmFruitStearinRefinedBleachedAndDeodorized\", \"PalmKernelMeal\", \"PalmKernelOilCrude\",
     \"PalmKernelOilProcesse\", \"PalmKernelPellets\", \"PalmKernelStearin\", \"Paper\",
     \"ParaffinWax\", \"Pasta\", \"Peakload\", \"PeanutMeal\", \"PeanutOil\", \"Peanuts\", \"Peas\",
     \"PetFood\", \"PetroleumSolvents\", \"Phenol\", \"PhosphateRock\", \"PhosphoricAcid\",
     \"PhthalicAnhydride\", \"Pistachios\", \"PlatinumBullion\", \"PlatinumCoins\",
     \"PlatinumIngots\", \"Polyacetals\", \"PolybutyleneTerephthalate\", \"Polycarbonate\",
     \"Polyester\", \"PolyetherPolyols\", \"PolyethyleneTerephthalate\", \"PolymethylMethacrylate\",
     \"Polyols\", \"PolypropyleneBlockCopolymer\", \"PolypropyleneHomopolymer\",
     \"PolypropyleneRandomCopolymer\", \"Pork\", \"Potash\", \"Potatoes\", \"Poultry\", \"Propane\",
     \"Propylene\", \"PropyleneGlycolEthers\", \"PropyleneOxide\", \"Pulp\", \"Quinoa\",
     \"RabbitMeat\", \"Rapemeal\", \"RapeseedCanola\", \"RapeseedCanolaOil\", \"RedBeans\",
     \"RenewableEnergyCertificate\", \"RenewableObligationCertificate\", \"Rhodium\", \"Robusta\",
     \"RoughRice\", \"Rubber\", \"Ruthenium\", \"Rye\", \"SANPlastic\", \"Safflower\",
     \"SafflowerOil\", \"Salt\", \"ScrapAluminum\", \"ScrapCopper\", \"ScrapIron\", \"ScrapLead\",
     \"ScrapNickel\", \"ScrapTin\", \"ScrapZinc\", \"SeedCorn\", \"Selenium\", \"Sesame\",
     \"SheaButter\", \"SheaNuts\", \"Shellfish\", \"Shrimp\", \"Silicon\", \"Silk\",
     \"SilverBullion\", \"SilverCoins\", \"SilverIngots\", \"Sisal\", \"SoapNoodles\", \"SodaAsh\",
     \"Sorbitol\", \"SorghumMilo\", \"Soybean\", \"SoybeanMeal\", \"SoybeanOil\",
     \"SoybeanPellets\", \"SpicesHerbs\", \"StainlessSteel\", \"Steel\", \"StraightRunFuelOil\",
     \"Styrene\", \"SugarBeetPulp\", \"SugarCane\", \"SulfuricAcid\", \"Sulphur\",
     \"SulphurDioxide\", \"Sunflower\", \"SunflowerOil\", \"SunflowerSeedMeal\", \"SuspensionPVC\",
     \"SweetPotatoes\", \"SyntheticSweetCrude\", \"TallOil\", \"TankerCleanSingleVoyage\",
     \"TankerCleanTimeCharter\", \"TankerDirtySingleVoyage\", \"TankerDirtyTimeCharter\",
     \"Tantalite\", \"TapiocaMeal\", \"Tea\", \"TerephthalicAcid\", \"ThermalCoal\",
     \"TimberLumber\", \"Tin\", \"TinOre\", \"Titanium\", \"TitaniumDioxide\", \"Tobacco\",
     \"Toluene\", \"Triethanolamine\", \"TriethyleneGlycol\", \"TripleSimplePhosphate\",
     \"Triticale\", \"TungOil\", \"Tungstate\", \"Tungsten\", \"USLightSweetCrudes\", \"Uranium\",
     \"Urea\", \"UreaAmmoniumNitrate\", \"Vanadium\", \"Veal\", \"VegetableOil\", \"VinylAcetate\",
     \"VinylChlorideMonomer\", \"VoluntaryCarbonUnit\", \"VoluntaryEmissionReduction\", \"Walnuts\",
     \"WheatBran\", \"WheatFlour\", \"WheatStarch\", \"Whey\", \"WhiteCertificate\",
     \"WhiteSpirit\", \"Wine\", \"Wolframite\", \"WoodProducts\", \"WoodyBiomass\", \"Wool\",
     \"Yoghurt\", \"Zinc\", and \"ZincOre\"."""
    source: Optional[str] = rest_field()
    """Get source."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The name of underlying defining the commodity and energy curve."""

    @overload
    def __init__(
        self,
        *,
        definition_expiry_date: Optional[datetime.date] = None,
        name: Optional[str] = None,
        product: Optional[Union[str, "_models.ProductEnum"]] = None,
        source: Optional[str] = None,
        underlying_code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveDefinitionOutput(_model_base.Model):
    """CommoditiesCurveDefinitionOutput.

    Attributes
    ----------
    currency : str
        The currency code of the commodity and energy curve.
    curve_tenors : list[str]
        List of user-defined curve tenors or dates to be computed.  The default
        value is None, needs to be assigned before using.
    curve_tenors_frequency : str or ~analyticsapi.models.CurveTenorsFrequencyEnum
        The curve tenors frequency. The possible values are:   * Monthly *
        Quarterly   * Yearly. Known values are: "Monthly", "Quarterly", and
        "Yearly".
    id : str
        Id of the curve definition.
    name : str
        The name of the commodity and energy curve.
    product : str or ~analyticsapi.models.ProductEnum
        Commodities RCS product. Please note that not all products can be
        priced for now. Known values are: "ABSPlastic", "AceticAcid",
        "Acetone", "AcrylateEsters", "AcrylicAcid", "Acrylonitrile",
        "AdipicAcid", "AlfalfaHay", "AlfalfaMeal", "AlfalfaPellets",
        "AlfalfaSeed", "Almonds", "AlphaMethylstyrene", "AluminaBauxite",
        "Aluminium", "AmmoniaWater25Percent", "AmmoniumNitrate",
        "AnhydrousAmmonia", "AnhydrousSulfate", "AnthraceneFraction",
        "Antimony", "Arabica", "Arsenic", "Asphalt", "AssignedAmountUnit",
        "AvocadoOil", "BarleyBran", "Baseload", "Beef", "Beer", "Beeswax",
        "Benzene", "BeverageWaste", "Biodiesel", "BirdSeed", "Bismuth",
        "BisphenolA", "BlackSeed", "Block", "BoneMeal", "Brass", "BrazilNuts",
        "BrentCrudes", "Bronze", "Buckwheat", "BunkerFuel", "BurningKerosene",
        "Butadiene", "ButadieneLatexes", "ButadieneNitrileRubbers",
        "ButadieneStyreneLatexes", "ButadieneStyreneRubbers", "Butane",
        "Butanediol", "Butter", "ButylAcetate", "ButylRubbers", "Cadmium",
        "CanarySeed", "Caprolactam", "CarbamideFormaldehydeResins", "Cashews",
        "Cassava", "CastorOil", "CausticSoda", "CellulosicBiofuels",
        "CertifiedEmissionReduction", "Cheese", "Chestnuts", "Chromite",
        "Chromium", "CitrusPulp", "Clothing", "CloudCover", "Cobalt", "Cocoa",
        "CoconutOil", "CokingCoal", "Cola", "CoolingDegreeDays", "Copper",
        "CopperConcentrates", "CopperOre", "Copra", "CopraPellets", "CornOil",
        "Cornflour", "Cosmetics", "Cotton", "CottonYarn", "Cottonseed",
        "CottonseedMeal", "CottonseedOil", "Cramp", "Cumene", "Cyclohexane",
        "Detergents", "DiammoniumPhosphate", "Diamond", "Diesel",
        "Diethanolamine", "DiethyleneGlycol", "DimethylTerephthalate",
        "Dioctylphthalate", "DistillersDriedGrainsWithSolubles",
        "DivinylRubbers", "Drugs", "DryBulkSingleVoyage", "DryBulkTimeCharter",
        "DualPurposeKerosene", "DubaiCrude", "Dyes", "EdibleBarley",
        "EdibleWheat", "Egg", "ElectricalWire", "EmissionReductionUnit",
        "EmulsionPVC", "Epichlorohydrin", "EpoxyResins", "EssentialOils",
        "Ethane", "Ethanol", "EthylTertiaryButylEther", "Ethylbenzene",
        "Ethylene", "EthyleneDichloride", "EthyleneOxide",
        "EthylenePropyleneRubbers", "EthyleneVinylAcetate", "Ethylhexanol",
        "EuropeanAviationAllowanc", "EuropeanUnitAllowance",
        "ExpandablePolystyrene", "FatProducts", "FattyAcid", "FattyAlcohols",
        "FeatherMeal", "FeedBarley", "FeedConcentrate", "FeedCorn",
        "FeedWheat", "Ferroalloy", "Ferrochrome", "FiberProducts", "Fish",
        "FishMeal", "FishOil", "Flax", "Flour", "FrogLegs", "Fruit",
        "FurSkins", "Gallium", "Gasoline", "GasolineComponents", "Gelatine",
        "GeneralPurposePolystyren", "Germanium", "GlutenFeedPellets",
        "GlutenMeal", "Glycerine", "GlycolEthers", "GoatMeat", "GoldBullion",
        "GoldCoins", "GoldIngots", "Greaves", "GreenBeans",
        "GrowingDegreeDays", "Gum", "Gunmetal", "HazelNuts",
        "HeatingDegreeDays", "HeatingOilGasOil", "HeavyPyrolysisResins",
        "Hemp", "Hexane", "HighDensityPolyethylene", "HighImpactPolystyrene",
        "HighSulphurFuelOil", "HominyFeed", "Honey", "Hops", "Horticulture",
        "HydrochloricAcid", "Indium", "Iridium", "IronOre", "IsoButanol",
        "IsoPropanol", "Isocyanates", "IsophthalicAcid", "IsopreneRubbers",
        "JetFuel", "Jute", "LambMutton", "LardTallow", "Lead", "LeadOre",
        "Leather", "LinearAlkylbenzene", "LinearAlkylbenzeneSulpho",
        "LinearLowDensityPolyeth", "Linen", "LinseedFlaxseed", "LinseedOil",
        "LiquefiedNaturalGas", "LiquidPyrolysisProducts", "LiveCattle",
        "LivePigHog", "LiveSheepLamb", "LowDensityPolyethylene",
        "LowSulphurFuelOil", "LowSulphurWaxyResidue", "LubricatingOils",
        "Magnesium", "MaleicAnhydride", "Malt", "MaltingBarley",
        "MaltingWheat", "Manganese", "ManganeseOre", "MeatExtracts",
        "MeatMeal", "Melamine", "Mercury", "Methanol", "MethylEthylKetone",
        "MethylIsobutylKetone", "MethylMethacrylate",
        "MethylTertiaryButylEther", "MethyleneChloride", "Milk", "MilletBran",
        "MixedXylenes", "Molasses", "Molybdenum", "MonoAmmoniumPhosphate",
        "Monoethanolamine", "MonoethyleneGlycol", "MonopropyleneGlycol",
        "Mustard", "NButanol", "Naphtha", "NaturalGasLiquids", "Nickel",
        "NickelOre", "NitrogenFertilizers", "NitrogenPhosphorusPotassium",
        "NitrousOxide", "NorthAmericanSpecialAluminiumAlloy", "Nylon",
        "OXylene", "OatBran", "OffPeak", "Offal", "OliveOil", "Olives",
        "OrangeJuice", "OtherBran", "OtherCrudes", "OtherLPG", "OtherMeat",
        "OtherNaturalGas", "OtherNuts", "OtherOilCrops", "OtherRootCrops",
        "OtherSeedCrops", "PXylene", "PalladiumBullion", "PalladiumCoins",
        "PalladiumIngots", "PalmFruitOilBleachedAndNeutralized",
        "PalmFruitOilCrude", "PalmFruitOilOleinRefinedBleachedAndDeodorized",
        "PalmFruitStearinRefinedBleachedAndDeodorized", "PalmKernelMeal",
        "PalmKernelOilCrude", "PalmKernelOilProcesse", "PalmKernelPellets",
        "PalmKernelStearin", "Paper", "ParaffinWax", "Pasta", "Peakload",
        "PeanutMeal", "PeanutOil", "Peanuts", "Peas", "PetFood",
        "PetroleumSolvents", "Phenol", "PhosphateRock", "PhosphoricAcid",
        "PhthalicAnhydride", "Pistachios", "PlatinumBullion", "PlatinumCoins",
        "PlatinumIngots", "Polyacetals", "PolybutyleneTerephthalate",
        "Polycarbonate", "Polyester", "PolyetherPolyols",
        "PolyethyleneTerephthalate", "PolymethylMethacrylate", "Polyols",
        "PolypropyleneBlockCopolymer", "PolypropyleneHomopolymer",
        "PolypropyleneRandomCopolymer", "Pork", "Potash", "Potatoes",
        "Poultry", "Propane", "Propylene", "PropyleneGlycolEthers",
        "PropyleneOxide", "Pulp", "Quinoa", "RabbitMeat", "Rapemeal",
        "RapeseedCanola", "RapeseedCanolaOil", "RedBeans",
        "RenewableEnergyCertificate", "RenewableObligationCertificate",
        "Rhodium", "Robusta", "RoughRice", "Rubber", "Ruthenium", "Rye",
        "SANPlastic", "Safflower", "SafflowerOil", "Salt", "ScrapAluminum",
        "ScrapCopper", "ScrapIron", "ScrapLead", "ScrapNickel", "ScrapTin",
        "ScrapZinc", "SeedCorn", "Selenium", "Sesame", "SheaButter",
        "SheaNuts", "Shellfish", "Shrimp", "Silicon", "Silk", "SilverBullion",
        "SilverCoins", "SilverIngots", "Sisal", "SoapNoodles", "SodaAsh",
        "Sorbitol", "SorghumMilo", "Soybean", "SoybeanMeal", "SoybeanOil",
        "SoybeanPellets", "SpicesHerbs", "StainlessSteel", "Steel",
        "StraightRunFuelOil", "Styrene", "SugarBeetPulp", "SugarCane",
        "SulfuricAcid", "Sulphur", "SulphurDioxide", "Sunflower",
        "SunflowerOil", "SunflowerSeedMeal", "SuspensionPVC", "SweetPotatoes",
        "SyntheticSweetCrude", "TallOil", "TankerCleanSingleVoyage",
        "TankerCleanTimeCharter", "TankerDirtySingleVoyage",
        "TankerDirtyTimeCharter", "Tantalite", "TapiocaMeal", "Tea",
        "TerephthalicAcid", "ThermalCoal", "TimberLumber", "Tin", "TinOre",
        "Titanium", "TitaniumDioxide", "Tobacco", "Toluene", "Triethanolamine",
        "TriethyleneGlycol", "TripleSimplePhosphate", "Triticale", "TungOil",
        "Tungstate", "Tungsten", "USLightSweetCrudes", "Uranium", "Urea",
        "UreaAmmoniumNitrate", "Vanadium", "Veal", "VegetableOil",
        "VinylAcetate", "VinylChlorideMonomer", "VoluntaryCarbonUnit",
        "VoluntaryEmissionReduction", "Walnuts", "WheatBran", "WheatFlour",
        "WheatStarch", "Whey", "WhiteCertificate", "WhiteSpirit", "Wine",
        "Wolframite", "WoodProducts", "WoodyBiomass", "Wool", "Yoghurt",
        "Zinc", and "ZincOre".
    sector : str or ~analyticsapi.models.SectorEnum
        Commodities RCS sector. Please note that not all products can be priced
        for now. Known values are: "Agriculture", "Energy", "Metals", "Other",
        "Transportation", and "Weather".
    source : str
        Get source.
    sub_sector : str or ~analyticsapi.models.SubSectorEnum
        Commodities RCS sub-sector. Please note that not all products can be
        priced for now. Known values are: "BaseMetalsOres", "Biofuels",
        "Chemicals", "Cloud", "Coal", "Dairy", "DryBulkFreight", "Emissions",
        "Fertilizer", "ForestryFibre", "GasProducts", "Grains", "IronSteel",
        "Livestock", "MealsFeedsPulses", "MinorMetalsMinerals",
        "MiscellaneousAgriculture", "OilProducts", "Oilseeds",
        "Petrochemicals", "Power", "PreciousMetalsMinerals", "RenewableEnergy",
        "ScrapSecondaryAlloys", "Softs", "TankerFreight", and "Temperature".
    underlying_code : str
        The name of underlying defining the commodity and energy curve.
    """

    currency: Optional[str] = rest_field()
    """The currency code of the commodity and energy curve."""
    curve_tenors: Optional[List[str]] = rest_field(name="curveTenors")
    """List of user-defined curve tenors or dates to be computed."""
    curve_tenors_frequency: Optional[Union[str, "_models.CurveTenorsFrequencyEnum"]] = rest_field(
        name="curveTenorsFrequency"
    )
    """The curve tenors frequency. The possible values are:   * Monthly   * Quarterly   * Yearly.
     Known values are: \"Monthly\", \"Quarterly\", and \"Yearly\"."""
    id: Optional[str] = rest_field()
    """Id of the curve definition."""
    name: Optional[str] = rest_field()
    """The name of the commodity and energy curve."""
    product: Optional[Union[str, "_models.ProductEnum"]] = rest_field()
    """Commodities RCS product. Please note that not all products can be priced for now. Known values
     are: \"ABSPlastic\", \"AceticAcid\", \"Acetone\", \"AcrylateEsters\", \"AcrylicAcid\",
     \"Acrylonitrile\", \"AdipicAcid\", \"AlfalfaHay\", \"AlfalfaMeal\", \"AlfalfaPellets\",
     \"AlfalfaSeed\", \"Almonds\", \"AlphaMethylstyrene\", \"AluminaBauxite\", \"Aluminium\",
     \"AmmoniaWater25Percent\", \"AmmoniumNitrate\", \"AnhydrousAmmonia\", \"AnhydrousSulfate\",
     \"AnthraceneFraction\", \"Antimony\", \"Arabica\", \"Arsenic\", \"Asphalt\",
     \"AssignedAmountUnit\", \"AvocadoOil\", \"BarleyBran\", \"Baseload\", \"Beef\", \"Beer\",
     \"Beeswax\", \"Benzene\", \"BeverageWaste\", \"Biodiesel\", \"BirdSeed\", \"Bismuth\",
     \"BisphenolA\", \"BlackSeed\", \"Block\", \"BoneMeal\", \"Brass\", \"BrazilNuts\",
     \"BrentCrudes\", \"Bronze\", \"Buckwheat\", \"BunkerFuel\", \"BurningKerosene\", \"Butadiene\",
     \"ButadieneLatexes\", \"ButadieneNitrileRubbers\", \"ButadieneStyreneLatexes\",
     \"ButadieneStyreneRubbers\", \"Butane\", \"Butanediol\", \"Butter\", \"ButylAcetate\",
     \"ButylRubbers\", \"Cadmium\", \"CanarySeed\", \"Caprolactam\",
     \"CarbamideFormaldehydeResins\", \"Cashews\", \"Cassava\", \"CastorOil\", \"CausticSoda\",
     \"CellulosicBiofuels\", \"CertifiedEmissionReduction\", \"Cheese\", \"Chestnuts\",
     \"Chromite\", \"Chromium\", \"CitrusPulp\", \"Clothing\", \"CloudCover\", \"Cobalt\",
     \"Cocoa\", \"CoconutOil\", \"CokingCoal\", \"Cola\", \"CoolingDegreeDays\", \"Copper\",
     \"CopperConcentrates\", \"CopperOre\", \"Copra\", \"CopraPellets\", \"CornOil\", \"Cornflour\",
     \"Cosmetics\", \"Cotton\", \"CottonYarn\", \"Cottonseed\", \"CottonseedMeal\",
     \"CottonseedOil\", \"Cramp\", \"Cumene\", \"Cyclohexane\", \"Detergents\",
     \"DiammoniumPhosphate\", \"Diamond\", \"Diesel\", \"Diethanolamine\", \"DiethyleneGlycol\",
     \"DimethylTerephthalate\", \"Dioctylphthalate\", \"DistillersDriedGrainsWithSolubles\",
     \"DivinylRubbers\", \"Drugs\", \"DryBulkSingleVoyage\", \"DryBulkTimeCharter\",
     \"DualPurposeKerosene\", \"DubaiCrude\", \"Dyes\", \"EdibleBarley\", \"EdibleWheat\", \"Egg\",
     \"ElectricalWire\", \"EmissionReductionUnit\", \"EmulsionPVC\", \"Epichlorohydrin\",
     \"EpoxyResins\", \"EssentialOils\", \"Ethane\", \"Ethanol\", \"EthylTertiaryButylEther\",
     \"Ethylbenzene\", \"Ethylene\", \"EthyleneDichloride\", \"EthyleneOxide\",
     \"EthylenePropyleneRubbers\", \"EthyleneVinylAcetate\", \"Ethylhexanol\",
     \"EuropeanAviationAllowanc\", \"EuropeanUnitAllowance\", \"ExpandablePolystyrene\",
     \"FatProducts\", \"FattyAcid\", \"FattyAlcohols\", \"FeatherMeal\", \"FeedBarley\",
     \"FeedConcentrate\", \"FeedCorn\", \"FeedWheat\", \"Ferroalloy\", \"Ferrochrome\",
     \"FiberProducts\", \"Fish\", \"FishMeal\", \"FishOil\", \"Flax\", \"Flour\", \"FrogLegs\",
     \"Fruit\", \"FurSkins\", \"Gallium\", \"Gasoline\", \"GasolineComponents\", \"Gelatine\",
     \"GeneralPurposePolystyren\", \"Germanium\", \"GlutenFeedPellets\", \"GlutenMeal\",
     \"Glycerine\", \"GlycolEthers\", \"GoatMeat\", \"GoldBullion\", \"GoldCoins\", \"GoldIngots\",
     \"Greaves\", \"GreenBeans\", \"GrowingDegreeDays\", \"Gum\", \"Gunmetal\", \"HazelNuts\",
     \"HeatingDegreeDays\", \"HeatingOilGasOil\", \"HeavyPyrolysisResins\", \"Hemp\", \"Hexane\",
     \"HighDensityPolyethylene\", \"HighImpactPolystyrene\", \"HighSulphurFuelOil\", \"HominyFeed\",
     \"Honey\", \"Hops\", \"Horticulture\", \"HydrochloricAcid\", \"Indium\", \"Iridium\",
     \"IronOre\", \"IsoButanol\", \"IsoPropanol\", \"Isocyanates\", \"IsophthalicAcid\",
     \"IsopreneRubbers\", \"JetFuel\", \"Jute\", \"LambMutton\", \"LardTallow\", \"Lead\",
     \"LeadOre\", \"Leather\", \"LinearAlkylbenzene\", \"LinearAlkylbenzeneSulpho\",
     \"LinearLowDensityPolyeth\", \"Linen\", \"LinseedFlaxseed\", \"LinseedOil\",
     \"LiquefiedNaturalGas\", \"LiquidPyrolysisProducts\", \"LiveCattle\", \"LivePigHog\",
     \"LiveSheepLamb\", \"LowDensityPolyethylene\", \"LowSulphurFuelOil\",
     \"LowSulphurWaxyResidue\", \"LubricatingOils\", \"Magnesium\", \"MaleicAnhydride\", \"Malt\",
     \"MaltingBarley\", \"MaltingWheat\", \"Manganese\", \"ManganeseOre\", \"MeatExtracts\",
     \"MeatMeal\", \"Melamine\", \"Mercury\", \"Methanol\", \"MethylEthylKetone\",
     \"MethylIsobutylKetone\", \"MethylMethacrylate\", \"MethylTertiaryButylEther\",
     \"MethyleneChloride\", \"Milk\", \"MilletBran\", \"MixedXylenes\", \"Molasses\",
     \"Molybdenum\", \"MonoAmmoniumPhosphate\", \"Monoethanolamine\", \"MonoethyleneGlycol\",
     \"MonopropyleneGlycol\", \"Mustard\", \"NButanol\", \"Naphtha\", \"NaturalGasLiquids\",
     \"Nickel\", \"NickelOre\", \"NitrogenFertilizers\", \"NitrogenPhosphorusPotassium\",
     \"NitrousOxide\", \"NorthAmericanSpecialAluminiumAlloy\", \"Nylon\", \"OXylene\", \"OatBran\",
     \"OffPeak\", \"Offal\", \"OliveOil\", \"Olives\", \"OrangeJuice\", \"OtherBran\",
     \"OtherCrudes\", \"OtherLPG\", \"OtherMeat\", \"OtherNaturalGas\", \"OtherNuts\",
     \"OtherOilCrops\", \"OtherRootCrops\", \"OtherSeedCrops\", \"PXylene\", \"PalladiumBullion\",
     \"PalladiumCoins\", \"PalladiumIngots\", \"PalmFruitOilBleachedAndNeutralized\",
     \"PalmFruitOilCrude\", \"PalmFruitOilOleinRefinedBleachedAndDeodorized\",
     \"PalmFruitStearinRefinedBleachedAndDeodorized\", \"PalmKernelMeal\", \"PalmKernelOilCrude\",
     \"PalmKernelOilProcesse\", \"PalmKernelPellets\", \"PalmKernelStearin\", \"Paper\",
     \"ParaffinWax\", \"Pasta\", \"Peakload\", \"PeanutMeal\", \"PeanutOil\", \"Peanuts\", \"Peas\",
     \"PetFood\", \"PetroleumSolvents\", \"Phenol\", \"PhosphateRock\", \"PhosphoricAcid\",
     \"PhthalicAnhydride\", \"Pistachios\", \"PlatinumBullion\", \"PlatinumCoins\",
     \"PlatinumIngots\", \"Polyacetals\", \"PolybutyleneTerephthalate\", \"Polycarbonate\",
     \"Polyester\", \"PolyetherPolyols\", \"PolyethyleneTerephthalate\", \"PolymethylMethacrylate\",
     \"Polyols\", \"PolypropyleneBlockCopolymer\", \"PolypropyleneHomopolymer\",
     \"PolypropyleneRandomCopolymer\", \"Pork\", \"Potash\", \"Potatoes\", \"Poultry\", \"Propane\",
     \"Propylene\", \"PropyleneGlycolEthers\", \"PropyleneOxide\", \"Pulp\", \"Quinoa\",
     \"RabbitMeat\", \"Rapemeal\", \"RapeseedCanola\", \"RapeseedCanolaOil\", \"RedBeans\",
     \"RenewableEnergyCertificate\", \"RenewableObligationCertificate\", \"Rhodium\", \"Robusta\",
     \"RoughRice\", \"Rubber\", \"Ruthenium\", \"Rye\", \"SANPlastic\", \"Safflower\",
     \"SafflowerOil\", \"Salt\", \"ScrapAluminum\", \"ScrapCopper\", \"ScrapIron\", \"ScrapLead\",
     \"ScrapNickel\", \"ScrapTin\", \"ScrapZinc\", \"SeedCorn\", \"Selenium\", \"Sesame\",
     \"SheaButter\", \"SheaNuts\", \"Shellfish\", \"Shrimp\", \"Silicon\", \"Silk\",
     \"SilverBullion\", \"SilverCoins\", \"SilverIngots\", \"Sisal\", \"SoapNoodles\", \"SodaAsh\",
     \"Sorbitol\", \"SorghumMilo\", \"Soybean\", \"SoybeanMeal\", \"SoybeanOil\",
     \"SoybeanPellets\", \"SpicesHerbs\", \"StainlessSteel\", \"Steel\", \"StraightRunFuelOil\",
     \"Styrene\", \"SugarBeetPulp\", \"SugarCane\", \"SulfuricAcid\", \"Sulphur\",
     \"SulphurDioxide\", \"Sunflower\", \"SunflowerOil\", \"SunflowerSeedMeal\", \"SuspensionPVC\",
     \"SweetPotatoes\", \"SyntheticSweetCrude\", \"TallOil\", \"TankerCleanSingleVoyage\",
     \"TankerCleanTimeCharter\", \"TankerDirtySingleVoyage\", \"TankerDirtyTimeCharter\",
     \"Tantalite\", \"TapiocaMeal\", \"Tea\", \"TerephthalicAcid\", \"ThermalCoal\",
     \"TimberLumber\", \"Tin\", \"TinOre\", \"Titanium\", \"TitaniumDioxide\", \"Tobacco\",
     \"Toluene\", \"Triethanolamine\", \"TriethyleneGlycol\", \"TripleSimplePhosphate\",
     \"Triticale\", \"TungOil\", \"Tungstate\", \"Tungsten\", \"USLightSweetCrudes\", \"Uranium\",
     \"Urea\", \"UreaAmmoniumNitrate\", \"Vanadium\", \"Veal\", \"VegetableOil\", \"VinylAcetate\",
     \"VinylChlorideMonomer\", \"VoluntaryCarbonUnit\", \"VoluntaryEmissionReduction\", \"Walnuts\",
     \"WheatBran\", \"WheatFlour\", \"WheatStarch\", \"Whey\", \"WhiteCertificate\",
     \"WhiteSpirit\", \"Wine\", \"Wolframite\", \"WoodProducts\", \"WoodyBiomass\", \"Wool\",
     \"Yoghurt\", \"Zinc\", and \"ZincOre\"."""
    sector: Optional[Union[str, "_models.SectorEnum"]] = rest_field()
    """Commodities RCS sector. Please note that not all products can be priced for now. Known values
     are: \"Agriculture\", \"Energy\", \"Metals\", \"Other\", \"Transportation\", and \"Weather\"."""
    source: Optional[str] = rest_field()
    """Get source."""
    sub_sector: Optional[Union[str, "_models.SubSectorEnum"]] = rest_field(name="subSector")
    """Commodities RCS sub-sector. Please note that not all products can be priced for now. Known
     values are: \"BaseMetalsOres\", \"Biofuels\", \"Chemicals\", \"Cloud\", \"Coal\", \"Dairy\",
     \"DryBulkFreight\", \"Emissions\", \"Fertilizer\", \"ForestryFibre\", \"GasProducts\",
     \"Grains\", \"IronSteel\", \"Livestock\", \"MealsFeedsPulses\", \"MinorMetalsMinerals\",
     \"MiscellaneousAgriculture\", \"OilProducts\", \"Oilseeds\", \"Petrochemicals\", \"Power\",
     \"PreciousMetalsMinerals\", \"RenewableEnergy\", \"ScrapSecondaryAlloys\", \"Softs\",
     \"TankerFreight\", and \"Temperature\"."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The name of underlying defining the commodity and energy curve."""

    @overload
    def __init__(
        self,
        *,
        currency: Optional[str] = None,
        curve_tenors: Optional[List[str]] = None,
        curve_tenors_frequency: Optional[Union[str, "_models.CurveTenorsFrequencyEnum"]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        product: Optional[Union[str, "_models.ProductEnum"]] = None,
        sector: Optional[Union[str, "_models.SectorEnum"]] = None,
        source: Optional[str] = None,
        sub_sector: Optional[Union[str, "_models.SubSectorEnum"]] = None,
        underlying_code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveDefinitionRequest(_model_base.Model):
    """CommoditiesCurveDefinitionRequest.

    Attributes
    ----------
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    id : str
        Id of the curve definition.
    name : str
        The name of the commodity and energy curve.
    product : str or ~analyticsapi.models.ProductEnum
        Commodities RCS product. Please note that not all products can be
        priced for now. Known values are: "ABSPlastic", "AceticAcid",
        "Acetone", "AcrylateEsters", "AcrylicAcid", "Acrylonitrile",
        "AdipicAcid", "AlfalfaHay", "AlfalfaMeal", "AlfalfaPellets",
        "AlfalfaSeed", "Almonds", "AlphaMethylstyrene", "AluminaBauxite",
        "Aluminium", "AmmoniaWater25Percent", "AmmoniumNitrate",
        "AnhydrousAmmonia", "AnhydrousSulfate", "AnthraceneFraction",
        "Antimony", "Arabica", "Arsenic", "Asphalt", "AssignedAmountUnit",
        "AvocadoOil", "BarleyBran", "Baseload", "Beef", "Beer", "Beeswax",
        "Benzene", "BeverageWaste", "Biodiesel", "BirdSeed", "Bismuth",
        "BisphenolA", "BlackSeed", "Block", "BoneMeal", "Brass", "BrazilNuts",
        "BrentCrudes", "Bronze", "Buckwheat", "BunkerFuel", "BurningKerosene",
        "Butadiene", "ButadieneLatexes", "ButadieneNitrileRubbers",
        "ButadieneStyreneLatexes", "ButadieneStyreneRubbers", "Butane",
        "Butanediol", "Butter", "ButylAcetate", "ButylRubbers", "Cadmium",
        "CanarySeed", "Caprolactam", "CarbamideFormaldehydeResins", "Cashews",
        "Cassava", "CastorOil", "CausticSoda", "CellulosicBiofuels",
        "CertifiedEmissionReduction", "Cheese", "Chestnuts", "Chromite",
        "Chromium", "CitrusPulp", "Clothing", "CloudCover", "Cobalt", "Cocoa",
        "CoconutOil", "CokingCoal", "Cola", "CoolingDegreeDays", "Copper",
        "CopperConcentrates", "CopperOre", "Copra", "CopraPellets", "CornOil",
        "Cornflour", "Cosmetics", "Cotton", "CottonYarn", "Cottonseed",
        "CottonseedMeal", "CottonseedOil", "Cramp", "Cumene", "Cyclohexane",
        "Detergents", "DiammoniumPhosphate", "Diamond", "Diesel",
        "Diethanolamine", "DiethyleneGlycol", "DimethylTerephthalate",
        "Dioctylphthalate", "DistillersDriedGrainsWithSolubles",
        "DivinylRubbers", "Drugs", "DryBulkSingleVoyage", "DryBulkTimeCharter",
        "DualPurposeKerosene", "DubaiCrude", "Dyes", "EdibleBarley",
        "EdibleWheat", "Egg", "ElectricalWire", "EmissionReductionUnit",
        "EmulsionPVC", "Epichlorohydrin", "EpoxyResins", "EssentialOils",
        "Ethane", "Ethanol", "EthylTertiaryButylEther", "Ethylbenzene",
        "Ethylene", "EthyleneDichloride", "EthyleneOxide",
        "EthylenePropyleneRubbers", "EthyleneVinylAcetate", "Ethylhexanol",
        "EuropeanAviationAllowanc", "EuropeanUnitAllowance",
        "ExpandablePolystyrene", "FatProducts", "FattyAcid", "FattyAlcohols",
        "FeatherMeal", "FeedBarley", "FeedConcentrate", "FeedCorn",
        "FeedWheat", "Ferroalloy", "Ferrochrome", "FiberProducts", "Fish",
        "FishMeal", "FishOil", "Flax", "Flour", "FrogLegs", "Fruit",
        "FurSkins", "Gallium", "Gasoline", "GasolineComponents", "Gelatine",
        "GeneralPurposePolystyren", "Germanium", "GlutenFeedPellets",
        "GlutenMeal", "Glycerine", "GlycolEthers", "GoatMeat", "GoldBullion",
        "GoldCoins", "GoldIngots", "Greaves", "GreenBeans",
        "GrowingDegreeDays", "Gum", "Gunmetal", "HazelNuts",
        "HeatingDegreeDays", "HeatingOilGasOil", "HeavyPyrolysisResins",
        "Hemp", "Hexane", "HighDensityPolyethylene", "HighImpactPolystyrene",
        "HighSulphurFuelOil", "HominyFeed", "Honey", "Hops", "Horticulture",
        "HydrochloricAcid", "Indium", "Iridium", "IronOre", "IsoButanol",
        "IsoPropanol", "Isocyanates", "IsophthalicAcid", "IsopreneRubbers",
        "JetFuel", "Jute", "LambMutton", "LardTallow", "Lead", "LeadOre",
        "Leather", "LinearAlkylbenzene", "LinearAlkylbenzeneSulpho",
        "LinearLowDensityPolyeth", "Linen", "LinseedFlaxseed", "LinseedOil",
        "LiquefiedNaturalGas", "LiquidPyrolysisProducts", "LiveCattle",
        "LivePigHog", "LiveSheepLamb", "LowDensityPolyethylene",
        "LowSulphurFuelOil", "LowSulphurWaxyResidue", "LubricatingOils",
        "Magnesium", "MaleicAnhydride", "Malt", "MaltingBarley",
        "MaltingWheat", "Manganese", "ManganeseOre", "MeatExtracts",
        "MeatMeal", "Melamine", "Mercury", "Methanol", "MethylEthylKetone",
        "MethylIsobutylKetone", "MethylMethacrylate",
        "MethylTertiaryButylEther", "MethyleneChloride", "Milk", "MilletBran",
        "MixedXylenes", "Molasses", "Molybdenum", "MonoAmmoniumPhosphate",
        "Monoethanolamine", "MonoethyleneGlycol", "MonopropyleneGlycol",
        "Mustard", "NButanol", "Naphtha", "NaturalGasLiquids", "Nickel",
        "NickelOre", "NitrogenFertilizers", "NitrogenPhosphorusPotassium",
        "NitrousOxide", "NorthAmericanSpecialAluminiumAlloy", "Nylon",
        "OXylene", "OatBran", "OffPeak", "Offal", "OliveOil", "Olives",
        "OrangeJuice", "OtherBran", "OtherCrudes", "OtherLPG", "OtherMeat",
        "OtherNaturalGas", "OtherNuts", "OtherOilCrops", "OtherRootCrops",
        "OtherSeedCrops", "PXylene", "PalladiumBullion", "PalladiumCoins",
        "PalladiumIngots", "PalmFruitOilBleachedAndNeutralized",
        "PalmFruitOilCrude", "PalmFruitOilOleinRefinedBleachedAndDeodorized",
        "PalmFruitStearinRefinedBleachedAndDeodorized", "PalmKernelMeal",
        "PalmKernelOilCrude", "PalmKernelOilProcesse", "PalmKernelPellets",
        "PalmKernelStearin", "Paper", "ParaffinWax", "Pasta", "Peakload",
        "PeanutMeal", "PeanutOil", "Peanuts", "Peas", "PetFood",
        "PetroleumSolvents", "Phenol", "PhosphateRock", "PhosphoricAcid",
        "PhthalicAnhydride", "Pistachios", "PlatinumBullion", "PlatinumCoins",
        "PlatinumIngots", "Polyacetals", "PolybutyleneTerephthalate",
        "Polycarbonate", "Polyester", "PolyetherPolyols",
        "PolyethyleneTerephthalate", "PolymethylMethacrylate", "Polyols",
        "PolypropyleneBlockCopolymer", "PolypropyleneHomopolymer",
        "PolypropyleneRandomCopolymer", "Pork", "Potash", "Potatoes",
        "Poultry", "Propane", "Propylene", "PropyleneGlycolEthers",
        "PropyleneOxide", "Pulp", "Quinoa", "RabbitMeat", "Rapemeal",
        "RapeseedCanola", "RapeseedCanolaOil", "RedBeans",
        "RenewableEnergyCertificate", "RenewableObligationCertificate",
        "Rhodium", "Robusta", "RoughRice", "Rubber", "Ruthenium", "Rye",
        "SANPlastic", "Safflower", "SafflowerOil", "Salt", "ScrapAluminum",
        "ScrapCopper", "ScrapIron", "ScrapLead", "ScrapNickel", "ScrapTin",
        "ScrapZinc", "SeedCorn", "Selenium", "Sesame", "SheaButter",
        "SheaNuts", "Shellfish", "Shrimp", "Silicon", "Silk", "SilverBullion",
        "SilverCoins", "SilverIngots", "Sisal", "SoapNoodles", "SodaAsh",
        "Sorbitol", "SorghumMilo", "Soybean", "SoybeanMeal", "SoybeanOil",
        "SoybeanPellets", "SpicesHerbs", "StainlessSteel", "Steel",
        "StraightRunFuelOil", "Styrene", "SugarBeetPulp", "SugarCane",
        "SulfuricAcid", "Sulphur", "SulphurDioxide", "Sunflower",
        "SunflowerOil", "SunflowerSeedMeal", "SuspensionPVC", "SweetPotatoes",
        "SyntheticSweetCrude", "TallOil", "TankerCleanSingleVoyage",
        "TankerCleanTimeCharter", "TankerDirtySingleVoyage",
        "TankerDirtyTimeCharter", "Tantalite", "TapiocaMeal", "Tea",
        "TerephthalicAcid", "ThermalCoal", "TimberLumber", "Tin", "TinOre",
        "Titanium", "TitaniumDioxide", "Tobacco", "Toluene", "Triethanolamine",
        "TriethyleneGlycol", "TripleSimplePhosphate", "Triticale", "TungOil",
        "Tungstate", "Tungsten", "USLightSweetCrudes", "Uranium", "Urea",
        "UreaAmmoniumNitrate", "Vanadium", "Veal", "VegetableOil",
        "VinylAcetate", "VinylChlorideMonomer", "VoluntaryCarbonUnit",
        "VoluntaryEmissionReduction", "Walnuts", "WheatBran", "WheatFlour",
        "WheatStarch", "Whey", "WhiteCertificate", "WhiteSpirit", "Wine",
        "Wolframite", "WoodProducts", "WoodyBiomass", "Wool", "Yoghurt",
        "Zinc", and "ZincOre".
    sector : str or ~analyticsapi.models.SectorEnum
        Commodities RCS sector. Please note that not all products can be priced
        for now. Known values are: "Agriculture", "Energy", "Metals", "Other",
        "Transportation", and "Weather".
    source : str
        Get source.
    sub_sector : str or ~analyticsapi.models.SubSectorEnum
        Commodities RCS sub-sector. Please note that not all products can be
        priced for now. Known values are: "BaseMetalsOres", "Biofuels",
        "Chemicals", "Cloud", "Coal", "Dairy", "DryBulkFreight", "Emissions",
        "Fertilizer", "ForestryFibre", "GasProducts", "Grains", "IronSteel",
        "Livestock", "MealsFeedsPulses", "MinorMetalsMinerals",
        "MiscellaneousAgriculture", "OilProducts", "Oilseeds",
        "Petrochemicals", "Power", "PreciousMetalsMinerals", "RenewableEnergy",
        "ScrapSecondaryAlloys", "Softs", "TankerFreight", and "Temperature".
    underlying_code : str
        The name of underlying defining the commodity and energy curve.
    valuation_date : ~datetime.date
        Get valuationDate.
    """

    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""
    id: Optional[str] = rest_field()
    """Id of the curve definition."""
    name: Optional[str] = rest_field()
    """The name of the commodity and energy curve."""
    product: Optional[Union[str, "_models.ProductEnum"]] = rest_field()
    """Commodities RCS product. Please note that not all products can be priced for now. Known values
     are: \"ABSPlastic\", \"AceticAcid\", \"Acetone\", \"AcrylateEsters\", \"AcrylicAcid\",
     \"Acrylonitrile\", \"AdipicAcid\", \"AlfalfaHay\", \"AlfalfaMeal\", \"AlfalfaPellets\",
     \"AlfalfaSeed\", \"Almonds\", \"AlphaMethylstyrene\", \"AluminaBauxite\", \"Aluminium\",
     \"AmmoniaWater25Percent\", \"AmmoniumNitrate\", \"AnhydrousAmmonia\", \"AnhydrousSulfate\",
     \"AnthraceneFraction\", \"Antimony\", \"Arabica\", \"Arsenic\", \"Asphalt\",
     \"AssignedAmountUnit\", \"AvocadoOil\", \"BarleyBran\", \"Baseload\", \"Beef\", \"Beer\",
     \"Beeswax\", \"Benzene\", \"BeverageWaste\", \"Biodiesel\", \"BirdSeed\", \"Bismuth\",
     \"BisphenolA\", \"BlackSeed\", \"Block\", \"BoneMeal\", \"Brass\", \"BrazilNuts\",
     \"BrentCrudes\", \"Bronze\", \"Buckwheat\", \"BunkerFuel\", \"BurningKerosene\", \"Butadiene\",
     \"ButadieneLatexes\", \"ButadieneNitrileRubbers\", \"ButadieneStyreneLatexes\",
     \"ButadieneStyreneRubbers\", \"Butane\", \"Butanediol\", \"Butter\", \"ButylAcetate\",
     \"ButylRubbers\", \"Cadmium\", \"CanarySeed\", \"Caprolactam\",
     \"CarbamideFormaldehydeResins\", \"Cashews\", \"Cassava\", \"CastorOil\", \"CausticSoda\",
     \"CellulosicBiofuels\", \"CertifiedEmissionReduction\", \"Cheese\", \"Chestnuts\",
     \"Chromite\", \"Chromium\", \"CitrusPulp\", \"Clothing\", \"CloudCover\", \"Cobalt\",
     \"Cocoa\", \"CoconutOil\", \"CokingCoal\", \"Cola\", \"CoolingDegreeDays\", \"Copper\",
     \"CopperConcentrates\", \"CopperOre\", \"Copra\", \"CopraPellets\", \"CornOil\", \"Cornflour\",
     \"Cosmetics\", \"Cotton\", \"CottonYarn\", \"Cottonseed\", \"CottonseedMeal\",
     \"CottonseedOil\", \"Cramp\", \"Cumene\", \"Cyclohexane\", \"Detergents\",
     \"DiammoniumPhosphate\", \"Diamond\", \"Diesel\", \"Diethanolamine\", \"DiethyleneGlycol\",
     \"DimethylTerephthalate\", \"Dioctylphthalate\", \"DistillersDriedGrainsWithSolubles\",
     \"DivinylRubbers\", \"Drugs\", \"DryBulkSingleVoyage\", \"DryBulkTimeCharter\",
     \"DualPurposeKerosene\", \"DubaiCrude\", \"Dyes\", \"EdibleBarley\", \"EdibleWheat\", \"Egg\",
     \"ElectricalWire\", \"EmissionReductionUnit\", \"EmulsionPVC\", \"Epichlorohydrin\",
     \"EpoxyResins\", \"EssentialOils\", \"Ethane\", \"Ethanol\", \"EthylTertiaryButylEther\",
     \"Ethylbenzene\", \"Ethylene\", \"EthyleneDichloride\", \"EthyleneOxide\",
     \"EthylenePropyleneRubbers\", \"EthyleneVinylAcetate\", \"Ethylhexanol\",
     \"EuropeanAviationAllowanc\", \"EuropeanUnitAllowance\", \"ExpandablePolystyrene\",
     \"FatProducts\", \"FattyAcid\", \"FattyAlcohols\", \"FeatherMeal\", \"FeedBarley\",
     \"FeedConcentrate\", \"FeedCorn\", \"FeedWheat\", \"Ferroalloy\", \"Ferrochrome\",
     \"FiberProducts\", \"Fish\", \"FishMeal\", \"FishOil\", \"Flax\", \"Flour\", \"FrogLegs\",
     \"Fruit\", \"FurSkins\", \"Gallium\", \"Gasoline\", \"GasolineComponents\", \"Gelatine\",
     \"GeneralPurposePolystyren\", \"Germanium\", \"GlutenFeedPellets\", \"GlutenMeal\",
     \"Glycerine\", \"GlycolEthers\", \"GoatMeat\", \"GoldBullion\", \"GoldCoins\", \"GoldIngots\",
     \"Greaves\", \"GreenBeans\", \"GrowingDegreeDays\", \"Gum\", \"Gunmetal\", \"HazelNuts\",
     \"HeatingDegreeDays\", \"HeatingOilGasOil\", \"HeavyPyrolysisResins\", \"Hemp\", \"Hexane\",
     \"HighDensityPolyethylene\", \"HighImpactPolystyrene\", \"HighSulphurFuelOil\", \"HominyFeed\",
     \"Honey\", \"Hops\", \"Horticulture\", \"HydrochloricAcid\", \"Indium\", \"Iridium\",
     \"IronOre\", \"IsoButanol\", \"IsoPropanol\", \"Isocyanates\", \"IsophthalicAcid\",
     \"IsopreneRubbers\", \"JetFuel\", \"Jute\", \"LambMutton\", \"LardTallow\", \"Lead\",
     \"LeadOre\", \"Leather\", \"LinearAlkylbenzene\", \"LinearAlkylbenzeneSulpho\",
     \"LinearLowDensityPolyeth\", \"Linen\", \"LinseedFlaxseed\", \"LinseedOil\",
     \"LiquefiedNaturalGas\", \"LiquidPyrolysisProducts\", \"LiveCattle\", \"LivePigHog\",
     \"LiveSheepLamb\", \"LowDensityPolyethylene\", \"LowSulphurFuelOil\",
     \"LowSulphurWaxyResidue\", \"LubricatingOils\", \"Magnesium\", \"MaleicAnhydride\", \"Malt\",
     \"MaltingBarley\", \"MaltingWheat\", \"Manganese\", \"ManganeseOre\", \"MeatExtracts\",
     \"MeatMeal\", \"Melamine\", \"Mercury\", \"Methanol\", \"MethylEthylKetone\",
     \"MethylIsobutylKetone\", \"MethylMethacrylate\", \"MethylTertiaryButylEther\",
     \"MethyleneChloride\", \"Milk\", \"MilletBran\", \"MixedXylenes\", \"Molasses\",
     \"Molybdenum\", \"MonoAmmoniumPhosphate\", \"Monoethanolamine\", \"MonoethyleneGlycol\",
     \"MonopropyleneGlycol\", \"Mustard\", \"NButanol\", \"Naphtha\", \"NaturalGasLiquids\",
     \"Nickel\", \"NickelOre\", \"NitrogenFertilizers\", \"NitrogenPhosphorusPotassium\",
     \"NitrousOxide\", \"NorthAmericanSpecialAluminiumAlloy\", \"Nylon\", \"OXylene\", \"OatBran\",
     \"OffPeak\", \"Offal\", \"OliveOil\", \"Olives\", \"OrangeJuice\", \"OtherBran\",
     \"OtherCrudes\", \"OtherLPG\", \"OtherMeat\", \"OtherNaturalGas\", \"OtherNuts\",
     \"OtherOilCrops\", \"OtherRootCrops\", \"OtherSeedCrops\", \"PXylene\", \"PalladiumBullion\",
     \"PalladiumCoins\", \"PalladiumIngots\", \"PalmFruitOilBleachedAndNeutralized\",
     \"PalmFruitOilCrude\", \"PalmFruitOilOleinRefinedBleachedAndDeodorized\",
     \"PalmFruitStearinRefinedBleachedAndDeodorized\", \"PalmKernelMeal\", \"PalmKernelOilCrude\",
     \"PalmKernelOilProcesse\", \"PalmKernelPellets\", \"PalmKernelStearin\", \"Paper\",
     \"ParaffinWax\", \"Pasta\", \"Peakload\", \"PeanutMeal\", \"PeanutOil\", \"Peanuts\", \"Peas\",
     \"PetFood\", \"PetroleumSolvents\", \"Phenol\", \"PhosphateRock\", \"PhosphoricAcid\",
     \"PhthalicAnhydride\", \"Pistachios\", \"PlatinumBullion\", \"PlatinumCoins\",
     \"PlatinumIngots\", \"Polyacetals\", \"PolybutyleneTerephthalate\", \"Polycarbonate\",
     \"Polyester\", \"PolyetherPolyols\", \"PolyethyleneTerephthalate\", \"PolymethylMethacrylate\",
     \"Polyols\", \"PolypropyleneBlockCopolymer\", \"PolypropyleneHomopolymer\",
     \"PolypropyleneRandomCopolymer\", \"Pork\", \"Potash\", \"Potatoes\", \"Poultry\", \"Propane\",
     \"Propylene\", \"PropyleneGlycolEthers\", \"PropyleneOxide\", \"Pulp\", \"Quinoa\",
     \"RabbitMeat\", \"Rapemeal\", \"RapeseedCanola\", \"RapeseedCanolaOil\", \"RedBeans\",
     \"RenewableEnergyCertificate\", \"RenewableObligationCertificate\", \"Rhodium\", \"Robusta\",
     \"RoughRice\", \"Rubber\", \"Ruthenium\", \"Rye\", \"SANPlastic\", \"Safflower\",
     \"SafflowerOil\", \"Salt\", \"ScrapAluminum\", \"ScrapCopper\", \"ScrapIron\", \"ScrapLead\",
     \"ScrapNickel\", \"ScrapTin\", \"ScrapZinc\", \"SeedCorn\", \"Selenium\", \"Sesame\",
     \"SheaButter\", \"SheaNuts\", \"Shellfish\", \"Shrimp\", \"Silicon\", \"Silk\",
     \"SilverBullion\", \"SilverCoins\", \"SilverIngots\", \"Sisal\", \"SoapNoodles\", \"SodaAsh\",
     \"Sorbitol\", \"SorghumMilo\", \"Soybean\", \"SoybeanMeal\", \"SoybeanOil\",
     \"SoybeanPellets\", \"SpicesHerbs\", \"StainlessSteel\", \"Steel\", \"StraightRunFuelOil\",
     \"Styrene\", \"SugarBeetPulp\", \"SugarCane\", \"SulfuricAcid\", \"Sulphur\",
     \"SulphurDioxide\", \"Sunflower\", \"SunflowerOil\", \"SunflowerSeedMeal\", \"SuspensionPVC\",
     \"SweetPotatoes\", \"SyntheticSweetCrude\", \"TallOil\", \"TankerCleanSingleVoyage\",
     \"TankerCleanTimeCharter\", \"TankerDirtySingleVoyage\", \"TankerDirtyTimeCharter\",
     \"Tantalite\", \"TapiocaMeal\", \"Tea\", \"TerephthalicAcid\", \"ThermalCoal\",
     \"TimberLumber\", \"Tin\", \"TinOre\", \"Titanium\", \"TitaniumDioxide\", \"Tobacco\",
     \"Toluene\", \"Triethanolamine\", \"TriethyleneGlycol\", \"TripleSimplePhosphate\",
     \"Triticale\", \"TungOil\", \"Tungstate\", \"Tungsten\", \"USLightSweetCrudes\", \"Uranium\",
     \"Urea\", \"UreaAmmoniumNitrate\", \"Vanadium\", \"Veal\", \"VegetableOil\", \"VinylAcetate\",
     \"VinylChlorideMonomer\", \"VoluntaryCarbonUnit\", \"VoluntaryEmissionReduction\", \"Walnuts\",
     \"WheatBran\", \"WheatFlour\", \"WheatStarch\", \"Whey\", \"WhiteCertificate\",
     \"WhiteSpirit\", \"Wine\", \"Wolframite\", \"WoodProducts\", \"WoodyBiomass\", \"Wool\",
     \"Yoghurt\", \"Zinc\", and \"ZincOre\"."""
    sector: Optional[Union[str, "_models.SectorEnum"]] = rest_field()
    """Commodities RCS sector. Please note that not all products can be priced for now. Known values
     are: \"Agriculture\", \"Energy\", \"Metals\", \"Other\", \"Transportation\", and \"Weather\"."""
    source: Optional[str] = rest_field()
    """Get source."""
    sub_sector: Optional[Union[str, "_models.SubSectorEnum"]] = rest_field(name="subSector")
    """Commodities RCS sub-sector. Please note that not all products can be priced for now. Known
     values are: \"BaseMetalsOres\", \"Biofuels\", \"Chemicals\", \"Cloud\", \"Coal\", \"Dairy\",
     \"DryBulkFreight\", \"Emissions\", \"Fertilizer\", \"ForestryFibre\", \"GasProducts\",
     \"Grains\", \"IronSteel\", \"Livestock\", \"MealsFeedsPulses\", \"MinorMetalsMinerals\",
     \"MiscellaneousAgriculture\", \"OilProducts\", \"Oilseeds\", \"Petrochemicals\", \"Power\",
     \"PreciousMetalsMinerals\", \"RenewableEnergy\", \"ScrapSecondaryAlloys\", \"Softs\",
     \"TankerFreight\", and \"Temperature\"."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The name of underlying defining the commodity and energy curve."""
    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """Get valuationDate."""

    @overload
    def __init__(
        self,
        *,
        curve_tag: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        product: Optional[Union[str, "_models.ProductEnum"]] = None,
        sector: Optional[Union[str, "_models.SectorEnum"]] = None,
        source: Optional[str] = None,
        sub_sector: Optional[Union[str, "_models.SubSectorEnum"]] = None,
        underlying_code: Optional[str] = None,
        valuation_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveDefinitionRequestKeys(_model_base.Model):
    """CommoditiesCurveDefinitionRequestKeys.

    Attributes
    ----------
    curve_tenors : list[str]
        List of user-defined curve tenors or dates to be computed.  The default
        value is None, needs to be assigned before using.
    curve_tenors_frequency : str or ~analyticsapi.models.CurveTenorsFrequencyEnum
        The curve tenors frequency. The possible values are:   * Monthly *
        Quarterly   * Yearly. Known values are: "Monthly", "Quarterly", and
        "Yearly".
    id : str
        Id of the curve definition.
    name : str
        The name of the commodity and energy curve.
    product : str or ~analyticsapi.models.ProductEnum
        Commodities RCS product. Please note that not all products can be
        priced for now. Known values are: "ABSPlastic", "AceticAcid",
        "Acetone", "AcrylateEsters", "AcrylicAcid", "Acrylonitrile",
        "AdipicAcid", "AlfalfaHay", "AlfalfaMeal", "AlfalfaPellets",
        "AlfalfaSeed", "Almonds", "AlphaMethylstyrene", "AluminaBauxite",
        "Aluminium", "AmmoniaWater25Percent", "AmmoniumNitrate",
        "AnhydrousAmmonia", "AnhydrousSulfate", "AnthraceneFraction",
        "Antimony", "Arabica", "Arsenic", "Asphalt", "AssignedAmountUnit",
        "AvocadoOil", "BarleyBran", "Baseload", "Beef", "Beer", "Beeswax",
        "Benzene", "BeverageWaste", "Biodiesel", "BirdSeed", "Bismuth",
        "BisphenolA", "BlackSeed", "Block", "BoneMeal", "Brass", "BrazilNuts",
        "BrentCrudes", "Bronze", "Buckwheat", "BunkerFuel", "BurningKerosene",
        "Butadiene", "ButadieneLatexes", "ButadieneNitrileRubbers",
        "ButadieneStyreneLatexes", "ButadieneStyreneRubbers", "Butane",
        "Butanediol", "Butter", "ButylAcetate", "ButylRubbers", "Cadmium",
        "CanarySeed", "Caprolactam", "CarbamideFormaldehydeResins", "Cashews",
        "Cassava", "CastorOil", "CausticSoda", "CellulosicBiofuels",
        "CertifiedEmissionReduction", "Cheese", "Chestnuts", "Chromite",
        "Chromium", "CitrusPulp", "Clothing", "CloudCover", "Cobalt", "Cocoa",
        "CoconutOil", "CokingCoal", "Cola", "CoolingDegreeDays", "Copper",
        "CopperConcentrates", "CopperOre", "Copra", "CopraPellets", "CornOil",
        "Cornflour", "Cosmetics", "Cotton", "CottonYarn", "Cottonseed",
        "CottonseedMeal", "CottonseedOil", "Cramp", "Cumene", "Cyclohexane",
        "Detergents", "DiammoniumPhosphate", "Diamond", "Diesel",
        "Diethanolamine", "DiethyleneGlycol", "DimethylTerephthalate",
        "Dioctylphthalate", "DistillersDriedGrainsWithSolubles",
        "DivinylRubbers", "Drugs", "DryBulkSingleVoyage", "DryBulkTimeCharter",
        "DualPurposeKerosene", "DubaiCrude", "Dyes", "EdibleBarley",
        "EdibleWheat", "Egg", "ElectricalWire", "EmissionReductionUnit",
        "EmulsionPVC", "Epichlorohydrin", "EpoxyResins", "EssentialOils",
        "Ethane", "Ethanol", "EthylTertiaryButylEther", "Ethylbenzene",
        "Ethylene", "EthyleneDichloride", "EthyleneOxide",
        "EthylenePropyleneRubbers", "EthyleneVinylAcetate", "Ethylhexanol",
        "EuropeanAviationAllowanc", "EuropeanUnitAllowance",
        "ExpandablePolystyrene", "FatProducts", "FattyAcid", "FattyAlcohols",
        "FeatherMeal", "FeedBarley", "FeedConcentrate", "FeedCorn",
        "FeedWheat", "Ferroalloy", "Ferrochrome", "FiberProducts", "Fish",
        "FishMeal", "FishOil", "Flax", "Flour", "FrogLegs", "Fruit",
        "FurSkins", "Gallium", "Gasoline", "GasolineComponents", "Gelatine",
        "GeneralPurposePolystyren", "Germanium", "GlutenFeedPellets",
        "GlutenMeal", "Glycerine", "GlycolEthers", "GoatMeat", "GoldBullion",
        "GoldCoins", "GoldIngots", "Greaves", "GreenBeans",
        "GrowingDegreeDays", "Gum", "Gunmetal", "HazelNuts",
        "HeatingDegreeDays", "HeatingOilGasOil", "HeavyPyrolysisResins",
        "Hemp", "Hexane", "HighDensityPolyethylene", "HighImpactPolystyrene",
        "HighSulphurFuelOil", "HominyFeed", "Honey", "Hops", "Horticulture",
        "HydrochloricAcid", "Indium", "Iridium", "IronOre", "IsoButanol",
        "IsoPropanol", "Isocyanates", "IsophthalicAcid", "IsopreneRubbers",
        "JetFuel", "Jute", "LambMutton", "LardTallow", "Lead", "LeadOre",
        "Leather", "LinearAlkylbenzene", "LinearAlkylbenzeneSulpho",
        "LinearLowDensityPolyeth", "Linen", "LinseedFlaxseed", "LinseedOil",
        "LiquefiedNaturalGas", "LiquidPyrolysisProducts", "LiveCattle",
        "LivePigHog", "LiveSheepLamb", "LowDensityPolyethylene",
        "LowSulphurFuelOil", "LowSulphurWaxyResidue", "LubricatingOils",
        "Magnesium", "MaleicAnhydride", "Malt", "MaltingBarley",
        "MaltingWheat", "Manganese", "ManganeseOre", "MeatExtracts",
        "MeatMeal", "Melamine", "Mercury", "Methanol", "MethylEthylKetone",
        "MethylIsobutylKetone", "MethylMethacrylate",
        "MethylTertiaryButylEther", "MethyleneChloride", "Milk", "MilletBran",
        "MixedXylenes", "Molasses", "Molybdenum", "MonoAmmoniumPhosphate",
        "Monoethanolamine", "MonoethyleneGlycol", "MonopropyleneGlycol",
        "Mustard", "NButanol", "Naphtha", "NaturalGasLiquids", "Nickel",
        "NickelOre", "NitrogenFertilizers", "NitrogenPhosphorusPotassium",
        "NitrousOxide", "NorthAmericanSpecialAluminiumAlloy", "Nylon",
        "OXylene", "OatBran", "OffPeak", "Offal", "OliveOil", "Olives",
        "OrangeJuice", "OtherBran", "OtherCrudes", "OtherLPG", "OtherMeat",
        "OtherNaturalGas", "OtherNuts", "OtherOilCrops", "OtherRootCrops",
        "OtherSeedCrops", "PXylene", "PalladiumBullion", "PalladiumCoins",
        "PalladiumIngots", "PalmFruitOilBleachedAndNeutralized",
        "PalmFruitOilCrude", "PalmFruitOilOleinRefinedBleachedAndDeodorized",
        "PalmFruitStearinRefinedBleachedAndDeodorized", "PalmKernelMeal",
        "PalmKernelOilCrude", "PalmKernelOilProcesse", "PalmKernelPellets",
        "PalmKernelStearin", "Paper", "ParaffinWax", "Pasta", "Peakload",
        "PeanutMeal", "PeanutOil", "Peanuts", "Peas", "PetFood",
        "PetroleumSolvents", "Phenol", "PhosphateRock", "PhosphoricAcid",
        "PhthalicAnhydride", "Pistachios", "PlatinumBullion", "PlatinumCoins",
        "PlatinumIngots", "Polyacetals", "PolybutyleneTerephthalate",
        "Polycarbonate", "Polyester", "PolyetherPolyols",
        "PolyethyleneTerephthalate", "PolymethylMethacrylate", "Polyols",
        "PolypropyleneBlockCopolymer", "PolypropyleneHomopolymer",
        "PolypropyleneRandomCopolymer", "Pork", "Potash", "Potatoes",
        "Poultry", "Propane", "Propylene", "PropyleneGlycolEthers",
        "PropyleneOxide", "Pulp", "Quinoa", "RabbitMeat", "Rapemeal",
        "RapeseedCanola", "RapeseedCanolaOil", "RedBeans",
        "RenewableEnergyCertificate", "RenewableObligationCertificate",
        "Rhodium", "Robusta", "RoughRice", "Rubber", "Ruthenium", "Rye",
        "SANPlastic", "Safflower", "SafflowerOil", "Salt", "ScrapAluminum",
        "ScrapCopper", "ScrapIron", "ScrapLead", "ScrapNickel", "ScrapTin",
        "ScrapZinc", "SeedCorn", "Selenium", "Sesame", "SheaButter",
        "SheaNuts", "Shellfish", "Shrimp", "Silicon", "Silk", "SilverBullion",
        "SilverCoins", "SilverIngots", "Sisal", "SoapNoodles", "SodaAsh",
        "Sorbitol", "SorghumMilo", "Soybean", "SoybeanMeal", "SoybeanOil",
        "SoybeanPellets", "SpicesHerbs", "StainlessSteel", "Steel",
        "StraightRunFuelOil", "Styrene", "SugarBeetPulp", "SugarCane",
        "SulfuricAcid", "Sulphur", "SulphurDioxide", "Sunflower",
        "SunflowerOil", "SunflowerSeedMeal", "SuspensionPVC", "SweetPotatoes",
        "SyntheticSweetCrude", "TallOil", "TankerCleanSingleVoyage",
        "TankerCleanTimeCharter", "TankerDirtySingleVoyage",
        "TankerDirtyTimeCharter", "Tantalite", "TapiocaMeal", "Tea",
        "TerephthalicAcid", "ThermalCoal", "TimberLumber", "Tin", "TinOre",
        "Titanium", "TitaniumDioxide", "Tobacco", "Toluene", "Triethanolamine",
        "TriethyleneGlycol", "TripleSimplePhosphate", "Triticale", "TungOil",
        "Tungstate", "Tungsten", "USLightSweetCrudes", "Uranium", "Urea",
        "UreaAmmoniumNitrate", "Vanadium", "Veal", "VegetableOil",
        "VinylAcetate", "VinylChlorideMonomer", "VoluntaryCarbonUnit",
        "VoluntaryEmissionReduction", "Walnuts", "WheatBran", "WheatFlour",
        "WheatStarch", "Whey", "WhiteCertificate", "WhiteSpirit", "Wine",
        "Wolframite", "WoodProducts", "WoodyBiomass", "Wool", "Yoghurt",
        "Zinc", and "ZincOre".
    sector : str or ~analyticsapi.models.SectorEnum
        Commodities RCS sector. Please note that not all products can be priced
        for now. Known values are: "Agriculture", "Energy", "Metals", "Other",
        "Transportation", and "Weather".
    source : str
        Get source.
    sub_sector : str or ~analyticsapi.models.SubSectorEnum
        Commodities RCS sub-sector. Please note that not all products can be
        priced for now. Known values are: "BaseMetalsOres", "Biofuels",
        "Chemicals", "Cloud", "Coal", "Dairy", "DryBulkFreight", "Emissions",
        "Fertilizer", "ForestryFibre", "GasProducts", "Grains", "IronSteel",
        "Livestock", "MealsFeedsPulses", "MinorMetalsMinerals",
        "MiscellaneousAgriculture", "OilProducts", "Oilseeds",
        "Petrochemicals", "Power", "PreciousMetalsMinerals", "RenewableEnergy",
        "ScrapSecondaryAlloys", "Softs", "TankerFreight", and "Temperature".
    underlying_code : str
        The name of underlying defining the commodity and energy curve.
    """

    curve_tenors: Optional[List[str]] = rest_field(name="curveTenors")
    """List of user-defined curve tenors or dates to be computed."""
    curve_tenors_frequency: Optional[Union[str, "_models.CurveTenorsFrequencyEnum"]] = rest_field(
        name="curveTenorsFrequency"
    )
    """The curve tenors frequency. The possible values are:   * Monthly   * Quarterly   * Yearly.
     Known values are: \"Monthly\", \"Quarterly\", and \"Yearly\"."""
    id: Optional[str] = rest_field()
    """Id of the curve definition."""
    name: Optional[str] = rest_field()
    """The name of the commodity and energy curve."""
    product: Optional[Union[str, "_models.ProductEnum"]] = rest_field()
    """Commodities RCS product. Please note that not all products can be priced for now. Known values
     are: \"ABSPlastic\", \"AceticAcid\", \"Acetone\", \"AcrylateEsters\", \"AcrylicAcid\",
     \"Acrylonitrile\", \"AdipicAcid\", \"AlfalfaHay\", \"AlfalfaMeal\", \"AlfalfaPellets\",
     \"AlfalfaSeed\", \"Almonds\", \"AlphaMethylstyrene\", \"AluminaBauxite\", \"Aluminium\",
     \"AmmoniaWater25Percent\", \"AmmoniumNitrate\", \"AnhydrousAmmonia\", \"AnhydrousSulfate\",
     \"AnthraceneFraction\", \"Antimony\", \"Arabica\", \"Arsenic\", \"Asphalt\",
     \"AssignedAmountUnit\", \"AvocadoOil\", \"BarleyBran\", \"Baseload\", \"Beef\", \"Beer\",
     \"Beeswax\", \"Benzene\", \"BeverageWaste\", \"Biodiesel\", \"BirdSeed\", \"Bismuth\",
     \"BisphenolA\", \"BlackSeed\", \"Block\", \"BoneMeal\", \"Brass\", \"BrazilNuts\",
     \"BrentCrudes\", \"Bronze\", \"Buckwheat\", \"BunkerFuel\", \"BurningKerosene\", \"Butadiene\",
     \"ButadieneLatexes\", \"ButadieneNitrileRubbers\", \"ButadieneStyreneLatexes\",
     \"ButadieneStyreneRubbers\", \"Butane\", \"Butanediol\", \"Butter\", \"ButylAcetate\",
     \"ButylRubbers\", \"Cadmium\", \"CanarySeed\", \"Caprolactam\",
     \"CarbamideFormaldehydeResins\", \"Cashews\", \"Cassava\", \"CastorOil\", \"CausticSoda\",
     \"CellulosicBiofuels\", \"CertifiedEmissionReduction\", \"Cheese\", \"Chestnuts\",
     \"Chromite\", \"Chromium\", \"CitrusPulp\", \"Clothing\", \"CloudCover\", \"Cobalt\",
     \"Cocoa\", \"CoconutOil\", \"CokingCoal\", \"Cola\", \"CoolingDegreeDays\", \"Copper\",
     \"CopperConcentrates\", \"CopperOre\", \"Copra\", \"CopraPellets\", \"CornOil\", \"Cornflour\",
     \"Cosmetics\", \"Cotton\", \"CottonYarn\", \"Cottonseed\", \"CottonseedMeal\",
     \"CottonseedOil\", \"Cramp\", \"Cumene\", \"Cyclohexane\", \"Detergents\",
     \"DiammoniumPhosphate\", \"Diamond\", \"Diesel\", \"Diethanolamine\", \"DiethyleneGlycol\",
     \"DimethylTerephthalate\", \"Dioctylphthalate\", \"DistillersDriedGrainsWithSolubles\",
     \"DivinylRubbers\", \"Drugs\", \"DryBulkSingleVoyage\", \"DryBulkTimeCharter\",
     \"DualPurposeKerosene\", \"DubaiCrude\", \"Dyes\", \"EdibleBarley\", \"EdibleWheat\", \"Egg\",
     \"ElectricalWire\", \"EmissionReductionUnit\", \"EmulsionPVC\", \"Epichlorohydrin\",
     \"EpoxyResins\", \"EssentialOils\", \"Ethane\", \"Ethanol\", \"EthylTertiaryButylEther\",
     \"Ethylbenzene\", \"Ethylene\", \"EthyleneDichloride\", \"EthyleneOxide\",
     \"EthylenePropyleneRubbers\", \"EthyleneVinylAcetate\", \"Ethylhexanol\",
     \"EuropeanAviationAllowanc\", \"EuropeanUnitAllowance\", \"ExpandablePolystyrene\",
     \"FatProducts\", \"FattyAcid\", \"FattyAlcohols\", \"FeatherMeal\", \"FeedBarley\",
     \"FeedConcentrate\", \"FeedCorn\", \"FeedWheat\", \"Ferroalloy\", \"Ferrochrome\",
     \"FiberProducts\", \"Fish\", \"FishMeal\", \"FishOil\", \"Flax\", \"Flour\", \"FrogLegs\",
     \"Fruit\", \"FurSkins\", \"Gallium\", \"Gasoline\", \"GasolineComponents\", \"Gelatine\",
     \"GeneralPurposePolystyren\", \"Germanium\", \"GlutenFeedPellets\", \"GlutenMeal\",
     \"Glycerine\", \"GlycolEthers\", \"GoatMeat\", \"GoldBullion\", \"GoldCoins\", \"GoldIngots\",
     \"Greaves\", \"GreenBeans\", \"GrowingDegreeDays\", \"Gum\", \"Gunmetal\", \"HazelNuts\",
     \"HeatingDegreeDays\", \"HeatingOilGasOil\", \"HeavyPyrolysisResins\", \"Hemp\", \"Hexane\",
     \"HighDensityPolyethylene\", \"HighImpactPolystyrene\", \"HighSulphurFuelOil\", \"HominyFeed\",
     \"Honey\", \"Hops\", \"Horticulture\", \"HydrochloricAcid\", \"Indium\", \"Iridium\",
     \"IronOre\", \"IsoButanol\", \"IsoPropanol\", \"Isocyanates\", \"IsophthalicAcid\",
     \"IsopreneRubbers\", \"JetFuel\", \"Jute\", \"LambMutton\", \"LardTallow\", \"Lead\",
     \"LeadOre\", \"Leather\", \"LinearAlkylbenzene\", \"LinearAlkylbenzeneSulpho\",
     \"LinearLowDensityPolyeth\", \"Linen\", \"LinseedFlaxseed\", \"LinseedOil\",
     \"LiquefiedNaturalGas\", \"LiquidPyrolysisProducts\", \"LiveCattle\", \"LivePigHog\",
     \"LiveSheepLamb\", \"LowDensityPolyethylene\", \"LowSulphurFuelOil\",
     \"LowSulphurWaxyResidue\", \"LubricatingOils\", \"Magnesium\", \"MaleicAnhydride\", \"Malt\",
     \"MaltingBarley\", \"MaltingWheat\", \"Manganese\", \"ManganeseOre\", \"MeatExtracts\",
     \"MeatMeal\", \"Melamine\", \"Mercury\", \"Methanol\", \"MethylEthylKetone\",
     \"MethylIsobutylKetone\", \"MethylMethacrylate\", \"MethylTertiaryButylEther\",
     \"MethyleneChloride\", \"Milk\", \"MilletBran\", \"MixedXylenes\", \"Molasses\",
     \"Molybdenum\", \"MonoAmmoniumPhosphate\", \"Monoethanolamine\", \"MonoethyleneGlycol\",
     \"MonopropyleneGlycol\", \"Mustard\", \"NButanol\", \"Naphtha\", \"NaturalGasLiquids\",
     \"Nickel\", \"NickelOre\", \"NitrogenFertilizers\", \"NitrogenPhosphorusPotassium\",
     \"NitrousOxide\", \"NorthAmericanSpecialAluminiumAlloy\", \"Nylon\", \"OXylene\", \"OatBran\",
     \"OffPeak\", \"Offal\", \"OliveOil\", \"Olives\", \"OrangeJuice\", \"OtherBran\",
     \"OtherCrudes\", \"OtherLPG\", \"OtherMeat\", \"OtherNaturalGas\", \"OtherNuts\",
     \"OtherOilCrops\", \"OtherRootCrops\", \"OtherSeedCrops\", \"PXylene\", \"PalladiumBullion\",
     \"PalladiumCoins\", \"PalladiumIngots\", \"PalmFruitOilBleachedAndNeutralized\",
     \"PalmFruitOilCrude\", \"PalmFruitOilOleinRefinedBleachedAndDeodorized\",
     \"PalmFruitStearinRefinedBleachedAndDeodorized\", \"PalmKernelMeal\", \"PalmKernelOilCrude\",
     \"PalmKernelOilProcesse\", \"PalmKernelPellets\", \"PalmKernelStearin\", \"Paper\",
     \"ParaffinWax\", \"Pasta\", \"Peakload\", \"PeanutMeal\", \"PeanutOil\", \"Peanuts\", \"Peas\",
     \"PetFood\", \"PetroleumSolvents\", \"Phenol\", \"PhosphateRock\", \"PhosphoricAcid\",
     \"PhthalicAnhydride\", \"Pistachios\", \"PlatinumBullion\", \"PlatinumCoins\",
     \"PlatinumIngots\", \"Polyacetals\", \"PolybutyleneTerephthalate\", \"Polycarbonate\",
     \"Polyester\", \"PolyetherPolyols\", \"PolyethyleneTerephthalate\", \"PolymethylMethacrylate\",
     \"Polyols\", \"PolypropyleneBlockCopolymer\", \"PolypropyleneHomopolymer\",
     \"PolypropyleneRandomCopolymer\", \"Pork\", \"Potash\", \"Potatoes\", \"Poultry\", \"Propane\",
     \"Propylene\", \"PropyleneGlycolEthers\", \"PropyleneOxide\", \"Pulp\", \"Quinoa\",
     \"RabbitMeat\", \"Rapemeal\", \"RapeseedCanola\", \"RapeseedCanolaOil\", \"RedBeans\",
     \"RenewableEnergyCertificate\", \"RenewableObligationCertificate\", \"Rhodium\", \"Robusta\",
     \"RoughRice\", \"Rubber\", \"Ruthenium\", \"Rye\", \"SANPlastic\", \"Safflower\",
     \"SafflowerOil\", \"Salt\", \"ScrapAluminum\", \"ScrapCopper\", \"ScrapIron\", \"ScrapLead\",
     \"ScrapNickel\", \"ScrapTin\", \"ScrapZinc\", \"SeedCorn\", \"Selenium\", \"Sesame\",
     \"SheaButter\", \"SheaNuts\", \"Shellfish\", \"Shrimp\", \"Silicon\", \"Silk\",
     \"SilverBullion\", \"SilverCoins\", \"SilverIngots\", \"Sisal\", \"SoapNoodles\", \"SodaAsh\",
     \"Sorbitol\", \"SorghumMilo\", \"Soybean\", \"SoybeanMeal\", \"SoybeanOil\",
     \"SoybeanPellets\", \"SpicesHerbs\", \"StainlessSteel\", \"Steel\", \"StraightRunFuelOil\",
     \"Styrene\", \"SugarBeetPulp\", \"SugarCane\", \"SulfuricAcid\", \"Sulphur\",
     \"SulphurDioxide\", \"Sunflower\", \"SunflowerOil\", \"SunflowerSeedMeal\", \"SuspensionPVC\",
     \"SweetPotatoes\", \"SyntheticSweetCrude\", \"TallOil\", \"TankerCleanSingleVoyage\",
     \"TankerCleanTimeCharter\", \"TankerDirtySingleVoyage\", \"TankerDirtyTimeCharter\",
     \"Tantalite\", \"TapiocaMeal\", \"Tea\", \"TerephthalicAcid\", \"ThermalCoal\",
     \"TimberLumber\", \"Tin\", \"TinOre\", \"Titanium\", \"TitaniumDioxide\", \"Tobacco\",
     \"Toluene\", \"Triethanolamine\", \"TriethyleneGlycol\", \"TripleSimplePhosphate\",
     \"Triticale\", \"TungOil\", \"Tungstate\", \"Tungsten\", \"USLightSweetCrudes\", \"Uranium\",
     \"Urea\", \"UreaAmmoniumNitrate\", \"Vanadium\", \"Veal\", \"VegetableOil\", \"VinylAcetate\",
     \"VinylChlorideMonomer\", \"VoluntaryCarbonUnit\", \"VoluntaryEmissionReduction\", \"Walnuts\",
     \"WheatBran\", \"WheatFlour\", \"WheatStarch\", \"Whey\", \"WhiteCertificate\",
     \"WhiteSpirit\", \"Wine\", \"Wolframite\", \"WoodProducts\", \"WoodyBiomass\", \"Wool\",
     \"Yoghurt\", \"Zinc\", and \"ZincOre\"."""
    sector: Optional[Union[str, "_models.SectorEnum"]] = rest_field()
    """Commodities RCS sector. Please note that not all products can be priced for now. Known values
     are: \"Agriculture\", \"Energy\", \"Metals\", \"Other\", \"Transportation\", and \"Weather\"."""
    source: Optional[str] = rest_field()
    """Get source."""
    sub_sector: Optional[Union[str, "_models.SubSectorEnum"]] = rest_field(name="subSector")
    """Commodities RCS sub-sector. Please note that not all products can be priced for now. Known
     values are: \"BaseMetalsOres\", \"Biofuels\", \"Chemicals\", \"Cloud\", \"Coal\", \"Dairy\",
     \"DryBulkFreight\", \"Emissions\", \"Fertilizer\", \"ForestryFibre\", \"GasProducts\",
     \"Grains\", \"IronSteel\", \"Livestock\", \"MealsFeedsPulses\", \"MinorMetalsMinerals\",
     \"MiscellaneousAgriculture\", \"OilProducts\", \"Oilseeds\", \"Petrochemicals\", \"Power\",
     \"PreciousMetalsMinerals\", \"RenewableEnergy\", \"ScrapSecondaryAlloys\", \"Softs\",
     \"TankerFreight\", and \"Temperature\"."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The name of underlying defining the commodity and energy curve."""

    @overload
    def __init__(
        self,
        *,
        curve_tenors: Optional[List[str]] = None,
        curve_tenors_frequency: Optional[Union[str, "_models.CurveTenorsFrequencyEnum"]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        product: Optional[Union[str, "_models.ProductEnum"]] = None,
        sector: Optional[Union[str, "_models.SectorEnum"]] = None,
        source: Optional[str] = None,
        sub_sector: Optional[Union[str, "_models.SubSectorEnum"]] = None,
        underlying_code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveDefinitionResponse(_model_base.Model):
    """CommoditiesCurveDefinitionResponse.

    Attributes
    ----------
    curve_definition : ~analyticsapi.models.CommoditiesCurveDefinition
    curve_info : ~analyticsapi.models.CurveInfo
    segments : list[~analyticsapi.models.CommoditiesInstrumentsSegment]
        Get segments.  The default value is None, needs to be assigned before
        using.
    """

    curve_definition: Optional["_models.CommoditiesCurveDefinition"] = rest_field(name="curveDefinition")
    curve_info: Optional["_models.CurveInfo"] = rest_field(name="curveInfo")
    segments: Optional[List["_models.CommoditiesInstrumentsSegment"]] = rest_field()
    """Get segments."""

    @overload
    def __init__(
        self,
        *,
        curve_definition: Optional["_models.CommoditiesCurveDefinition"] = None,
        curve_info: Optional["_models.CurveInfo"] = None,
        segments: Optional[List["_models.CommoditiesInstrumentsSegment"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveDefinitionsResponse(_model_base.Model):
    """CommoditiesCurveDefinitionsResponse.

    Attributes
    ----------
    data : list[~analyticsapi.models.CommoditiesCurveDefinitionsResponseItems]
        Get data.  The default value is None, needs to be assigned before
        using.
    """

    data: Optional[List["_models.CommoditiesCurveDefinitionsResponseItems"]] = rest_field()
    """Get data."""

    @overload
    def __init__(
        self,
        data: Optional[List["_models.CommoditiesCurveDefinitionsResponseItems"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CommoditiesCurveDefinitionsResponseItems(_model_base.Model):
    """CommoditiesCurveDefinitionsResponseItems.

    Attributes
    ----------
    curve_definitions : list[~analyticsapi.models.CommoditiesCurveDefinition]
        Get curveDefinitions.  The default value is None, needs to be assigned
        before using.
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    """

    curve_definitions: Optional[List["_models.CommoditiesCurveDefinition"]] = rest_field(name="curveDefinitions")
    """Get curveDefinitions."""
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""

    @overload
    def __init__(
        self,
        *,
        curve_definitions: Optional[List["_models.CommoditiesCurveDefinition"]] = None,
        curve_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveParameters(_model_base.Model):
    """CommoditiesCurveParameters.

    Attributes
    ----------
    constituents_filters : ~analyticsapi.models.ConstituentsFiltersDescription
    conversion_factor : float
        The conversion factor. Default value is 1.
    market_data_access_denied_fallback : str or ~analyticsapi.models.MarketDataAccessDeniedFallbackEnum
        * ReturnError: dont price the surface and return an error (Default
        value) - IgnoreConstituents: price the surface without the error market
        data - UseDelayedData: use delayed Market Data if possible. Known
        values are: "IgnoreConstituents", "ReturnError", and "UseDelayedData".
    scope : list[str]
        Specifies the Inter-Product Spreads that are linked to the current
        Reference Curve (e.g.: \\"MOGAS_1\\", \\"MAGAS_2\\").  The default
        value is None, needs to be assigned before using.
    seasonality : ~analyticsapi.models.Seasonality
    use_delayed_data_if_denied : bool
    valuation_date : ~datetime.date
        The valuation date. The default value is the current date.
    year_basis : int
        Get yearBasis.
    """

    constituents_filters: Optional["_models.ConstituentsFiltersDescription"] = rest_field(name="constituentsFilters")
    conversion_factor: Optional[float] = rest_field(name="conversionFactor")
    """The conversion factor. Default value is 1."""
    market_data_access_denied_fallback: Optional[Union[str, "_models.MarketDataAccessDeniedFallbackEnum"]] = rest_field(
        name="marketDataAccessDeniedFallback"
    )
    """* ReturnError: dont price the surface and return an error (Default value) -
     IgnoreConstituents: price the surface without the error market data - UseDelayedData: use
     delayed Market Data if possible. Known values are: \"IgnoreConstituents\", \"ReturnError\", and
     \"UseDelayedData\"."""
    scope: Optional[List[str]] = rest_field()
    """Specifies the Inter-Product Spreads that are linked to the current Reference Curve (e.g.:
     \\"MOGAS_1\\", \\"MAGAS_2\\")."""
    seasonality: Optional["_models.Seasonality"] = rest_field()
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")
    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """The valuation date. The default value is the current date."""
    year_basis: Optional[int] = rest_field(name="yearBasis")
    """Get yearBasis."""

    @overload
    def __init__(
        self,
        *,
        constituents_filters: Optional["_models.ConstituentsFiltersDescription"] = None,
        conversion_factor: Optional[float] = None,
        market_data_access_denied_fallback: Optional[Union[str, "_models.MarketDataAccessDeniedFallbackEnum"]] = None,
        scope: Optional[List[str]] = None,
        seasonality: Optional["_models.Seasonality"] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
        valuation_date: Optional[datetime.date] = None,
        year_basis: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveParametersDescription(_model_base.Model):
    """CommoditiesCurveParametersDescription.

    Attributes
    ----------
    constituents_filters : ~analyticsapi.models.ConstituentsFiltersDescription
    conversion_factor : float
        The conversion factor. Default value is 1.
    market_data_access_denied_fallback : str or ~analyticsapi.models.MarketDataAccessDeniedFallbackEnum
        * ReturnError: dont price the surface and return an error (Default
        value) - IgnoreConstituents: price the surface without the error market
        data - UseDelayedData: use delayed Market Data if possible. Known
        values are: "IgnoreConstituents", "ReturnError", and "UseDelayedData".
    scope : list[str]
        Specifies the Inter-Product Spreads that are linked to the current
        Reference Curve (e.g.: \\"MOGAS_1\\", \\"MAGAS_2\\").  The default
        value is None, needs to be assigned before using.
    seasonality : ~analyticsapi.models.SeasonalityDescription
    use_delayed_data_if_denied : bool
    year_basis : int
        Get yearBasis.
    """

    constituents_filters: Optional["_models.ConstituentsFiltersDescription"] = rest_field(name="constituentsFilters")
    conversion_factor: Optional[float] = rest_field(name="conversionFactor")
    """The conversion factor. Default value is 1."""
    market_data_access_denied_fallback: Optional[Union[str, "_models.MarketDataAccessDeniedFallbackEnum"]] = rest_field(
        name="marketDataAccessDeniedFallback"
    )
    """* ReturnError: dont price the surface and return an error (Default value) -
     IgnoreConstituents: price the surface without the error market data - UseDelayedData: use
     delayed Market Data if possible. Known values are: \"IgnoreConstituents\", \"ReturnError\", and
     \"UseDelayedData\"."""
    scope: Optional[List[str]] = rest_field()
    """Specifies the Inter-Product Spreads that are linked to the current Reference Curve (e.g.:
     \\"MOGAS_1\\", \\"MAGAS_2\\")."""
    seasonality: Optional["_models.SeasonalityDescription"] = rest_field()
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")
    year_basis: Optional[int] = rest_field(name="yearBasis")
    """Get yearBasis."""

    @overload
    def __init__(
        self,
        *,
        constituents_filters: Optional["_models.ConstituentsFiltersDescription"] = None,
        conversion_factor: Optional[float] = None,
        market_data_access_denied_fallback: Optional[Union[str, "_models.MarketDataAccessDeniedFallbackEnum"]] = None,
        scope: Optional[List[str]] = None,
        seasonality: Optional["_models.SeasonalityDescription"] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
        year_basis: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurvePoint(_model_base.Model):
    """CommoditiesCurvePoint.

    Attributes
    ----------
    convenience_yield : float
        Get convenienceYield.
    discount_factor : float
        Get discountFactor.
    end_date : ~datetime.date
        Get endDate.
    fair_value : float
        Get fairValue.
    instrument : ~analyticsapi.models.CommoditiesCurvePointsInstrument
    seasonality_factor : float
        Get seasonalityFactor.
    tenor : str
        Get tenor.
    """

    convenience_yield: Optional[float] = rest_field(name="convenienceYield")
    """Get convenienceYield."""
    discount_factor: Optional[float] = rest_field(name="discountFactor")
    """Get discountFactor."""
    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """Get endDate."""
    fair_value: Optional[float] = rest_field(name="fairValue")
    """Get fairValue."""
    instrument: Optional["_models.CommoditiesCurvePointsInstrument"] = rest_field()
    seasonality_factor: Optional[float] = rest_field(name="seasonalityFactor")
    """Get seasonalityFactor."""
    tenor: Optional[str] = rest_field()
    """Get tenor."""

    @overload
    def __init__(
        self,
        *,
        convenience_yield: Optional[float] = None,
        discount_factor: Optional[float] = None,
        end_date: Optional[datetime.date] = None,
        fair_value: Optional[float] = None,
        instrument: Optional["_models.CommoditiesCurvePointsInstrument"] = None,
        seasonality_factor: Optional[float] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurvePointsInstrument(_model_base.Model):
    """CommoditiesCurvePointsInstrument.

    Attributes
    ----------
    calculation_method : str
        Get calculationMethod.
    instrument_type : str
        Get instrumentType.
    """

    calculation_method: Optional[str] = rest_field(name="calculationMethod")
    """Get calculationMethod."""
    instrument_type: Optional[str] = rest_field(name="instrumentType")
    """Get instrumentType."""

    @overload
    def __init__(
        self,
        *,
        calculation_method: Optional[str] = None,
        instrument_type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveReferenceUpdateDefinition(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesCurveReferenceUpdateDefinition.

    Attributes
    ----------
    constituents : ~analyticsapi.models.CommoditiesCurveConstituentsDescription
    curve_definition : ~analyticsapi.models.CommoditiesCurveDefinitionBase
    curve_parameters : ~analyticsapi.models.CommoditiesCurveParametersDescription
    """

    constituents: Optional["_models.CommoditiesCurveConstituentsDescription"] = rest_field()
    curve_definition: Optional["_models.CommoditiesCurveDefinitionBase"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.CommoditiesCurveParametersDescription"] = rest_field(name="curveParameters")

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.CommoditiesCurveConstituentsDescription"] = None,
        curve_definition: Optional["_models.CommoditiesCurveDefinitionBase"] = None,
        curve_parameters: Optional["_models.CommoditiesCurveParametersDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveRequestItem(_model_base.Model):
    """CommoditiesCurveRequestItem.

    Attributes
    ----------
    constituents : ~analyticsapi.models.CommoditiesCurveConstituents
    curve_definition : ~analyticsapi.models.CommoditiesCurveDefinitionRequestKeys
    curve_parameters : ~analyticsapi.models.CommoditiesCurveParameters
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    discount_curves : dict[str, ~analyticsapi.models.CommoditiesInterestRateCurve]
        Dictionary of interest rate curve per currency.
    reference_curves : list[~analyticsapi.models.CommoditiesReferenceCurve]
        Get referenceCurves.  The default value is None, needs to be assigned
        before using.
    """

    constituents: Optional["_models.CommoditiesCurveConstituents"] = rest_field()
    curve_definition: Optional["_models.CommoditiesCurveDefinitionRequestKeys"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.CommoditiesCurveParameters"] = rest_field(name="curveParameters")
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""
    discount_curves: Optional[Dict[str, "_models.CommoditiesInterestRateCurve"]] = rest_field(name="discountCurves")
    """Dictionary of interest rate curve per currency."""
    reference_curves: Optional[List["_models.CommoditiesReferenceCurve"]] = rest_field(name="referenceCurves")
    """Get referenceCurves."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.CommoditiesCurveConstituents"] = None,
        curve_definition: Optional["_models.CommoditiesCurveDefinitionRequestKeys"] = None,
        curve_parameters: Optional["_models.CommoditiesCurveParameters"] = None,
        curve_tag: Optional[str] = None,
        discount_curves: Optional[Dict[str, "_models.CommoditiesInterestRateCurve"]] = None,
        reference_curves: Optional[List["_models.CommoditiesReferenceCurve"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurveResponse(_model_base.Model):
    """CommoditiesCurveResponse.

    Attributes
    ----------
    data : ~analyticsapi.models.CommoditiesCurveDefinitionResponse
        Required.
    """

    data: "_models.CommoditiesCurveDefinitionResponse" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.CommoditiesCurveDefinitionResponse",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CommoditiesCurveSegmentReferenceCurve(_model_base.Model):
    """CommoditiesCurveSegmentReferenceCurve.

    Attributes
    ----------
    curve_id : str
        Get curveId.
    """

    curve_id: Optional[str] = rest_field(name="curveId")
    """Get curveId."""

    @overload
    def __init__(
        self,
        curve_id: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["curve_id"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CommoditiesCurvesReferenceResponseItem(_model_base.Model):
    """CommoditiesCurvesReferenceResponseItem.

    Attributes
    ----------
    constituents : ~analyticsapi.models.CommoditiesCurveConstituentsOutput
    curve_definition : ~analyticsapi.models.CommoditiesCurveDefinitionOutput
    curve_parameters : ~analyticsapi.models.CommoditiesCurveParameters
    curve_points : list[~analyticsapi.models.CommoditiesCurvePoint]
        Get curvePoints.  The default value is None, needs to be assigned
        before using.
    invalid_constituents : ~analyticsapi.models.CommoditiesCurveConstituentsOutput
    """

    constituents: Optional["_models.CommoditiesCurveConstituentsOutput"] = rest_field()
    curve_definition: Optional["_models.CommoditiesCurveDefinitionOutput"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.CommoditiesCurveParameters"] = rest_field(name="curveParameters")
    curve_points: Optional[List["_models.CommoditiesCurvePoint"]] = rest_field(name="curvePoints")
    """Get curvePoints."""
    invalid_constituents: Optional["_models.CommoditiesCurveConstituentsOutput"] = rest_field(
        name="invalidConstituents"
    )

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.CommoditiesCurveConstituentsOutput"] = None,
        curve_definition: Optional["_models.CommoditiesCurveDefinitionOutput"] = None,
        curve_parameters: Optional["_models.CommoditiesCurveParameters"] = None,
        curve_points: Optional[List["_models.CommoditiesCurvePoint"]] = None,
        invalid_constituents: Optional["_models.CommoditiesCurveConstituentsOutput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesCurvesResponse(_model_base.Model):
    """CommoditiesCurvesResponse.

    Attributes
    ----------
    data : list[~analyticsapi.models.CommoditiesCurvesResponseItem]
        Get data.  The default value is None, needs to be assigned before
        using.
    """

    data: Optional[List["_models.CommoditiesCurvesResponseItem"]] = rest_field()
    """Get data."""

    @overload
    def __init__(
        self,
        data: Optional[List["_models.CommoditiesCurvesResponseItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CommoditiesCurvesResponseItem(_model_base.Model):
    """CommoditiesCurvesResponseItem.

    Attributes
    ----------
    constituents : ~analyticsapi.models.CommoditiesCurveConstituentsOutput
    curve_definition : ~analyticsapi.models.CommoditiesCurveDefinitionOutput
    curve_parameters : ~analyticsapi.models.CommoditiesCurveParameters
    curve_points : list[~analyticsapi.models.CommoditiesCurvePoint]
        Get curvePoints.  The default value is None, needs to be assigned
        before using.
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    discount_curves : dict[str, ~analyticsapi.models.CommoditiesInterestRateCurve]
        Dictionary of interest rate curve per currency.
    invalid_constituents : ~analyticsapi.models.CommoditiesCurveConstituentsOutput
    reference_curves : list[~analyticsapi.models.CommoditiesCurvesReferenceResponseItem]
        Get referenceCurves.  The default value is None, needs to be assigned
        before using.
    """

    constituents: Optional["_models.CommoditiesCurveConstituentsOutput"] = rest_field()
    curve_definition: Optional["_models.CommoditiesCurveDefinitionOutput"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.CommoditiesCurveParameters"] = rest_field(name="curveParameters")
    curve_points: Optional[List["_models.CommoditiesCurvePoint"]] = rest_field(name="curvePoints")
    """Get curvePoints."""
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""
    discount_curves: Optional[Dict[str, "_models.CommoditiesInterestRateCurve"]] = rest_field(name="discountCurves")
    """Dictionary of interest rate curve per currency."""
    invalid_constituents: Optional["_models.CommoditiesCurveConstituentsOutput"] = rest_field(
        name="invalidConstituents"
    )
    reference_curves: Optional[List["_models.CommoditiesCurvesReferenceResponseItem"]] = rest_field(
        name="referenceCurves"
    )
    """Get referenceCurves."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.CommoditiesCurveConstituentsOutput"] = None,
        curve_definition: Optional["_models.CommoditiesCurveDefinitionOutput"] = None,
        curve_parameters: Optional["_models.CommoditiesCurveParameters"] = None,
        curve_points: Optional[List["_models.CommoditiesCurvePoint"]] = None,
        curve_tag: Optional[str] = None,
        discount_curves: Optional[Dict[str, "_models.CommoditiesInterestRateCurve"]] = None,
        invalid_constituents: Optional["_models.CommoditiesCurveConstituentsOutput"] = None,
        reference_curves: Optional[List["_models.CommoditiesCurvesReferenceResponseItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFieldsFormulaOutput(_model_base.Model):
    """CommoditiesFieldsFormulaOutput.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldDoubleOutput
    bid : ~analyticsapi.models.FieldDoubleOutput
    last : ~analyticsapi.models.FieldDoubleOutput
    settlement : ~analyticsapi.models.FieldDoubleOutput
    """

    ask: Optional["_models.FieldDoubleOutput"] = rest_field()
    bid: Optional["_models.FieldDoubleOutput"] = rest_field()
    last: Optional["_models.FieldDoubleOutput"] = rest_field()
    settlement: Optional["_models.FieldDoubleOutput"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldDoubleOutput"] = None,
        bid: Optional["_models.FieldDoubleOutput"] = None,
        last: Optional["_models.FieldDoubleOutput"] = None,
        settlement: Optional["_models.FieldDoubleOutput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesFields(_model_base.Model):
    """CommoditiesFuturesFields.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldFormulaDoubleValue
    bid : ~analyticsapi.models.FieldFormulaDoubleValue
    bid_ask_time : ~analyticsapi.models.FieldTimeValue
    block_trade_date : ~analyticsapi.models.FieldDateValue
    block_trade_last : ~analyticsapi.models.FieldFormulaDoubleValue
    block_trade_last_time : ~analyticsapi.models.FieldTimeValue
    last : ~analyticsapi.models.FieldFormulaDoubleValue
    last_time : ~analyticsapi.models.FieldTimeValue
    settlement : ~analyticsapi.models.FieldFormulaDoubleValue
    settlement_date : ~analyticsapi.models.FieldDateValue
    trade_date : ~analyticsapi.models.FieldDateValue
    """

    ask: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    bid: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    bid_ask_time: Optional["_models.FieldTimeValue"] = rest_field(name="bidAskTime")
    block_trade_date: Optional["_models.FieldDateValue"] = rest_field(name="blockTradeDate")
    block_trade_last: Optional["_models.FieldFormulaDoubleValue"] = rest_field(name="blockTradeLast")
    block_trade_last_time: Optional["_models.FieldTimeValue"] = rest_field(name="blockTradeLastTime")
    last: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    last_time: Optional["_models.FieldTimeValue"] = rest_field(name="lastTime")
    settlement: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    settlement_date: Optional["_models.FieldDateValue"] = rest_field(name="settlementDate")
    trade_date: Optional["_models.FieldDateValue"] = rest_field(name="tradeDate")

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldFormulaDoubleValue"] = None,
        bid: Optional["_models.FieldFormulaDoubleValue"] = None,
        bid_ask_time: Optional["_models.FieldTimeValue"] = None,
        block_trade_date: Optional["_models.FieldDateValue"] = None,
        block_trade_last: Optional["_models.FieldFormulaDoubleValue"] = None,
        block_trade_last_time: Optional["_models.FieldTimeValue"] = None,
        last: Optional["_models.FieldFormulaDoubleValue"] = None,
        last_time: Optional["_models.FieldTimeValue"] = None,
        settlement: Optional["_models.FieldFormulaDoubleValue"] = None,
        settlement_date: Optional["_models.FieldDateValue"] = None,
        trade_date: Optional["_models.FieldDateValue"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesFieldsDescription(_model_base.Model):
    """CommoditiesFuturesFieldsDescription.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldFormulaDescription
    bid : ~analyticsapi.models.FieldFormulaDescription
    bid_ask_time : ~analyticsapi.models.FieldDescription
    block_trade_date : ~analyticsapi.models.FieldDescription
    block_trade_last : ~analyticsapi.models.FieldFormulaDescription
    block_trade_last_time : ~analyticsapi.models.FieldDescription
    currency : ~analyticsapi.models.FieldDescription
    last : ~analyticsapi.models.FieldFormulaDescription
    last_time : ~analyticsapi.models.FieldDescription
    maturity_date : ~analyticsapi.models.FieldDescription
    settlement : ~analyticsapi.models.FieldFormulaDescription
    settlement_date : ~analyticsapi.models.FieldDescription
    tick_value : ~analyticsapi.models.FieldDescription
    trade_date : ~analyticsapi.models.FieldDescription
    """

    ask: Optional["_models.FieldFormulaDescription"] = rest_field()
    bid: Optional["_models.FieldFormulaDescription"] = rest_field()
    bid_ask_time: Optional["_models.FieldDescription"] = rest_field(name="bidAskTime")
    block_trade_date: Optional["_models.FieldDescription"] = rest_field(name="blockTradeDate")
    block_trade_last: Optional["_models.FieldFormulaDescription"] = rest_field(name="blockTradeLast")
    block_trade_last_time: Optional["_models.FieldDescription"] = rest_field(name="blockTradeLastTime")
    currency: Optional["_models.FieldDescription"] = rest_field()
    last: Optional["_models.FieldFormulaDescription"] = rest_field()
    last_time: Optional["_models.FieldDescription"] = rest_field(name="lastTime")
    maturity_date: Optional["_models.FieldDescription"] = rest_field(name="maturityDate")
    settlement: Optional["_models.FieldFormulaDescription"] = rest_field()
    settlement_date: Optional["_models.FieldDescription"] = rest_field(name="settlementDate")
    tick_value: Optional["_models.FieldDescription"] = rest_field(name="tickValue")
    trade_date: Optional["_models.FieldDescription"] = rest_field(name="tradeDate")

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldFormulaDescription"] = None,
        bid: Optional["_models.FieldFormulaDescription"] = None,
        bid_ask_time: Optional["_models.FieldDescription"] = None,
        block_trade_date: Optional["_models.FieldDescription"] = None,
        block_trade_last: Optional["_models.FieldFormulaDescription"] = None,
        block_trade_last_time: Optional["_models.FieldDescription"] = None,
        currency: Optional["_models.FieldDescription"] = None,
        last: Optional["_models.FieldFormulaDescription"] = None,
        last_time: Optional["_models.FieldDescription"] = None,
        maturity_date: Optional["_models.FieldDescription"] = None,
        settlement: Optional["_models.FieldFormulaDescription"] = None,
        settlement_date: Optional["_models.FieldDescription"] = None,
        tick_value: Optional["_models.FieldDescription"] = None,
        trade_date: Optional["_models.FieldDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesFieldsFormulaDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesFuturesFieldsFormulaDescription.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldDescription
    bid : ~analyticsapi.models.FieldDescription
    block_trade_last : ~analyticsapi.models.FieldDescription
    last : ~analyticsapi.models.FieldDescription
    settlement : ~analyticsapi.models.FieldDescription
    """

    ask: Optional["_models.FieldDescription"] = rest_field()
    bid: Optional["_models.FieldDescription"] = rest_field()
    block_trade_last: Optional["_models.FieldDescription"] = rest_field(name="blockTradeLast")
    last: Optional["_models.FieldDescription"] = rest_field()
    settlement: Optional["_models.FieldDescription"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldDescription"] = None,
        bid: Optional["_models.FieldDescription"] = None,
        block_trade_last: Optional["_models.FieldDescription"] = None,
        last: Optional["_models.FieldDescription"] = None,
        settlement: Optional["_models.FieldDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesFieldsOutput(_model_base.Model):
    """CommoditiesFuturesFieldsOutput.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldFormulaDoubleOutput
    bid : ~analyticsapi.models.FieldFormulaDoubleOutput
    bid_ask_time : ~analyticsapi.models.FieldTimeOutput
    block_trade_date : ~analyticsapi.models.FieldDateOutput
    block_trade_last : ~analyticsapi.models.FieldFormulaDoubleOutput
    block_trade_last_time : ~analyticsapi.models.FieldTimeOutput
    last : ~analyticsapi.models.FieldFormulaDoubleOutput
    last_time : ~analyticsapi.models.FieldTimeOutput
    market_data_date : ~datetime.date
        Get marketDataDate.
    market_data_time : ~analyticsapi.models.MarketDataTime
    settlement : ~analyticsapi.models.FieldFormulaDoubleOutput
    settlement_date : ~analyticsapi.models.FieldDateOutput
    trade_date : ~analyticsapi.models.FieldDateOutput
    """

    ask: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    bid: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    bid_ask_time: Optional["_models.FieldTimeOutput"] = rest_field(name="bidAskTime")
    block_trade_date: Optional["_models.FieldDateOutput"] = rest_field(name="blockTradeDate")
    block_trade_last: Optional["_models.FieldFormulaDoubleOutput"] = rest_field(name="blockTradeLast")
    block_trade_last_time: Optional["_models.FieldTimeOutput"] = rest_field(name="blockTradeLastTime")
    last: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    last_time: Optional["_models.FieldTimeOutput"] = rest_field(name="lastTime")
    market_data_date: Optional[datetime.date] = rest_field(name="marketDataDate")
    """Get marketDataDate."""
    market_data_time: Optional["_models.MarketDataTime"] = rest_field(name="marketDataTime")
    settlement: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    settlement_date: Optional["_models.FieldDateOutput"] = rest_field(name="settlementDate")
    trade_date: Optional["_models.FieldDateOutput"] = rest_field(name="tradeDate")

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldFormulaDoubleOutput"] = None,
        bid: Optional["_models.FieldFormulaDoubleOutput"] = None,
        bid_ask_time: Optional["_models.FieldTimeOutput"] = None,
        block_trade_date: Optional["_models.FieldDateOutput"] = None,
        block_trade_last: Optional["_models.FieldFormulaDoubleOutput"] = None,
        block_trade_last_time: Optional["_models.FieldTimeOutput"] = None,
        last: Optional["_models.FieldFormulaDoubleOutput"] = None,
        last_time: Optional["_models.FieldTimeOutput"] = None,
        market_data_date: Optional[datetime.date] = None,
        market_data_time: Optional["_models.MarketDataTime"] = None,
        settlement: Optional["_models.FieldFormulaDoubleOutput"] = None,
        settlement_date: Optional["_models.FieldDateOutput"] = None,
        trade_date: Optional["_models.FieldDateOutput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesFormulaFields(_model_base.Model):
    """CommoditiesFuturesFormulaFields.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldDoubleValue
    bid : ~analyticsapi.models.FieldDoubleValue
    last : ~analyticsapi.models.FieldDoubleValue
    settlement : ~analyticsapi.models.FieldDoubleValue
    """

    ask: Optional["_models.FieldDoubleValue"] = rest_field()
    bid: Optional["_models.FieldDoubleValue"] = rest_field()
    last: Optional["_models.FieldDoubleValue"] = rest_field()
    settlement: Optional["_models.FieldDoubleValue"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldDoubleValue"] = None,
        bid: Optional["_models.FieldDoubleValue"] = None,
        last: Optional["_models.FieldDoubleValue"] = None,
        settlement: Optional["_models.FieldDoubleValue"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesFormulaParameter(_model_base.Model):
    """CommoditiesFuturesFormulaParameter.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesFuturesFormulaFields
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesFuturesFormulaFields"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesFuturesFormulaFields"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesFormulaParameterDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesFuturesFormulaParameterDescription.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesFuturesFieldsFormulaDescription
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesFuturesFieldsFormulaDescription"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesFuturesFieldsFormulaDescription"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesFormulaParameterOutput(_model_base.Model):
    """CommoditiesFuturesFormulaParameterOutput.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesFieldsFormulaOutput
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesFieldsFormulaOutput"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesFieldsFormulaOutput"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesInstrument(_model_base.Model):
    """CommoditiesFuturesInstrument.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesFuturesFields
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.CommoditiesFuturesFormulaParameter]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CommoditiesFuturesInstrumentDefinition
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesFuturesFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.CommoditiesFuturesFormulaParameter"]] = rest_field(
        name="formulaParameters"
    )
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CommoditiesFuturesInstrumentDefinition"] = rest_field(
        name="instrumentDefinition"
    )

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesFuturesFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.CommoditiesFuturesFormulaParameter"]] = None,
        instrument_definition: Optional["_models.CommoditiesFuturesInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesInstrumentDefinition(_model_base.Model):
    """CommoditiesFuturesInstrumentDefinition.

    Attributes
    ----------
    instrument_code : str
        Get instrumentCode.
    instrument_group_tag : str
        Get instrumentGroupTag.
    maturity_date : ~datetime.date
        Get maturityDate.
    priority_rank : int
        Get priorityRank.
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_group_tag: Optional[str] = rest_field(name="instrumentGroupTag")
    """Get instrumentGroupTag."""
    maturity_date: Optional[datetime.date] = rest_field(name="maturityDate")
    """Get maturityDate."""
    priority_rank: Optional[int] = rest_field(name="priorityRank")
    """Get priorityRank."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        instrument_group_tag: Optional[str] = None,
        maturity_date: Optional[datetime.date] = None,
        priority_rank: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesInstrumentDescription(_model_base.Model):
    """CommoditiesFuturesInstrumentDescription.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesFuturesFieldsDescription
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.CommoditiesFuturesFormulaParameterDescription]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CommoditiesInstrumentDefinitionDescription
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesFuturesFieldsDescription"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.CommoditiesFuturesFormulaParameterDescription"]] = rest_field(
        name="formulaParameters"
    )
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CommoditiesInstrumentDefinitionDescription"] = rest_field(
        name="instrumentDefinition"
    )

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesFuturesFieldsDescription"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.CommoditiesFuturesFormulaParameterDescription"]] = None,
        instrument_definition: Optional["_models.CommoditiesInstrumentDefinitionDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesFuturesInstrumentOutput(_model_base.Model):
    """CommoditiesFuturesInstrumentOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.CommoditiesFuturesFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.CommoditiesFuturesFormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CommoditiesFuturesInstrumentDefinition
    status_message : str
        Get statusMessage.
    """

    fields: Optional["_models.CommoditiesFuturesFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.CommoditiesFuturesFormulaParameterOutput"]] = rest_field(
        name="formulaParameters"
    )
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CommoditiesFuturesInstrumentDefinition"] = rest_field(
        name="instrumentDefinition"
    )
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.CommoditiesFuturesFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.CommoditiesFuturesFormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.CommoditiesFuturesInstrumentDefinition"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInstrumentDefinitionDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInstrumentDefinitionDescription.

    Attributes
    ----------
    instrument_code : str
        Get instrumentCode.
    instrument_group_tag : str
        Get instrumentGroupTag.
    priority_rank : int
        Get priorityRank.
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_group_tag: Optional[str] = rest_field(name="instrumentGroupTag")
    """Get instrumentGroupTag."""
    priority_rank: Optional[int] = rest_field(name="priorityRank")
    """Get priorityRank."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        instrument_group_tag: Optional[str] = None,
        priority_rank: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInstrumentsOutput(_model_base.Model):
    """CommoditiesInstrumentsOutput.

    Attributes
    ----------
    calendar_spreads : list[~analyticsapi.models.CommoditiesCalendarSpreadInstrumentOutput]
        Get calendarSpreads.  The default value is None, needs to be assigned
        before using.
    futures : list[~analyticsapi.models.CommoditiesFuturesInstrumentOutput]
        Get futures.  The default value is None, needs to be assigned before
        using.
    inter_product_spreads : list[~analyticsapi.models.CommoditiesInterProductSpreadInstrumentsOutput]
        Get interProductSpreads.  The default value is None, needs to be
        assigned before using.
    """

    calendar_spreads: Optional[List["_models.CommoditiesCalendarSpreadInstrumentOutput"]] = rest_field(
        name="calendarSpreads"
    )
    """Get calendarSpreads."""
    futures: Optional[List["_models.CommoditiesFuturesInstrumentOutput"]] = rest_field()
    """Get futures."""
    inter_product_spreads: Optional[List["_models.CommoditiesInterProductSpreadInstrumentsOutput"]] = rest_field(
        name="interProductSpreads"
    )
    """Get interProductSpreads."""

    @overload
    def __init__(
        self,
        *,
        calendar_spreads: Optional[List["_models.CommoditiesCalendarSpreadInstrumentOutput"]] = None,
        futures: Optional[List["_models.CommoditiesFuturesInstrumentOutput"]] = None,
        inter_product_spreads: Optional[List["_models.CommoditiesInterProductSpreadInstrumentsOutput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInstrumentsRequest(_model_base.Model):
    """CommoditiesInstrumentsRequest.

    Attributes
    ----------
    calendar_spreads : list[~analyticsapi.models.CommoditiesCalendarSpreadInstrument]
        Get calendarSpreads.  The default value is None, needs to be assigned
        before using.
    futures : list[~analyticsapi.models.CommoditiesFuturesInstrument]
        Get futures.  The default value is None, needs to be assigned before
        using.
    inter_product_spreads : list[~analyticsapi.models.CommoditiesInterProductSpreadInstrument]
        Get interProductSpreads.  The default value is None, needs to be
        assigned before using.
    """

    calendar_spreads: Optional[List["_models.CommoditiesCalendarSpreadInstrument"]] = rest_field(name="calendarSpreads")
    """Get calendarSpreads."""
    futures: Optional[List["_models.CommoditiesFuturesInstrument"]] = rest_field()
    """Get futures."""
    inter_product_spreads: Optional[List["_models.CommoditiesInterProductSpreadInstrument"]] = rest_field(
        name="interProductSpreads"
    )
    """Get interProductSpreads."""

    @overload
    def __init__(
        self,
        *,
        calendar_spreads: Optional[List["_models.CommoditiesCalendarSpreadInstrument"]] = None,
        futures: Optional[List["_models.CommoditiesFuturesInstrument"]] = None,
        inter_product_spreads: Optional[List["_models.CommoditiesInterProductSpreadInstrument"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInstrumentsSegment(_model_base.Model):
    """CommoditiesInstrumentsSegment.

    Attributes
    ----------
    constituents : ~analyticsapi.models.CommoditiesCurveConstituentsDescription
    curve_parameters : ~analyticsapi.models.CommoditiesCurveParametersDescription
    reference_curves : list[~analyticsapi.models.CommoditiesCurveReferenceUpdateDefinition]
        Get referenceCurves.  The default value is None, needs to be assigned
        before using.
    start_date : ~datetime.date
        Get startDate.
    """

    constituents: Optional["_models.CommoditiesCurveConstituentsDescription"] = rest_field()
    curve_parameters: Optional["_models.CommoditiesCurveParametersDescription"] = rest_field(name="curveParameters")
    reference_curves: Optional[List["_models.CommoditiesCurveReferenceUpdateDefinition"]] = rest_field(
        name="referenceCurves"
    )
    """Get referenceCurves."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """Get startDate."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.CommoditiesCurveConstituentsDescription"] = None,
        curve_parameters: Optional["_models.CommoditiesCurveParametersDescription"] = None,
        reference_curves: Optional[List["_models.CommoditiesCurveReferenceUpdateDefinition"]] = None,
        start_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInstrumentsSegmentCreate(_model_base.Model):
    """CommoditiesInstrumentsSegmentCreate.

    Attributes
    ----------
    constituents : ~analyticsapi.models.CommoditiesCurveConstituentsDescription
    curve_parameters : ~analyticsapi.models.CommoditiesCurveParametersDescription
    reference_curves : list[~analyticsapi.models.CommoditiesCurveSegmentReferenceCurve]
        Get referenceCurves.  The default value is None, needs to be assigned
        before using.
    start_date : ~datetime.date
        Get startDate.
    """

    constituents: Optional["_models.CommoditiesCurveConstituentsDescription"] = rest_field()
    curve_parameters: Optional["_models.CommoditiesCurveParametersDescription"] = rest_field(name="curveParameters")
    reference_curves: Optional[List["_models.CommoditiesCurveSegmentReferenceCurve"]] = rest_field(
        name="referenceCurves"
    )
    """Get referenceCurves."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """Get startDate."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.CommoditiesCurveConstituentsDescription"] = None,
        curve_parameters: Optional["_models.CommoditiesCurveParametersDescription"] = None,
        reference_curves: Optional[List["_models.CommoditiesCurveSegmentReferenceCurve"]] = None,
        start_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterestRateCurve(_model_base.Model):
    """CommoditiesInterestRateCurve.

    Attributes
    ----------
    curve_definition : ~analyticsapi.models.CommoditiesInterestRateCurveDefinition
    curve_parameters : ~analyticsapi.models.ZcCurveParameters
    curves : dict[str, ~analyticsapi.models.ZcCurve]
        Get curves.
    """

    curve_definition: Optional["_models.CommoditiesInterestRateCurveDefinition"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.ZcCurveParameters"] = rest_field(name="curveParameters")
    curves: Optional[Dict[str, "_models.ZcCurve"]] = rest_field()
    """Get curves."""

    @overload
    def __init__(
        self,
        *,
        curve_definition: Optional["_models.CommoditiesInterestRateCurveDefinition"] = None,
        curve_parameters: Optional["_models.ZcCurveParameters"] = None,
        curves: Optional[Dict[str, "_models.ZcCurve"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterestRateCurveDefinition(_model_base.Model):
    """CommoditiesInterestRateCurveDefinition.

    Attributes
    ----------
    constituent_override_mode : str or ~analyticsapi.models.ConstituentOverrideModeEnum
        A method to use the default constituents. The possible values are:   *
        ReplaceDefinition: replace the default constituents by the user
        constituents from the input request,   * MergeWithDefinition: merge the
        default constituents and the user constituents from the input request,
        The default value is 'ReplaceDefinition'.  If the
        ignoreExistingDefinition is true, the constituentOverrideMode is set to
        ReplaceDefinition. Known values are: "MergeWithDefinition" and
        "ReplaceDefinition".
    currency : str
        The currency code of the interest rate curve (e.g., &#39;EUR&#39;).
    discounting_tenor : str
        The tenor which defines the interest rate curve to be used for
        discounting. It is one of the availableDiscountingTenors (e.g., '1M',
        '1Y'). By default, the first element of availableDiscountingTenors is
        used.
    id : str
        The identifier of the commodity curve. Mandatory if currency or name is
        not specified.
    ignore_existing_definition : bool
    index_name : str
        The name of the floating rate index (e.g., &#39;ESTR&#39;).
    index_tenors : list[str]
        Get indexTenors.  The default value is None, needs to be assigned
        before using.
    is_non_deliverable : bool
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        The asset class used to generate the interest rate curve. The possible
        values are:   * Deposit   * Futures   * Swap. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    market_data_location : str
        The identifier of the market place from which constituents come from.
        Currently the following values are supported: &#39;Onshore&#39; and
        &#39;EMEA&#39;. The list of values can be extended by a user when
        creating a curve.
    name : str
        The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC
        Curve&#39;).
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the generated interest rate curve is sensitive.
        The possible value is: InterestRate. Known values are: "Credit",
        "CrossCurrency", "Inflation", and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of a curve.
        Curves created by Refinitiv have the &#39;Refinitiv&#39; source.
    """

    constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = rest_field(
        name="constituentOverrideMode"
    )
    """A method to use the default constituents. The possible values are:   * ReplaceDefinition:
     replace the default constituents by the user constituents from the input request,   *
     MergeWithDefinition: merge the default constituents and the user constituents from the input
     request, The default value is 'ReplaceDefinition'.  If the ignoreExistingDefinition is true,
     the constituentOverrideMode is set to ReplaceDefinition. Known values are:
     \"MergeWithDefinition\" and \"ReplaceDefinition\"."""
    currency: Optional[str] = rest_field()
    """The currency code of the interest rate curve (e.g., &#39;EUR&#39;)."""
    discounting_tenor: Optional[str] = rest_field(name="discountingTenor")
    """The tenor which defines the interest rate curve to be used for discounting. It is one of the
     availableDiscountingTenors (e.g., '1M', '1Y'). By default, the first element of
     availableDiscountingTenors is used."""
    id: Optional[str] = rest_field()
    """The identifier of the commodity curve. Mandatory if currency or name is not specified."""
    ignore_existing_definition: Optional[bool] = rest_field(name="ignoreExistingDefinition")
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., &#39;ESTR&#39;)."""
    index_tenors: Optional[List[str]] = rest_field(name="indexTenors")
    """Get indexTenors."""
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """The asset class used to generate the interest rate curve. The possible values are:   * Deposit
     * Futures   * Swap. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    market_data_location: Optional[str] = rest_field(name="marketDataLocation")
    """The identifier of the market place from which constituents come from. Currently the following
     values are supported: &#39;Onshore&#39; and &#39;EMEA&#39;. The list of values can be extended
     by a user when creating a curve."""
    name: Optional[str] = rest_field()
    """The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC Curve&#39;)."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the generated interest rate curve is sensitive. The possible value is:
     InterestRate. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of a curve. Curves created by Refinitiv
     have the &#39;Refinitiv&#39; source."""

    @overload
    def __init__(
        self,
        *,
        constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = None,
        currency: Optional[str] = None,
        discounting_tenor: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        ignore_existing_definition: Optional[bool] = None,
        index_name: Optional[str] = None,
        index_tenors: Optional[List[str]] = None,
        is_non_deliverable: Optional[bool] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        market_data_location: Optional[str] = None,
        name: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadFields(_model_base.Model):
    """CommoditiesInterProductSpreadFields.

    Attributes
    ----------
    last : ~analyticsapi.models.FieldFormulaDoubleValue
    last_time : ~analyticsapi.models.FieldTimeValue
    settlement : ~analyticsapi.models.FieldFormulaDoubleValue
    settlement_date : ~analyticsapi.models.FieldDateValue
    """

    last: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    last_time: Optional["_models.FieldTimeValue"] = rest_field(name="lastTime")
    settlement: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    settlement_date: Optional["_models.FieldDateValue"] = rest_field(name="settlementDate")

    @overload
    def __init__(
        self,
        *,
        last: Optional["_models.FieldFormulaDoubleValue"] = None,
        last_time: Optional["_models.FieldTimeValue"] = None,
        settlement: Optional["_models.FieldFormulaDoubleValue"] = None,
        settlement_date: Optional["_models.FieldDateValue"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadFieldsDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadFieldsDescription.

    Attributes
    ----------
    last : ~analyticsapi.models.FieldFormulaDescription
    last_time : ~analyticsapi.models.FieldDescription
    maturity_date : ~analyticsapi.models.FieldDescription
    settlement : ~analyticsapi.models.FieldFormulaDescription
    settlement_date : ~analyticsapi.models.FieldDescription
    """

    last: Optional["_models.FieldFormulaDescription"] = rest_field()
    last_time: Optional["_models.FieldDescription"] = rest_field(name="lastTime")
    maturity_date: Optional["_models.FieldDescription"] = rest_field(name="maturityDate")
    settlement: Optional["_models.FieldFormulaDescription"] = rest_field()
    settlement_date: Optional["_models.FieldDescription"] = rest_field(name="settlementDate")

    @overload
    def __init__(
        self,
        *,
        last: Optional["_models.FieldFormulaDescription"] = None,
        last_time: Optional["_models.FieldDescription"] = None,
        maturity_date: Optional["_models.FieldDescription"] = None,
        settlement: Optional["_models.FieldFormulaDescription"] = None,
        settlement_date: Optional["_models.FieldDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadFieldsFormulaDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadFieldsFormulaDescription.

    Attributes
    ----------
    last : ~analyticsapi.models.FieldDescription
    settlement : ~analyticsapi.models.FieldDescription
    """

    last: Optional["_models.FieldDescription"] = rest_field()
    settlement: Optional["_models.FieldDescription"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        last: Optional["_models.FieldDescription"] = None,
        settlement: Optional["_models.FieldDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadFieldsFormulaOutput(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadFieldsFormulaOutput.

    Attributes
    ----------
    last : ~analyticsapi.models.FieldDoubleOutput
    settlement : ~analyticsapi.models.FieldDoubleOutput
    """

    last: Optional["_models.FieldDoubleOutput"] = rest_field()
    settlement: Optional["_models.FieldDoubleOutput"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        last: Optional["_models.FieldDoubleOutput"] = None,
        settlement: Optional["_models.FieldDoubleOutput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadFieldsOutput(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadFieldsOutput.

    Attributes
    ----------
    last : ~analyticsapi.models.FieldFormulaDoubleOutput
    last_time : ~analyticsapi.models.FieldTimeOutput
    market_data_date : ~datetime.date
        Get marketDataDate.
    market_data_time : ~analyticsapi.models.MarketDataTime
    settlement : ~analyticsapi.models.FieldFormulaDoubleOutput
    settlement_date : ~analyticsapi.models.FieldDateOutput
    """

    last: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    last_time: Optional["_models.FieldTimeOutput"] = rest_field(name="lastTime")
    market_data_date: Optional[datetime.date] = rest_field(name="marketDataDate")
    """Get marketDataDate."""
    market_data_time: Optional["_models.MarketDataTime"] = rest_field(name="marketDataTime")
    settlement: Optional["_models.FieldFormulaDoubleOutput"] = rest_field()
    settlement_date: Optional["_models.FieldDateOutput"] = rest_field(name="settlementDate")

    @overload
    def __init__(
        self,
        *,
        last: Optional["_models.FieldFormulaDoubleOutput"] = None,
        last_time: Optional["_models.FieldTimeOutput"] = None,
        market_data_date: Optional[datetime.date] = None,
        market_data_time: Optional["_models.MarketDataTime"] = None,
        settlement: Optional["_models.FieldFormulaDoubleOutput"] = None,
        settlement_date: Optional["_models.FieldDateOutput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadFormulaFields(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadFormulaFields.

    Attributes
    ----------
    last : ~analyticsapi.models.FieldDoubleValue
    settlement : ~analyticsapi.models.FieldDoubleValue
    """

    last: Optional["_models.FieldDoubleValue"] = rest_field()
    settlement: Optional["_models.FieldDoubleValue"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        last: Optional["_models.FieldDoubleValue"] = None,
        settlement: Optional["_models.FieldDoubleValue"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadFormulaParameter(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadFormulaParameter.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesInterProductSpreadFormulaFields
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesInterProductSpreadFormulaFields"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesInterProductSpreadFormulaFields"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadFormulaParameterDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadFormulaParameterDescription.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesInterProductSpreadFieldsFormulaDescription
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesInterProductSpreadFieldsFormulaDescription"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesInterProductSpreadFieldsFormulaDescription"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadFormulaParameterOutput(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadFormulaParameterOutput.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesInterProductSpreadFieldsFormulaOutput
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesInterProductSpreadFieldsFormulaOutput"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesInterProductSpreadFieldsFormulaOutput"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadInstrument(_model_base.Model):
    """CommoditiesInterProductSpreadInstrument.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesInterProductSpreadFields
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.CommoditiesInterProductSpreadFormulaParameter]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CommoditiesInterProductSpreadInstrumentDefinition
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesInterProductSpreadFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.CommoditiesInterProductSpreadFormulaParameter"]] = rest_field(
        name="formulaParameters"
    )
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CommoditiesInterProductSpreadInstrumentDefinition"] = rest_field(
        name="instrumentDefinition"
    )

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesInterProductSpreadFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.CommoditiesInterProductSpreadFormulaParameter"]] = None,
        instrument_definition: Optional["_models.CommoditiesInterProductSpreadInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadInstrumentDefinition(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadInstrumentDefinition.

    Attributes
    ----------
    conversion_factor : float
        The conversion factor for the current Constituent. If not specified, we
        will take into account the conversion factor indicated at the Reference
        Curve level.
    instrument_code : str
        Get instrumentCode.
    instrument_group_tag : str
        Get instrumentGroupTag.
    maturity_date : ~datetime.date
        Get maturityDate.
    priority_rank : int
        Get priorityRank.
    """

    conversion_factor: Optional[float] = rest_field(name="conversionFactor")
    """The conversion factor for the current Constituent. If not specified, we will take into account
     the conversion factor indicated at the Reference Curve level."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_group_tag: Optional[str] = rest_field(name="instrumentGroupTag")
    """Get instrumentGroupTag."""
    maturity_date: Optional[datetime.date] = rest_field(name="maturityDate")
    """Get maturityDate."""
    priority_rank: Optional[int] = rest_field(name="priorityRank")
    """Get priorityRank."""

    @overload
    def __init__(
        self,
        *,
        conversion_factor: Optional[float] = None,
        instrument_code: Optional[str] = None,
        instrument_group_tag: Optional[str] = None,
        maturity_date: Optional[datetime.date] = None,
        priority_rank: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadInstrumentDefinitionDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadInstrumentDefinitionDescription.

    Attributes
    ----------
    conversion_factor : float
        The conversion factor for the current Constituent. If not specified, we
        will take into account the conversion factor indicated at the Reference
        Curve level.
    instrument_code : str
        Get instrumentCode.
    instrument_group_tag : str
        Get instrumentGroupTag.
    priority_rank : int
        Get priorityRank.
    """

    conversion_factor: Optional[float] = rest_field(name="conversionFactor")
    """The conversion factor for the current Constituent. If not specified, we will take into account
     the conversion factor indicated at the Reference Curve level."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_group_tag: Optional[str] = rest_field(name="instrumentGroupTag")
    """Get instrumentGroupTag."""
    priority_rank: Optional[int] = rest_field(name="priorityRank")
    """Get priorityRank."""

    @overload
    def __init__(
        self,
        *,
        conversion_factor: Optional[float] = None,
        instrument_code: Optional[str] = None,
        instrument_group_tag: Optional[str] = None,
        priority_rank: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadInstrumentDescription(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadInstrumentDescription.

    Attributes
    ----------
    chain : ~analyticsapi.models.CommoditiesChainSource
    fields : ~analyticsapi.models.CommoditiesInterProductSpreadFieldsDescription
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.CommoditiesInterProductSpreadFormulaParameterDescription]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CommoditiesInterProductSpreadInstrumentDefinitionDescription
    """

    chain: Optional["_models.CommoditiesChainSource"] = rest_field()
    fields: Optional["_models.CommoditiesInterProductSpreadFieldsDescription"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.CommoditiesInterProductSpreadFormulaParameterDescription"]] = rest_field(
        name="formulaParameters"
    )
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CommoditiesInterProductSpreadInstrumentDefinitionDescription"] = (
        rest_field(name="instrumentDefinition")
    )

    @overload
    def __init__(
        self,
        *,
        chain: Optional["_models.CommoditiesChainSource"] = None,
        fields: Optional["_models.CommoditiesInterProductSpreadFieldsDescription"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.CommoditiesInterProductSpreadFormulaParameterDescription"]] = None,
        instrument_definition: Optional["_models.CommoditiesInterProductSpreadInstrumentDefinitionDescription"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesInterProductSpreadInstrumentsOutput(_model_base.Model):  # pylint: disable=name-too-long
    """CommoditiesInterProductSpreadInstrumentsOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.CommoditiesInterProductSpreadFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.CommoditiesInterProductSpreadFormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CommoditiesInterProductSpreadInstrumentDefinition
    status_message : str
        Get statusMessage.
    """

    fields: Optional["_models.CommoditiesInterProductSpreadFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.CommoditiesInterProductSpreadFormulaParameterOutput"]] = rest_field(
        name="formulaParameters"
    )
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CommoditiesInterProductSpreadInstrumentDefinition"] = rest_field(
        name="instrumentDefinition"
    )
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.CommoditiesInterProductSpreadFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.CommoditiesInterProductSpreadFormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.CommoditiesInterProductSpreadInstrumentDefinition"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CommoditiesReferenceCurve(_model_base.Model):
    """CommoditiesReferenceCurve.

    Attributes
    ----------
    constituents : ~analyticsapi.models.CommoditiesCurveConstituents
    curve_definition : ~analyticsapi.models.CommoditiesCurveDefinitionRequestKeys
    curve_parameters : ~analyticsapi.models.CommoditiesCurveParameters
    """

    constituents: Optional["_models.CommoditiesCurveConstituents"] = rest_field()
    curve_definition: Optional["_models.CommoditiesCurveDefinitionRequestKeys"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.CommoditiesCurveParameters"] = rest_field(name="curveParameters")

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.CommoditiesCurveConstituents"] = None,
        curve_definition: Optional["_models.CommoditiesCurveDefinitionRequestKeys"] = None,
        curve_parameters: Optional["_models.CommoditiesCurveParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeDatesBatched(_model_base.Model):
    """An object to definine the properties of the calculated dates returned, with a dedicated error
    object for each calculation. This serializable object behaves exactly like a list of
    dictionaries when iterated or displayed. It can be converted to a DataFrame without
    transformation.

    Attributes
    ----------
    tenor : str
        The code indicating the tenor added to startDate to calculate the
        resulted date (e.g., 1Y). Required.
    end_date : ~datetime.date
        The date produced by the calculation. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., 2024-01-01).
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    error : ~analyticsapi.models.ServiceError
    """

    tenor: str = rest_field()
    """The code indicating the tenor added to startDate to calculate the resulted date (e.g., 1Y).
     Required."""
    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date produced by the calculation. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., 2024-01-01)."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""
    error: Optional["_models.ServiceError"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        tenor: str,
        end_date: Optional[datetime.date] = None,
        processing_information: Optional[str] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ComputeDatesResponse(_model_base.Model):
    """An object to define a paginated response to a request to calculate dates.

    Attributes
    ----------
    data : list[~analyticsapi.models.ComputeDatesBatched]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.CollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.ComputeDatesBatched"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.CollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.ComputeDatesBatched"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.CollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ConstantForwardRateParameters(_model_base.Model):
    """ConstantForwardRateParameters.

    Attributes
    ----------
    calibration_method : str or ~analyticsapi.models.CalibrationMethodEnum
        The constant forward rate method. The possible values are:   *
        BootstrapApproximation   * GlobalMinimization   *
        GlobalMinimizationLastIndex   * GlobalMinimizationMaturitiesWeighted.
        Known values are: "BootstrapApproximation", "GlobalMinimization",
        "GlobalMinimizationLastIndex", and
        "GlobalMinimizationMaturitiesWeighted".
    step_mode : str or ~analyticsapi.models.StepModeEnum
        The step mode. The possible values are:  * ConstantForwardRatesOnly  *
        ConstantForwardRatesThenZeroCouponRates  * None. Known values are:
        "ConstantForwardRatesOnly", "ConstantForwardRatesThenZeroCouponRates",
        and "None".
    zero_coupon_rate_start_date : ~datetime.date
        The date used to define the starting point to extend the OIS curve
        using zero coupon rates. The value is expressed in ISO 8601 format:
        YYYY-MM-DD (e.g., '2021-01-01').
    """

    calibration_method: Optional[Union[str, "_models.CalibrationMethodEnum"]] = rest_field(name="calibrationMethod")
    """The constant forward rate method. The possible values are:   * BootstrapApproximation   *
     GlobalMinimization   * GlobalMinimizationLastIndex   * GlobalMinimizationMaturitiesWeighted.
     Known values are: \"BootstrapApproximation\", \"GlobalMinimization\",
     \"GlobalMinimizationLastIndex\", and \"GlobalMinimizationMaturitiesWeighted\"."""
    step_mode: Optional[Union[str, "_models.StepModeEnum"]] = rest_field(name="stepMode")
    """The step mode. The possible values are:  * ConstantForwardRatesOnly  *
     ConstantForwardRatesThenZeroCouponRates  * None. Known values are:
     \"ConstantForwardRatesOnly\", \"ConstantForwardRatesThenZeroCouponRates\", and \"None\"."""
    zero_coupon_rate_start_date: Optional[datetime.date] = rest_field(name="zeroCouponRateStartDate")
    """The date used to define the starting point to extend the OIS curve using zero coupon rates. The
     value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""

    @overload
    def __init__(
        self,
        *,
        calibration_method: Optional[Union[str, "_models.CalibrationMethodEnum"]] = None,
        step_mode: Optional[Union[str, "_models.StepModeEnum"]] = None,
        zero_coupon_rate_start_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Constituents(_model_base.Model):
    """Constituents.

    Attributes
    ----------
    cross_currency_instruments : dict[str, ~analyticsapi.models.CrossCurrencyInstruments]
        The list of attributes for cross currency instruments used as
        constituents to generate the zero coupon curve. These attributes are
        applied to each currency pair which is used in calculation. By default,
        constituents are derived from the identified curveDefinition.
    interest_rate_instruments : dict[str, ~analyticsapi.models.InterestRateInstruments]
        The list of attributes for interest rate instruments used as
        constituents to generate the zero coupon curve. These attributes are
        applied to each currency which is used in calculation. By default,
        constituents are derived from the identified curveDefinition.
    """

    cross_currency_instruments: Optional[Dict[str, "_models.CrossCurrencyInstruments"]] = rest_field(
        name="crossCurrencyInstruments"
    )
    """The list of attributes for cross currency instruments used as constituents to generate the zero
     coupon curve. These attributes are applied to each currency pair which is used in calculation.
     By default, constituents are derived from the identified curveDefinition."""
    interest_rate_instruments: Optional[Dict[str, "_models.InterestRateInstruments"]] = rest_field(
        name="interestRateInstruments"
    )
    """The list of attributes for interest rate instruments used as constituents to generate the zero
     coupon curve. These attributes are applied to each currency which is used in calculation. By
     default, constituents are derived from the identified curveDefinition."""

    @overload
    def __init__(
        self,
        *,
        cross_currency_instruments: Optional[Dict[str, "_models.CrossCurrencyInstruments"]] = None,
        interest_rate_instruments: Optional[Dict[str, "_models.InterestRateInstruments"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ConstituentsFiltersDescription(_model_base.Model):
    """Filter the constituents used to calculate the curve.

    Attributes
    ----------
    cutoff_time : str
        Get cutoffTime.
    max_staleness1 : str
        default value is 00:30:00.
    max_staleness2 : str
        default value is 00:02:00.
    tick_value : float
        Minimum price change of the futures of the selected contract. Depends
        on the underlying contract.
    wide_market_def : float
        default value is 100 * 0.49 * tickValue.
    """

    cutoff_time: Optional[str] = rest_field(name="cutoffTime")
    """Get cutoffTime."""
    max_staleness1: Optional[str] = rest_field(name="maxStaleness1")
    """default value is 00:30:00."""
    max_staleness2: Optional[str] = rest_field(name="maxStaleness2")
    """default value is 00:02:00."""
    tick_value: Optional[float] = rest_field(name="tickValue")
    """Minimum price change of the futures of the selected contract. Depends on the underlying
     contract."""
    wide_market_def: Optional[float] = rest_field(name="wideMarketDef")
    """default value is 100 * 0.49 * tickValue."""

    @overload
    def __init__(
        self,
        *,
        cutoff_time: Optional[str] = None,
        max_staleness1: Optional[str] = None,
        max_staleness2: Optional[str] = None,
        tick_value: Optional[float] = None,
        wide_market_def: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ConstituentsOutput(_model_base.Model):
    """ConstituentsOutput.

    Attributes
    ----------
    cross_currency_instruments : dict[str, ~analyticsapi.models.CrossCurrencyInstrumentsOutput]
        Get crossCurrencyInstruments.
    interest_rate_instruments : dict[str, ~analyticsapi.models.InterestRateInstrumentsOutput]
        Get interestRateInstruments.
    """

    cross_currency_instruments: Optional[Dict[str, "_models.CrossCurrencyInstrumentsOutput"]] = rest_field(
        name="crossCurrencyInstruments"
    )
    """Get crossCurrencyInstruments."""
    interest_rate_instruments: Optional[Dict[str, "_models.InterestRateInstrumentsOutput"]] = rest_field(
        name="interestRateInstruments"
    )
    """Get interestRateInstruments."""

    @overload
    def __init__(
        self,
        *,
        cross_currency_instruments: Optional[Dict[str, "_models.CrossCurrencyInstrumentsOutput"]] = None,
        interest_rate_instruments: Optional[Dict[str, "_models.InterestRateInstrumentsOutput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ConsumerPriceIndex(_model_base.Model):
    """Consumer Price Index.

    Attributes
    ----------
    index_value : float
        The consumer price index value. Mandatory if 'consumerPriceIndexes'
        object property is specified.
    month : str or ~analyticsapi.models.MonthEnum
        Get month. Known values are: "January", "February", "March", "April",
        "May", "June", "July", "August", "September", "October", "November",
        and "December".
    year : int
        The year to which the consumer price index is applied. Mandatory if
        'consumerPriceIndexes' object property is specified.
    """

    index_value: Optional[float] = rest_field(name="indexValue")
    """The consumer price index value. Mandatory if 'consumerPriceIndexes' object property is
     specified."""
    month: Optional[Union[str, "_models.MonthEnum"]] = rest_field()
    """Get month. Known values are: \"January\", \"February\", \"March\", \"April\", \"May\",
     \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", and \"December\"."""
    year: Optional[int] = rest_field()
    """The year to which the consumer price index is applied. Mandatory if 'consumerPriceIndexes'
     object property is specified."""

    @overload
    def __init__(
        self,
        *,
        index_value: Optional[float] = None,
        month: Optional[Union[str, "_models.MonthEnum"]] = None,
        year: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ConsumerPriceIndexCurvePoint(_model_base.Model):
    """ConsumerPriceIndexCurvePoint.

    Attributes
    ----------
    index_value : float
        The consumer price index. The value is expressed in percentages.
    is_overridden : bool
    month : str or ~analyticsapi.models.MonthEnum
        Get month. Known values are: "January", "February", "March", "April",
        "May", "June", "July", "August", "September", "October", "November",
        and "December".
    year : int
        Get year.
    """

    index_value: Optional[float] = rest_field(name="indexValue")
    """The consumer price index. The value is expressed in percentages."""
    is_overridden: Optional[bool] = rest_field(name="isOverridden")
    month: Optional[Union[str, "_models.MonthEnum"]] = rest_field()
    """Get month. Known values are: \"January\", \"February\", \"March\", \"April\", \"May\",
     \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", and \"December\"."""
    year: Optional[int] = rest_field()
    """Get year."""

    @overload
    def __init__(
        self,
        *,
        index_value: Optional[float] = None,
        is_overridden: Optional[bool] = None,
        month: Optional[Union[str, "_models.MonthEnum"]] = None,
        year: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ConvertiblePricing(_model_base.Model):
    """ConvertiblePricing.

    Attributes
    ----------
    method : str
        Is one of the following types: Literal["AT_MARKET"],
        Literal["AT_IMPLIED_STOCK_VOLATILITY"],
        Literal["AT_IMPLIED_CREDIT_SPREAD"]
    market_price : float
    credit_spread : float
    stock_price : float
    stock_dividend_yield : float
    stock_volatility : float
    stock_borrow_rate : float
    """

    method: Optional[Literal["AT_MARKET", "AT_IMPLIED_STOCK_VOLATILITY", "AT_IMPLIED_CREDIT_SPREAD"]] = rest_field()
    """Is one of the following types: Literal[\"AT_MARKET\"],
     Literal[\"AT_IMPLIED_STOCK_VOLATILITY\"], Literal[\"AT_IMPLIED_CREDIT_SPREAD\"]"""
    market_price: Optional[float] = rest_field(name="marketPrice")
    credit_spread: Optional[float] = rest_field(name="creditSpread")
    stock_price: Optional[float] = rest_field(name="stockPrice")
    stock_dividend_yield: Optional[float] = rest_field(name="stockDividendYield")
    stock_volatility: Optional[float] = rest_field(name="stockVolatility")
    stock_borrow_rate: Optional[float] = rest_field(name="stockBorrowRate")

    @overload
    def __init__(
        self,
        *,
        method: Optional[Literal["AT_MARKET", "AT_IMPLIED_STOCK_VOLATILITY", "AT_IMPLIED_CREDIT_SPREAD"]] = None,
        market_price: Optional[float] = None,
        credit_spread: Optional[float] = None,
        stock_price: Optional[float] = None,
        stock_dividend_yield: Optional[float] = None,
        stock_volatility: Optional[float] = None,
        stock_borrow_rate: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ConvexityAdjustment(_model_base.Model):
    """An object that contains parameters used to control the convexity adjustment of the reference
    index.

    Attributes
    ----------
    mean_reversion_percent : float
        The mean reversion speed rate used to calculate the convexity
        adjustment.
    volatility_percent : float
        The volatility percent used to calculate the convexity adjustment.
    """

    mean_reversion_percent: Optional[float] = rest_field(name="meanReversionPercent")
    """The mean reversion speed rate used to calculate the convexity adjustment."""
    volatility_percent: Optional[float] = rest_field(name="volatilityPercent")
    """The volatility percent used to calculate the convexity adjustment."""

    @overload
    def __init__(
        self,
        *,
        mean_reversion_percent: Optional[float] = None,
        volatility_percent: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CountPeriodsOutput(_model_base.Model):
    """The result of the period calculation for the count periods endpoint.

    Attributes
    ----------
    count : float
        The calculated number of dates in the period from startDate to endDate.
        endDate is included, startDate is not. Required.
    period_type : str or ~analyticsapi.models.PeriodTypeOutput
        The type of the calculated period. Required. Known values are: "Day",
        "WorkingDay", "Week", "Month", "Quarter", and "Year".
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    count: float = rest_field()
    """The calculated number of dates in the period from startDate to endDate. endDate is included,
     startDate is not. Required."""
    period_type: Union[str, "_models.PeriodTypeOutput"] = rest_field(name="periodType")
    """The type of the calculated period. Required. Known values are: \"Day\", \"WorkingDay\",
     \"Week\", \"Month\", \"Quarter\", and \"Year\"."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        count: float,
        period_type: Union[str, "_models.PeriodTypeOutput"],
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CountPeriodsResponse(_model_base.Model):
    """An object to define the response to a request to calculate the period of time between two
    dates.

    Attributes
    ----------
    data : ~analyticsapi.models.CountPeriodsOutput
        Required.
    """

    data: "_models.CountPeriodsOutput" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.CountPeriodsOutput",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CreditConstituents(_model_base.Model):
    """CreditConstituents.

    Attributes
    ----------
    credit_instruments : dict[str, ~analyticsapi.models.CreditInstruments]
        Get creditInstruments.
    cross_currency_instruments : dict[str, ~analyticsapi.models.CrossCurrencyInstruments]
        Get crossCurrencyInstruments.
    """

    credit_instruments: Optional[Dict[str, "_models.CreditInstruments"]] = rest_field(name="creditInstruments")
    """Get creditInstruments."""
    cross_currency_instruments: Optional[Dict[str, "_models.CrossCurrencyInstruments"]] = rest_field(
        name="crossCurrencyInstruments"
    )
    """Get crossCurrencyInstruments."""

    @overload
    def __init__(
        self,
        *,
        credit_instruments: Optional[Dict[str, "_models.CreditInstruments"]] = None,
        cross_currency_instruments: Optional[Dict[str, "_models.CrossCurrencyInstruments"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditConstituentsDescription(_model_base.Model):
    """CreditConstituentsDescription.

    Attributes
    ----------
    bonds : list[~analyticsapi.models.BondInstrumentDescription]
        Get bonds.  The default value is None, needs to be assigned before
        using.
    credit_default_swaps : list[~analyticsapi.models.CreditDefaultSwapsInstrumentDescription]
        Get creditDefaultSwaps.  The default value is None, needs to be
        assigned before using.
    deposits : list[~analyticsapi.models.InstrumentDescription]
        Get deposits.  The default value is None, needs to be assigned before
        using.
    """

    bonds: Optional[List["_models.BondInstrumentDescription"]] = rest_field()
    """Get bonds."""
    credit_default_swaps: Optional[List["_models.CreditDefaultSwapsInstrumentDescription"]] = rest_field(
        name="creditDefaultSwaps"
    )
    """Get creditDefaultSwaps."""
    deposits: Optional[List["_models.InstrumentDescription"]] = rest_field()
    """Get deposits."""

    @overload
    def __init__(
        self,
        *,
        bonds: Optional[List["_models.BondInstrumentDescription"]] = None,
        credit_default_swaps: Optional[List["_models.CreditDefaultSwapsInstrumentDescription"]] = None,
        deposits: Optional[List["_models.InstrumentDescription"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditConstituentsOutput(_model_base.Model):
    """CreditConstituentsOutput.

    Attributes
    ----------
    credit_instruments : dict[str, ~analyticsapi.models.CreditInstrumentsOutput]
        Get creditInstruments.
    cross_currency_instruments : dict[str, ~analyticsapi.models.CrossCurrencyInstrumentsOutput]
        Get crossCurrencyInstruments.
    """

    credit_instruments: Optional[Dict[str, "_models.CreditInstrumentsOutput"]] = rest_field(name="creditInstruments")
    """Get creditInstruments."""
    cross_currency_instruments: Optional[Dict[str, "_models.CrossCurrencyInstrumentsOutput"]] = rest_field(
        name="crossCurrencyInstruments"
    )
    """Get crossCurrencyInstruments."""

    @overload
    def __init__(
        self,
        *,
        credit_instruments: Optional[Dict[str, "_models.CreditInstrumentsOutput"]] = None,
        cross_currency_instruments: Optional[Dict[str, "_models.CrossCurrencyInstrumentsOutput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveChoice(_model_base.Model):
    """The object to provide either a reference to a credit curve stored in the platform or a 3rd
    party curve.

    Attributes
    ----------
    reference : str
        The reference to a credit curve stored in the platform.
    curve : ~analyticsapi.models.CreditCurveInput
        The credit curve data.
    """

    reference: Optional[str] = rest_field()
    """The reference to a credit curve stored in the platform."""
    curve: Optional["_models.CreditCurveInput"] = rest_field()
    """The credit curve data."""

    @overload
    def __init__(
        self,
        *,
        reference: Optional[str] = None,
        curve: Optional["_models.CreditCurveInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveCreateDefinition(_model_base.Model):
    """CreditCurveCreateDefinition.

    Attributes
    ----------
    business_sector : str or ~analyticsapi.models.BusinessSectorEnum
        TRBC business sector of the economic sector. Known values are:
        "AcademicAndEducationalServices", "AppliedResources",
        "AutomobilesAndAutoParts", "BankingAndInvestmentServices", "Chemicals",
        "CollectiveInvestments", "ConsumerGoodsConglomerates",
        "CyclicalConsumerProducts", "CyclicalConsumerServices",
        "EnergyFossilFuels", "FinancialTechnologyAndInfrastructure",
        "FoodAndBeverages", "FoodAndDrugRetailing", "GovernmentActivity",
        "HealthcareServicesAndEquipment", "IndustrialAndCommercialServices",
        "IndustrialGoods", "InstitutionsAssociationsAndOrganizations",
        "Insurance", "InvestmentHoldingCompanies", "MineralResources",
        "PersonalAndHouseholdProductsAndServices",
        "PharmaceuticalsAndMedicalResearch", "RealEstate", "RenewableEnergy",
        "Retailers", "SoftwareAndITServices", "TechnologyEquipment",
        "TelecommunicationsServices", "Transportation", "Uranium", and
        "Utilities".
    country : str
        Country code of the issuer defined with Alpha-2 Code ISO 3166 country
        code convention.
    currency : str
        Bond curve currency code.
    curve_sub_type : str or ~analyticsapi.models.CurveSubTypeEnum
        Get curveSubType. Known values are: "BondCarry",
        "BreakevenInflationCurve", "CDSCreditIndex", "CapFloorVolatility",
        "CentralBankInterestRateProbability", "CommercialPaperBenchmark",
        "CorporateBondBenchmark", "CorporateBondPar", "CorporateBondSpread",
        "CorporateBondZero", "CorporateCDSCredit", "CorporateCashCredit",
        "CorporateIssuer", "Covered", "Deposit", "ForwardGovernmentBondZero",
        "ForwardGovernmentPar", "ForwardInflation", "ForwardRateAgreementZero",
        "ForwardStartingSwap", "GovernmentBenchmark",
        "GovernmentBondBenchmark", "GovernmentBondVolatility",
        "GovernmentCDSCredit", "GovernmentCashCredit",
        "GovernmentStripBenchmark", "InflationLinkedBenchmark",
        "InflationLinkedZero", "InterbankOfferRate", "InterestRateSwap",
        "InterestRateVolatility", "MunicipalBenchmark", "OvernightIndexSwap",
        "OvernightIndexSwapZero", "SemiSovereignCashCredit",
        "ShortTermInterestRateFuturesZero",
        "SolvencyIICorporateCreditSprdRating",
        "SolvencyIICoveredPfandbriefIssuer",
        "SolvencyIIFinancialCreditSprdRating",
        "SolvencyIIInterestRateSwapYield", "SolvencyIILiquiditySpread",
        "SolvencyIIPfandbriefYieldByCurrency", "SolvencyIIStructuredABSRating",
        "SolvencyIIStructuredMBSRating", "SolvencyIISwapDerivedZero",
        "SolvencyIITreasuryVersusIRSSpread", "SovereignAgencyBenchmark",
        "SwapCarry", "SwapPar", "SwapZero", "SwaptionVolatility", and
        "TreasurySpread".
    definition_expiry_date : ~datetime.date
        Get definitionExpiryDate.
    economic_sector : str or ~analyticsapi.models.EconomicSectorEnum
        TRBC economic sector of the issuer.  Available values are:
        BasicMaterials, Consumer Cyclicals, Consumer Non-Cyclicals, Energy,
        Financials, Healthcare, Industrials, Technology, Utilities. Known
        values are: "AcademicAndEducationalServices", "BasicMaterials",
        "ConsumerCyclicals", "ConsumerNonCyclicals", "Energy", "Financials",
        "GovernmentActivity", "Healthcare", "Industrials",
        "InstitutionsAssociationsAndOrganizations", "RealEstate", "Technology",
        and "Utilities".
    industry : str or ~analyticsapi.models.IndustryEnum
        TRBC industry of the industry group. Known values are:
        "AdvancedMedicalEquipmentAndTechnology", "AdvertisingAndMarketing",
        "AerospaceAndDefense", "AgriculturalChemicals", "Airlines",
        "AirportOperatorsAndServices", "Aluminum", "ApparelAndAccessories",
        "ApparelAndAccessoriesRetailers", "AppliancesToolsAndHousewares",
        "AutoAndTruckManufacturers", "AutoTruckAndMotorcycleParts",
        "AutoVehiclesPartsAndServiceRetailers", "Banks",
        "BiotechnologyAndMedicalResearch", "BlockchainAndCryptocurrency",
        "Brewers", "Broadcasting", "BusinessSupportServices",
        "BusinessSupportSupplies", "CasinosAndGaming", "CharityOrganizations",
        "CivicAndSocialOrganizations", "ClosedEndFunds", "Coal",
        "CommercialPrintingServices", "CommercialREITs", "CommodityChemicals",
        "CommunicationsAndNetworking", "ComputerAndElectronicsRetailers",
        "ComputerHardware", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConstructionSuppliesAndFixtures",
        "ConsumerGoodsConglomerates", "ConsumerLending", "ConsumerPublishing",
        "CorporateFinancialServices",
        "CourierPostalAirFreightAndLandbasedLogistics", "CrowdCollaboration",
        "DepartmentStores", "DiscountStores", "DistillersAndWineries",
        "DiversifiedChemicals", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedInvestmentServices", "DiversifiedMining",
        "DiversifiedREITs", "DrugRetailers", "ElectricUtilities",
        "ElectricalComponentsAndEquipment", "ElectronicEquipmentAndParts",
        "EmploymentServices", "EntertainmentProduction",
        "EnvironmentalOrganizations", "EnvironmentalServicesAndEquipment",
        "ExchangeTradedFunds",
        "FinancialAndCommodityMarketOperatorsAndServiceProviders",
        "FinancialTechnology", "FishingAndFarming", "FoodProcessing",
        "FoodRetailAndDistribution", "Footwear", "ForestAndWoodProducts",
        "Gold", "GovernmentAdministrationActivities",
        "GovernmentAndGovernmentFinance", "GroundFreightAndLogistics",
        "HealthcareFacilitiesAndServices", "HeavyElectricalEquipment",
        "HeavyMachineryAndVehicles", "HighwaysAndRailTracks",
        "HomeFurnishings", "HomeFurnishingsRetailers",
        "HomeImprovementProductsAndServicesRetailers", "Homebuilding",
        "HotelsMotelsAndCruiseLines", "HouseholdElectronics",
        "HouseholdProducts", "ITServicesAndConsulting",
        "IndependentPowerProducers", "IndustrialMachineryAndEquipment",
        "InsuranceFunds", "IntegratedHardwareAndSoftware",
        "IntegratedOilAndGas", "IntegratedTelecommunicationsServices",
        "InvestmentBankingAndBrokerageServices", "InvestmentHoldingCompanies",
        "InvestmentManagementAndFundOperators", "IronAndSteel",
        "LegalAndSafetyPublicServices", "LeisureAndRecreation",
        "LifeAndHealthInsurance", "ManagedHealthcare",
        "MarineFreightAndLogistics", "MarinePortServices",
        "MedicalEquipmentSuppliesAndDistribution",
        "MiningSupportServicesAndEquipment",
        "MiscellaneousEducationalServiceProviders",
        "MiscellaneousInfrastructure", "MiscellaneousSpecialtyRetailers",
        "MultilineInsuranceAndBrokers", "MultilineUtilities", "MutualFunds",
        "NationalSecurityAndInternationalAffairs", "NaturalGasUtilities",
        "NonAlcoholicBeverages", "NonGoldPreciousMetalsAndMinerals",
        "NonPaperContainersAndPackaging", "OfficeEquipment",
        "OilAndGasDrilling", "OilAndGasExplorationAndProduction",
        "OilAndGasRefiningAndMarketing", "OilAndGasTransportationServices",
        "OilRelatedServicesAndEquipment", "OnlineServices", "PaperPackaging",
        "PaperProducts", "PassengerTransportationGroundAndSea", "PensionFunds",
        "PersonalProducts", "PersonalServices", "Pharmaceuticals",
        "PhonesAndHandheldDevices", "ProfessionalAndBusinessEducation",
        "ProfessionalInformationServices", "ProfessionalOrganizations",
        "PropertyAndCasualtyInsurance",
        "RealEstateRentalDevelopmentAndOperations", "RealEstateServices",
        "RecreationalProducts", "Reinsurance", "ReligiousOrganizations",
        "RenewableEnergyEquipmentAndServices", "RenewableFuels",
        "ResidentialREITs", "RestaurantsAndBars", "SchoolCollegeAndUniversity",
        "SemiconductorEquipmentAndTesting", "Semiconductors", "Shipbuilding",
        "Software", "SpecializedREITs", "SpecialtyChemicals",
        "SpecialtyMiningAndMetals", "TextilesAndLeatherGoods",
        "TiresAndRubberProducts", "Tobacco", "ToysAndChildrenProducts",
        "UKInvestmentTrusts", "Uranium", "WaterAndRelatedUtilities", and
        "WirelessTelecommunicationsServices".
    industry_group : str or ~analyticsapi.models.IndustryGroupEnum
        TRBC industry group of the business sector. Known values are:
        "AerospaceAndDefense", "AutomobilesAndAutoParts",
        "BankingAndInvestmentServices", "BankingServices", "Beverages",
        "BiotechnologyAndMedicalResearch", "Chemicals", "Coal",
        "CollectiveInvestments", "CommunicationsAndNetworking",
        "ComputersPhonesAndHouseholdElectronics", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConsumerGoodsConglomerates",
        "ContainersAndPackaging", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedRetail", "ElectricUtilitiesAndIPPs",
        "ElectronicEquipmentAndParts", "FinancialTechnologyAndInfrastructure",
        "FoodAndDrugRetailing", "FoodAndTobacco",
        "FreightAndLogisticsServices", "GovernmentActivity",
        "HealthcareEquipmentAndSupplies", "HealthcareProvidersAndServices",
        "HomebuildingAndConstructionSupplies",
        "HotelsAndEntertainmentServices", "HouseholdGoods",
        "InstitutionsAssociationsAndOrganizations", "Insurance",
        "IntegratedHardwareAndSoftware",
        "InvestmentBankingAndInvestmentServices", "InvestmentHoldingCompanies",
        "LeisureProducts", "MachineryToolsHeavyVehiclesTrainsAndShips",
        "MediaAndPublishing", "MetalsAndMining",
        "MiscellaneousEducationalService", "MultilineUtilities",
        "NaturalGasUtilities", "OfficeEquipment", "OilAndGas",
        "OilAndGasRelatedEquipmentAndServices", "PaperAndForestProducts",
        "PassengerTransportationServices",
        "PersonalAndHouseholdProductsAndServices", "Pharmaceuticals",
        "ProfessionalAndBusinessEducation",
        "ProfessionalAndCommercialServices", "Providers",
        "RealEstateOperations", "RenewableEnergy",
        "ResidentialAndCommercialREITs", "SchoolCollegeAndUniversity",
        "SemiconductorsAndSemiconductorEquipment", "SoftwareAndITServices",
        "SpecialtyRetailers", "TelecommunicationsServices",
        "TextilesAndApparel", "TransportInfrastructure", "Uranium", and
        "WaterAndRelatedUtilities".
    is_currency_country_originator : bool
    issuer_type : str or ~analyticsapi.models.IssuerTypeEnum
        Type of the issuer. Available values are: Agency, Corporate, Munis,
        NonFinancials, Sovereign, Supranational. Known values are: "Agency",
        "Corporate", "Munis", "NonFinancials", "Sovereign", and
        "Supranational".
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        Get mainConstituentAssetClass. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    name : str
        Get name.
    rating : str or ~analyticsapi.models.RatingEnum
        Get rating. Known values are: "A", "A1", "A2", "A3", "AA", "AAA",
        "AAHigh", "AALow", "AAMinus", "AAPlus", "AHigh", "ALow", "AMinus",
        "APlus", "Aa1", "Aa2", "Aa3", "Aaa", "B", "B1", "B2", "B3", "BB",
        "BBB", "BBBHigh", "BBBLow", "BBBMinus", "BBBPlus", "BBHigh", "BBLow",
        "BBMinus", "BBPlus", "BHigh", "BLow", "BMinus", "BPlus", "Ba1", "Ba2",
        "Ba3", "Baa1", "Baa2", "Baa3", "C", "CC", "CCC", "CCCHigh", "CCCLow",
        "CCCMinus", "CCCPlus", "CCHigh", "CCLow", "CHigh", "CLow", "Ca",
        "Caa1", "Caa2", "Caa3", "D", "DD", "DDD", "F1", "F1Plus", "F2", and
        "F3".
    rating_scale_source : str or ~analyticsapi.models.RatingScaleSourceEnum
        Get ratingScaleSource. Known values are: "DBRS", "Fitch", "Moodys",
        "Refinitiv", and "SAndP".
    reference_entity : str
        Code to define the reference entity.
    reference_entity_type : str or ~analyticsapi.models.ReferenceEntityTypeEnum
        Type of the reference entity (mandatory if referenceEntity is defined).
        Available values are:   - ChainRic   - BondIsin   - BondRic   -
        OrganisationId   - Ticker. Known values are: "BondIsin", "BondRic",
        "ChainRic", "OrganisationId", and "Ticker".
    seniority : str or ~analyticsapi.models.CurvesAndSurfacesSeniorityEnum
        Get seniority. Known values are:
        "JuniorSecuredOrJuniorSubordinatedSecured",
        "JuniorUnsecuredOrJuniorSubordinatedUnsecured", "Secured",
        "SeniorNonPreferred", "SeniorPreferred", "SeniorSecured",
        "SeniorSecuredFirstAndRefundingMortgage", "SeniorSecuredFirstLien",
        "SeniorSecuredFirstMortgage",
        "SeniorSecuredGeneralAndRefundingMortgage", "SeniorSecuredMortgage",
        "SeniorSecuredSecondLien", "SeniorSecuredSecondMortgage",
        "SeniorSecuredThirdMortgage", "SeniorSubordinatedSecured",
        "SeniorSubordinatedUnsecured", "SeniorUnsecured",
        "SubordinatedSecured", "SubordinatedUnsecured", and "Unsecured".
    source : str
        Source or contributor code Default value is \\"Refinitiv\\".
    """

    business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = rest_field(name="businessSector")
    """TRBC business sector of the economic sector. Known values are:
     \"AcademicAndEducationalServices\", \"AppliedResources\", \"AutomobilesAndAutoParts\",
     \"BankingAndInvestmentServices\", \"Chemicals\", \"CollectiveInvestments\",
     \"ConsumerGoodsConglomerates\", \"CyclicalConsumerProducts\", \"CyclicalConsumerServices\",
     \"EnergyFossilFuels\", \"FinancialTechnologyAndInfrastructure\", \"FoodAndBeverages\",
     \"FoodAndDrugRetailing\", \"GovernmentActivity\", \"HealthcareServicesAndEquipment\",
     \"IndustrialAndCommercialServices\", \"IndustrialGoods\",
     \"InstitutionsAssociationsAndOrganizations\", \"Insurance\", \"InvestmentHoldingCompanies\",
     \"MineralResources\", \"PersonalAndHouseholdProductsAndServices\",
     \"PharmaceuticalsAndMedicalResearch\", \"RealEstate\", \"RenewableEnergy\", \"Retailers\",
     \"SoftwareAndITServices\", \"TechnologyEquipment\", \"TelecommunicationsServices\",
     \"Transportation\", \"Uranium\", and \"Utilities\"."""
    country: Optional[str] = rest_field()
    """Country code of the issuer defined with Alpha-2 Code ISO 3166 country code convention."""
    currency: Optional[str] = rest_field()
    """Bond curve currency code."""
    curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = rest_field(name="curveSubType")
    """Get curveSubType. Known values are: \"BondCarry\", \"BreakevenInflationCurve\",
     \"CDSCreditIndex\", \"CapFloorVolatility\", \"CentralBankInterestRateProbability\",
     \"CommercialPaperBenchmark\", \"CorporateBondBenchmark\", \"CorporateBondPar\",
     \"CorporateBondSpread\", \"CorporateBondZero\", \"CorporateCDSCredit\",
     \"CorporateCashCredit\", \"CorporateIssuer\", \"Covered\", \"Deposit\",
     \"ForwardGovernmentBondZero\", \"ForwardGovernmentPar\", \"ForwardInflation\",
     \"ForwardRateAgreementZero\", \"ForwardStartingSwap\", \"GovernmentBenchmark\",
     \"GovernmentBondBenchmark\", \"GovernmentBondVolatility\", \"GovernmentCDSCredit\",
     \"GovernmentCashCredit\", \"GovernmentStripBenchmark\", \"InflationLinkedBenchmark\",
     \"InflationLinkedZero\", \"InterbankOfferRate\", \"InterestRateSwap\",
     \"InterestRateVolatility\", \"MunicipalBenchmark\", \"OvernightIndexSwap\",
     \"OvernightIndexSwapZero\", \"SemiSovereignCashCredit\", \"ShortTermInterestRateFuturesZero\",
     \"SolvencyIICorporateCreditSprdRating\", \"SolvencyIICoveredPfandbriefIssuer\",
     \"SolvencyIIFinancialCreditSprdRating\", \"SolvencyIIInterestRateSwapYield\",
     \"SolvencyIILiquiditySpread\", \"SolvencyIIPfandbriefYieldByCurrency\",
     \"SolvencyIIStructuredABSRating\", \"SolvencyIIStructuredMBSRating\",
     \"SolvencyIISwapDerivedZero\", \"SolvencyIITreasuryVersusIRSSpread\",
     \"SovereignAgencyBenchmark\", \"SwapCarry\", \"SwapPar\", \"SwapZero\", \"SwaptionVolatility\",
     and \"TreasurySpread\"."""
    definition_expiry_date: Optional[datetime.date] = rest_field(name="definitionExpiryDate")
    """Get definitionExpiryDate."""
    economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = rest_field(name="economicSector")
    """TRBC economic sector of the issuer.  Available values are: BasicMaterials, Consumer Cyclicals,
     Consumer Non-Cyclicals, Energy, Financials, Healthcare, Industrials, Technology, Utilities.
     Known values are: \"AcademicAndEducationalServices\", \"BasicMaterials\",
     \"ConsumerCyclicals\", \"ConsumerNonCyclicals\", \"Energy\", \"Financials\",
     \"GovernmentActivity\", \"Healthcare\", \"Industrials\",
     \"InstitutionsAssociationsAndOrganizations\", \"RealEstate\", \"Technology\", and
     \"Utilities\"."""
    industry: Optional[Union[str, "_models.IndustryEnum"]] = rest_field()
    """TRBC industry of the industry group. Known values are:
     \"AdvancedMedicalEquipmentAndTechnology\", \"AdvertisingAndMarketing\",
     \"AerospaceAndDefense\", \"AgriculturalChemicals\", \"Airlines\",
     \"AirportOperatorsAndServices\", \"Aluminum\", \"ApparelAndAccessories\",
     \"ApparelAndAccessoriesRetailers\", \"AppliancesToolsAndHousewares\",
     \"AutoAndTruckManufacturers\", \"AutoTruckAndMotorcycleParts\",
     \"AutoVehiclesPartsAndServiceRetailers\", \"Banks\", \"BiotechnologyAndMedicalResearch\",
     \"BlockchainAndCryptocurrency\", \"Brewers\", \"Broadcasting\", \"BusinessSupportServices\",
     \"BusinessSupportSupplies\", \"CasinosAndGaming\", \"CharityOrganizations\",
     \"CivicAndSocialOrganizations\", \"ClosedEndFunds\", \"Coal\", \"CommercialPrintingServices\",
     \"CommercialREITs\", \"CommodityChemicals\", \"CommunicationsAndNetworking\",
     \"ComputerAndElectronicsRetailers\", \"ComputerHardware\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConstructionSuppliesAndFixtures\", \"ConsumerGoodsConglomerates\",
     \"ConsumerLending\", \"ConsumerPublishing\", \"CorporateFinancialServices\",
     \"CourierPostalAirFreightAndLandbasedLogistics\", \"CrowdCollaboration\", \"DepartmentStores\",
     \"DiscountStores\", \"DistillersAndWineries\", \"DiversifiedChemicals\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedInvestmentServices\",
     \"DiversifiedMining\", \"DiversifiedREITs\", \"DrugRetailers\", \"ElectricUtilities\",
     \"ElectricalComponentsAndEquipment\", \"ElectronicEquipmentAndParts\", \"EmploymentServices\",
     \"EntertainmentProduction\", \"EnvironmentalOrganizations\",
     \"EnvironmentalServicesAndEquipment\", \"ExchangeTradedFunds\",
     \"FinancialAndCommodityMarketOperatorsAndServiceProviders\", \"FinancialTechnology\",
     \"FishingAndFarming\", \"FoodProcessing\", \"FoodRetailAndDistribution\", \"Footwear\",
     \"ForestAndWoodProducts\", \"Gold\", \"GovernmentAdministrationActivities\",
     \"GovernmentAndGovernmentFinance\", \"GroundFreightAndLogistics\",
     \"HealthcareFacilitiesAndServices\", \"HeavyElectricalEquipment\",
     \"HeavyMachineryAndVehicles\", \"HighwaysAndRailTracks\", \"HomeFurnishings\",
     \"HomeFurnishingsRetailers\", \"HomeImprovementProductsAndServicesRetailers\",
     \"Homebuilding\", \"HotelsMotelsAndCruiseLines\", \"HouseholdElectronics\",
     \"HouseholdProducts\", \"ITServicesAndConsulting\", \"IndependentPowerProducers\",
     \"IndustrialMachineryAndEquipment\", \"InsuranceFunds\", \"IntegratedHardwareAndSoftware\",
     \"IntegratedOilAndGas\", \"IntegratedTelecommunicationsServices\",
     \"InvestmentBankingAndBrokerageServices\", \"InvestmentHoldingCompanies\",
     \"InvestmentManagementAndFundOperators\", \"IronAndSteel\", \"LegalAndSafetyPublicServices\",
     \"LeisureAndRecreation\", \"LifeAndHealthInsurance\", \"ManagedHealthcare\",
     \"MarineFreightAndLogistics\", \"MarinePortServices\",
     \"MedicalEquipmentSuppliesAndDistribution\", \"MiningSupportServicesAndEquipment\",
     \"MiscellaneousEducationalServiceProviders\", \"MiscellaneousInfrastructure\",
     \"MiscellaneousSpecialtyRetailers\", \"MultilineInsuranceAndBrokers\", \"MultilineUtilities\",
     \"MutualFunds\", \"NationalSecurityAndInternationalAffairs\", \"NaturalGasUtilities\",
     \"NonAlcoholicBeverages\", \"NonGoldPreciousMetalsAndMinerals\",
     \"NonPaperContainersAndPackaging\", \"OfficeEquipment\", \"OilAndGasDrilling\",
     \"OilAndGasExplorationAndProduction\", \"OilAndGasRefiningAndMarketing\",
     \"OilAndGasTransportationServices\", \"OilRelatedServicesAndEquipment\", \"OnlineServices\",
     \"PaperPackaging\", \"PaperProducts\", \"PassengerTransportationGroundAndSea\",
     \"PensionFunds\", \"PersonalProducts\", \"PersonalServices\", \"Pharmaceuticals\",
     \"PhonesAndHandheldDevices\", \"ProfessionalAndBusinessEducation\",
     \"ProfessionalInformationServices\", \"ProfessionalOrganizations\",
     \"PropertyAndCasualtyInsurance\", \"RealEstateRentalDevelopmentAndOperations\",
     \"RealEstateServices\", \"RecreationalProducts\", \"Reinsurance\", \"ReligiousOrganizations\",
     \"RenewableEnergyEquipmentAndServices\", \"RenewableFuels\", \"ResidentialREITs\",
     \"RestaurantsAndBars\", \"SchoolCollegeAndUniversity\", \"SemiconductorEquipmentAndTesting\",
     \"Semiconductors\", \"Shipbuilding\", \"Software\", \"SpecializedREITs\",
     \"SpecialtyChemicals\", \"SpecialtyMiningAndMetals\", \"TextilesAndLeatherGoods\",
     \"TiresAndRubberProducts\", \"Tobacco\", \"ToysAndChildrenProducts\", \"UKInvestmentTrusts\",
     \"Uranium\", \"WaterAndRelatedUtilities\", and \"WirelessTelecommunicationsServices\"."""
    industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = rest_field(name="industryGroup")
    """TRBC industry group of the business sector. Known values are: \"AerospaceAndDefense\",
     \"AutomobilesAndAutoParts\", \"BankingAndInvestmentServices\", \"BankingServices\",
     \"Beverages\", \"BiotechnologyAndMedicalResearch\", \"Chemicals\", \"Coal\",
     \"CollectiveInvestments\", \"CommunicationsAndNetworking\",
     \"ComputersPhonesAndHouseholdElectronics\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConsumerGoodsConglomerates\", \"ContainersAndPackaging\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedRetail\", \"ElectricUtilitiesAndIPPs\",
     \"ElectronicEquipmentAndParts\", \"FinancialTechnologyAndInfrastructure\",
     \"FoodAndDrugRetailing\", \"FoodAndTobacco\", \"FreightAndLogisticsServices\",
     \"GovernmentActivity\", \"HealthcareEquipmentAndSupplies\", \"HealthcareProvidersAndServices\",
     \"HomebuildingAndConstructionSupplies\", \"HotelsAndEntertainmentServices\",
     \"HouseholdGoods\", \"InstitutionsAssociationsAndOrganizations\", \"Insurance\",
     \"IntegratedHardwareAndSoftware\", \"InvestmentBankingAndInvestmentServices\",
     \"InvestmentHoldingCompanies\", \"LeisureProducts\",
     \"MachineryToolsHeavyVehiclesTrainsAndShips\", \"MediaAndPublishing\", \"MetalsAndMining\",
     \"MiscellaneousEducationalService\", \"MultilineUtilities\", \"NaturalGasUtilities\",
     \"OfficeEquipment\", \"OilAndGas\", \"OilAndGasRelatedEquipmentAndServices\",
     \"PaperAndForestProducts\", \"PassengerTransportationServices\",
     \"PersonalAndHouseholdProductsAndServices\", \"Pharmaceuticals\",
     \"ProfessionalAndBusinessEducation\", \"ProfessionalAndCommercialServices\", \"Providers\",
     \"RealEstateOperations\", \"RenewableEnergy\", \"ResidentialAndCommercialREITs\",
     \"SchoolCollegeAndUniversity\", \"SemiconductorsAndSemiconductorEquipment\",
     \"SoftwareAndITServices\", \"SpecialtyRetailers\", \"TelecommunicationsServices\",
     \"TextilesAndApparel\", \"TransportInfrastructure\", \"Uranium\", and
     \"WaterAndRelatedUtilities\"."""
    is_currency_country_originator: Optional[bool] = rest_field(name="isCurrencyCountryOriginator")
    issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = rest_field(name="issuerType")
    """Type of the issuer. Available values are: Agency, Corporate, Munis, NonFinancials, Sovereign,
     Supranational. Known values are: \"Agency\", \"Corporate\", \"Munis\", \"NonFinancials\",
     \"Sovereign\", and \"Supranational\"."""
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """Get mainConstituentAssetClass. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    name: Optional[str] = rest_field()
    """Get name."""
    rating: Optional[Union[str, "_models.RatingEnum"]] = rest_field()
    """Get rating. Known values are: \"A\", \"A1\", \"A2\", \"A3\", \"AA\", \"AAA\", \"AAHigh\",
     \"AALow\", \"AAMinus\", \"AAPlus\", \"AHigh\", \"ALow\", \"AMinus\", \"APlus\", \"Aa1\",
     \"Aa2\", \"Aa3\", \"Aaa\", \"B\", \"B1\", \"B2\", \"B3\", \"BB\", \"BBB\", \"BBBHigh\",
     \"BBBLow\", \"BBBMinus\", \"BBBPlus\", \"BBHigh\", \"BBLow\", \"BBMinus\", \"BBPlus\",
     \"BHigh\", \"BLow\", \"BMinus\", \"BPlus\", \"Ba1\", \"Ba2\", \"Ba3\", \"Baa1\", \"Baa2\",
     \"Baa3\", \"C\", \"CC\", \"CCC\", \"CCCHigh\", \"CCCLow\", \"CCCMinus\", \"CCCPlus\",
     \"CCHigh\", \"CCLow\", \"CHigh\", \"CLow\", \"Ca\", \"Caa1\", \"Caa2\", \"Caa3\", \"D\",
     \"DD\", \"DDD\", \"F1\", \"F1Plus\", \"F2\", and \"F3\"."""
    rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = rest_field(name="ratingScaleSource")
    """Get ratingScaleSource. Known values are: \"DBRS\", \"Fitch\", \"Moodys\", \"Refinitiv\", and
     \"SAndP\"."""
    reference_entity: Optional[str] = rest_field(name="referenceEntity")
    """Code to define the reference entity."""
    reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = rest_field(
        name="referenceEntityType"
    )
    """Type of the reference entity (mandatory if referenceEntity is defined). Available values are:
     - ChainRic   - BondIsin   - BondRic   - OrganisationId   - Ticker. Known values are:
     \"BondIsin\", \"BondRic\", \"ChainRic\", \"OrganisationId\", and \"Ticker\"."""
    seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = rest_field()
    """Get seniority. Known values are: \"JuniorSecuredOrJuniorSubordinatedSecured\",
     \"JuniorUnsecuredOrJuniorSubordinatedUnsecured\", \"Secured\", \"SeniorNonPreferred\",
     \"SeniorPreferred\", \"SeniorSecured\", \"SeniorSecuredFirstAndRefundingMortgage\",
     \"SeniorSecuredFirstLien\", \"SeniorSecuredFirstMortgage\",
     \"SeniorSecuredGeneralAndRefundingMortgage\", \"SeniorSecuredMortgage\",
     \"SeniorSecuredSecondLien\", \"SeniorSecuredSecondMortgage\", \"SeniorSecuredThirdMortgage\",
     \"SeniorSubordinatedSecured\", \"SeniorSubordinatedUnsecured\", \"SeniorUnsecured\",
     \"SubordinatedSecured\", \"SubordinatedUnsecured\", and \"Unsecured\"."""
    source: Optional[str] = rest_field()
    """Source or contributor code Default value is \\"Refinitiv\\"."""

    @overload
    def __init__(
        self,
        *,
        business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = None,
        country: Optional[str] = None,
        currency: Optional[str] = None,
        curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = None,
        definition_expiry_date: Optional[datetime.date] = None,
        economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = None,
        industry: Optional[Union[str, "_models.IndustryEnum"]] = None,
        industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = None,
        is_currency_country_originator: Optional[bool] = None,
        issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        name: Optional[str] = None,
        rating: Optional[Union[str, "_models.RatingEnum"]] = None,
        rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = None,
        reference_entity: Optional[str] = None,
        reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = None,
        seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveCreateRequest(_model_base.Model):
    """credit curve definition.

    Attributes
    ----------
    curve_definition : ~analyticsapi.models.CreditCurveCreateDefinition
    segments : list[~analyticsapi.models.CreditCurveInstrumentsSegment]
        Get segments.  The default value is None, needs to be assigned before
        using.
    """

    curve_definition: Optional["_models.CreditCurveCreateDefinition"] = rest_field(name="curveDefinition")
    segments: Optional[List["_models.CreditCurveInstrumentsSegment"]] = rest_field()
    """Get segments."""

    @overload
    def __init__(
        self,
        *,
        curve_definition: Optional["_models.CreditCurveCreateDefinition"] = None,
        segments: Optional[List["_models.CreditCurveInstrumentsSegment"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveDefinition(_model_base.Model):
    """CreditCurveDefinition.

    Attributes
    ----------
    business_sector : str or ~analyticsapi.models.BusinessSectorEnum
        TRBC business sector of the economic sector. Known values are:
        "AcademicAndEducationalServices", "AppliedResources",
        "AutomobilesAndAutoParts", "BankingAndInvestmentServices", "Chemicals",
        "CollectiveInvestments", "ConsumerGoodsConglomerates",
        "CyclicalConsumerProducts", "CyclicalConsumerServices",
        "EnergyFossilFuels", "FinancialTechnologyAndInfrastructure",
        "FoodAndBeverages", "FoodAndDrugRetailing", "GovernmentActivity",
        "HealthcareServicesAndEquipment", "IndustrialAndCommercialServices",
        "IndustrialGoods", "InstitutionsAssociationsAndOrganizations",
        "Insurance", "InvestmentHoldingCompanies", "MineralResources",
        "PersonalAndHouseholdProductsAndServices",
        "PharmaceuticalsAndMedicalResearch", "RealEstate", "RenewableEnergy",
        "Retailers", "SoftwareAndITServices", "TechnologyEquipment",
        "TelecommunicationsServices", "Transportation", "Uranium", and
        "Utilities".
    country : str
        Country code of the issuer defined with Alpha-2 Code ISO 3166 country
        code convention.
    credit_curve_type_fallback_logic : list[str]
        Credit curve types list used to define the fallback logic in order to
        find the best credit curve. Curves types are ordered by priority.  The
        default value is None, needs to be assigned before using.
    currency : str
        Bond curve currency code.
    curve_sub_type : str or ~analyticsapi.models.CurveSubTypeEnum
        Get curveSubType. Known values are: "BondCarry",
        "BreakevenInflationCurve", "CDSCreditIndex", "CapFloorVolatility",
        "CentralBankInterestRateProbability", "CommercialPaperBenchmark",
        "CorporateBondBenchmark", "CorporateBondPar", "CorporateBondSpread",
        "CorporateBondZero", "CorporateCDSCredit", "CorporateCashCredit",
        "CorporateIssuer", "Covered", "Deposit", "ForwardGovernmentBondZero",
        "ForwardGovernmentPar", "ForwardInflation", "ForwardRateAgreementZero",
        "ForwardStartingSwap", "GovernmentBenchmark",
        "GovernmentBondBenchmark", "GovernmentBondVolatility",
        "GovernmentCDSCredit", "GovernmentCashCredit",
        "GovernmentStripBenchmark", "InflationLinkedBenchmark",
        "InflationLinkedZero", "InterbankOfferRate", "InterestRateSwap",
        "InterestRateVolatility", "MunicipalBenchmark", "OvernightIndexSwap",
        "OvernightIndexSwapZero", "SemiSovereignCashCredit",
        "ShortTermInterestRateFuturesZero",
        "SolvencyIICorporateCreditSprdRating",
        "SolvencyIICoveredPfandbriefIssuer",
        "SolvencyIIFinancialCreditSprdRating",
        "SolvencyIIInterestRateSwapYield", "SolvencyIILiquiditySpread",
        "SolvencyIIPfandbriefYieldByCurrency", "SolvencyIIStructuredABSRating",
        "SolvencyIIStructuredMBSRating", "SolvencyIISwapDerivedZero",
        "SolvencyIITreasuryVersusIRSSpread", "SovereignAgencyBenchmark",
        "SwapCarry", "SwapPar", "SwapZero", "SwaptionVolatility", and
        "TreasurySpread".
    curve_tenors : list[str]
        User defined maturities to compute.  The default value is None, needs
        to be assigned before using.
    economic_sector : str or ~analyticsapi.models.EconomicSectorEnum
        TRBC economic sector of the issuer.  Available values are:
        BasicMaterials, Consumer Cyclicals, Consumer Non-Cyclicals, Energy,
        Financials, Healthcare, Industrials, Technology, Utilities. Known
        values are: "AcademicAndEducationalServices", "BasicMaterials",
        "ConsumerCyclicals", "ConsumerNonCyclicals", "Energy", "Financials",
        "GovernmentActivity", "Healthcare", "Industrials",
        "InstitutionsAssociationsAndOrganizations", "RealEstate", "Technology",
        and "Utilities".
    id : str
        Get id.
    industry : str or ~analyticsapi.models.IndustryEnum
        TRBC industry of the industry group. Known values are:
        "AdvancedMedicalEquipmentAndTechnology", "AdvertisingAndMarketing",
        "AerospaceAndDefense", "AgriculturalChemicals", "Airlines",
        "AirportOperatorsAndServices", "Aluminum", "ApparelAndAccessories",
        "ApparelAndAccessoriesRetailers", "AppliancesToolsAndHousewares",
        "AutoAndTruckManufacturers", "AutoTruckAndMotorcycleParts",
        "AutoVehiclesPartsAndServiceRetailers", "Banks",
        "BiotechnologyAndMedicalResearch", "BlockchainAndCryptocurrency",
        "Brewers", "Broadcasting", "BusinessSupportServices",
        "BusinessSupportSupplies", "CasinosAndGaming", "CharityOrganizations",
        "CivicAndSocialOrganizations", "ClosedEndFunds", "Coal",
        "CommercialPrintingServices", "CommercialREITs", "CommodityChemicals",
        "CommunicationsAndNetworking", "ComputerAndElectronicsRetailers",
        "ComputerHardware", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConstructionSuppliesAndFixtures",
        "ConsumerGoodsConglomerates", "ConsumerLending", "ConsumerPublishing",
        "CorporateFinancialServices",
        "CourierPostalAirFreightAndLandbasedLogistics", "CrowdCollaboration",
        "DepartmentStores", "DiscountStores", "DistillersAndWineries",
        "DiversifiedChemicals", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedInvestmentServices", "DiversifiedMining",
        "DiversifiedREITs", "DrugRetailers", "ElectricUtilities",
        "ElectricalComponentsAndEquipment", "ElectronicEquipmentAndParts",
        "EmploymentServices", "EntertainmentProduction",
        "EnvironmentalOrganizations", "EnvironmentalServicesAndEquipment",
        "ExchangeTradedFunds",
        "FinancialAndCommodityMarketOperatorsAndServiceProviders",
        "FinancialTechnology", "FishingAndFarming", "FoodProcessing",
        "FoodRetailAndDistribution", "Footwear", "ForestAndWoodProducts",
        "Gold", "GovernmentAdministrationActivities",
        "GovernmentAndGovernmentFinance", "GroundFreightAndLogistics",
        "HealthcareFacilitiesAndServices", "HeavyElectricalEquipment",
        "HeavyMachineryAndVehicles", "HighwaysAndRailTracks",
        "HomeFurnishings", "HomeFurnishingsRetailers",
        "HomeImprovementProductsAndServicesRetailers", "Homebuilding",
        "HotelsMotelsAndCruiseLines", "HouseholdElectronics",
        "HouseholdProducts", "ITServicesAndConsulting",
        "IndependentPowerProducers", "IndustrialMachineryAndEquipment",
        "InsuranceFunds", "IntegratedHardwareAndSoftware",
        "IntegratedOilAndGas", "IntegratedTelecommunicationsServices",
        "InvestmentBankingAndBrokerageServices", "InvestmentHoldingCompanies",
        "InvestmentManagementAndFundOperators", "IronAndSteel",
        "LegalAndSafetyPublicServices", "LeisureAndRecreation",
        "LifeAndHealthInsurance", "ManagedHealthcare",
        "MarineFreightAndLogistics", "MarinePortServices",
        "MedicalEquipmentSuppliesAndDistribution",
        "MiningSupportServicesAndEquipment",
        "MiscellaneousEducationalServiceProviders",
        "MiscellaneousInfrastructure", "MiscellaneousSpecialtyRetailers",
        "MultilineInsuranceAndBrokers", "MultilineUtilities", "MutualFunds",
        "NationalSecurityAndInternationalAffairs", "NaturalGasUtilities",
        "NonAlcoholicBeverages", "NonGoldPreciousMetalsAndMinerals",
        "NonPaperContainersAndPackaging", "OfficeEquipment",
        "OilAndGasDrilling", "OilAndGasExplorationAndProduction",
        "OilAndGasRefiningAndMarketing", "OilAndGasTransportationServices",
        "OilRelatedServicesAndEquipment", "OnlineServices", "PaperPackaging",
        "PaperProducts", "PassengerTransportationGroundAndSea", "PensionFunds",
        "PersonalProducts", "PersonalServices", "Pharmaceuticals",
        "PhonesAndHandheldDevices", "ProfessionalAndBusinessEducation",
        "ProfessionalInformationServices", "ProfessionalOrganizations",
        "PropertyAndCasualtyInsurance",
        "RealEstateRentalDevelopmentAndOperations", "RealEstateServices",
        "RecreationalProducts", "Reinsurance", "ReligiousOrganizations",
        "RenewableEnergyEquipmentAndServices", "RenewableFuels",
        "ResidentialREITs", "RestaurantsAndBars", "SchoolCollegeAndUniversity",
        "SemiconductorEquipmentAndTesting", "Semiconductors", "Shipbuilding",
        "Software", "SpecializedREITs", "SpecialtyChemicals",
        "SpecialtyMiningAndMetals", "TextilesAndLeatherGoods",
        "TiresAndRubberProducts", "Tobacco", "ToysAndChildrenProducts",
        "UKInvestmentTrusts", "Uranium", "WaterAndRelatedUtilities", and
        "WirelessTelecommunicationsServices".
    industry_group : str or ~analyticsapi.models.IndustryGroupEnum
        TRBC industry group of the business sector. Known values are:
        "AerospaceAndDefense", "AutomobilesAndAutoParts",
        "BankingAndInvestmentServices", "BankingServices", "Beverages",
        "BiotechnologyAndMedicalResearch", "Chemicals", "Coal",
        "CollectiveInvestments", "CommunicationsAndNetworking",
        "ComputersPhonesAndHouseholdElectronics", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConsumerGoodsConglomerates",
        "ContainersAndPackaging", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedRetail", "ElectricUtilitiesAndIPPs",
        "ElectronicEquipmentAndParts", "FinancialTechnologyAndInfrastructure",
        "FoodAndDrugRetailing", "FoodAndTobacco",
        "FreightAndLogisticsServices", "GovernmentActivity",
        "HealthcareEquipmentAndSupplies", "HealthcareProvidersAndServices",
        "HomebuildingAndConstructionSupplies",
        "HotelsAndEntertainmentServices", "HouseholdGoods",
        "InstitutionsAssociationsAndOrganizations", "Insurance",
        "IntegratedHardwareAndSoftware",
        "InvestmentBankingAndInvestmentServices", "InvestmentHoldingCompanies",
        "LeisureProducts", "MachineryToolsHeavyVehiclesTrainsAndShips",
        "MediaAndPublishing", "MetalsAndMining",
        "MiscellaneousEducationalService", "MultilineUtilities",
        "NaturalGasUtilities", "OfficeEquipment", "OilAndGas",
        "OilAndGasRelatedEquipmentAndServices", "PaperAndForestProducts",
        "PassengerTransportationServices",
        "PersonalAndHouseholdProductsAndServices", "Pharmaceuticals",
        "ProfessionalAndBusinessEducation",
        "ProfessionalAndCommercialServices", "Providers",
        "RealEstateOperations", "RenewableEnergy",
        "ResidentialAndCommercialREITs", "SchoolCollegeAndUniversity",
        "SemiconductorsAndSemiconductorEquipment", "SoftwareAndITServices",
        "SpecialtyRetailers", "TelecommunicationsServices",
        "TextilesAndApparel", "TransportInfrastructure", "Uranium", and
        "WaterAndRelatedUtilities".
    is_currency_country_originator : bool
    issuer_type : str or ~analyticsapi.models.IssuerTypeEnum
        Type of the issuer. Available values are: Agency, Corporate, Munis,
        NonFinancials, Sovereign, Supranational. Known values are: "Agency",
        "Corporate", "Munis", "NonFinancials", "Sovereign", and
        "Supranational".
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        Get mainConstituentAssetClass. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    name : str
        Get name.
    rating : str or ~analyticsapi.models.RatingEnum
        Get rating. Known values are: "A", "A1", "A2", "A3", "AA", "AAA",
        "AAHigh", "AALow", "AAMinus", "AAPlus", "AHigh", "ALow", "AMinus",
        "APlus", "Aa1", "Aa2", "Aa3", "Aaa", "B", "B1", "B2", "B3", "BB",
        "BBB", "BBBHigh", "BBBLow", "BBBMinus", "BBBPlus", "BBHigh", "BBLow",
        "BBMinus", "BBPlus", "BHigh", "BLow", "BMinus", "BPlus", "Ba1", "Ba2",
        "Ba3", "Baa1", "Baa2", "Baa3", "C", "CC", "CCC", "CCCHigh", "CCCLow",
        "CCCMinus", "CCCPlus", "CCHigh", "CCLow", "CHigh", "CLow", "Ca",
        "Caa1", "Caa2", "Caa3", "D", "DD", "DDD", "F1", "F1Plus", "F2", and
        "F3".
    rating_scale_source : str or ~analyticsapi.models.RatingScaleSourceEnum
        Get ratingScaleSource. Known values are: "DBRS", "Fitch", "Moodys",
        "Refinitiv", and "SAndP".
    reference_entity : str
        Code to define the reference entity.
    reference_entity_type : str or ~analyticsapi.models.ReferenceEntityTypeEnum
        Type of the reference entity (mandatory if referenceEntity is defined).
        Available values are:   - ChainRic   - BondIsin   - BondRic   -
        OrganisationId   - Ticker. Known values are: "BondIsin", "BondRic",
        "ChainRic", "OrganisationId", and "Ticker".
    seniority : str or ~analyticsapi.models.CurvesAndSurfacesSeniorityEnum
        Get seniority. Known values are:
        "JuniorSecuredOrJuniorSubordinatedSecured",
        "JuniorUnsecuredOrJuniorSubordinatedUnsecured", "Secured",
        "SeniorNonPreferred", "SeniorPreferred", "SeniorSecured",
        "SeniorSecuredFirstAndRefundingMortgage", "SeniorSecuredFirstLien",
        "SeniorSecuredFirstMortgage",
        "SeniorSecuredGeneralAndRefundingMortgage", "SeniorSecuredMortgage",
        "SeniorSecuredSecondLien", "SeniorSecuredSecondMortgage",
        "SeniorSecuredThirdMortgage", "SeniorSubordinatedSecured",
        "SeniorSubordinatedUnsecured", "SeniorUnsecured",
        "SubordinatedSecured", "SubordinatedUnsecured", and "Unsecured".
    source : str
        Source or contributor code Default value is \\"Refinitiv\\".
    """

    business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = rest_field(name="businessSector")
    """TRBC business sector of the economic sector. Known values are:
     \"AcademicAndEducationalServices\", \"AppliedResources\", \"AutomobilesAndAutoParts\",
     \"BankingAndInvestmentServices\", \"Chemicals\", \"CollectiveInvestments\",
     \"ConsumerGoodsConglomerates\", \"CyclicalConsumerProducts\", \"CyclicalConsumerServices\",
     \"EnergyFossilFuels\", \"FinancialTechnologyAndInfrastructure\", \"FoodAndBeverages\",
     \"FoodAndDrugRetailing\", \"GovernmentActivity\", \"HealthcareServicesAndEquipment\",
     \"IndustrialAndCommercialServices\", \"IndustrialGoods\",
     \"InstitutionsAssociationsAndOrganizations\", \"Insurance\", \"InvestmentHoldingCompanies\",
     \"MineralResources\", \"PersonalAndHouseholdProductsAndServices\",
     \"PharmaceuticalsAndMedicalResearch\", \"RealEstate\", \"RenewableEnergy\", \"Retailers\",
     \"SoftwareAndITServices\", \"TechnologyEquipment\", \"TelecommunicationsServices\",
     \"Transportation\", \"Uranium\", and \"Utilities\"."""
    country: Optional[str] = rest_field()
    """Country code of the issuer defined with Alpha-2 Code ISO 3166 country code convention."""
    credit_curve_type_fallback_logic: Optional[List[str]] = rest_field(name="creditCurveTypeFallbackLogic")
    """Credit curve types list used to define the fallback logic in order to find the best credit
     curve. Curves types are ordered by priority."""
    currency: Optional[str] = rest_field()
    """Bond curve currency code."""
    curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = rest_field(name="curveSubType")
    """Get curveSubType. Known values are: \"BondCarry\", \"BreakevenInflationCurve\",
     \"CDSCreditIndex\", \"CapFloorVolatility\", \"CentralBankInterestRateProbability\",
     \"CommercialPaperBenchmark\", \"CorporateBondBenchmark\", \"CorporateBondPar\",
     \"CorporateBondSpread\", \"CorporateBondZero\", \"CorporateCDSCredit\",
     \"CorporateCashCredit\", \"CorporateIssuer\", \"Covered\", \"Deposit\",
     \"ForwardGovernmentBondZero\", \"ForwardGovernmentPar\", \"ForwardInflation\",
     \"ForwardRateAgreementZero\", \"ForwardStartingSwap\", \"GovernmentBenchmark\",
     \"GovernmentBondBenchmark\", \"GovernmentBondVolatility\", \"GovernmentCDSCredit\",
     \"GovernmentCashCredit\", \"GovernmentStripBenchmark\", \"InflationLinkedBenchmark\",
     \"InflationLinkedZero\", \"InterbankOfferRate\", \"InterestRateSwap\",
     \"InterestRateVolatility\", \"MunicipalBenchmark\", \"OvernightIndexSwap\",
     \"OvernightIndexSwapZero\", \"SemiSovereignCashCredit\", \"ShortTermInterestRateFuturesZero\",
     \"SolvencyIICorporateCreditSprdRating\", \"SolvencyIICoveredPfandbriefIssuer\",
     \"SolvencyIIFinancialCreditSprdRating\", \"SolvencyIIInterestRateSwapYield\",
     \"SolvencyIILiquiditySpread\", \"SolvencyIIPfandbriefYieldByCurrency\",
     \"SolvencyIIStructuredABSRating\", \"SolvencyIIStructuredMBSRating\",
     \"SolvencyIISwapDerivedZero\", \"SolvencyIITreasuryVersusIRSSpread\",
     \"SovereignAgencyBenchmark\", \"SwapCarry\", \"SwapPar\", \"SwapZero\", \"SwaptionVolatility\",
     and \"TreasurySpread\"."""
    curve_tenors: Optional[List[str]] = rest_field(name="curveTenors")
    """User defined maturities to compute."""
    economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = rest_field(name="economicSector")
    """TRBC economic sector of the issuer.  Available values are: BasicMaterials, Consumer Cyclicals,
     Consumer Non-Cyclicals, Energy, Financials, Healthcare, Industrials, Technology, Utilities.
     Known values are: \"AcademicAndEducationalServices\", \"BasicMaterials\",
     \"ConsumerCyclicals\", \"ConsumerNonCyclicals\", \"Energy\", \"Financials\",
     \"GovernmentActivity\", \"Healthcare\", \"Industrials\",
     \"InstitutionsAssociationsAndOrganizations\", \"RealEstate\", \"Technology\", and
     \"Utilities\"."""
    id: Optional[str] = rest_field()
    """Get id."""
    industry: Optional[Union[str, "_models.IndustryEnum"]] = rest_field()
    """TRBC industry of the industry group. Known values are:
     \"AdvancedMedicalEquipmentAndTechnology\", \"AdvertisingAndMarketing\",
     \"AerospaceAndDefense\", \"AgriculturalChemicals\", \"Airlines\",
     \"AirportOperatorsAndServices\", \"Aluminum\", \"ApparelAndAccessories\",
     \"ApparelAndAccessoriesRetailers\", \"AppliancesToolsAndHousewares\",
     \"AutoAndTruckManufacturers\", \"AutoTruckAndMotorcycleParts\",
     \"AutoVehiclesPartsAndServiceRetailers\", \"Banks\", \"BiotechnologyAndMedicalResearch\",
     \"BlockchainAndCryptocurrency\", \"Brewers\", \"Broadcasting\", \"BusinessSupportServices\",
     \"BusinessSupportSupplies\", \"CasinosAndGaming\", \"CharityOrganizations\",
     \"CivicAndSocialOrganizations\", \"ClosedEndFunds\", \"Coal\", \"CommercialPrintingServices\",
     \"CommercialREITs\", \"CommodityChemicals\", \"CommunicationsAndNetworking\",
     \"ComputerAndElectronicsRetailers\", \"ComputerHardware\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConstructionSuppliesAndFixtures\", \"ConsumerGoodsConglomerates\",
     \"ConsumerLending\", \"ConsumerPublishing\", \"CorporateFinancialServices\",
     \"CourierPostalAirFreightAndLandbasedLogistics\", \"CrowdCollaboration\", \"DepartmentStores\",
     \"DiscountStores\", \"DistillersAndWineries\", \"DiversifiedChemicals\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedInvestmentServices\",
     \"DiversifiedMining\", \"DiversifiedREITs\", \"DrugRetailers\", \"ElectricUtilities\",
     \"ElectricalComponentsAndEquipment\", \"ElectronicEquipmentAndParts\", \"EmploymentServices\",
     \"EntertainmentProduction\", \"EnvironmentalOrganizations\",
     \"EnvironmentalServicesAndEquipment\", \"ExchangeTradedFunds\",
     \"FinancialAndCommodityMarketOperatorsAndServiceProviders\", \"FinancialTechnology\",
     \"FishingAndFarming\", \"FoodProcessing\", \"FoodRetailAndDistribution\", \"Footwear\",
     \"ForestAndWoodProducts\", \"Gold\", \"GovernmentAdministrationActivities\",
     \"GovernmentAndGovernmentFinance\", \"GroundFreightAndLogistics\",
     \"HealthcareFacilitiesAndServices\", \"HeavyElectricalEquipment\",
     \"HeavyMachineryAndVehicles\", \"HighwaysAndRailTracks\", \"HomeFurnishings\",
     \"HomeFurnishingsRetailers\", \"HomeImprovementProductsAndServicesRetailers\",
     \"Homebuilding\", \"HotelsMotelsAndCruiseLines\", \"HouseholdElectronics\",
     \"HouseholdProducts\", \"ITServicesAndConsulting\", \"IndependentPowerProducers\",
     \"IndustrialMachineryAndEquipment\", \"InsuranceFunds\", \"IntegratedHardwareAndSoftware\",
     \"IntegratedOilAndGas\", \"IntegratedTelecommunicationsServices\",
     \"InvestmentBankingAndBrokerageServices\", \"InvestmentHoldingCompanies\",
     \"InvestmentManagementAndFundOperators\", \"IronAndSteel\", \"LegalAndSafetyPublicServices\",
     \"LeisureAndRecreation\", \"LifeAndHealthInsurance\", \"ManagedHealthcare\",
     \"MarineFreightAndLogistics\", \"MarinePortServices\",
     \"MedicalEquipmentSuppliesAndDistribution\", \"MiningSupportServicesAndEquipment\",
     \"MiscellaneousEducationalServiceProviders\", \"MiscellaneousInfrastructure\",
     \"MiscellaneousSpecialtyRetailers\", \"MultilineInsuranceAndBrokers\", \"MultilineUtilities\",
     \"MutualFunds\", \"NationalSecurityAndInternationalAffairs\", \"NaturalGasUtilities\",
     \"NonAlcoholicBeverages\", \"NonGoldPreciousMetalsAndMinerals\",
     \"NonPaperContainersAndPackaging\", \"OfficeEquipment\", \"OilAndGasDrilling\",
     \"OilAndGasExplorationAndProduction\", \"OilAndGasRefiningAndMarketing\",
     \"OilAndGasTransportationServices\", \"OilRelatedServicesAndEquipment\", \"OnlineServices\",
     \"PaperPackaging\", \"PaperProducts\", \"PassengerTransportationGroundAndSea\",
     \"PensionFunds\", \"PersonalProducts\", \"PersonalServices\", \"Pharmaceuticals\",
     \"PhonesAndHandheldDevices\", \"ProfessionalAndBusinessEducation\",
     \"ProfessionalInformationServices\", \"ProfessionalOrganizations\",
     \"PropertyAndCasualtyInsurance\", \"RealEstateRentalDevelopmentAndOperations\",
     \"RealEstateServices\", \"RecreationalProducts\", \"Reinsurance\", \"ReligiousOrganizations\",
     \"RenewableEnergyEquipmentAndServices\", \"RenewableFuels\", \"ResidentialREITs\",
     \"RestaurantsAndBars\", \"SchoolCollegeAndUniversity\", \"SemiconductorEquipmentAndTesting\",
     \"Semiconductors\", \"Shipbuilding\", \"Software\", \"SpecializedREITs\",
     \"SpecialtyChemicals\", \"SpecialtyMiningAndMetals\", \"TextilesAndLeatherGoods\",
     \"TiresAndRubberProducts\", \"Tobacco\", \"ToysAndChildrenProducts\", \"UKInvestmentTrusts\",
     \"Uranium\", \"WaterAndRelatedUtilities\", and \"WirelessTelecommunicationsServices\"."""
    industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = rest_field(name="industryGroup")
    """TRBC industry group of the business sector. Known values are: \"AerospaceAndDefense\",
     \"AutomobilesAndAutoParts\", \"BankingAndInvestmentServices\", \"BankingServices\",
     \"Beverages\", \"BiotechnologyAndMedicalResearch\", \"Chemicals\", \"Coal\",
     \"CollectiveInvestments\", \"CommunicationsAndNetworking\",
     \"ComputersPhonesAndHouseholdElectronics\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConsumerGoodsConglomerates\", \"ContainersAndPackaging\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedRetail\", \"ElectricUtilitiesAndIPPs\",
     \"ElectronicEquipmentAndParts\", \"FinancialTechnologyAndInfrastructure\",
     \"FoodAndDrugRetailing\", \"FoodAndTobacco\", \"FreightAndLogisticsServices\",
     \"GovernmentActivity\", \"HealthcareEquipmentAndSupplies\", \"HealthcareProvidersAndServices\",
     \"HomebuildingAndConstructionSupplies\", \"HotelsAndEntertainmentServices\",
     \"HouseholdGoods\", \"InstitutionsAssociationsAndOrganizations\", \"Insurance\",
     \"IntegratedHardwareAndSoftware\", \"InvestmentBankingAndInvestmentServices\",
     \"InvestmentHoldingCompanies\", \"LeisureProducts\",
     \"MachineryToolsHeavyVehiclesTrainsAndShips\", \"MediaAndPublishing\", \"MetalsAndMining\",
     \"MiscellaneousEducationalService\", \"MultilineUtilities\", \"NaturalGasUtilities\",
     \"OfficeEquipment\", \"OilAndGas\", \"OilAndGasRelatedEquipmentAndServices\",
     \"PaperAndForestProducts\", \"PassengerTransportationServices\",
     \"PersonalAndHouseholdProductsAndServices\", \"Pharmaceuticals\",
     \"ProfessionalAndBusinessEducation\", \"ProfessionalAndCommercialServices\", \"Providers\",
     \"RealEstateOperations\", \"RenewableEnergy\", \"ResidentialAndCommercialREITs\",
     \"SchoolCollegeAndUniversity\", \"SemiconductorsAndSemiconductorEquipment\",
     \"SoftwareAndITServices\", \"SpecialtyRetailers\", \"TelecommunicationsServices\",
     \"TextilesAndApparel\", \"TransportInfrastructure\", \"Uranium\", and
     \"WaterAndRelatedUtilities\"."""
    is_currency_country_originator: Optional[bool] = rest_field(name="isCurrencyCountryOriginator")
    issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = rest_field(name="issuerType")
    """Type of the issuer. Available values are: Agency, Corporate, Munis, NonFinancials, Sovereign,
     Supranational. Known values are: \"Agency\", \"Corporate\", \"Munis\", \"NonFinancials\",
     \"Sovereign\", and \"Supranational\"."""
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """Get mainConstituentAssetClass. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    name: Optional[str] = rest_field()
    """Get name."""
    rating: Optional[Union[str, "_models.RatingEnum"]] = rest_field()
    """Get rating. Known values are: \"A\", \"A1\", \"A2\", \"A3\", \"AA\", \"AAA\", \"AAHigh\",
     \"AALow\", \"AAMinus\", \"AAPlus\", \"AHigh\", \"ALow\", \"AMinus\", \"APlus\", \"Aa1\",
     \"Aa2\", \"Aa3\", \"Aaa\", \"B\", \"B1\", \"B2\", \"B3\", \"BB\", \"BBB\", \"BBBHigh\",
     \"BBBLow\", \"BBBMinus\", \"BBBPlus\", \"BBHigh\", \"BBLow\", \"BBMinus\", \"BBPlus\",
     \"BHigh\", \"BLow\", \"BMinus\", \"BPlus\", \"Ba1\", \"Ba2\", \"Ba3\", \"Baa1\", \"Baa2\",
     \"Baa3\", \"C\", \"CC\", \"CCC\", \"CCCHigh\", \"CCCLow\", \"CCCMinus\", \"CCCPlus\",
     \"CCHigh\", \"CCLow\", \"CHigh\", \"CLow\", \"Ca\", \"Caa1\", \"Caa2\", \"Caa3\", \"D\",
     \"DD\", \"DDD\", \"F1\", \"F1Plus\", \"F2\", and \"F3\"."""
    rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = rest_field(name="ratingScaleSource")
    """Get ratingScaleSource. Known values are: \"DBRS\", \"Fitch\", \"Moodys\", \"Refinitiv\", and
     \"SAndP\"."""
    reference_entity: Optional[str] = rest_field(name="referenceEntity")
    """Code to define the reference entity."""
    reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = rest_field(
        name="referenceEntityType"
    )
    """Type of the reference entity (mandatory if referenceEntity is defined). Available values are:
     - ChainRic   - BondIsin   - BondRic   - OrganisationId   - Ticker. Known values are:
     \"BondIsin\", \"BondRic\", \"ChainRic\", \"OrganisationId\", and \"Ticker\"."""
    seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = rest_field()
    """Get seniority. Known values are: \"JuniorSecuredOrJuniorSubordinatedSecured\",
     \"JuniorUnsecuredOrJuniorSubordinatedUnsecured\", \"Secured\", \"SeniorNonPreferred\",
     \"SeniorPreferred\", \"SeniorSecured\", \"SeniorSecuredFirstAndRefundingMortgage\",
     \"SeniorSecuredFirstLien\", \"SeniorSecuredFirstMortgage\",
     \"SeniorSecuredGeneralAndRefundingMortgage\", \"SeniorSecuredMortgage\",
     \"SeniorSecuredSecondLien\", \"SeniorSecuredSecondMortgage\", \"SeniorSecuredThirdMortgage\",
     \"SeniorSubordinatedSecured\", \"SeniorSubordinatedUnsecured\", \"SeniorUnsecured\",
     \"SubordinatedSecured\", \"SubordinatedUnsecured\", and \"Unsecured\"."""
    source: Optional[str] = rest_field()
    """Source or contributor code Default value is \\"Refinitiv\\"."""

    @overload
    def __init__(
        self,
        *,
        business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = None,
        country: Optional[str] = None,
        credit_curve_type_fallback_logic: Optional[List[str]] = None,
        currency: Optional[str] = None,
        curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = None,
        curve_tenors: Optional[List[str]] = None,
        economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        industry: Optional[Union[str, "_models.IndustryEnum"]] = None,
        industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = None,
        is_currency_country_originator: Optional[bool] = None,
        issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        name: Optional[str] = None,
        rating: Optional[Union[str, "_models.RatingEnum"]] = None,
        rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = None,
        reference_entity: Optional[str] = None,
        reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = None,
        seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveDefinitionDescription(_model_base.Model):
    """CreditCurveDefinitionDescription.

    Attributes
    ----------
    business_sector : str or ~analyticsapi.models.BusinessSectorEnum
        TRBC business sector of the economic sector. Known values are:
        "AcademicAndEducationalServices", "AppliedResources",
        "AutomobilesAndAutoParts", "BankingAndInvestmentServices", "Chemicals",
        "CollectiveInvestments", "ConsumerGoodsConglomerates",
        "CyclicalConsumerProducts", "CyclicalConsumerServices",
        "EnergyFossilFuels", "FinancialTechnologyAndInfrastructure",
        "FoodAndBeverages", "FoodAndDrugRetailing", "GovernmentActivity",
        "HealthcareServicesAndEquipment", "IndustrialAndCommercialServices",
        "IndustrialGoods", "InstitutionsAssociationsAndOrganizations",
        "Insurance", "InvestmentHoldingCompanies", "MineralResources",
        "PersonalAndHouseholdProductsAndServices",
        "PharmaceuticalsAndMedicalResearch", "RealEstate", "RenewableEnergy",
        "Retailers", "SoftwareAndITServices", "TechnologyEquipment",
        "TelecommunicationsServices", "Transportation", "Uranium", and
        "Utilities".
    country : str
        Country code of the issuer defined with Alpha-2 Code ISO 3166 country
        code convention.
    currency : str
        Bond curve currency code.
    curve_sub_type : str or ~analyticsapi.models.CurveSubTypeEnum
        Get curveSubType. Known values are: "BondCarry",
        "BreakevenInflationCurve", "CDSCreditIndex", "CapFloorVolatility",
        "CentralBankInterestRateProbability", "CommercialPaperBenchmark",
        "CorporateBondBenchmark", "CorporateBondPar", "CorporateBondSpread",
        "CorporateBondZero", "CorporateCDSCredit", "CorporateCashCredit",
        "CorporateIssuer", "Covered", "Deposit", "ForwardGovernmentBondZero",
        "ForwardGovernmentPar", "ForwardInflation", "ForwardRateAgreementZero",
        "ForwardStartingSwap", "GovernmentBenchmark",
        "GovernmentBondBenchmark", "GovernmentBondVolatility",
        "GovernmentCDSCredit", "GovernmentCashCredit",
        "GovernmentStripBenchmark", "InflationLinkedBenchmark",
        "InflationLinkedZero", "InterbankOfferRate", "InterestRateSwap",
        "InterestRateVolatility", "MunicipalBenchmark", "OvernightIndexSwap",
        "OvernightIndexSwapZero", "SemiSovereignCashCredit",
        "ShortTermInterestRateFuturesZero",
        "SolvencyIICorporateCreditSprdRating",
        "SolvencyIICoveredPfandbriefIssuer",
        "SolvencyIIFinancialCreditSprdRating",
        "SolvencyIIInterestRateSwapYield", "SolvencyIILiquiditySpread",
        "SolvencyIIPfandbriefYieldByCurrency", "SolvencyIIStructuredABSRating",
        "SolvencyIIStructuredMBSRating", "SolvencyIISwapDerivedZero",
        "SolvencyIITreasuryVersusIRSSpread", "SovereignAgencyBenchmark",
        "SwapCarry", "SwapPar", "SwapZero", "SwaptionVolatility", and
        "TreasurySpread".
    definition_expiry_date : ~datetime.date
        Get definitionExpiryDate.
    economic_sector : str or ~analyticsapi.models.EconomicSectorEnum
        TRBC economic sector of the issuer.  Available values are:
        BasicMaterials, Consumer Cyclicals, Consumer Non-Cyclicals, Energy,
        Financials, Healthcare, Industrials, Technology, Utilities. Known
        values are: "AcademicAndEducationalServices", "BasicMaterials",
        "ConsumerCyclicals", "ConsumerNonCyclicals", "Energy", "Financials",
        "GovernmentActivity", "Healthcare", "Industrials",
        "InstitutionsAssociationsAndOrganizations", "RealEstate", "Technology",
        and "Utilities".
    first_historical_availability_date : ~datetime.date
        The date starting from which the definition of the curve can be used.
        The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01').
    id : str
        Id of the curve definition.
    industry : str or ~analyticsapi.models.IndustryEnum
        TRBC industry of the industry group. Known values are:
        "AdvancedMedicalEquipmentAndTechnology", "AdvertisingAndMarketing",
        "AerospaceAndDefense", "AgriculturalChemicals", "Airlines",
        "AirportOperatorsAndServices", "Aluminum", "ApparelAndAccessories",
        "ApparelAndAccessoriesRetailers", "AppliancesToolsAndHousewares",
        "AutoAndTruckManufacturers", "AutoTruckAndMotorcycleParts",
        "AutoVehiclesPartsAndServiceRetailers", "Banks",
        "BiotechnologyAndMedicalResearch", "BlockchainAndCryptocurrency",
        "Brewers", "Broadcasting", "BusinessSupportServices",
        "BusinessSupportSupplies", "CasinosAndGaming", "CharityOrganizations",
        "CivicAndSocialOrganizations", "ClosedEndFunds", "Coal",
        "CommercialPrintingServices", "CommercialREITs", "CommodityChemicals",
        "CommunicationsAndNetworking", "ComputerAndElectronicsRetailers",
        "ComputerHardware", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConstructionSuppliesAndFixtures",
        "ConsumerGoodsConglomerates", "ConsumerLending", "ConsumerPublishing",
        "CorporateFinancialServices",
        "CourierPostalAirFreightAndLandbasedLogistics", "CrowdCollaboration",
        "DepartmentStores", "DiscountStores", "DistillersAndWineries",
        "DiversifiedChemicals", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedInvestmentServices", "DiversifiedMining",
        "DiversifiedREITs", "DrugRetailers", "ElectricUtilities",
        "ElectricalComponentsAndEquipment", "ElectronicEquipmentAndParts",
        "EmploymentServices", "EntertainmentProduction",
        "EnvironmentalOrganizations", "EnvironmentalServicesAndEquipment",
        "ExchangeTradedFunds",
        "FinancialAndCommodityMarketOperatorsAndServiceProviders",
        "FinancialTechnology", "FishingAndFarming", "FoodProcessing",
        "FoodRetailAndDistribution", "Footwear", "ForestAndWoodProducts",
        "Gold", "GovernmentAdministrationActivities",
        "GovernmentAndGovernmentFinance", "GroundFreightAndLogistics",
        "HealthcareFacilitiesAndServices", "HeavyElectricalEquipment",
        "HeavyMachineryAndVehicles", "HighwaysAndRailTracks",
        "HomeFurnishings", "HomeFurnishingsRetailers",
        "HomeImprovementProductsAndServicesRetailers", "Homebuilding",
        "HotelsMotelsAndCruiseLines", "HouseholdElectronics",
        "HouseholdProducts", "ITServicesAndConsulting",
        "IndependentPowerProducers", "IndustrialMachineryAndEquipment",
        "InsuranceFunds", "IntegratedHardwareAndSoftware",
        "IntegratedOilAndGas", "IntegratedTelecommunicationsServices",
        "InvestmentBankingAndBrokerageServices", "InvestmentHoldingCompanies",
        "InvestmentManagementAndFundOperators", "IronAndSteel",
        "LegalAndSafetyPublicServices", "LeisureAndRecreation",
        "LifeAndHealthInsurance", "ManagedHealthcare",
        "MarineFreightAndLogistics", "MarinePortServices",
        "MedicalEquipmentSuppliesAndDistribution",
        "MiningSupportServicesAndEquipment",
        "MiscellaneousEducationalServiceProviders",
        "MiscellaneousInfrastructure", "MiscellaneousSpecialtyRetailers",
        "MultilineInsuranceAndBrokers", "MultilineUtilities", "MutualFunds",
        "NationalSecurityAndInternationalAffairs", "NaturalGasUtilities",
        "NonAlcoholicBeverages", "NonGoldPreciousMetalsAndMinerals",
        "NonPaperContainersAndPackaging", "OfficeEquipment",
        "OilAndGasDrilling", "OilAndGasExplorationAndProduction",
        "OilAndGasRefiningAndMarketing", "OilAndGasTransportationServices",
        "OilRelatedServicesAndEquipment", "OnlineServices", "PaperPackaging",
        "PaperProducts", "PassengerTransportationGroundAndSea", "PensionFunds",
        "PersonalProducts", "PersonalServices", "Pharmaceuticals",
        "PhonesAndHandheldDevices", "ProfessionalAndBusinessEducation",
        "ProfessionalInformationServices", "ProfessionalOrganizations",
        "PropertyAndCasualtyInsurance",
        "RealEstateRentalDevelopmentAndOperations", "RealEstateServices",
        "RecreationalProducts", "Reinsurance", "ReligiousOrganizations",
        "RenewableEnergyEquipmentAndServices", "RenewableFuels",
        "ResidentialREITs", "RestaurantsAndBars", "SchoolCollegeAndUniversity",
        "SemiconductorEquipmentAndTesting", "Semiconductors", "Shipbuilding",
        "Software", "SpecializedREITs", "SpecialtyChemicals",
        "SpecialtyMiningAndMetals", "TextilesAndLeatherGoods",
        "TiresAndRubberProducts", "Tobacco", "ToysAndChildrenProducts",
        "UKInvestmentTrusts", "Uranium", "WaterAndRelatedUtilities", and
        "WirelessTelecommunicationsServices".
    industry_group : str or ~analyticsapi.models.IndustryGroupEnum
        TRBC industry group of the business sector. Known values are:
        "AerospaceAndDefense", "AutomobilesAndAutoParts",
        "BankingAndInvestmentServices", "BankingServices", "Beverages",
        "BiotechnologyAndMedicalResearch", "Chemicals", "Coal",
        "CollectiveInvestments", "CommunicationsAndNetworking",
        "ComputersPhonesAndHouseholdElectronics", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConsumerGoodsConglomerates",
        "ContainersAndPackaging", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedRetail", "ElectricUtilitiesAndIPPs",
        "ElectronicEquipmentAndParts", "FinancialTechnologyAndInfrastructure",
        "FoodAndDrugRetailing", "FoodAndTobacco",
        "FreightAndLogisticsServices", "GovernmentActivity",
        "HealthcareEquipmentAndSupplies", "HealthcareProvidersAndServices",
        "HomebuildingAndConstructionSupplies",
        "HotelsAndEntertainmentServices", "HouseholdGoods",
        "InstitutionsAssociationsAndOrganizations", "Insurance",
        "IntegratedHardwareAndSoftware",
        "InvestmentBankingAndInvestmentServices", "InvestmentHoldingCompanies",
        "LeisureProducts", "MachineryToolsHeavyVehiclesTrainsAndShips",
        "MediaAndPublishing", "MetalsAndMining",
        "MiscellaneousEducationalService", "MultilineUtilities",
        "NaturalGasUtilities", "OfficeEquipment", "OilAndGas",
        "OilAndGasRelatedEquipmentAndServices", "PaperAndForestProducts",
        "PassengerTransportationServices",
        "PersonalAndHouseholdProductsAndServices", "Pharmaceuticals",
        "ProfessionalAndBusinessEducation",
        "ProfessionalAndCommercialServices", "Providers",
        "RealEstateOperations", "RenewableEnergy",
        "ResidentialAndCommercialREITs", "SchoolCollegeAndUniversity",
        "SemiconductorsAndSemiconductorEquipment", "SoftwareAndITServices",
        "SpecialtyRetailers", "TelecommunicationsServices",
        "TextilesAndApparel", "TransportInfrastructure", "Uranium", and
        "WaterAndRelatedUtilities".
    is_currency_country_originator : bool
    issuer_type : str or ~analyticsapi.models.IssuerTypeEnum
        Type of the issuer. Available values are: Agency, Corporate, Munis,
        NonFinancials, Sovereign, Supranational. Known values are: "Agency",
        "Corporate", "Munis", "NonFinancials", "Sovereign", and
        "Supranational".
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        Get mainConstituentAssetClass. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    name : str
        Get name.
    owner : str
        UUID of the curve definition owner for none Refinitiv curve.
    rating : str or ~analyticsapi.models.RatingEnum
        Get rating. Known values are: "A", "A1", "A2", "A3", "AA", "AAA",
        "AAHigh", "AALow", "AAMinus", "AAPlus", "AHigh", "ALow", "AMinus",
        "APlus", "Aa1", "Aa2", "Aa3", "Aaa", "B", "B1", "B2", "B3", "BB",
        "BBB", "BBBHigh", "BBBLow", "BBBMinus", "BBBPlus", "BBHigh", "BBLow",
        "BBMinus", "BBPlus", "BHigh", "BLow", "BMinus", "BPlus", "Ba1", "Ba2",
        "Ba3", "Baa1", "Baa2", "Baa3", "C", "CC", "CCC", "CCCHigh", "CCCLow",
        "CCCMinus", "CCCPlus", "CCHigh", "CCLow", "CHigh", "CLow", "Ca",
        "Caa1", "Caa2", "Caa3", "D", "DD", "DDD", "F1", "F1Plus", "F2", and
        "F3".
    rating_scale_source : str or ~analyticsapi.models.RatingScaleSourceEnum
        Get ratingScaleSource. Known values are: "DBRS", "Fitch", "Moodys",
        "Refinitiv", and "SAndP".
    reference_entity : str
        Code to define the reference entity.
    reference_entity_type : str or ~analyticsapi.models.ReferenceEntityTypeEnum
        Type of the reference entity (mandatory if referenceEntity is defined).
        Available values are:   - ChainRic   - BondIsin   - BondRic   -
        OrganisationId   - Ticker. Known values are: "BondIsin", "BondRic",
        "ChainRic", "OrganisationId", and "Ticker".
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        Get riskType. Known values are: "Credit", "CrossCurrency", "Inflation",
        and "InterestRate".
    seniority : str or ~analyticsapi.models.CurvesAndSurfacesSeniorityEnum
        Get seniority. Known values are:
        "JuniorSecuredOrJuniorSubordinatedSecured",
        "JuniorUnsecuredOrJuniorSubordinatedUnsecured", "Secured",
        "SeniorNonPreferred", "SeniorPreferred", "SeniorSecured",
        "SeniorSecuredFirstAndRefundingMortgage", "SeniorSecuredFirstLien",
        "SeniorSecuredFirstMortgage",
        "SeniorSecuredGeneralAndRefundingMortgage", "SeniorSecuredMortgage",
        "SeniorSecuredSecondLien", "SeniorSecuredSecondMortgage",
        "SeniorSecuredThirdMortgage", "SeniorSubordinatedSecured",
        "SeniorSubordinatedUnsecured", "SeniorUnsecured",
        "SubordinatedSecured", "SubordinatedUnsecured", and "Unsecured".
    source : str
        Source or contributor code Default value is \\"Refinitiv\\".
    """

    business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = rest_field(name="businessSector")
    """TRBC business sector of the economic sector. Known values are:
     \"AcademicAndEducationalServices\", \"AppliedResources\", \"AutomobilesAndAutoParts\",
     \"BankingAndInvestmentServices\", \"Chemicals\", \"CollectiveInvestments\",
     \"ConsumerGoodsConglomerates\", \"CyclicalConsumerProducts\", \"CyclicalConsumerServices\",
     \"EnergyFossilFuels\", \"FinancialTechnologyAndInfrastructure\", \"FoodAndBeverages\",
     \"FoodAndDrugRetailing\", \"GovernmentActivity\", \"HealthcareServicesAndEquipment\",
     \"IndustrialAndCommercialServices\", \"IndustrialGoods\",
     \"InstitutionsAssociationsAndOrganizations\", \"Insurance\", \"InvestmentHoldingCompanies\",
     \"MineralResources\", \"PersonalAndHouseholdProductsAndServices\",
     \"PharmaceuticalsAndMedicalResearch\", \"RealEstate\", \"RenewableEnergy\", \"Retailers\",
     \"SoftwareAndITServices\", \"TechnologyEquipment\", \"TelecommunicationsServices\",
     \"Transportation\", \"Uranium\", and \"Utilities\"."""
    country: Optional[str] = rest_field()
    """Country code of the issuer defined with Alpha-2 Code ISO 3166 country code convention."""
    currency: Optional[str] = rest_field()
    """Bond curve currency code."""
    curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = rest_field(name="curveSubType")
    """Get curveSubType. Known values are: \"BondCarry\", \"BreakevenInflationCurve\",
     \"CDSCreditIndex\", \"CapFloorVolatility\", \"CentralBankInterestRateProbability\",
     \"CommercialPaperBenchmark\", \"CorporateBondBenchmark\", \"CorporateBondPar\",
     \"CorporateBondSpread\", \"CorporateBondZero\", \"CorporateCDSCredit\",
     \"CorporateCashCredit\", \"CorporateIssuer\", \"Covered\", \"Deposit\",
     \"ForwardGovernmentBondZero\", \"ForwardGovernmentPar\", \"ForwardInflation\",
     \"ForwardRateAgreementZero\", \"ForwardStartingSwap\", \"GovernmentBenchmark\",
     \"GovernmentBondBenchmark\", \"GovernmentBondVolatility\", \"GovernmentCDSCredit\",
     \"GovernmentCashCredit\", \"GovernmentStripBenchmark\", \"InflationLinkedBenchmark\",
     \"InflationLinkedZero\", \"InterbankOfferRate\", \"InterestRateSwap\",
     \"InterestRateVolatility\", \"MunicipalBenchmark\", \"OvernightIndexSwap\",
     \"OvernightIndexSwapZero\", \"SemiSovereignCashCredit\", \"ShortTermInterestRateFuturesZero\",
     \"SolvencyIICorporateCreditSprdRating\", \"SolvencyIICoveredPfandbriefIssuer\",
     \"SolvencyIIFinancialCreditSprdRating\", \"SolvencyIIInterestRateSwapYield\",
     \"SolvencyIILiquiditySpread\", \"SolvencyIIPfandbriefYieldByCurrency\",
     \"SolvencyIIStructuredABSRating\", \"SolvencyIIStructuredMBSRating\",
     \"SolvencyIISwapDerivedZero\", \"SolvencyIITreasuryVersusIRSSpread\",
     \"SovereignAgencyBenchmark\", \"SwapCarry\", \"SwapPar\", \"SwapZero\", \"SwaptionVolatility\",
     and \"TreasurySpread\"."""
    definition_expiry_date: Optional[datetime.date] = rest_field(name="definitionExpiryDate")
    """Get definitionExpiryDate."""
    economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = rest_field(name="economicSector")
    """TRBC economic sector of the issuer.  Available values are: BasicMaterials, Consumer Cyclicals,
     Consumer Non-Cyclicals, Energy, Financials, Healthcare, Industrials, Technology, Utilities.
     Known values are: \"AcademicAndEducationalServices\", \"BasicMaterials\",
     \"ConsumerCyclicals\", \"ConsumerNonCyclicals\", \"Energy\", \"Financials\",
     \"GovernmentActivity\", \"Healthcare\", \"Industrials\",
     \"InstitutionsAssociationsAndOrganizations\", \"RealEstate\", \"Technology\", and
     \"Utilities\"."""
    first_historical_availability_date: Optional[datetime.date] = rest_field(name="firstHistoricalAvailabilityDate")
    """The date starting from which the definition of the curve can be used.  The value is expressed
     in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    id: Optional[str] = rest_field()
    """Id of the curve definition."""
    industry: Optional[Union[str, "_models.IndustryEnum"]] = rest_field()
    """TRBC industry of the industry group. Known values are:
     \"AdvancedMedicalEquipmentAndTechnology\", \"AdvertisingAndMarketing\",
     \"AerospaceAndDefense\", \"AgriculturalChemicals\", \"Airlines\",
     \"AirportOperatorsAndServices\", \"Aluminum\", \"ApparelAndAccessories\",
     \"ApparelAndAccessoriesRetailers\", \"AppliancesToolsAndHousewares\",
     \"AutoAndTruckManufacturers\", \"AutoTruckAndMotorcycleParts\",
     \"AutoVehiclesPartsAndServiceRetailers\", \"Banks\", \"BiotechnologyAndMedicalResearch\",
     \"BlockchainAndCryptocurrency\", \"Brewers\", \"Broadcasting\", \"BusinessSupportServices\",
     \"BusinessSupportSupplies\", \"CasinosAndGaming\", \"CharityOrganizations\",
     \"CivicAndSocialOrganizations\", \"ClosedEndFunds\", \"Coal\", \"CommercialPrintingServices\",
     \"CommercialREITs\", \"CommodityChemicals\", \"CommunicationsAndNetworking\",
     \"ComputerAndElectronicsRetailers\", \"ComputerHardware\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConstructionSuppliesAndFixtures\", \"ConsumerGoodsConglomerates\",
     \"ConsumerLending\", \"ConsumerPublishing\", \"CorporateFinancialServices\",
     \"CourierPostalAirFreightAndLandbasedLogistics\", \"CrowdCollaboration\", \"DepartmentStores\",
     \"DiscountStores\", \"DistillersAndWineries\", \"DiversifiedChemicals\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedInvestmentServices\",
     \"DiversifiedMining\", \"DiversifiedREITs\", \"DrugRetailers\", \"ElectricUtilities\",
     \"ElectricalComponentsAndEquipment\", \"ElectronicEquipmentAndParts\", \"EmploymentServices\",
     \"EntertainmentProduction\", \"EnvironmentalOrganizations\",
     \"EnvironmentalServicesAndEquipment\", \"ExchangeTradedFunds\",
     \"FinancialAndCommodityMarketOperatorsAndServiceProviders\", \"FinancialTechnology\",
     \"FishingAndFarming\", \"FoodProcessing\", \"FoodRetailAndDistribution\", \"Footwear\",
     \"ForestAndWoodProducts\", \"Gold\", \"GovernmentAdministrationActivities\",
     \"GovernmentAndGovernmentFinance\", \"GroundFreightAndLogistics\",
     \"HealthcareFacilitiesAndServices\", \"HeavyElectricalEquipment\",
     \"HeavyMachineryAndVehicles\", \"HighwaysAndRailTracks\", \"HomeFurnishings\",
     \"HomeFurnishingsRetailers\", \"HomeImprovementProductsAndServicesRetailers\",
     \"Homebuilding\", \"HotelsMotelsAndCruiseLines\", \"HouseholdElectronics\",
     \"HouseholdProducts\", \"ITServicesAndConsulting\", \"IndependentPowerProducers\",
     \"IndustrialMachineryAndEquipment\", \"InsuranceFunds\", \"IntegratedHardwareAndSoftware\",
     \"IntegratedOilAndGas\", \"IntegratedTelecommunicationsServices\",
     \"InvestmentBankingAndBrokerageServices\", \"InvestmentHoldingCompanies\",
     \"InvestmentManagementAndFundOperators\", \"IronAndSteel\", \"LegalAndSafetyPublicServices\",
     \"LeisureAndRecreation\", \"LifeAndHealthInsurance\", \"ManagedHealthcare\",
     \"MarineFreightAndLogistics\", \"MarinePortServices\",
     \"MedicalEquipmentSuppliesAndDistribution\", \"MiningSupportServicesAndEquipment\",
     \"MiscellaneousEducationalServiceProviders\", \"MiscellaneousInfrastructure\",
     \"MiscellaneousSpecialtyRetailers\", \"MultilineInsuranceAndBrokers\", \"MultilineUtilities\",
     \"MutualFunds\", \"NationalSecurityAndInternationalAffairs\", \"NaturalGasUtilities\",
     \"NonAlcoholicBeverages\", \"NonGoldPreciousMetalsAndMinerals\",
     \"NonPaperContainersAndPackaging\", \"OfficeEquipment\", \"OilAndGasDrilling\",
     \"OilAndGasExplorationAndProduction\", \"OilAndGasRefiningAndMarketing\",
     \"OilAndGasTransportationServices\", \"OilRelatedServicesAndEquipment\", \"OnlineServices\",
     \"PaperPackaging\", \"PaperProducts\", \"PassengerTransportationGroundAndSea\",
     \"PensionFunds\", \"PersonalProducts\", \"PersonalServices\", \"Pharmaceuticals\",
     \"PhonesAndHandheldDevices\", \"ProfessionalAndBusinessEducation\",
     \"ProfessionalInformationServices\", \"ProfessionalOrganizations\",
     \"PropertyAndCasualtyInsurance\", \"RealEstateRentalDevelopmentAndOperations\",
     \"RealEstateServices\", \"RecreationalProducts\", \"Reinsurance\", \"ReligiousOrganizations\",
     \"RenewableEnergyEquipmentAndServices\", \"RenewableFuels\", \"ResidentialREITs\",
     \"RestaurantsAndBars\", \"SchoolCollegeAndUniversity\", \"SemiconductorEquipmentAndTesting\",
     \"Semiconductors\", \"Shipbuilding\", \"Software\", \"SpecializedREITs\",
     \"SpecialtyChemicals\", \"SpecialtyMiningAndMetals\", \"TextilesAndLeatherGoods\",
     \"TiresAndRubberProducts\", \"Tobacco\", \"ToysAndChildrenProducts\", \"UKInvestmentTrusts\",
     \"Uranium\", \"WaterAndRelatedUtilities\", and \"WirelessTelecommunicationsServices\"."""
    industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = rest_field(name="industryGroup")
    """TRBC industry group of the business sector. Known values are: \"AerospaceAndDefense\",
     \"AutomobilesAndAutoParts\", \"BankingAndInvestmentServices\", \"BankingServices\",
     \"Beverages\", \"BiotechnologyAndMedicalResearch\", \"Chemicals\", \"Coal\",
     \"CollectiveInvestments\", \"CommunicationsAndNetworking\",
     \"ComputersPhonesAndHouseholdElectronics\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConsumerGoodsConglomerates\", \"ContainersAndPackaging\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedRetail\", \"ElectricUtilitiesAndIPPs\",
     \"ElectronicEquipmentAndParts\", \"FinancialTechnologyAndInfrastructure\",
     \"FoodAndDrugRetailing\", \"FoodAndTobacco\", \"FreightAndLogisticsServices\",
     \"GovernmentActivity\", \"HealthcareEquipmentAndSupplies\", \"HealthcareProvidersAndServices\",
     \"HomebuildingAndConstructionSupplies\", \"HotelsAndEntertainmentServices\",
     \"HouseholdGoods\", \"InstitutionsAssociationsAndOrganizations\", \"Insurance\",
     \"IntegratedHardwareAndSoftware\", \"InvestmentBankingAndInvestmentServices\",
     \"InvestmentHoldingCompanies\", \"LeisureProducts\",
     \"MachineryToolsHeavyVehiclesTrainsAndShips\", \"MediaAndPublishing\", \"MetalsAndMining\",
     \"MiscellaneousEducationalService\", \"MultilineUtilities\", \"NaturalGasUtilities\",
     \"OfficeEquipment\", \"OilAndGas\", \"OilAndGasRelatedEquipmentAndServices\",
     \"PaperAndForestProducts\", \"PassengerTransportationServices\",
     \"PersonalAndHouseholdProductsAndServices\", \"Pharmaceuticals\",
     \"ProfessionalAndBusinessEducation\", \"ProfessionalAndCommercialServices\", \"Providers\",
     \"RealEstateOperations\", \"RenewableEnergy\", \"ResidentialAndCommercialREITs\",
     \"SchoolCollegeAndUniversity\", \"SemiconductorsAndSemiconductorEquipment\",
     \"SoftwareAndITServices\", \"SpecialtyRetailers\", \"TelecommunicationsServices\",
     \"TextilesAndApparel\", \"TransportInfrastructure\", \"Uranium\", and
     \"WaterAndRelatedUtilities\"."""
    is_currency_country_originator: Optional[bool] = rest_field(name="isCurrencyCountryOriginator")
    issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = rest_field(name="issuerType")
    """Type of the issuer. Available values are: Agency, Corporate, Munis, NonFinancials, Sovereign,
     Supranational. Known values are: \"Agency\", \"Corporate\", \"Munis\", \"NonFinancials\",
     \"Sovereign\", and \"Supranational\"."""
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """Get mainConstituentAssetClass. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    name: Optional[str] = rest_field()
    """Get name."""
    owner: Optional[str] = rest_field()
    """UUID of the curve definition owner for none Refinitiv curve."""
    rating: Optional[Union[str, "_models.RatingEnum"]] = rest_field()
    """Get rating. Known values are: \"A\", \"A1\", \"A2\", \"A3\", \"AA\", \"AAA\", \"AAHigh\",
     \"AALow\", \"AAMinus\", \"AAPlus\", \"AHigh\", \"ALow\", \"AMinus\", \"APlus\", \"Aa1\",
     \"Aa2\", \"Aa3\", \"Aaa\", \"B\", \"B1\", \"B2\", \"B3\", \"BB\", \"BBB\", \"BBBHigh\",
     \"BBBLow\", \"BBBMinus\", \"BBBPlus\", \"BBHigh\", \"BBLow\", \"BBMinus\", \"BBPlus\",
     \"BHigh\", \"BLow\", \"BMinus\", \"BPlus\", \"Ba1\", \"Ba2\", \"Ba3\", \"Baa1\", \"Baa2\",
     \"Baa3\", \"C\", \"CC\", \"CCC\", \"CCCHigh\", \"CCCLow\", \"CCCMinus\", \"CCCPlus\",
     \"CCHigh\", \"CCLow\", \"CHigh\", \"CLow\", \"Ca\", \"Caa1\", \"Caa2\", \"Caa3\", \"D\",
     \"DD\", \"DDD\", \"F1\", \"F1Plus\", \"F2\", and \"F3\"."""
    rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = rest_field(name="ratingScaleSource")
    """Get ratingScaleSource. Known values are: \"DBRS\", \"Fitch\", \"Moodys\", \"Refinitiv\", and
     \"SAndP\"."""
    reference_entity: Optional[str] = rest_field(name="referenceEntity")
    """Code to define the reference entity."""
    reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = rest_field(
        name="referenceEntityType"
    )
    """Type of the reference entity (mandatory if referenceEntity is defined). Available values are:
     - ChainRic   - BondIsin   - BondRic   - OrganisationId   - Ticker. Known values are:
     \"BondIsin\", \"BondRic\", \"ChainRic\", \"OrganisationId\", and \"Ticker\"."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """Get riskType. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = rest_field()
    """Get seniority. Known values are: \"JuniorSecuredOrJuniorSubordinatedSecured\",
     \"JuniorUnsecuredOrJuniorSubordinatedUnsecured\", \"Secured\", \"SeniorNonPreferred\",
     \"SeniorPreferred\", \"SeniorSecured\", \"SeniorSecuredFirstAndRefundingMortgage\",
     \"SeniorSecuredFirstLien\", \"SeniorSecuredFirstMortgage\",
     \"SeniorSecuredGeneralAndRefundingMortgage\", \"SeniorSecuredMortgage\",
     \"SeniorSecuredSecondLien\", \"SeniorSecuredSecondMortgage\", \"SeniorSecuredThirdMortgage\",
     \"SeniorSubordinatedSecured\", \"SeniorSubordinatedUnsecured\", \"SeniorUnsecured\",
     \"SubordinatedSecured\", \"SubordinatedUnsecured\", and \"Unsecured\"."""
    source: Optional[str] = rest_field()
    """Source or contributor code Default value is \\"Refinitiv\\"."""

    @overload
    def __init__(
        self,
        *,
        business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = None,
        country: Optional[str] = None,
        currency: Optional[str] = None,
        curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = None,
        definition_expiry_date: Optional[datetime.date] = None,
        economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = None,
        first_historical_availability_date: Optional[datetime.date] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        industry: Optional[Union[str, "_models.IndustryEnum"]] = None,
        industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = None,
        is_currency_country_originator: Optional[bool] = None,
        issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        name: Optional[str] = None,
        owner: Optional[str] = None,
        rating: Optional[Union[str, "_models.RatingEnum"]] = None,
        rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = None,
        reference_entity: Optional[str] = None,
        reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveDefinitionOutput(_model_base.Model):
    """CreditCurveDefinitionOutput.

    Attributes
    ----------
    business_sector : str or ~analyticsapi.models.BusinessSectorEnum
        TRBC business sector of the economic sector. Known values are:
        "AcademicAndEducationalServices", "AppliedResources",
        "AutomobilesAndAutoParts", "BankingAndInvestmentServices", "Chemicals",
        "CollectiveInvestments", "ConsumerGoodsConglomerates",
        "CyclicalConsumerProducts", "CyclicalConsumerServices",
        "EnergyFossilFuels", "FinancialTechnologyAndInfrastructure",
        "FoodAndBeverages", "FoodAndDrugRetailing", "GovernmentActivity",
        "HealthcareServicesAndEquipment", "IndustrialAndCommercialServices",
        "IndustrialGoods", "InstitutionsAssociationsAndOrganizations",
        "Insurance", "InvestmentHoldingCompanies", "MineralResources",
        "PersonalAndHouseholdProductsAndServices",
        "PharmaceuticalsAndMedicalResearch", "RealEstate", "RenewableEnergy",
        "Retailers", "SoftwareAndITServices", "TechnologyEquipment",
        "TelecommunicationsServices", "Transportation", "Uranium", and
        "Utilities".
    country : str
        Country code of the issuer defined with Alpha-2 Code ISO 3166 country
        code convention.
    credit_curve_type : str or ~analyticsapi.models.CreditCurveTypeEnum
        Get creditCurveType. Known values are: "BondIssuerCurve",
        "BondPeersCurve", "BondRatingCurve", "BondSectorRatingCurve",
        "CDSIssuerCurve", "CDSPeersCurve", "CDSRatingCurve", and
        "CDSSectorRatingCurve".
    currency : str
        Bond curve currency code.
    curve_sub_type : str or ~analyticsapi.models.CurveSubTypeEnum
        Get curveSubType. Known values are: "BondCarry",
        "BreakevenInflationCurve", "CDSCreditIndex", "CapFloorVolatility",
        "CentralBankInterestRateProbability", "CommercialPaperBenchmark",
        "CorporateBondBenchmark", "CorporateBondPar", "CorporateBondSpread",
        "CorporateBondZero", "CorporateCDSCredit", "CorporateCashCredit",
        "CorporateIssuer", "Covered", "Deposit", "ForwardGovernmentBondZero",
        "ForwardGovernmentPar", "ForwardInflation", "ForwardRateAgreementZero",
        "ForwardStartingSwap", "GovernmentBenchmark",
        "GovernmentBondBenchmark", "GovernmentBondVolatility",
        "GovernmentCDSCredit", "GovernmentCashCredit",
        "GovernmentStripBenchmark", "InflationLinkedBenchmark",
        "InflationLinkedZero", "InterbankOfferRate", "InterestRateSwap",
        "InterestRateVolatility", "MunicipalBenchmark", "OvernightIndexSwap",
        "OvernightIndexSwapZero", "SemiSovereignCashCredit",
        "ShortTermInterestRateFuturesZero",
        "SolvencyIICorporateCreditSprdRating",
        "SolvencyIICoveredPfandbriefIssuer",
        "SolvencyIIFinancialCreditSprdRating",
        "SolvencyIIInterestRateSwapYield", "SolvencyIILiquiditySpread",
        "SolvencyIIPfandbriefYieldByCurrency", "SolvencyIIStructuredABSRating",
        "SolvencyIIStructuredMBSRating", "SolvencyIISwapDerivedZero",
        "SolvencyIITreasuryVersusIRSSpread", "SovereignAgencyBenchmark",
        "SwapCarry", "SwapPar", "SwapZero", "SwaptionVolatility", and
        "TreasurySpread".
    curve_tenors : list[str]
        User defined maturities to compute.  The default value is None, needs
        to be assigned before using.
    economic_sector : str or ~analyticsapi.models.EconomicSectorEnum
        TRBC economic sector of the issuer.  Available values are:
        BasicMaterials, Consumer Cyclicals, Consumer Non-Cyclicals, Energy,
        Financials, Healthcare, Industrials, Technology, Utilities. Known
        values are: "AcademicAndEducationalServices", "BasicMaterials",
        "ConsumerCyclicals", "ConsumerNonCyclicals", "Energy", "Financials",
        "GovernmentActivity", "Healthcare", "Industrials",
        "InstitutionsAssociationsAndOrganizations", "RealEstate", "Technology",
        and "Utilities".
    id : str
        Id of the curve definition.
    industry : str or ~analyticsapi.models.IndustryEnum
        TRBC industry of the industry group. Known values are:
        "AdvancedMedicalEquipmentAndTechnology", "AdvertisingAndMarketing",
        "AerospaceAndDefense", "AgriculturalChemicals", "Airlines",
        "AirportOperatorsAndServices", "Aluminum", "ApparelAndAccessories",
        "ApparelAndAccessoriesRetailers", "AppliancesToolsAndHousewares",
        "AutoAndTruckManufacturers", "AutoTruckAndMotorcycleParts",
        "AutoVehiclesPartsAndServiceRetailers", "Banks",
        "BiotechnologyAndMedicalResearch", "BlockchainAndCryptocurrency",
        "Brewers", "Broadcasting", "BusinessSupportServices",
        "BusinessSupportSupplies", "CasinosAndGaming", "CharityOrganizations",
        "CivicAndSocialOrganizations", "ClosedEndFunds", "Coal",
        "CommercialPrintingServices", "CommercialREITs", "CommodityChemicals",
        "CommunicationsAndNetworking", "ComputerAndElectronicsRetailers",
        "ComputerHardware", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConstructionSuppliesAndFixtures",
        "ConsumerGoodsConglomerates", "ConsumerLending", "ConsumerPublishing",
        "CorporateFinancialServices",
        "CourierPostalAirFreightAndLandbasedLogistics", "CrowdCollaboration",
        "DepartmentStores", "DiscountStores", "DistillersAndWineries",
        "DiversifiedChemicals", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedInvestmentServices", "DiversifiedMining",
        "DiversifiedREITs", "DrugRetailers", "ElectricUtilities",
        "ElectricalComponentsAndEquipment", "ElectronicEquipmentAndParts",
        "EmploymentServices", "EntertainmentProduction",
        "EnvironmentalOrganizations", "EnvironmentalServicesAndEquipment",
        "ExchangeTradedFunds",
        "FinancialAndCommodityMarketOperatorsAndServiceProviders",
        "FinancialTechnology", "FishingAndFarming", "FoodProcessing",
        "FoodRetailAndDistribution", "Footwear", "ForestAndWoodProducts",
        "Gold", "GovernmentAdministrationActivities",
        "GovernmentAndGovernmentFinance", "GroundFreightAndLogistics",
        "HealthcareFacilitiesAndServices", "HeavyElectricalEquipment",
        "HeavyMachineryAndVehicles", "HighwaysAndRailTracks",
        "HomeFurnishings", "HomeFurnishingsRetailers",
        "HomeImprovementProductsAndServicesRetailers", "Homebuilding",
        "HotelsMotelsAndCruiseLines", "HouseholdElectronics",
        "HouseholdProducts", "ITServicesAndConsulting",
        "IndependentPowerProducers", "IndustrialMachineryAndEquipment",
        "InsuranceFunds", "IntegratedHardwareAndSoftware",
        "IntegratedOilAndGas", "IntegratedTelecommunicationsServices",
        "InvestmentBankingAndBrokerageServices", "InvestmentHoldingCompanies",
        "InvestmentManagementAndFundOperators", "IronAndSteel",
        "LegalAndSafetyPublicServices", "LeisureAndRecreation",
        "LifeAndHealthInsurance", "ManagedHealthcare",
        "MarineFreightAndLogistics", "MarinePortServices",
        "MedicalEquipmentSuppliesAndDistribution",
        "MiningSupportServicesAndEquipment",
        "MiscellaneousEducationalServiceProviders",
        "MiscellaneousInfrastructure", "MiscellaneousSpecialtyRetailers",
        "MultilineInsuranceAndBrokers", "MultilineUtilities", "MutualFunds",
        "NationalSecurityAndInternationalAffairs", "NaturalGasUtilities",
        "NonAlcoholicBeverages", "NonGoldPreciousMetalsAndMinerals",
        "NonPaperContainersAndPackaging", "OfficeEquipment",
        "OilAndGasDrilling", "OilAndGasExplorationAndProduction",
        "OilAndGasRefiningAndMarketing", "OilAndGasTransportationServices",
        "OilRelatedServicesAndEquipment", "OnlineServices", "PaperPackaging",
        "PaperProducts", "PassengerTransportationGroundAndSea", "PensionFunds",
        "PersonalProducts", "PersonalServices", "Pharmaceuticals",
        "PhonesAndHandheldDevices", "ProfessionalAndBusinessEducation",
        "ProfessionalInformationServices", "ProfessionalOrganizations",
        "PropertyAndCasualtyInsurance",
        "RealEstateRentalDevelopmentAndOperations", "RealEstateServices",
        "RecreationalProducts", "Reinsurance", "ReligiousOrganizations",
        "RenewableEnergyEquipmentAndServices", "RenewableFuels",
        "ResidentialREITs", "RestaurantsAndBars", "SchoolCollegeAndUniversity",
        "SemiconductorEquipmentAndTesting", "Semiconductors", "Shipbuilding",
        "Software", "SpecializedREITs", "SpecialtyChemicals",
        "SpecialtyMiningAndMetals", "TextilesAndLeatherGoods",
        "TiresAndRubberProducts", "Tobacco", "ToysAndChildrenProducts",
        "UKInvestmentTrusts", "Uranium", "WaterAndRelatedUtilities", and
        "WirelessTelecommunicationsServices".
    industry_group : str or ~analyticsapi.models.IndustryGroupEnum
        TRBC industry group of the business sector. Known values are:
        "AerospaceAndDefense", "AutomobilesAndAutoParts",
        "BankingAndInvestmentServices", "BankingServices", "Beverages",
        "BiotechnologyAndMedicalResearch", "Chemicals", "Coal",
        "CollectiveInvestments", "CommunicationsAndNetworking",
        "ComputersPhonesAndHouseholdElectronics", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConsumerGoodsConglomerates",
        "ContainersAndPackaging", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedRetail", "ElectricUtilitiesAndIPPs",
        "ElectronicEquipmentAndParts", "FinancialTechnologyAndInfrastructure",
        "FoodAndDrugRetailing", "FoodAndTobacco",
        "FreightAndLogisticsServices", "GovernmentActivity",
        "HealthcareEquipmentAndSupplies", "HealthcareProvidersAndServices",
        "HomebuildingAndConstructionSupplies",
        "HotelsAndEntertainmentServices", "HouseholdGoods",
        "InstitutionsAssociationsAndOrganizations", "Insurance",
        "IntegratedHardwareAndSoftware",
        "InvestmentBankingAndInvestmentServices", "InvestmentHoldingCompanies",
        "LeisureProducts", "MachineryToolsHeavyVehiclesTrainsAndShips",
        "MediaAndPublishing", "MetalsAndMining",
        "MiscellaneousEducationalService", "MultilineUtilities",
        "NaturalGasUtilities", "OfficeEquipment", "OilAndGas",
        "OilAndGasRelatedEquipmentAndServices", "PaperAndForestProducts",
        "PassengerTransportationServices",
        "PersonalAndHouseholdProductsAndServices", "Pharmaceuticals",
        "ProfessionalAndBusinessEducation",
        "ProfessionalAndCommercialServices", "Providers",
        "RealEstateOperations", "RenewableEnergy",
        "ResidentialAndCommercialREITs", "SchoolCollegeAndUniversity",
        "SemiconductorsAndSemiconductorEquipment", "SoftwareAndITServices",
        "SpecialtyRetailers", "TelecommunicationsServices",
        "TextilesAndApparel", "TransportInfrastructure", "Uranium", and
        "WaterAndRelatedUtilities".
    is_currency_country_originator : bool
    issuer_type : str or ~analyticsapi.models.IssuerTypeEnum
        Type of the issuer. Available values are: Agency, Corporate, Munis,
        NonFinancials, Sovereign, Supranational. Known values are: "Agency",
        "Corporate", "Munis", "NonFinancials", "Sovereign", and
        "Supranational".
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        Get mainConstituentAssetClass. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    name : str
        Get name.
    rating : str or ~analyticsapi.models.RatingEnum
        Get rating. Known values are: "A", "A1", "A2", "A3", "AA", "AAA",
        "AAHigh", "AALow", "AAMinus", "AAPlus", "AHigh", "ALow", "AMinus",
        "APlus", "Aa1", "Aa2", "Aa3", "Aaa", "B", "B1", "B2", "B3", "BB",
        "BBB", "BBBHigh", "BBBLow", "BBBMinus", "BBBPlus", "BBHigh", "BBLow",
        "BBMinus", "BBPlus", "BHigh", "BLow", "BMinus", "BPlus", "Ba1", "Ba2",
        "Ba3", "Baa1", "Baa2", "Baa3", "C", "CC", "CCC", "CCCHigh", "CCCLow",
        "CCCMinus", "CCCPlus", "CCHigh", "CCLow", "CHigh", "CLow", "Ca",
        "Caa1", "Caa2", "Caa3", "D", "DD", "DDD", "F1", "F1Plus", "F2", and
        "F3".
    rating_scale_source : str or ~analyticsapi.models.RatingScaleSourceEnum
        Get ratingScaleSource. Known values are: "DBRS", "Fitch", "Moodys",
        "Refinitiv", and "SAndP".
    reference_entity : str
        Code to define the reference entity.
    reference_entity_type : str or ~analyticsapi.models.ReferenceEntityTypeEnum
        Type of the reference entity (mandatory if referenceEntity is defined).
        Available values are:   - ChainRic   - BondIsin   - BondRic   -
        OrganisationId   - Ticker. Known values are: "BondIsin", "BondRic",
        "ChainRic", "OrganisationId", and "Ticker".
    seniority : str or ~analyticsapi.models.CurvesAndSurfacesSeniorityEnum
        Get seniority. Known values are:
        "JuniorSecuredOrJuniorSubordinatedSecured",
        "JuniorUnsecuredOrJuniorSubordinatedUnsecured", "Secured",
        "SeniorNonPreferred", "SeniorPreferred", "SeniorSecured",
        "SeniorSecuredFirstAndRefundingMortgage", "SeniorSecuredFirstLien",
        "SeniorSecuredFirstMortgage",
        "SeniorSecuredGeneralAndRefundingMortgage", "SeniorSecuredMortgage",
        "SeniorSecuredSecondLien", "SeniorSecuredSecondMortgage",
        "SeniorSecuredThirdMortgage", "SeniorSubordinatedSecured",
        "SeniorSubordinatedUnsecured", "SeniorUnsecured",
        "SubordinatedSecured", "SubordinatedUnsecured", and "Unsecured".
    source : str
        Source or contributor code Default value is \\"Refinitiv\\".
    """

    business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = rest_field(name="businessSector")
    """TRBC business sector of the economic sector. Known values are:
     \"AcademicAndEducationalServices\", \"AppliedResources\", \"AutomobilesAndAutoParts\",
     \"BankingAndInvestmentServices\", \"Chemicals\", \"CollectiveInvestments\",
     \"ConsumerGoodsConglomerates\", \"CyclicalConsumerProducts\", \"CyclicalConsumerServices\",
     \"EnergyFossilFuels\", \"FinancialTechnologyAndInfrastructure\", \"FoodAndBeverages\",
     \"FoodAndDrugRetailing\", \"GovernmentActivity\", \"HealthcareServicesAndEquipment\",
     \"IndustrialAndCommercialServices\", \"IndustrialGoods\",
     \"InstitutionsAssociationsAndOrganizations\", \"Insurance\", \"InvestmentHoldingCompanies\",
     \"MineralResources\", \"PersonalAndHouseholdProductsAndServices\",
     \"PharmaceuticalsAndMedicalResearch\", \"RealEstate\", \"RenewableEnergy\", \"Retailers\",
     \"SoftwareAndITServices\", \"TechnologyEquipment\", \"TelecommunicationsServices\",
     \"Transportation\", \"Uranium\", and \"Utilities\"."""
    country: Optional[str] = rest_field()
    """Country code of the issuer defined with Alpha-2 Code ISO 3166 country code convention."""
    credit_curve_type: Optional[Union[str, "_models.CreditCurveTypeEnum"]] = rest_field(name="creditCurveType")
    """Get creditCurveType. Known values are: \"BondIssuerCurve\", \"BondPeersCurve\",
     \"BondRatingCurve\", \"BondSectorRatingCurve\", \"CDSIssuerCurve\", \"CDSPeersCurve\",
     \"CDSRatingCurve\", and \"CDSSectorRatingCurve\"."""
    currency: Optional[str] = rest_field()
    """Bond curve currency code."""
    curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = rest_field(name="curveSubType")
    """Get curveSubType. Known values are: \"BondCarry\", \"BreakevenInflationCurve\",
     \"CDSCreditIndex\", \"CapFloorVolatility\", \"CentralBankInterestRateProbability\",
     \"CommercialPaperBenchmark\", \"CorporateBondBenchmark\", \"CorporateBondPar\",
     \"CorporateBondSpread\", \"CorporateBondZero\", \"CorporateCDSCredit\",
     \"CorporateCashCredit\", \"CorporateIssuer\", \"Covered\", \"Deposit\",
     \"ForwardGovernmentBondZero\", \"ForwardGovernmentPar\", \"ForwardInflation\",
     \"ForwardRateAgreementZero\", \"ForwardStartingSwap\", \"GovernmentBenchmark\",
     \"GovernmentBondBenchmark\", \"GovernmentBondVolatility\", \"GovernmentCDSCredit\",
     \"GovernmentCashCredit\", \"GovernmentStripBenchmark\", \"InflationLinkedBenchmark\",
     \"InflationLinkedZero\", \"InterbankOfferRate\", \"InterestRateSwap\",
     \"InterestRateVolatility\", \"MunicipalBenchmark\", \"OvernightIndexSwap\",
     \"OvernightIndexSwapZero\", \"SemiSovereignCashCredit\", \"ShortTermInterestRateFuturesZero\",
     \"SolvencyIICorporateCreditSprdRating\", \"SolvencyIICoveredPfandbriefIssuer\",
     \"SolvencyIIFinancialCreditSprdRating\", \"SolvencyIIInterestRateSwapYield\",
     \"SolvencyIILiquiditySpread\", \"SolvencyIIPfandbriefYieldByCurrency\",
     \"SolvencyIIStructuredABSRating\", \"SolvencyIIStructuredMBSRating\",
     \"SolvencyIISwapDerivedZero\", \"SolvencyIITreasuryVersusIRSSpread\",
     \"SovereignAgencyBenchmark\", \"SwapCarry\", \"SwapPar\", \"SwapZero\", \"SwaptionVolatility\",
     and \"TreasurySpread\"."""
    curve_tenors: Optional[List[str]] = rest_field(name="curveTenors")
    """User defined maturities to compute."""
    economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = rest_field(name="economicSector")
    """TRBC economic sector of the issuer.  Available values are: BasicMaterials, Consumer Cyclicals,
     Consumer Non-Cyclicals, Energy, Financials, Healthcare, Industrials, Technology, Utilities.
     Known values are: \"AcademicAndEducationalServices\", \"BasicMaterials\",
     \"ConsumerCyclicals\", \"ConsumerNonCyclicals\", \"Energy\", \"Financials\",
     \"GovernmentActivity\", \"Healthcare\", \"Industrials\",
     \"InstitutionsAssociationsAndOrganizations\", \"RealEstate\", \"Technology\", and
     \"Utilities\"."""
    id: Optional[str] = rest_field()
    """Id of the curve definition."""
    industry: Optional[Union[str, "_models.IndustryEnum"]] = rest_field()
    """TRBC industry of the industry group. Known values are:
     \"AdvancedMedicalEquipmentAndTechnology\", \"AdvertisingAndMarketing\",
     \"AerospaceAndDefense\", \"AgriculturalChemicals\", \"Airlines\",
     \"AirportOperatorsAndServices\", \"Aluminum\", \"ApparelAndAccessories\",
     \"ApparelAndAccessoriesRetailers\", \"AppliancesToolsAndHousewares\",
     \"AutoAndTruckManufacturers\", \"AutoTruckAndMotorcycleParts\",
     \"AutoVehiclesPartsAndServiceRetailers\", \"Banks\", \"BiotechnologyAndMedicalResearch\",
     \"BlockchainAndCryptocurrency\", \"Brewers\", \"Broadcasting\", \"BusinessSupportServices\",
     \"BusinessSupportSupplies\", \"CasinosAndGaming\", \"CharityOrganizations\",
     \"CivicAndSocialOrganizations\", \"ClosedEndFunds\", \"Coal\", \"CommercialPrintingServices\",
     \"CommercialREITs\", \"CommodityChemicals\", \"CommunicationsAndNetworking\",
     \"ComputerAndElectronicsRetailers\", \"ComputerHardware\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConstructionSuppliesAndFixtures\", \"ConsumerGoodsConglomerates\",
     \"ConsumerLending\", \"ConsumerPublishing\", \"CorporateFinancialServices\",
     \"CourierPostalAirFreightAndLandbasedLogistics\", \"CrowdCollaboration\", \"DepartmentStores\",
     \"DiscountStores\", \"DistillersAndWineries\", \"DiversifiedChemicals\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedInvestmentServices\",
     \"DiversifiedMining\", \"DiversifiedREITs\", \"DrugRetailers\", \"ElectricUtilities\",
     \"ElectricalComponentsAndEquipment\", \"ElectronicEquipmentAndParts\", \"EmploymentServices\",
     \"EntertainmentProduction\", \"EnvironmentalOrganizations\",
     \"EnvironmentalServicesAndEquipment\", \"ExchangeTradedFunds\",
     \"FinancialAndCommodityMarketOperatorsAndServiceProviders\", \"FinancialTechnology\",
     \"FishingAndFarming\", \"FoodProcessing\", \"FoodRetailAndDistribution\", \"Footwear\",
     \"ForestAndWoodProducts\", \"Gold\", \"GovernmentAdministrationActivities\",
     \"GovernmentAndGovernmentFinance\", \"GroundFreightAndLogistics\",
     \"HealthcareFacilitiesAndServices\", \"HeavyElectricalEquipment\",
     \"HeavyMachineryAndVehicles\", \"HighwaysAndRailTracks\", \"HomeFurnishings\",
     \"HomeFurnishingsRetailers\", \"HomeImprovementProductsAndServicesRetailers\",
     \"Homebuilding\", \"HotelsMotelsAndCruiseLines\", \"HouseholdElectronics\",
     \"HouseholdProducts\", \"ITServicesAndConsulting\", \"IndependentPowerProducers\",
     \"IndustrialMachineryAndEquipment\", \"InsuranceFunds\", \"IntegratedHardwareAndSoftware\",
     \"IntegratedOilAndGas\", \"IntegratedTelecommunicationsServices\",
     \"InvestmentBankingAndBrokerageServices\", \"InvestmentHoldingCompanies\",
     \"InvestmentManagementAndFundOperators\", \"IronAndSteel\", \"LegalAndSafetyPublicServices\",
     \"LeisureAndRecreation\", \"LifeAndHealthInsurance\", \"ManagedHealthcare\",
     \"MarineFreightAndLogistics\", \"MarinePortServices\",
     \"MedicalEquipmentSuppliesAndDistribution\", \"MiningSupportServicesAndEquipment\",
     \"MiscellaneousEducationalServiceProviders\", \"MiscellaneousInfrastructure\",
     \"MiscellaneousSpecialtyRetailers\", \"MultilineInsuranceAndBrokers\", \"MultilineUtilities\",
     \"MutualFunds\", \"NationalSecurityAndInternationalAffairs\", \"NaturalGasUtilities\",
     \"NonAlcoholicBeverages\", \"NonGoldPreciousMetalsAndMinerals\",
     \"NonPaperContainersAndPackaging\", \"OfficeEquipment\", \"OilAndGasDrilling\",
     \"OilAndGasExplorationAndProduction\", \"OilAndGasRefiningAndMarketing\",
     \"OilAndGasTransportationServices\", \"OilRelatedServicesAndEquipment\", \"OnlineServices\",
     \"PaperPackaging\", \"PaperProducts\", \"PassengerTransportationGroundAndSea\",
     \"PensionFunds\", \"PersonalProducts\", \"PersonalServices\", \"Pharmaceuticals\",
     \"PhonesAndHandheldDevices\", \"ProfessionalAndBusinessEducation\",
     \"ProfessionalInformationServices\", \"ProfessionalOrganizations\",
     \"PropertyAndCasualtyInsurance\", \"RealEstateRentalDevelopmentAndOperations\",
     \"RealEstateServices\", \"RecreationalProducts\", \"Reinsurance\", \"ReligiousOrganizations\",
     \"RenewableEnergyEquipmentAndServices\", \"RenewableFuels\", \"ResidentialREITs\",
     \"RestaurantsAndBars\", \"SchoolCollegeAndUniversity\", \"SemiconductorEquipmentAndTesting\",
     \"Semiconductors\", \"Shipbuilding\", \"Software\", \"SpecializedREITs\",
     \"SpecialtyChemicals\", \"SpecialtyMiningAndMetals\", \"TextilesAndLeatherGoods\",
     \"TiresAndRubberProducts\", \"Tobacco\", \"ToysAndChildrenProducts\", \"UKInvestmentTrusts\",
     \"Uranium\", \"WaterAndRelatedUtilities\", and \"WirelessTelecommunicationsServices\"."""
    industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = rest_field(name="industryGroup")
    """TRBC industry group of the business sector. Known values are: \"AerospaceAndDefense\",
     \"AutomobilesAndAutoParts\", \"BankingAndInvestmentServices\", \"BankingServices\",
     \"Beverages\", \"BiotechnologyAndMedicalResearch\", \"Chemicals\", \"Coal\",
     \"CollectiveInvestments\", \"CommunicationsAndNetworking\",
     \"ComputersPhonesAndHouseholdElectronics\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConsumerGoodsConglomerates\", \"ContainersAndPackaging\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedRetail\", \"ElectricUtilitiesAndIPPs\",
     \"ElectronicEquipmentAndParts\", \"FinancialTechnologyAndInfrastructure\",
     \"FoodAndDrugRetailing\", \"FoodAndTobacco\", \"FreightAndLogisticsServices\",
     \"GovernmentActivity\", \"HealthcareEquipmentAndSupplies\", \"HealthcareProvidersAndServices\",
     \"HomebuildingAndConstructionSupplies\", \"HotelsAndEntertainmentServices\",
     \"HouseholdGoods\", \"InstitutionsAssociationsAndOrganizations\", \"Insurance\",
     \"IntegratedHardwareAndSoftware\", \"InvestmentBankingAndInvestmentServices\",
     \"InvestmentHoldingCompanies\", \"LeisureProducts\",
     \"MachineryToolsHeavyVehiclesTrainsAndShips\", \"MediaAndPublishing\", \"MetalsAndMining\",
     \"MiscellaneousEducationalService\", \"MultilineUtilities\", \"NaturalGasUtilities\",
     \"OfficeEquipment\", \"OilAndGas\", \"OilAndGasRelatedEquipmentAndServices\",
     \"PaperAndForestProducts\", \"PassengerTransportationServices\",
     \"PersonalAndHouseholdProductsAndServices\", \"Pharmaceuticals\",
     \"ProfessionalAndBusinessEducation\", \"ProfessionalAndCommercialServices\", \"Providers\",
     \"RealEstateOperations\", \"RenewableEnergy\", \"ResidentialAndCommercialREITs\",
     \"SchoolCollegeAndUniversity\", \"SemiconductorsAndSemiconductorEquipment\",
     \"SoftwareAndITServices\", \"SpecialtyRetailers\", \"TelecommunicationsServices\",
     \"TextilesAndApparel\", \"TransportInfrastructure\", \"Uranium\", and
     \"WaterAndRelatedUtilities\"."""
    is_currency_country_originator: Optional[bool] = rest_field(name="isCurrencyCountryOriginator")
    issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = rest_field(name="issuerType")
    """Type of the issuer. Available values are: Agency, Corporate, Munis, NonFinancials, Sovereign,
     Supranational. Known values are: \"Agency\", \"Corporate\", \"Munis\", \"NonFinancials\",
     \"Sovereign\", and \"Supranational\"."""
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """Get mainConstituentAssetClass. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    name: Optional[str] = rest_field()
    """Get name."""
    rating: Optional[Union[str, "_models.RatingEnum"]] = rest_field()
    """Get rating. Known values are: \"A\", \"A1\", \"A2\", \"A3\", \"AA\", \"AAA\", \"AAHigh\",
     \"AALow\", \"AAMinus\", \"AAPlus\", \"AHigh\", \"ALow\", \"AMinus\", \"APlus\", \"Aa1\",
     \"Aa2\", \"Aa3\", \"Aaa\", \"B\", \"B1\", \"B2\", \"B3\", \"BB\", \"BBB\", \"BBBHigh\",
     \"BBBLow\", \"BBBMinus\", \"BBBPlus\", \"BBHigh\", \"BBLow\", \"BBMinus\", \"BBPlus\",
     \"BHigh\", \"BLow\", \"BMinus\", \"BPlus\", \"Ba1\", \"Ba2\", \"Ba3\", \"Baa1\", \"Baa2\",
     \"Baa3\", \"C\", \"CC\", \"CCC\", \"CCCHigh\", \"CCCLow\", \"CCCMinus\", \"CCCPlus\",
     \"CCHigh\", \"CCLow\", \"CHigh\", \"CLow\", \"Ca\", \"Caa1\", \"Caa2\", \"Caa3\", \"D\",
     \"DD\", \"DDD\", \"F1\", \"F1Plus\", \"F2\", and \"F3\"."""
    rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = rest_field(name="ratingScaleSource")
    """Get ratingScaleSource. Known values are: \"DBRS\", \"Fitch\", \"Moodys\", \"Refinitiv\", and
     \"SAndP\"."""
    reference_entity: Optional[str] = rest_field(name="referenceEntity")
    """Code to define the reference entity."""
    reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = rest_field(
        name="referenceEntityType"
    )
    """Type of the reference entity (mandatory if referenceEntity is defined). Available values are:
     - ChainRic   - BondIsin   - BondRic   - OrganisationId   - Ticker. Known values are:
     \"BondIsin\", \"BondRic\", \"ChainRic\", \"OrganisationId\", and \"Ticker\"."""
    seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = rest_field()
    """Get seniority. Known values are: \"JuniorSecuredOrJuniorSubordinatedSecured\",
     \"JuniorUnsecuredOrJuniorSubordinatedUnsecured\", \"Secured\", \"SeniorNonPreferred\",
     \"SeniorPreferred\", \"SeniorSecured\", \"SeniorSecuredFirstAndRefundingMortgage\",
     \"SeniorSecuredFirstLien\", \"SeniorSecuredFirstMortgage\",
     \"SeniorSecuredGeneralAndRefundingMortgage\", \"SeniorSecuredMortgage\",
     \"SeniorSecuredSecondLien\", \"SeniorSecuredSecondMortgage\", \"SeniorSecuredThirdMortgage\",
     \"SeniorSubordinatedSecured\", \"SeniorSubordinatedUnsecured\", \"SeniorUnsecured\",
     \"SubordinatedSecured\", \"SubordinatedUnsecured\", and \"Unsecured\"."""
    source: Optional[str] = rest_field()
    """Source or contributor code Default value is \\"Refinitiv\\"."""

    @overload
    def __init__(
        self,
        *,
        business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = None,
        country: Optional[str] = None,
        credit_curve_type: Optional[Union[str, "_models.CreditCurveTypeEnum"]] = None,
        currency: Optional[str] = None,
        curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = None,
        curve_tenors: Optional[List[str]] = None,
        economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        industry: Optional[Union[str, "_models.IndustryEnum"]] = None,
        industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = None,
        is_currency_country_originator: Optional[bool] = None,
        issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        name: Optional[str] = None,
        rating: Optional[Union[str, "_models.RatingEnum"]] = None,
        rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = None,
        reference_entity: Optional[str] = None,
        reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = None,
        seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveDefinitionResponse(_model_base.Model):
    """CreditCurveDefinitionResponse.

    Attributes
    ----------
    curve_definition : ~analyticsapi.models.CreditCurveDefinitionDescription
    curve_info : ~analyticsapi.models.CurveInfo
    segments : list[~analyticsapi.models.CreditCurveInstrumentsSegment]
        Get segments.  The default value is None, needs to be assigned before
        using.
    """

    curve_definition: Optional["_models.CreditCurveDefinitionDescription"] = rest_field(name="curveDefinition")
    curve_info: Optional["_models.CurveInfo"] = rest_field(name="curveInfo")
    segments: Optional[List["_models.CreditCurveInstrumentsSegment"]] = rest_field()
    """Get segments."""

    @overload
    def __init__(
        self,
        *,
        curve_definition: Optional["_models.CreditCurveDefinitionDescription"] = None,
        curve_info: Optional["_models.CurveInfo"] = None,
        segments: Optional[List["_models.CreditCurveInstrumentsSegment"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveDefinitionResponseItem(_model_base.Model):
    """CreditCurveDefinitionResponseItem.

    Attributes
    ----------
    business_sector : str or ~analyticsapi.models.BusinessSectorEnum
        TRBC business sector of the economic sector. Known values are:
        "AcademicAndEducationalServices", "AppliedResources",
        "AutomobilesAndAutoParts", "BankingAndInvestmentServices", "Chemicals",
        "CollectiveInvestments", "ConsumerGoodsConglomerates",
        "CyclicalConsumerProducts", "CyclicalConsumerServices",
        "EnergyFossilFuels", "FinancialTechnologyAndInfrastructure",
        "FoodAndBeverages", "FoodAndDrugRetailing", "GovernmentActivity",
        "HealthcareServicesAndEquipment", "IndustrialAndCommercialServices",
        "IndustrialGoods", "InstitutionsAssociationsAndOrganizations",
        "Insurance", "InvestmentHoldingCompanies", "MineralResources",
        "PersonalAndHouseholdProductsAndServices",
        "PharmaceuticalsAndMedicalResearch", "RealEstate", "RenewableEnergy",
        "Retailers", "SoftwareAndITServices", "TechnologyEquipment",
        "TelecommunicationsServices", "Transportation", "Uranium", and
        "Utilities".
    country : str
        Country code of the issuer defined with Alpha-2 Code ISO 3166 country
        code convention.
    credit_curve_type : str or ~analyticsapi.models.CreditCurveTypeEnum
        Get creditCurveType. Known values are: "BondIssuerCurve",
        "BondPeersCurve", "BondRatingCurve", "BondSectorRatingCurve",
        "CDSIssuerCurve", "CDSPeersCurve", "CDSRatingCurve", and
        "CDSSectorRatingCurve".
    currency : str
        Bond curve currency code.
    curve_sub_type : str or ~analyticsapi.models.CurveSubTypeEnum
        Get curveSubType. Known values are: "BondCarry",
        "BreakevenInflationCurve", "CDSCreditIndex", "CapFloorVolatility",
        "CentralBankInterestRateProbability", "CommercialPaperBenchmark",
        "CorporateBondBenchmark", "CorporateBondPar", "CorporateBondSpread",
        "CorporateBondZero", "CorporateCDSCredit", "CorporateCashCredit",
        "CorporateIssuer", "Covered", "Deposit", "ForwardGovernmentBondZero",
        "ForwardGovernmentPar", "ForwardInflation", "ForwardRateAgreementZero",
        "ForwardStartingSwap", "GovernmentBenchmark",
        "GovernmentBondBenchmark", "GovernmentBondVolatility",
        "GovernmentCDSCredit", "GovernmentCashCredit",
        "GovernmentStripBenchmark", "InflationLinkedBenchmark",
        "InflationLinkedZero", "InterbankOfferRate", "InterestRateSwap",
        "InterestRateVolatility", "MunicipalBenchmark", "OvernightIndexSwap",
        "OvernightIndexSwapZero", "SemiSovereignCashCredit",
        "ShortTermInterestRateFuturesZero",
        "SolvencyIICorporateCreditSprdRating",
        "SolvencyIICoveredPfandbriefIssuer",
        "SolvencyIIFinancialCreditSprdRating",
        "SolvencyIIInterestRateSwapYield", "SolvencyIILiquiditySpread",
        "SolvencyIIPfandbriefYieldByCurrency", "SolvencyIIStructuredABSRating",
        "SolvencyIIStructuredMBSRating", "SolvencyIISwapDerivedZero",
        "SolvencyIITreasuryVersusIRSSpread", "SovereignAgencyBenchmark",
        "SwapCarry", "SwapPar", "SwapZero", "SwaptionVolatility", and
        "TreasurySpread".
    curve_tenors : list[str]
        User defined maturities to compute.  The default value is None, needs
        to be assigned before using.
    economic_sector : str or ~analyticsapi.models.EconomicSectorEnum
        TRBC economic sector of the issuer.  Available values are:
        BasicMaterials, Consumer Cyclicals, Consumer Non-Cyclicals, Energy,
        Financials, Healthcare, Industrials, Technology, Utilities. Known
        values are: "AcademicAndEducationalServices", "BasicMaterials",
        "ConsumerCyclicals", "ConsumerNonCyclicals", "Energy", "Financials",
        "GovernmentActivity", "Healthcare", "Industrials",
        "InstitutionsAssociationsAndOrganizations", "RealEstate", "Technology",
        and "Utilities".
    first_historical_availability_date : ~datetime.date
        The date starting from which the definition of the curve can be used.
        The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01').
    id : str
        Id of the curve definition.
    industry : str or ~analyticsapi.models.IndustryEnum
        TRBC industry of the industry group. Known values are:
        "AdvancedMedicalEquipmentAndTechnology", "AdvertisingAndMarketing",
        "AerospaceAndDefense", "AgriculturalChemicals", "Airlines",
        "AirportOperatorsAndServices", "Aluminum", "ApparelAndAccessories",
        "ApparelAndAccessoriesRetailers", "AppliancesToolsAndHousewares",
        "AutoAndTruckManufacturers", "AutoTruckAndMotorcycleParts",
        "AutoVehiclesPartsAndServiceRetailers", "Banks",
        "BiotechnologyAndMedicalResearch", "BlockchainAndCryptocurrency",
        "Brewers", "Broadcasting", "BusinessSupportServices",
        "BusinessSupportSupplies", "CasinosAndGaming", "CharityOrganizations",
        "CivicAndSocialOrganizations", "ClosedEndFunds", "Coal",
        "CommercialPrintingServices", "CommercialREITs", "CommodityChemicals",
        "CommunicationsAndNetworking", "ComputerAndElectronicsRetailers",
        "ComputerHardware", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConstructionSuppliesAndFixtures",
        "ConsumerGoodsConglomerates", "ConsumerLending", "ConsumerPublishing",
        "CorporateFinancialServices",
        "CourierPostalAirFreightAndLandbasedLogistics", "CrowdCollaboration",
        "DepartmentStores", "DiscountStores", "DistillersAndWineries",
        "DiversifiedChemicals", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedInvestmentServices", "DiversifiedMining",
        "DiversifiedREITs", "DrugRetailers", "ElectricUtilities",
        "ElectricalComponentsAndEquipment", "ElectronicEquipmentAndParts",
        "EmploymentServices", "EntertainmentProduction",
        "EnvironmentalOrganizations", "EnvironmentalServicesAndEquipment",
        "ExchangeTradedFunds",
        "FinancialAndCommodityMarketOperatorsAndServiceProviders",
        "FinancialTechnology", "FishingAndFarming", "FoodProcessing",
        "FoodRetailAndDistribution", "Footwear", "ForestAndWoodProducts",
        "Gold", "GovernmentAdministrationActivities",
        "GovernmentAndGovernmentFinance", "GroundFreightAndLogistics",
        "HealthcareFacilitiesAndServices", "HeavyElectricalEquipment",
        "HeavyMachineryAndVehicles", "HighwaysAndRailTracks",
        "HomeFurnishings", "HomeFurnishingsRetailers",
        "HomeImprovementProductsAndServicesRetailers", "Homebuilding",
        "HotelsMotelsAndCruiseLines", "HouseholdElectronics",
        "HouseholdProducts", "ITServicesAndConsulting",
        "IndependentPowerProducers", "IndustrialMachineryAndEquipment",
        "InsuranceFunds", "IntegratedHardwareAndSoftware",
        "IntegratedOilAndGas", "IntegratedTelecommunicationsServices",
        "InvestmentBankingAndBrokerageServices", "InvestmentHoldingCompanies",
        "InvestmentManagementAndFundOperators", "IronAndSteel",
        "LegalAndSafetyPublicServices", "LeisureAndRecreation",
        "LifeAndHealthInsurance", "ManagedHealthcare",
        "MarineFreightAndLogistics", "MarinePortServices",
        "MedicalEquipmentSuppliesAndDistribution",
        "MiningSupportServicesAndEquipment",
        "MiscellaneousEducationalServiceProviders",
        "MiscellaneousInfrastructure", "MiscellaneousSpecialtyRetailers",
        "MultilineInsuranceAndBrokers", "MultilineUtilities", "MutualFunds",
        "NationalSecurityAndInternationalAffairs", "NaturalGasUtilities",
        "NonAlcoholicBeverages", "NonGoldPreciousMetalsAndMinerals",
        "NonPaperContainersAndPackaging", "OfficeEquipment",
        "OilAndGasDrilling", "OilAndGasExplorationAndProduction",
        "OilAndGasRefiningAndMarketing", "OilAndGasTransportationServices",
        "OilRelatedServicesAndEquipment", "OnlineServices", "PaperPackaging",
        "PaperProducts", "PassengerTransportationGroundAndSea", "PensionFunds",
        "PersonalProducts", "PersonalServices", "Pharmaceuticals",
        "PhonesAndHandheldDevices", "ProfessionalAndBusinessEducation",
        "ProfessionalInformationServices", "ProfessionalOrganizations",
        "PropertyAndCasualtyInsurance",
        "RealEstateRentalDevelopmentAndOperations", "RealEstateServices",
        "RecreationalProducts", "Reinsurance", "ReligiousOrganizations",
        "RenewableEnergyEquipmentAndServices", "RenewableFuels",
        "ResidentialREITs", "RestaurantsAndBars", "SchoolCollegeAndUniversity",
        "SemiconductorEquipmentAndTesting", "Semiconductors", "Shipbuilding",
        "Software", "SpecializedREITs", "SpecialtyChemicals",
        "SpecialtyMiningAndMetals", "TextilesAndLeatherGoods",
        "TiresAndRubberProducts", "Tobacco", "ToysAndChildrenProducts",
        "UKInvestmentTrusts", "Uranium", "WaterAndRelatedUtilities", and
        "WirelessTelecommunicationsServices".
    industry_group : str or ~analyticsapi.models.IndustryGroupEnum
        TRBC industry group of the business sector. Known values are:
        "AerospaceAndDefense", "AutomobilesAndAutoParts",
        "BankingAndInvestmentServices", "BankingServices", "Beverages",
        "BiotechnologyAndMedicalResearch", "Chemicals", "Coal",
        "CollectiveInvestments", "CommunicationsAndNetworking",
        "ComputersPhonesAndHouseholdElectronics", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConsumerGoodsConglomerates",
        "ContainersAndPackaging", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedRetail", "ElectricUtilitiesAndIPPs",
        "ElectronicEquipmentAndParts", "FinancialTechnologyAndInfrastructure",
        "FoodAndDrugRetailing", "FoodAndTobacco",
        "FreightAndLogisticsServices", "GovernmentActivity",
        "HealthcareEquipmentAndSupplies", "HealthcareProvidersAndServices",
        "HomebuildingAndConstructionSupplies",
        "HotelsAndEntertainmentServices", "HouseholdGoods",
        "InstitutionsAssociationsAndOrganizations", "Insurance",
        "IntegratedHardwareAndSoftware",
        "InvestmentBankingAndInvestmentServices", "InvestmentHoldingCompanies",
        "LeisureProducts", "MachineryToolsHeavyVehiclesTrainsAndShips",
        "MediaAndPublishing", "MetalsAndMining",
        "MiscellaneousEducationalService", "MultilineUtilities",
        "NaturalGasUtilities", "OfficeEquipment", "OilAndGas",
        "OilAndGasRelatedEquipmentAndServices", "PaperAndForestProducts",
        "PassengerTransportationServices",
        "PersonalAndHouseholdProductsAndServices", "Pharmaceuticals",
        "ProfessionalAndBusinessEducation",
        "ProfessionalAndCommercialServices", "Providers",
        "RealEstateOperations", "RenewableEnergy",
        "ResidentialAndCommercialREITs", "SchoolCollegeAndUniversity",
        "SemiconductorsAndSemiconductorEquipment", "SoftwareAndITServices",
        "SpecialtyRetailers", "TelecommunicationsServices",
        "TextilesAndApparel", "TransportInfrastructure", "Uranium", and
        "WaterAndRelatedUtilities".
    is_currency_country_originator : bool
    issuer_type : str or ~analyticsapi.models.IssuerTypeEnum
        Type of the issuer. Available values are: Agency, Corporate, Munis,
        NonFinancials, Sovereign, Supranational. Known values are: "Agency",
        "Corporate", "Munis", "NonFinancials", "Sovereign", and
        "Supranational".
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        Get mainConstituentAssetClass. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    name : str
        Get name.
    rating : str or ~analyticsapi.models.RatingEnum
        Get rating. Known values are: "A", "A1", "A2", "A3", "AA", "AAA",
        "AAHigh", "AALow", "AAMinus", "AAPlus", "AHigh", "ALow", "AMinus",
        "APlus", "Aa1", "Aa2", "Aa3", "Aaa", "B", "B1", "B2", "B3", "BB",
        "BBB", "BBBHigh", "BBBLow", "BBBMinus", "BBBPlus", "BBHigh", "BBLow",
        "BBMinus", "BBPlus", "BHigh", "BLow", "BMinus", "BPlus", "Ba1", "Ba2",
        "Ba3", "Baa1", "Baa2", "Baa3", "C", "CC", "CCC", "CCCHigh", "CCCLow",
        "CCCMinus", "CCCPlus", "CCHigh", "CCLow", "CHigh", "CLow", "Ca",
        "Caa1", "Caa2", "Caa3", "D", "DD", "DDD", "F1", "F1Plus", "F2", and
        "F3".
    rating_scale_source : str or ~analyticsapi.models.RatingScaleSourceEnum
        Get ratingScaleSource. Known values are: "DBRS", "Fitch", "Moodys",
        "Refinitiv", and "SAndP".
    reference_entity : str
        Code to define the reference entity.
    reference_entity_type : str or ~analyticsapi.models.ReferenceEntityTypeEnum
        Type of the reference entity (mandatory if referenceEntity is defined).
        Available values are:   - ChainRic   - BondIsin   - BondRic   -
        OrganisationId   - Ticker. Known values are: "BondIsin", "BondRic",
        "ChainRic", "OrganisationId", and "Ticker".
    seniority : str or ~analyticsapi.models.CurvesAndSurfacesSeniorityEnum
        Get seniority. Known values are:
        "JuniorSecuredOrJuniorSubordinatedSecured",
        "JuniorUnsecuredOrJuniorSubordinatedUnsecured", "Secured",
        "SeniorNonPreferred", "SeniorPreferred", "SeniorSecured",
        "SeniorSecuredFirstAndRefundingMortgage", "SeniorSecuredFirstLien",
        "SeniorSecuredFirstMortgage",
        "SeniorSecuredGeneralAndRefundingMortgage", "SeniorSecuredMortgage",
        "SeniorSecuredSecondLien", "SeniorSecuredSecondMortgage",
        "SeniorSecuredThirdMortgage", "SeniorSubordinatedSecured",
        "SeniorSubordinatedUnsecured", "SeniorUnsecured",
        "SubordinatedSecured", "SubordinatedUnsecured", and "Unsecured".
    source : str
        Source or contributor code Default value is \\"Refinitiv\\".
    """

    business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = rest_field(name="businessSector")
    """TRBC business sector of the economic sector. Known values are:
     \"AcademicAndEducationalServices\", \"AppliedResources\", \"AutomobilesAndAutoParts\",
     \"BankingAndInvestmentServices\", \"Chemicals\", \"CollectiveInvestments\",
     \"ConsumerGoodsConglomerates\", \"CyclicalConsumerProducts\", \"CyclicalConsumerServices\",
     \"EnergyFossilFuels\", \"FinancialTechnologyAndInfrastructure\", \"FoodAndBeverages\",
     \"FoodAndDrugRetailing\", \"GovernmentActivity\", \"HealthcareServicesAndEquipment\",
     \"IndustrialAndCommercialServices\", \"IndustrialGoods\",
     \"InstitutionsAssociationsAndOrganizations\", \"Insurance\", \"InvestmentHoldingCompanies\",
     \"MineralResources\", \"PersonalAndHouseholdProductsAndServices\",
     \"PharmaceuticalsAndMedicalResearch\", \"RealEstate\", \"RenewableEnergy\", \"Retailers\",
     \"SoftwareAndITServices\", \"TechnologyEquipment\", \"TelecommunicationsServices\",
     \"Transportation\", \"Uranium\", and \"Utilities\"."""
    country: Optional[str] = rest_field()
    """Country code of the issuer defined with Alpha-2 Code ISO 3166 country code convention."""
    credit_curve_type: Optional[Union[str, "_models.CreditCurveTypeEnum"]] = rest_field(name="creditCurveType")
    """Get creditCurveType. Known values are: \"BondIssuerCurve\", \"BondPeersCurve\",
     \"BondRatingCurve\", \"BondSectorRatingCurve\", \"CDSIssuerCurve\", \"CDSPeersCurve\",
     \"CDSRatingCurve\", and \"CDSSectorRatingCurve\"."""
    currency: Optional[str] = rest_field()
    """Bond curve currency code."""
    curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = rest_field(name="curveSubType")
    """Get curveSubType. Known values are: \"BondCarry\", \"BreakevenInflationCurve\",
     \"CDSCreditIndex\", \"CapFloorVolatility\", \"CentralBankInterestRateProbability\",
     \"CommercialPaperBenchmark\", \"CorporateBondBenchmark\", \"CorporateBondPar\",
     \"CorporateBondSpread\", \"CorporateBondZero\", \"CorporateCDSCredit\",
     \"CorporateCashCredit\", \"CorporateIssuer\", \"Covered\", \"Deposit\",
     \"ForwardGovernmentBondZero\", \"ForwardGovernmentPar\", \"ForwardInflation\",
     \"ForwardRateAgreementZero\", \"ForwardStartingSwap\", \"GovernmentBenchmark\",
     \"GovernmentBondBenchmark\", \"GovernmentBondVolatility\", \"GovernmentCDSCredit\",
     \"GovernmentCashCredit\", \"GovernmentStripBenchmark\", \"InflationLinkedBenchmark\",
     \"InflationLinkedZero\", \"InterbankOfferRate\", \"InterestRateSwap\",
     \"InterestRateVolatility\", \"MunicipalBenchmark\", \"OvernightIndexSwap\",
     \"OvernightIndexSwapZero\", \"SemiSovereignCashCredit\", \"ShortTermInterestRateFuturesZero\",
     \"SolvencyIICorporateCreditSprdRating\", \"SolvencyIICoveredPfandbriefIssuer\",
     \"SolvencyIIFinancialCreditSprdRating\", \"SolvencyIIInterestRateSwapYield\",
     \"SolvencyIILiquiditySpread\", \"SolvencyIIPfandbriefYieldByCurrency\",
     \"SolvencyIIStructuredABSRating\", \"SolvencyIIStructuredMBSRating\",
     \"SolvencyIISwapDerivedZero\", \"SolvencyIITreasuryVersusIRSSpread\",
     \"SovereignAgencyBenchmark\", \"SwapCarry\", \"SwapPar\", \"SwapZero\", \"SwaptionVolatility\",
     and \"TreasurySpread\"."""
    curve_tenors: Optional[List[str]] = rest_field(name="curveTenors")
    """User defined maturities to compute."""
    economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = rest_field(name="economicSector")
    """TRBC economic sector of the issuer.  Available values are: BasicMaterials, Consumer Cyclicals,
     Consumer Non-Cyclicals, Energy, Financials, Healthcare, Industrials, Technology, Utilities.
     Known values are: \"AcademicAndEducationalServices\", \"BasicMaterials\",
     \"ConsumerCyclicals\", \"ConsumerNonCyclicals\", \"Energy\", \"Financials\",
     \"GovernmentActivity\", \"Healthcare\", \"Industrials\",
     \"InstitutionsAssociationsAndOrganizations\", \"RealEstate\", \"Technology\", and
     \"Utilities\"."""
    first_historical_availability_date: Optional[datetime.date] = rest_field(name="firstHistoricalAvailabilityDate")
    """The date starting from which the definition of the curve can be used.  The value is expressed
     in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    id: Optional[str] = rest_field()
    """Id of the curve definition."""
    industry: Optional[Union[str, "_models.IndustryEnum"]] = rest_field()
    """TRBC industry of the industry group. Known values are:
     \"AdvancedMedicalEquipmentAndTechnology\", \"AdvertisingAndMarketing\",
     \"AerospaceAndDefense\", \"AgriculturalChemicals\", \"Airlines\",
     \"AirportOperatorsAndServices\", \"Aluminum\", \"ApparelAndAccessories\",
     \"ApparelAndAccessoriesRetailers\", \"AppliancesToolsAndHousewares\",
     \"AutoAndTruckManufacturers\", \"AutoTruckAndMotorcycleParts\",
     \"AutoVehiclesPartsAndServiceRetailers\", \"Banks\", \"BiotechnologyAndMedicalResearch\",
     \"BlockchainAndCryptocurrency\", \"Brewers\", \"Broadcasting\", \"BusinessSupportServices\",
     \"BusinessSupportSupplies\", \"CasinosAndGaming\", \"CharityOrganizations\",
     \"CivicAndSocialOrganizations\", \"ClosedEndFunds\", \"Coal\", \"CommercialPrintingServices\",
     \"CommercialREITs\", \"CommodityChemicals\", \"CommunicationsAndNetworking\",
     \"ComputerAndElectronicsRetailers\", \"ComputerHardware\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConstructionSuppliesAndFixtures\", \"ConsumerGoodsConglomerates\",
     \"ConsumerLending\", \"ConsumerPublishing\", \"CorporateFinancialServices\",
     \"CourierPostalAirFreightAndLandbasedLogistics\", \"CrowdCollaboration\", \"DepartmentStores\",
     \"DiscountStores\", \"DistillersAndWineries\", \"DiversifiedChemicals\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedInvestmentServices\",
     \"DiversifiedMining\", \"DiversifiedREITs\", \"DrugRetailers\", \"ElectricUtilities\",
     \"ElectricalComponentsAndEquipment\", \"ElectronicEquipmentAndParts\", \"EmploymentServices\",
     \"EntertainmentProduction\", \"EnvironmentalOrganizations\",
     \"EnvironmentalServicesAndEquipment\", \"ExchangeTradedFunds\",
     \"FinancialAndCommodityMarketOperatorsAndServiceProviders\", \"FinancialTechnology\",
     \"FishingAndFarming\", \"FoodProcessing\", \"FoodRetailAndDistribution\", \"Footwear\",
     \"ForestAndWoodProducts\", \"Gold\", \"GovernmentAdministrationActivities\",
     \"GovernmentAndGovernmentFinance\", \"GroundFreightAndLogistics\",
     \"HealthcareFacilitiesAndServices\", \"HeavyElectricalEquipment\",
     \"HeavyMachineryAndVehicles\", \"HighwaysAndRailTracks\", \"HomeFurnishings\",
     \"HomeFurnishingsRetailers\", \"HomeImprovementProductsAndServicesRetailers\",
     \"Homebuilding\", \"HotelsMotelsAndCruiseLines\", \"HouseholdElectronics\",
     \"HouseholdProducts\", \"ITServicesAndConsulting\", \"IndependentPowerProducers\",
     \"IndustrialMachineryAndEquipment\", \"InsuranceFunds\", \"IntegratedHardwareAndSoftware\",
     \"IntegratedOilAndGas\", \"IntegratedTelecommunicationsServices\",
     \"InvestmentBankingAndBrokerageServices\", \"InvestmentHoldingCompanies\",
     \"InvestmentManagementAndFundOperators\", \"IronAndSteel\", \"LegalAndSafetyPublicServices\",
     \"LeisureAndRecreation\", \"LifeAndHealthInsurance\", \"ManagedHealthcare\",
     \"MarineFreightAndLogistics\", \"MarinePortServices\",
     \"MedicalEquipmentSuppliesAndDistribution\", \"MiningSupportServicesAndEquipment\",
     \"MiscellaneousEducationalServiceProviders\", \"MiscellaneousInfrastructure\",
     \"MiscellaneousSpecialtyRetailers\", \"MultilineInsuranceAndBrokers\", \"MultilineUtilities\",
     \"MutualFunds\", \"NationalSecurityAndInternationalAffairs\", \"NaturalGasUtilities\",
     \"NonAlcoholicBeverages\", \"NonGoldPreciousMetalsAndMinerals\",
     \"NonPaperContainersAndPackaging\", \"OfficeEquipment\", \"OilAndGasDrilling\",
     \"OilAndGasExplorationAndProduction\", \"OilAndGasRefiningAndMarketing\",
     \"OilAndGasTransportationServices\", \"OilRelatedServicesAndEquipment\", \"OnlineServices\",
     \"PaperPackaging\", \"PaperProducts\", \"PassengerTransportationGroundAndSea\",
     \"PensionFunds\", \"PersonalProducts\", \"PersonalServices\", \"Pharmaceuticals\",
     \"PhonesAndHandheldDevices\", \"ProfessionalAndBusinessEducation\",
     \"ProfessionalInformationServices\", \"ProfessionalOrganizations\",
     \"PropertyAndCasualtyInsurance\", \"RealEstateRentalDevelopmentAndOperations\",
     \"RealEstateServices\", \"RecreationalProducts\", \"Reinsurance\", \"ReligiousOrganizations\",
     \"RenewableEnergyEquipmentAndServices\", \"RenewableFuels\", \"ResidentialREITs\",
     \"RestaurantsAndBars\", \"SchoolCollegeAndUniversity\", \"SemiconductorEquipmentAndTesting\",
     \"Semiconductors\", \"Shipbuilding\", \"Software\", \"SpecializedREITs\",
     \"SpecialtyChemicals\", \"SpecialtyMiningAndMetals\", \"TextilesAndLeatherGoods\",
     \"TiresAndRubberProducts\", \"Tobacco\", \"ToysAndChildrenProducts\", \"UKInvestmentTrusts\",
     \"Uranium\", \"WaterAndRelatedUtilities\", and \"WirelessTelecommunicationsServices\"."""
    industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = rest_field(name="industryGroup")
    """TRBC industry group of the business sector. Known values are: \"AerospaceAndDefense\",
     \"AutomobilesAndAutoParts\", \"BankingAndInvestmentServices\", \"BankingServices\",
     \"Beverages\", \"BiotechnologyAndMedicalResearch\", \"Chemicals\", \"Coal\",
     \"CollectiveInvestments\", \"CommunicationsAndNetworking\",
     \"ComputersPhonesAndHouseholdElectronics\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConsumerGoodsConglomerates\", \"ContainersAndPackaging\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedRetail\", \"ElectricUtilitiesAndIPPs\",
     \"ElectronicEquipmentAndParts\", \"FinancialTechnologyAndInfrastructure\",
     \"FoodAndDrugRetailing\", \"FoodAndTobacco\", \"FreightAndLogisticsServices\",
     \"GovernmentActivity\", \"HealthcareEquipmentAndSupplies\", \"HealthcareProvidersAndServices\",
     \"HomebuildingAndConstructionSupplies\", \"HotelsAndEntertainmentServices\",
     \"HouseholdGoods\", \"InstitutionsAssociationsAndOrganizations\", \"Insurance\",
     \"IntegratedHardwareAndSoftware\", \"InvestmentBankingAndInvestmentServices\",
     \"InvestmentHoldingCompanies\", \"LeisureProducts\",
     \"MachineryToolsHeavyVehiclesTrainsAndShips\", \"MediaAndPublishing\", \"MetalsAndMining\",
     \"MiscellaneousEducationalService\", \"MultilineUtilities\", \"NaturalGasUtilities\",
     \"OfficeEquipment\", \"OilAndGas\", \"OilAndGasRelatedEquipmentAndServices\",
     \"PaperAndForestProducts\", \"PassengerTransportationServices\",
     \"PersonalAndHouseholdProductsAndServices\", \"Pharmaceuticals\",
     \"ProfessionalAndBusinessEducation\", \"ProfessionalAndCommercialServices\", \"Providers\",
     \"RealEstateOperations\", \"RenewableEnergy\", \"ResidentialAndCommercialREITs\",
     \"SchoolCollegeAndUniversity\", \"SemiconductorsAndSemiconductorEquipment\",
     \"SoftwareAndITServices\", \"SpecialtyRetailers\", \"TelecommunicationsServices\",
     \"TextilesAndApparel\", \"TransportInfrastructure\", \"Uranium\", and
     \"WaterAndRelatedUtilities\"."""
    is_currency_country_originator: Optional[bool] = rest_field(name="isCurrencyCountryOriginator")
    issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = rest_field(name="issuerType")
    """Type of the issuer. Available values are: Agency, Corporate, Munis, NonFinancials, Sovereign,
     Supranational. Known values are: \"Agency\", \"Corporate\", \"Munis\", \"NonFinancials\",
     \"Sovereign\", and \"Supranational\"."""
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """Get mainConstituentAssetClass. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    name: Optional[str] = rest_field()
    """Get name."""
    rating: Optional[Union[str, "_models.RatingEnum"]] = rest_field()
    """Get rating. Known values are: \"A\", \"A1\", \"A2\", \"A3\", \"AA\", \"AAA\", \"AAHigh\",
     \"AALow\", \"AAMinus\", \"AAPlus\", \"AHigh\", \"ALow\", \"AMinus\", \"APlus\", \"Aa1\",
     \"Aa2\", \"Aa3\", \"Aaa\", \"B\", \"B1\", \"B2\", \"B3\", \"BB\", \"BBB\", \"BBBHigh\",
     \"BBBLow\", \"BBBMinus\", \"BBBPlus\", \"BBHigh\", \"BBLow\", \"BBMinus\", \"BBPlus\",
     \"BHigh\", \"BLow\", \"BMinus\", \"BPlus\", \"Ba1\", \"Ba2\", \"Ba3\", \"Baa1\", \"Baa2\",
     \"Baa3\", \"C\", \"CC\", \"CCC\", \"CCCHigh\", \"CCCLow\", \"CCCMinus\", \"CCCPlus\",
     \"CCHigh\", \"CCLow\", \"CHigh\", \"CLow\", \"Ca\", \"Caa1\", \"Caa2\", \"Caa3\", \"D\",
     \"DD\", \"DDD\", \"F1\", \"F1Plus\", \"F2\", and \"F3\"."""
    rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = rest_field(name="ratingScaleSource")
    """Get ratingScaleSource. Known values are: \"DBRS\", \"Fitch\", \"Moodys\", \"Refinitiv\", and
     \"SAndP\"."""
    reference_entity: Optional[str] = rest_field(name="referenceEntity")
    """Code to define the reference entity."""
    reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = rest_field(
        name="referenceEntityType"
    )
    """Type of the reference entity (mandatory if referenceEntity is defined). Available values are:
     - ChainRic   - BondIsin   - BondRic   - OrganisationId   - Ticker. Known values are:
     \"BondIsin\", \"BondRic\", \"ChainRic\", \"OrganisationId\", and \"Ticker\"."""
    seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = rest_field()
    """Get seniority. Known values are: \"JuniorSecuredOrJuniorSubordinatedSecured\",
     \"JuniorUnsecuredOrJuniorSubordinatedUnsecured\", \"Secured\", \"SeniorNonPreferred\",
     \"SeniorPreferred\", \"SeniorSecured\", \"SeniorSecuredFirstAndRefundingMortgage\",
     \"SeniorSecuredFirstLien\", \"SeniorSecuredFirstMortgage\",
     \"SeniorSecuredGeneralAndRefundingMortgage\", \"SeniorSecuredMortgage\",
     \"SeniorSecuredSecondLien\", \"SeniorSecuredSecondMortgage\", \"SeniorSecuredThirdMortgage\",
     \"SeniorSubordinatedSecured\", \"SeniorSubordinatedUnsecured\", \"SeniorUnsecured\",
     \"SubordinatedSecured\", \"SubordinatedUnsecured\", and \"Unsecured\"."""
    source: Optional[str] = rest_field()
    """Source or contributor code Default value is \\"Refinitiv\\"."""

    @overload
    def __init__(
        self,
        *,
        business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = None,
        country: Optional[str] = None,
        credit_curve_type: Optional[Union[str, "_models.CreditCurveTypeEnum"]] = None,
        currency: Optional[str] = None,
        curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = None,
        curve_tenors: Optional[List[str]] = None,
        economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = None,
        first_historical_availability_date: Optional[datetime.date] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        industry: Optional[Union[str, "_models.IndustryEnum"]] = None,
        industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = None,
        is_currency_country_originator: Optional[bool] = None,
        issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        name: Optional[str] = None,
        rating: Optional[Union[str, "_models.RatingEnum"]] = None,
        rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = None,
        reference_entity: Optional[str] = None,
        reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = None,
        seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveDefinitionsResponse(_model_base.Model):
    """CreditCurveDefinitionsResponse.

    Attributes
    ----------
    data : list[~analyticsapi.models.CreditCurveDefinitionsResponseItems]
        Get data.  The default value is None, needs to be assigned before
        using.
    """

    data: Optional[List["_models.CreditCurveDefinitionsResponseItems"]] = rest_field()
    """Get data."""

    @overload
    def __init__(
        self,
        data: Optional[List["_models.CreditCurveDefinitionsResponseItems"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CreditCurveDefinitionsResponseItems(_model_base.Model):
    """CreditCurveDefinitionsResponseItems.

    Attributes
    ----------
    curve_definitions : list[~analyticsapi.models.CreditCurveDefinitionResponseItem]
        Get curveDefinitions.  The default value is None, needs to be assigned
        before using.
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    """

    curve_definitions: Optional[List["_models.CreditCurveDefinitionResponseItem"]] = rest_field(name="curveDefinitions")
    """Get curveDefinitions."""
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""

    @overload
    def __init__(
        self,
        *,
        curve_definitions: Optional[List["_models.CreditCurveDefinitionResponseItem"]] = None,
        curve_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveInput(_model_base.Model):
    """The object defining the 3rd party credit curve.

    Attributes
    ----------
    zc_type : str or ~analyticsapi.models.ZcTypeEnum
        The type of values provided (zero coupon rates or discount factors).
        Required. Known values are: "Rate" and "DiscountFactor".
    zc_unit : str or ~analyticsapi.models.UnitEnum
        The unit of the values provided (absolute, basis point, percentage).
        Required. Known values are: "Absolute", "BasisPoint", and "Percentage".
    points : list[~analyticsapi.models.CurveDataPoint]
        The list of dates and values. Required.  The default value is None,
        needs to be assigned before using.
    entity_code : str
        The code of the reference entity. Required.
    """

    zc_type: Union[str, "_models.ZcTypeEnum"] = rest_field(name="zcType")
    """The type of values provided (zero coupon rates or discount factors). Required. Known values
     are: \"Rate\" and \"DiscountFactor\"."""
    zc_unit: Union[str, "_models.UnitEnum"] = rest_field(name="zcUnit")
    """The unit of the values provided (absolute, basis point, percentage). Required. Known values
     are: \"Absolute\", \"BasisPoint\", and \"Percentage\"."""
    points: List["_models.CurveDataPoint"] = rest_field()
    """The list of dates and values. Required."""
    entity_code: str = rest_field(name="entityCode")
    """The code of the reference entity. Required."""

    @overload
    def __init__(
        self,
        *,
        zc_type: Union[str, "_models.ZcTypeEnum"],
        zc_unit: Union[str, "_models.UnitEnum"],
        points: List["_models.CurveDataPoint"],
        entity_code: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveInstrumentsSegment(_model_base.Model):
    """CreditCurveInstrumentsSegment.

    Attributes
    ----------
    constituents : ~analyticsapi.models.CreditConstituentsDescription
    curve_parameters : ~analyticsapi.models.CreditCurveParametersDescription
    start_date : ~datetime.date
        Get startDate.
    """

    constituents: Optional["_models.CreditConstituentsDescription"] = rest_field()
    curve_parameters: Optional["_models.CreditCurveParametersDescription"] = rest_field(name="curveParameters")
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """Get startDate."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.CreditConstituentsDescription"] = None,
        curve_parameters: Optional["_models.CreditCurveParametersDescription"] = None,
        start_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveParameters(_model_base.Model):
    """CreditCurveParameters.

    Attributes
    ----------
    basis_spline_knots : int
        Number of knots you can choose to build the yield curve when using the
        basis-spline models.
    basis_spline_smooth_model : str or ~analyticsapi.models.BasisSplineSmoothModelEnum
        Basis spline model. Values can be: - McCullochLinearRegression -
        WaggonerSmoothingSplineModel - AndersonSmoothingSplineModel. Known
        values are: "AndersonSmoothingSplineModel",
        "McCullochLinearRegression", and "WaggonerSmoothingSplineModel".
    calendar_adjustment : str or ~analyticsapi.models.CalendarAdjustmentEnum
        The cash flow adjustment according to a selected calendar. The possible
        values are:   * No   * Weekend: for the cash flow pricing using the
        calendar &#39;Weekend&#39;   * Calendar: for the cash flow pricing
        using the calendar defined by the parameter &#39;calendars&#39;. The
        default value is &#39;Calendar&#39;. Known values are: "Calendar",
        "No", and "Weekend".
    calendars : list[str]
        The list of comma-separated calendar codes used to define non-working
        days and to adjust interest rate curve coupon dates and values (e.g.,
        &#39;EMU_FI&#39;). By default, the calendar code is derived from the
        interest rate curve currency.  The default value is None, needs to be
        assigned before using.
    calibration_model : str or ~analyticsapi.models.CalibrationModelEnum
        Bond zero coupon curve calibration method. Values can be:   -
        BasisSpline   - NelsonSiegelSvensson   - Bootstrap. Known values are:
        "BasisSpline", "Bootstrap", and "NelsonSiegelSvensson".
    calibration_parameters : ~analyticsapi.models.CalibrationParameters
    compounding_type : str or ~analyticsapi.models.CompoundingTypeEnum
        The yield type of the interest rate curve. The possible values are:   *
        Discounted   * Compounded   * Continuous   * MoneyMarket The default
        value is &#39;Compounded&#39;. Known values are: "Compounded",
        "Continuous", "Discounted", and "MoneyMarket".
    extrapolation_mode : str or ~analyticsapi.models.ExtrapolationModeEnum
        The extrapolation method used in the zero coupon curve bootstrapping.
        The possible values are:   * None: no extrapolation,   * Constant:
        constant extrapolation,   * Linear: linear extrapolation. The default
        value is 'None'. Known values are: "Constant", "ConstantForwardRate",
        "ConstantRate", "Linear", "None", and "UltimateForwardRate".
    interest_calculation_method : str or ~analyticsapi.models.CurvesAndSurfacesInterestCalculationMethodEnum
        The day count basis method used to compute the points of the zero
        coupon curve. The possible values are:   * Dcb_30_360     Actual number
        of days in the coupon period calculated on the basis of a year of 360
        days with twelve 30-day months unless: - the last day of the period is
        the 31st day of a month and the first day of the period is a day other
        than the 30th or 31st day of a month, in which case the month that
        includes the last day shall not be considered to be shortened to a
        30-day month,     - the last day of the period is the last day of the
        month of February, in which case the month of February shall not be
        considered to be lengthened to a 30-day month.   * Dcb_30_Actual
        The day count is identical to 30/360 (US) and the year basis is
        identical to Actual/Actual.   * Dcb_Actual_360     The day count is the
        actual number of days of the period. The year basis is 360.   *
        Dcb_Actual_365 The day count is the actual number of days of the
        period. The year basis is 365.   * Dcb_Actual_Actual     The DCB is
        calculated by Actual days / year basis where:     - Actual days are
        defined as the actual days between the starting date (D1.M1.Y1) and end
        date (D2.M2.Y2).     - Year basis is defined as the actual days between
        the start date (D1.M1.Y1) and the next relevant interest payment date
        (D3.M3.Y3) multiplied by the instrument coupon frequency.   *
        Dcb_Actual_Actual_ISDA     Similar to Actual/365, except for a period
        that includes days falling in a leap year. It is calculated by DCB
        &#x3D; number of days in a leap year/366 + number of days in a non-leap
        year/365.     A convention is also known as Actual/365 ISDA.
        *Dcb_30_360_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if
        D1 is 31, change it to 30,     - if D2 is 31 and D1 is 30, change D2 to
        30.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
        Dcb_30_365_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if
        D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31
        then D2&#x3D;30.     Then the date difference is
        (Y2-Y1)x365+(M2-M1)x30+(D2-D1)   * Dcb_30_360_US For two dates
        (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     -
        if D2&#x3D;31 and D1&#x3D;30 or 31 then D2&#x3D;30,     - if D1 is the
        last day of February then D1&#x3D;30,     - if D1 is the last day of
        February and D2 is the last day of February then D2&#x3D;30.     The
        last day of February is February 29 in leap years and February 28 in
        non leap years.     The 30/360 US rule is identical to 30/360 ISDA when
        the EOM (end-of-month) convention does not apply. This indicates
        whether all coupon payment dates fall on the last day of the month. If
        the investment is not EOM, it will always pay on the same day of the
        month (e.g., the 10th).     Then the date difference is
        (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_Actual_Actual_AFB     The DCB
        is calculated by Actual days / year basis where:     Actual days are
        defined as the actual days between the start date (D1.M1.Y1) and end
        date (D2.M2.Y2). Year basis is either 365 if the calculation period
        does not contain 29th Feb, or 366 if the calculation period includes
        29th Feb.   * Dcb_WorkingDays_252     The day count is the actual
        number of business days of the period according to the instrument
        calendars. The year basis is 252. Commonly used in the Brazilian
        market.   * Dcb_Actual_365L     The day count is the actual number of
        days of the period. The year basis is calculated in the following two
        rules:     - if the coupon frequency is annual, then year basis is 366
        if the 29 Feb. is included in the interest period, else 365,     - if
        the coupon frequency is not annual, then year basis is 366 for each
        interest period where ending date falls in a leap year, otherwise it is
        365.   * Dcb_ActualLeapDay_365     The day count ignores 29th February
        when counting days. The year basis is 365 days.   *
        Dcb_ActualLeapDay_360     The day count ignores 29th February when
        counting days. The year basis is 360 days.   * Dcb_Actual_36525     The
        day count is the actual number of days of the period. The year basis is
        365.25.   * Dcb_Actual_365_CanadianConvention Follows the Canadian
        domestic bond market convention. The day count basis is computed as
        follows:     - if the number of days of a period is less than the
        actual number of days in a regular coupon period the Dcb_Actual_365
        convention is used,     - otherwise: DCB &#x3D; 1 -
        DaysRemainingInPeriod x Frequency / 365.   * Dcb_30_360_German     For
        two dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then
        D1&#x3D;30,     - if D2&#x3D;31 then D2&#x3D;30,     - if D1 is the
        last day of February then D1&#x3D;30,     - if D2 is the last day of
        February then D2&#x3D;30.     The last day of February is February 29
        in leap years and February 28 in non leap years.     Then the date
        difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_30_365_German
        Similar to 30/360 (German), except that the year basis is treated as
        365 days.   * Dcb_30_Actual_German     The day count is identical to
        30/360 (German) and the year basis is similar to Actual/Actual. This
        method was formerly used in the Eurobond markets.   * Dcb_30E_360_ISMA
        Actual number of days in the coupon period calculated on the basis of a
        year of 360 days with twelve 30-day months (regardless of the date of
        the first day or last day of the period).   * Dcb_Actual_364     A
        special case of Actual/Actual (ISMA) when a coupon period contains 91
        or 182 days. Actual/364 applies for some short-term instruments.
        Day count basis &#x3D; 364.   * Dcb_30_Actual_ISDA   *
        Dcb_30_365_Brazil   * Dcb_Actual_365P   * Dcb_Constant. Known values
        are: "Dcb_30E_360_ISMA", "Dcb_30_360", "Dcb_30_360_German",
        "Dcb_30_360_ISDA", "Dcb_30_360_US", "Dcb_30_365_Brazil",
        "Dcb_30_365_German", "Dcb_30_365_ISDA", "Dcb_30_Actual",
        "Dcb_30_Actual_German", "Dcb_30_Actual_ISDA", "Dcb_ActualLeapDay_360",
        "Dcb_ActualLeapDay_365", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_36525", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_Actual_365_CanadianConvention",
        "Dcb_Actual_Actual", "Dcb_Actual_Actual_AFB", "Dcb_Actual_Actual_ISDA",
        "Dcb_Constant", and "Dcb_WorkingDays_252".
    interpolation_mode : str or ~analyticsapi.models.InterpolationModeEnum
        The interpolation method used in zero curve bootstrapping. The possible
        values are:   * CubicDiscount: local cubic interpolation of discount
        factors   * CubicRate: local cubic interpolation of rates   *
        CubicSpline: a natural cubic spline   * ForwardMonotoneConvex: forward
        Monotone Convexc interpolation   * Linear: linear interpolation * Log:
        log-linear interpolation   * Hermite: Hermite (Bessel) interpolation
        * AkimaMethod: the Akima method (a smoother variant of local cubic
        interpolation)   * FritschButlandMethod: the Fritsch-Butland method (a
        monotonic cubic variant)   * KrugerMethod: the Kruger method (a
        monotonic cubic variant)   * MonotonicCubicNaturalSpline: a monotonic
        natural cubic spline   * MonotonicHermiteCubic: monotonic Hermite
        (Bessel) cubic interpolation   * TensionSpline: a tension spline. Known
        values are: "AkimaMethod", "CubicDiscount", "CubicRate", "CubicSpline",
        "ForwardMonotoneConvex", "FritschButlandMethod", "Hermite",
        "KrugerMethod", "Linear", "Log", "MonotonicCubicNaturalSpline",
        "MonotonicHermiteCubic", "Step", and "TensionSpline".
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        The quoted price side of the instrument to be used for the zero coupon
        curve construction. The possible values are:   * Bid   * Ask   * Mid
        The default value is &#39;Mid&#39;. Known values are: "Ask", "Bid",
        "Last", and "Mid".
    use_delayed_data_if_denied : bool
    use_duration_weighted_minimization : bool
    use_multi_dimensional_solver : bool
    valuation_date : ~datetime.date
        Valuation date for this curve, that means the data at which instrument
        market data is retrieved.
    """

    basis_spline_knots: Optional[int] = rest_field(name="basisSplineKnots")
    """Number of knots you can choose to build the yield curve when using the basis-spline models."""
    basis_spline_smooth_model: Optional[Union[str, "_models.BasisSplineSmoothModelEnum"]] = rest_field(
        name="basisSplineSmoothModel"
    )
    """Basis spline model. Values can be: - McCullochLinearRegression - WaggonerSmoothingSplineModel -
     AndersonSmoothingSplineModel. Known values are: \"AndersonSmoothingSplineModel\",
     \"McCullochLinearRegression\", and \"WaggonerSmoothingSplineModel\"."""
    calendar_adjustment: Optional[Union[str, "_models.CalendarAdjustmentEnum"]] = rest_field(name="calendarAdjustment")
    """The cash flow adjustment according to a selected calendar. The possible values are:   * No   *
     Weekend: for the cash flow pricing using the calendar &#39;Weekend&#39;   * Calendar: for the
     cash flow pricing using the calendar defined by the parameter &#39;calendars&#39;. The default
     value is &#39;Calendar&#39;. Known values are: \"Calendar\", \"No\", and \"Weekend\"."""
    calendars: Optional[List[str]] = rest_field()
    """The list of comma-separated calendar codes used to define non-working days and to adjust
     interest rate curve coupon dates and values (e.g., &#39;EMU_FI&#39;). By default, the calendar
     code is derived from the interest rate curve currency."""
    calibration_model: Optional[Union[str, "_models.CalibrationModelEnum"]] = rest_field(name="calibrationModel")
    """Bond zero coupon curve calibration method. Values can be:   - BasisSpline   -
     NelsonSiegelSvensson   - Bootstrap. Known values are: \"BasisSpline\", \"Bootstrap\", and
     \"NelsonSiegelSvensson\"."""
    calibration_parameters: Optional["_models.CalibrationParameters"] = rest_field(name="calibrationParameters")
    compounding_type: Optional[Union[str, "_models.CompoundingTypeEnum"]] = rest_field(name="compoundingType")
    """The yield type of the interest rate curve. The possible values are:   * Discounted   *
     Compounded   * Continuous   * MoneyMarket The default value is &#39;Compounded&#39;. Known
     values are: \"Compounded\", \"Continuous\", \"Discounted\", and \"MoneyMarket\"."""
    extrapolation_mode: Optional[Union[str, "_models.ExtrapolationModeEnum"]] = rest_field(name="extrapolationMode")
    """The extrapolation method used in the zero coupon curve bootstrapping. The possible values are:
     * None: no extrapolation,   * Constant: constant extrapolation,   * Linear: linear
     extrapolation. The default value is 'None'. Known values are: \"Constant\",
     \"ConstantForwardRate\", \"ConstantRate\", \"Linear\", \"None\", and \"UltimateForwardRate\"."""
    interest_calculation_method: Optional[Union[str, "_models.CurvesAndSurfacesInterestCalculationMethodEnum"]] = (
        rest_field(name="interestCalculationMethod")
    )
    """The day count basis method used to compute the points of the zero coupon curve. The possible
     values are:   * Dcb_30_360     Actual number of days in the coupon period calculated on the
     basis of a year of 360 days with twelve 30-day months unless:     - the last day of the period
     is the 31st day of a month and the first day of the period is a day other than the 30th or 31st
     day of a month, in which case the month that includes the last day shall not be considered to
     be shortened to a 30-day month,     - the last day of the period is the last day of the month
     of February, in which case the month of February shall not be considered to be lengthened to a
     30-day month.   * Dcb_30_Actual     The day count is identical to 30/360 (US) and the year
     basis is identical to Actual/Actual.   * Dcb_Actual_360     The day count is the actual number
     of days of the period. The year basis is 360.   * Dcb_Actual_365     The day count is the
     actual number of days of the period. The year basis is 365.   * Dcb_Actual_Actual     The DCB
     is calculated by Actual days / year basis where:     - Actual days are defined as the actual
     days between the starting date (D1.M1.Y1) and end date (D2.M2.Y2).     - Year basis is defined
     as the actual days between the start date (D1.M1.Y1) and the next relevant interest payment
     date (D3.M3.Y3) multiplied by the instrument coupon frequency.   * Dcb_Actual_Actual_ISDA
     Similar to Actual/365, except for a period that includes days falling in a leap year. It is
     calculated by DCB &#x3D; number of days in a leap year/366 + number of days in a non-leap
     year/365.     A convention is also known as Actual/365 ISDA.   *Dcb_30_360_ISDA     For two
     dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1 is 31, change it to 30,     - if D2 is 31 and D1
     is 30, change D2 to 30.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
     Dcb_30_365_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then
     D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31 then D2&#x3D;30.     Then the date
     difference is (Y2-Y1)x365+(M2-M1)x30+(D2-D1)   * Dcb_30_360_US     For two dates (Y1,M1,D1) and
     (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31 then
     D2&#x3D;30,     - if D1 is the last day of February then D1&#x3D;30,     - if D1 is the last
     day of February and D2 is the last day of February then D2&#x3D;30.     The last day of
     February is February 29 in leap years and February 28 in non leap years.     The 30/360 US rule
     is identical to 30/360 ISDA when the EOM (end-of-month) convention does not apply. This
     indicates whether all coupon payment dates fall on the last day of the month. If the investment
     is not EOM, it will always pay on the same day of the month (e.g., the 10th).     Then the date
     difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_Actual_Actual_AFB     The DCB is
     calculated by Actual days / year basis where:     Actual days are defined as the actual days
     between the start date (D1.M1.Y1) and end date (D2.M2.Y2).     Year basis is either 365 if the
     calculation period does not contain 29th Feb, or 366 if the calculation period includes 29th
     Feb.   * Dcb_WorkingDays_252     The day count is the actual number of business days of the
     period according to the instrument calendars. The year basis is 252. Commonly used in the
     Brazilian market.   * Dcb_Actual_365L     The day count is the actual number of days of the
     period. The year basis is calculated in the following two rules:     - if the coupon frequency
     is annual, then year basis is 366 if the 29 Feb. is included in the interest period, else 365,
     - if the coupon frequency is not annual, then year basis is 366 for each interest period where
     ending date falls in a leap year, otherwise it is 365.   * Dcb_ActualLeapDay_365     The day
     count ignores 29th February when counting days. The year basis is 365 days.   *
     Dcb_ActualLeapDay_360     The day count ignores 29th February when counting days. The year
     basis is 360 days.   * Dcb_Actual_36525     The day count is the actual number of days of the
     period. The year basis is 365.25.   * Dcb_Actual_365_CanadianConvention     Follows the
     Canadian domestic bond market convention. The day count basis is computed as follows:     - if
     the number of days of a period is less than the actual number of days in a regular coupon
     period the Dcb_Actual_365 convention is used,     - otherwise: DCB &#x3D; 1 -
     DaysRemainingInPeriod x Frequency / 365.   * Dcb_30_360_German     For two dates (Y1,M1,D1) and
     (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 then D2&#x3D;30,     - if
     D1 is the last day of February then D1&#x3D;30,     - if D2 is the last day of February then
     D2&#x3D;30.     The last day of February is February 29 in leap years and February 28 in non
     leap years.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
     Dcb_30_365_German     Similar to 30/360 (German), except that the year basis is treated as 365
     days.   * Dcb_30_Actual_German     The day count is identical to 30/360 (German) and the year
     basis is similar to Actual/Actual. This method was formerly used in the Eurobond markets.   *
     Dcb_30E_360_ISMA     Actual number of days in the coupon period calculated on the basis of a
     year of 360 days with twelve 30-day months (regardless of the date of the first day or last day
     of the period).   * Dcb_Actual_364     A special case of Actual/Actual (ISMA) when a coupon
     period contains 91 or 182 days. Actual/364 applies for some short-term instruments.     Day
     count basis &#x3D; 364.   * Dcb_30_Actual_ISDA   * Dcb_30_365_Brazil   * Dcb_Actual_365P   *
     Dcb_Constant. Known values are: \"Dcb_30E_360_ISMA\", \"Dcb_30_360\", \"Dcb_30_360_German\",
     \"Dcb_30_360_ISDA\", \"Dcb_30_360_US\", \"Dcb_30_365_Brazil\", \"Dcb_30_365_German\",
     \"Dcb_30_365_ISDA\", \"Dcb_30_Actual\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual_ISDA\",
     \"Dcb_ActualLeapDay_360\", \"Dcb_ActualLeapDay_365\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_36525\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_Actual_365_CanadianConvention\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_AFB\",
     \"Dcb_Actual_Actual_ISDA\", \"Dcb_Constant\", and \"Dcb_WorkingDays_252\"."""
    interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = rest_field(name="interpolationMode")
    """The interpolation method used in zero curve bootstrapping. The possible values are:   *
     CubicDiscount: local cubic interpolation of discount factors   * CubicRate: local cubic
     interpolation of rates   * CubicSpline: a natural cubic spline   * ForwardMonotoneConvex:
     forward Monotone Convexc interpolation   * Linear: linear interpolation   * Log: log-linear
     interpolation   * Hermite: Hermite (Bessel) interpolation   * AkimaMethod: the Akima method (a
     smoother variant of local cubic interpolation)   * FritschButlandMethod: the Fritsch-Butland
     method (a monotonic cubic variant)   * KrugerMethod: the Kruger method (a monotonic cubic
     variant)   * MonotonicCubicNaturalSpline: a monotonic natural cubic spline   *
     MonotonicHermiteCubic: monotonic Hermite (Bessel) cubic interpolation   * TensionSpline: a
     tension spline. Known values are: \"AkimaMethod\", \"CubicDiscount\", \"CubicRate\",
     \"CubicSpline\", \"ForwardMonotoneConvex\", \"FritschButlandMethod\", \"Hermite\",
     \"KrugerMethod\", \"Linear\", \"Log\", \"MonotonicCubicNaturalSpline\",
     \"MonotonicHermiteCubic\", \"Step\", and \"TensionSpline\"."""
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """The quoted price side of the instrument to be used for the zero coupon curve construction. The
     possible values are:   * Bid   * Ask   * Mid The default value is &#39;Mid&#39;. Known values
     are: \"Ask\", \"Bid\", \"Last\", and \"Mid\"."""
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")
    use_duration_weighted_minimization: Optional[bool] = rest_field(name="useDurationWeightedMinimization")
    use_multi_dimensional_solver: Optional[bool] = rest_field(name="useMultiDimensionalSolver")
    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """Valuation date for this curve, that means the data at which instrument market data is
     retrieved."""

    @overload
    def __init__(
        self,
        *,
        basis_spline_knots: Optional[int] = None,
        basis_spline_smooth_model: Optional[Union[str, "_models.BasisSplineSmoothModelEnum"]] = None,
        calendar_adjustment: Optional[Union[str, "_models.CalendarAdjustmentEnum"]] = None,
        calendars: Optional[List[str]] = None,
        calibration_model: Optional[Union[str, "_models.CalibrationModelEnum"]] = None,
        calibration_parameters: Optional["_models.CalibrationParameters"] = None,
        compounding_type: Optional[Union[str, "_models.CompoundingTypeEnum"]] = None,
        extrapolation_mode: Optional[Union[str, "_models.ExtrapolationModeEnum"]] = None,
        interest_calculation_method: Optional[
            Union[str, "_models.CurvesAndSurfacesInterestCalculationMethodEnum"]
        ] = None,
        interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
        use_duration_weighted_minimization: Optional[bool] = None,
        use_multi_dimensional_solver: Optional[bool] = None,
        valuation_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveParametersDescription(_model_base.Model):
    """CreditCurveParametersDescription.

    Attributes
    ----------
    basis_spline_knots : int
        Number of knots you can choose to build the yield curve when using the
        basis-spline models.
    basis_spline_smooth_model : str or ~analyticsapi.models.BasisSplineSmoothModelEnum
        Basis spline model. Values can be: - McCullochLinearRegression -
        WaggonerSmoothingSplineModel - AndersonSmoothingSplineModel. Known
        values are: "AndersonSmoothingSplineModel",
        "McCullochLinearRegression", and "WaggonerSmoothingSplineModel".
    calendar_adjustment : str or ~analyticsapi.models.CalendarAdjustmentEnum
        The cash flow adjustment according to a selected calendar. The possible
        values are:   * No   * Weekend: for the cash flow pricing using the
        calendar &#39;Weekend&#39;   * Calendar: for the cash flow pricing
        using the calendar defined by the parameter &#39;calendars&#39;. The
        default value is &#39;Calendar&#39;. Known values are: "Calendar",
        "No", and "Weekend".
    calendars : list[str]
        The list of comma-separated calendar codes used to define non-working
        days and to adjust interest rate curve coupon dates and values (e.g.,
        &#39;EMU_FI&#39;). By default, the calendar code is derived from the
        interest rate curve currency.  The default value is None, needs to be
        assigned before using.
    calibration_model : str or ~analyticsapi.models.CalibrationModelEnum
        Bond zero coupon curve calibration method. Values can be:   -
        BasisSpline   - NelsonSiegelSvensson   - Bootstrap. Known values are:
        "BasisSpline", "Bootstrap", and "NelsonSiegelSvensson".
    calibration_parameters : ~analyticsapi.models.CalibrationParameters
    compounding_type : str or ~analyticsapi.models.CompoundingTypeEnum
        The yield type of the interest rate curve. The possible values are:   *
        Discounted   * Compounded   * Continuous   * MoneyMarket The default
        value is &#39;Compounded&#39;. Known values are: "Compounded",
        "Continuous", "Discounted", and "MoneyMarket".
    extrapolation_mode : str or ~analyticsapi.models.ExtrapolationModeEnum
        The extrapolation method used in the zero coupon curve bootstrapping.
        The possible values are:   * None: no extrapolation,   * Constant:
        constant extrapolation,   * Linear: linear extrapolation. The default
        value is 'None'. Known values are: "Constant", "ConstantForwardRate",
        "ConstantRate", "Linear", "None", and "UltimateForwardRate".
    interest_calculation_method : str or ~analyticsapi.models.CurvesAndSurfacesInterestCalculationMethodEnum
        The day count basis method used to compute the points of the zero
        coupon curve. The possible values are:   * Dcb_30_360     Actual number
        of days in the coupon period calculated on the basis of a year of 360
        days with twelve 30-day months unless: - the last day of the period is
        the 31st day of a month and the first day of the period is a day other
        than the 30th or 31st day of a month, in which case the month that
        includes the last day shall not be considered to be shortened to a
        30-day month,     - the last day of the period is the last day of the
        month of February, in which case the month of February shall not be
        considered to be lengthened to a 30-day month.   * Dcb_30_Actual
        The day count is identical to 30/360 (US) and the year basis is
        identical to Actual/Actual.   * Dcb_Actual_360     The day count is the
        actual number of days of the period. The year basis is 360.   *
        Dcb_Actual_365 The day count is the actual number of days of the
        period. The year basis is 365.   * Dcb_Actual_Actual     The DCB is
        calculated by Actual days / year basis where:     - Actual days are
        defined as the actual days between the starting date (D1.M1.Y1) and end
        date (D2.M2.Y2).     - Year basis is defined as the actual days between
        the start date (D1.M1.Y1) and the next relevant interest payment date
        (D3.M3.Y3) multiplied by the instrument coupon frequency.   *
        Dcb_Actual_Actual_ISDA     Similar to Actual/365, except for a period
        that includes days falling in a leap year. It is calculated by DCB
        &#x3D; number of days in a leap year/366 + number of days in a non-leap
        year/365.     A convention is also known as Actual/365 ISDA.
        *Dcb_30_360_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if
        D1 is 31, change it to 30,     - if D2 is 31 and D1 is 30, change D2 to
        30.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
        Dcb_30_365_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if
        D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31
        then D2&#x3D;30.     Then the date difference is
        (Y2-Y1)x365+(M2-M1)x30+(D2-D1)   * Dcb_30_360_US For two dates
        (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     -
        if D2&#x3D;31 and D1&#x3D;30 or 31 then D2&#x3D;30,     - if D1 is the
        last day of February then D1&#x3D;30,     - if D1 is the last day of
        February and D2 is the last day of February then D2&#x3D;30.     The
        last day of February is February 29 in leap years and February 28 in
        non leap years.     The 30/360 US rule is identical to 30/360 ISDA when
        the EOM (end-of-month) convention does not apply. This indicates
        whether all coupon payment dates fall on the last day of the month. If
        the investment is not EOM, it will always pay on the same day of the
        month (e.g., the 10th).     Then the date difference is
        (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_Actual_Actual_AFB     The DCB
        is calculated by Actual days / year basis where:     Actual days are
        defined as the actual days between the start date (D1.M1.Y1) and end
        date (D2.M2.Y2). Year basis is either 365 if the calculation period
        does not contain 29th Feb, or 366 if the calculation period includes
        29th Feb.   * Dcb_WorkingDays_252     The day count is the actual
        number of business days of the period according to the instrument
        calendars. The year basis is 252. Commonly used in the Brazilian
        market.   * Dcb_Actual_365L     The day count is the actual number of
        days of the period. The year basis is calculated in the following two
        rules:     - if the coupon frequency is annual, then year basis is 366
        if the 29 Feb. is included in the interest period, else 365,     - if
        the coupon frequency is not annual, then year basis is 366 for each
        interest period where ending date falls in a leap year, otherwise it is
        365.   * Dcb_ActualLeapDay_365     The day count ignores 29th February
        when counting days. The year basis is 365 days.   *
        Dcb_ActualLeapDay_360     The day count ignores 29th February when
        counting days. The year basis is 360 days.   * Dcb_Actual_36525     The
        day count is the actual number of days of the period. The year basis is
        365.25.   * Dcb_Actual_365_CanadianConvention Follows the Canadian
        domestic bond market convention. The day count basis is computed as
        follows:     - if the number of days of a period is less than the
        actual number of days in a regular coupon period the Dcb_Actual_365
        convention is used,     - otherwise: DCB &#x3D; 1 -
        DaysRemainingInPeriod x Frequency / 365.   * Dcb_30_360_German     For
        two dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then
        D1&#x3D;30,     - if D2&#x3D;31 then D2&#x3D;30,     - if D1 is the
        last day of February then D1&#x3D;30,     - if D2 is the last day of
        February then D2&#x3D;30.     The last day of February is February 29
        in leap years and February 28 in non leap years.     Then the date
        difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_30_365_German
        Similar to 30/360 (German), except that the year basis is treated as
        365 days.   * Dcb_30_Actual_German     The day count is identical to
        30/360 (German) and the year basis is similar to Actual/Actual. This
        method was formerly used in the Eurobond markets.   * Dcb_30E_360_ISMA
        Actual number of days in the coupon period calculated on the basis of a
        year of 360 days with twelve 30-day months (regardless of the date of
        the first day or last day of the period).   * Dcb_Actual_364     A
        special case of Actual/Actual (ISMA) when a coupon period contains 91
        or 182 days. Actual/364 applies for some short-term instruments.
        Day count basis &#x3D; 364.   * Dcb_30_Actual_ISDA   *
        Dcb_30_365_Brazil   * Dcb_Actual_365P   * Dcb_Constant. Known values
        are: "Dcb_30E_360_ISMA", "Dcb_30_360", "Dcb_30_360_German",
        "Dcb_30_360_ISDA", "Dcb_30_360_US", "Dcb_30_365_Brazil",
        "Dcb_30_365_German", "Dcb_30_365_ISDA", "Dcb_30_Actual",
        "Dcb_30_Actual_German", "Dcb_30_Actual_ISDA", "Dcb_ActualLeapDay_360",
        "Dcb_ActualLeapDay_365", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_36525", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_Actual_365_CanadianConvention",
        "Dcb_Actual_Actual", "Dcb_Actual_Actual_AFB", "Dcb_Actual_Actual_ISDA",
        "Dcb_Constant", and "Dcb_WorkingDays_252".
    interpolation_mode : str or ~analyticsapi.models.InterpolationModeEnum
        The interpolation method used in zero curve bootstrapping. The possible
        values are:   * CubicDiscount: local cubic interpolation of discount
        factors   * CubicRate: local cubic interpolation of rates   *
        CubicSpline: a natural cubic spline   * ForwardMonotoneConvex: forward
        Monotone Convexc interpolation   * Linear: linear interpolation * Log:
        log-linear interpolation   * Hermite: Hermite (Bessel) interpolation
        * AkimaMethod: the Akima method (a smoother variant of local cubic
        interpolation)   * FritschButlandMethod: the Fritsch-Butland method (a
        monotonic cubic variant)   * KrugerMethod: the Kruger method (a
        monotonic cubic variant)   * MonotonicCubicNaturalSpline: a monotonic
        natural cubic spline   * MonotonicHermiteCubic: monotonic Hermite
        (Bessel) cubic interpolation   * TensionSpline: a tension spline. Known
        values are: "AkimaMethod", "CubicDiscount", "CubicRate", "CubicSpline",
        "ForwardMonotoneConvex", "FritschButlandMethod", "Hermite",
        "KrugerMethod", "Linear", "Log", "MonotonicCubicNaturalSpline",
        "MonotonicHermiteCubic", "Step", and "TensionSpline".
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        The quoted price side of the instrument to be used for the zero coupon
        curve construction. The possible values are:   * Bid   * Ask   * Mid
        The default value is &#39;Mid&#39;. Known values are: "Ask", "Bid",
        "Last", and "Mid".
    use_delayed_data_if_denied : bool
    use_duration_weighted_minimization : bool
    use_multi_dimensional_solver : bool
    """

    basis_spline_knots: Optional[int] = rest_field(name="basisSplineKnots")
    """Number of knots you can choose to build the yield curve when using the basis-spline models."""
    basis_spline_smooth_model: Optional[Union[str, "_models.BasisSplineSmoothModelEnum"]] = rest_field(
        name="basisSplineSmoothModel"
    )
    """Basis spline model. Values can be: - McCullochLinearRegression - WaggonerSmoothingSplineModel -
     AndersonSmoothingSplineModel. Known values are: \"AndersonSmoothingSplineModel\",
     \"McCullochLinearRegression\", and \"WaggonerSmoothingSplineModel\"."""
    calendar_adjustment: Optional[Union[str, "_models.CalendarAdjustmentEnum"]] = rest_field(name="calendarAdjustment")
    """The cash flow adjustment according to a selected calendar. The possible values are:   * No   *
     Weekend: for the cash flow pricing using the calendar &#39;Weekend&#39;   * Calendar: for the
     cash flow pricing using the calendar defined by the parameter &#39;calendars&#39;. The default
     value is &#39;Calendar&#39;. Known values are: \"Calendar\", \"No\", and \"Weekend\"."""
    calendars: Optional[List[str]] = rest_field()
    """The list of comma-separated calendar codes used to define non-working days and to adjust
     interest rate curve coupon dates and values (e.g., &#39;EMU_FI&#39;). By default, the calendar
     code is derived from the interest rate curve currency."""
    calibration_model: Optional[Union[str, "_models.CalibrationModelEnum"]] = rest_field(name="calibrationModel")
    """Bond zero coupon curve calibration method. Values can be:   - BasisSpline   -
     NelsonSiegelSvensson   - Bootstrap. Known values are: \"BasisSpline\", \"Bootstrap\", and
     \"NelsonSiegelSvensson\"."""
    calibration_parameters: Optional["_models.CalibrationParameters"] = rest_field(name="calibrationParameters")
    compounding_type: Optional[Union[str, "_models.CompoundingTypeEnum"]] = rest_field(name="compoundingType")
    """The yield type of the interest rate curve. The possible values are:   * Discounted   *
     Compounded   * Continuous   * MoneyMarket The default value is &#39;Compounded&#39;. Known
     values are: \"Compounded\", \"Continuous\", \"Discounted\", and \"MoneyMarket\"."""
    extrapolation_mode: Optional[Union[str, "_models.ExtrapolationModeEnum"]] = rest_field(name="extrapolationMode")
    """The extrapolation method used in the zero coupon curve bootstrapping. The possible values are:
     * None: no extrapolation,   * Constant: constant extrapolation,   * Linear: linear
     extrapolation. The default value is 'None'. Known values are: \"Constant\",
     \"ConstantForwardRate\", \"ConstantRate\", \"Linear\", \"None\", and \"UltimateForwardRate\"."""
    interest_calculation_method: Optional[Union[str, "_models.CurvesAndSurfacesInterestCalculationMethodEnum"]] = (
        rest_field(name="interestCalculationMethod")
    )
    """The day count basis method used to compute the points of the zero coupon curve. The possible
     values are:   * Dcb_30_360     Actual number of days in the coupon period calculated on the
     basis of a year of 360 days with twelve 30-day months unless:     - the last day of the period
     is the 31st day of a month and the first day of the period is a day other than the 30th or 31st
     day of a month, in which case the month that includes the last day shall not be considered to
     be shortened to a 30-day month,     - the last day of the period is the last day of the month
     of February, in which case the month of February shall not be considered to be lengthened to a
     30-day month.   * Dcb_30_Actual     The day count is identical to 30/360 (US) and the year
     basis is identical to Actual/Actual.   * Dcb_Actual_360     The day count is the actual number
     of days of the period. The year basis is 360.   * Dcb_Actual_365     The day count is the
     actual number of days of the period. The year basis is 365.   * Dcb_Actual_Actual     The DCB
     is calculated by Actual days / year basis where:     - Actual days are defined as the actual
     days between the starting date (D1.M1.Y1) and end date (D2.M2.Y2).     - Year basis is defined
     as the actual days between the start date (D1.M1.Y1) and the next relevant interest payment
     date (D3.M3.Y3) multiplied by the instrument coupon frequency.   * Dcb_Actual_Actual_ISDA
     Similar to Actual/365, except for a period that includes days falling in a leap year. It is
     calculated by DCB &#x3D; number of days in a leap year/366 + number of days in a non-leap
     year/365.     A convention is also known as Actual/365 ISDA.   *Dcb_30_360_ISDA     For two
     dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1 is 31, change it to 30,     - if D2 is 31 and D1
     is 30, change D2 to 30.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
     Dcb_30_365_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then
     D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31 then D2&#x3D;30.     Then the date
     difference is (Y2-Y1)x365+(M2-M1)x30+(D2-D1)   * Dcb_30_360_US     For two dates (Y1,M1,D1) and
     (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31 then
     D2&#x3D;30,     - if D1 is the last day of February then D1&#x3D;30,     - if D1 is the last
     day of February and D2 is the last day of February then D2&#x3D;30.     The last day of
     February is February 29 in leap years and February 28 in non leap years.     The 30/360 US rule
     is identical to 30/360 ISDA when the EOM (end-of-month) convention does not apply. This
     indicates whether all coupon payment dates fall on the last day of the month. If the investment
     is not EOM, it will always pay on the same day of the month (e.g., the 10th).     Then the date
     difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_Actual_Actual_AFB     The DCB is
     calculated by Actual days / year basis where:     Actual days are defined as the actual days
     between the start date (D1.M1.Y1) and end date (D2.M2.Y2).     Year basis is either 365 if the
     calculation period does not contain 29th Feb, or 366 if the calculation period includes 29th
     Feb.   * Dcb_WorkingDays_252     The day count is the actual number of business days of the
     period according to the instrument calendars. The year basis is 252. Commonly used in the
     Brazilian market.   * Dcb_Actual_365L     The day count is the actual number of days of the
     period. The year basis is calculated in the following two rules:     - if the coupon frequency
     is annual, then year basis is 366 if the 29 Feb. is included in the interest period, else 365,
     - if the coupon frequency is not annual, then year basis is 366 for each interest period where
     ending date falls in a leap year, otherwise it is 365.   * Dcb_ActualLeapDay_365     The day
     count ignores 29th February when counting days. The year basis is 365 days.   *
     Dcb_ActualLeapDay_360     The day count ignores 29th February when counting days. The year
     basis is 360 days.   * Dcb_Actual_36525     The day count is the actual number of days of the
     period. The year basis is 365.25.   * Dcb_Actual_365_CanadianConvention     Follows the
     Canadian domestic bond market convention. The day count basis is computed as follows:     - if
     the number of days of a period is less than the actual number of days in a regular coupon
     period the Dcb_Actual_365 convention is used,     - otherwise: DCB &#x3D; 1 -
     DaysRemainingInPeriod x Frequency / 365.   * Dcb_30_360_German     For two dates (Y1,M1,D1) and
     (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 then D2&#x3D;30,     - if
     D1 is the last day of February then D1&#x3D;30,     - if D2 is the last day of February then
     D2&#x3D;30.     The last day of February is February 29 in leap years and February 28 in non
     leap years.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
     Dcb_30_365_German     Similar to 30/360 (German), except that the year basis is treated as 365
     days.   * Dcb_30_Actual_German     The day count is identical to 30/360 (German) and the year
     basis is similar to Actual/Actual. This method was formerly used in the Eurobond markets.   *
     Dcb_30E_360_ISMA     Actual number of days in the coupon period calculated on the basis of a
     year of 360 days with twelve 30-day months (regardless of the date of the first day or last day
     of the period).   * Dcb_Actual_364     A special case of Actual/Actual (ISMA) when a coupon
     period contains 91 or 182 days. Actual/364 applies for some short-term instruments.     Day
     count basis &#x3D; 364.   * Dcb_30_Actual_ISDA   * Dcb_30_365_Brazil   * Dcb_Actual_365P   *
     Dcb_Constant. Known values are: \"Dcb_30E_360_ISMA\", \"Dcb_30_360\", \"Dcb_30_360_German\",
     \"Dcb_30_360_ISDA\", \"Dcb_30_360_US\", \"Dcb_30_365_Brazil\", \"Dcb_30_365_German\",
     \"Dcb_30_365_ISDA\", \"Dcb_30_Actual\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual_ISDA\",
     \"Dcb_ActualLeapDay_360\", \"Dcb_ActualLeapDay_365\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_36525\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_Actual_365_CanadianConvention\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_AFB\",
     \"Dcb_Actual_Actual_ISDA\", \"Dcb_Constant\", and \"Dcb_WorkingDays_252\"."""
    interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = rest_field(name="interpolationMode")
    """The interpolation method used in zero curve bootstrapping. The possible values are:   *
     CubicDiscount: local cubic interpolation of discount factors   * CubicRate: local cubic
     interpolation of rates   * CubicSpline: a natural cubic spline   * ForwardMonotoneConvex:
     forward Monotone Convexc interpolation   * Linear: linear interpolation   * Log: log-linear
     interpolation   * Hermite: Hermite (Bessel) interpolation   * AkimaMethod: the Akima method (a
     smoother variant of local cubic interpolation)   * FritschButlandMethod: the Fritsch-Butland
     method (a monotonic cubic variant)   * KrugerMethod: the Kruger method (a monotonic cubic
     variant)   * MonotonicCubicNaturalSpline: a monotonic natural cubic spline   *
     MonotonicHermiteCubic: monotonic Hermite (Bessel) cubic interpolation   * TensionSpline: a
     tension spline. Known values are: \"AkimaMethod\", \"CubicDiscount\", \"CubicRate\",
     \"CubicSpline\", \"ForwardMonotoneConvex\", \"FritschButlandMethod\", \"Hermite\",
     \"KrugerMethod\", \"Linear\", \"Log\", \"MonotonicCubicNaturalSpline\",
     \"MonotonicHermiteCubic\", \"Step\", and \"TensionSpline\"."""
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """The quoted price side of the instrument to be used for the zero coupon curve construction. The
     possible values are:   * Bid   * Ask   * Mid The default value is &#39;Mid&#39;. Known values
     are: \"Ask\", \"Bid\", \"Last\", and \"Mid\"."""
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")
    use_duration_weighted_minimization: Optional[bool] = rest_field(name="useDurationWeightedMinimization")
    use_multi_dimensional_solver: Optional[bool] = rest_field(name="useMultiDimensionalSolver")

    @overload
    def __init__(
        self,
        *,
        basis_spline_knots: Optional[int] = None,
        basis_spline_smooth_model: Optional[Union[str, "_models.BasisSplineSmoothModelEnum"]] = None,
        calendar_adjustment: Optional[Union[str, "_models.CalendarAdjustmentEnum"]] = None,
        calendars: Optional[List[str]] = None,
        calibration_model: Optional[Union[str, "_models.CalibrationModelEnum"]] = None,
        calibration_parameters: Optional["_models.CalibrationParameters"] = None,
        compounding_type: Optional[Union[str, "_models.CompoundingTypeEnum"]] = None,
        extrapolation_mode: Optional[Union[str, "_models.ExtrapolationModeEnum"]] = None,
        interest_calculation_method: Optional[
            Union[str, "_models.CurvesAndSurfacesInterestCalculationMethodEnum"]
        ] = None,
        interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
        use_duration_weighted_minimization: Optional[bool] = None,
        use_multi_dimensional_solver: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurvePoint(_model_base.Model):
    """CreditCurvePoint.

    Attributes
    ----------
    discount_factor : float
        The ratio used to calculate the present value of future cash flows at
        valuationDate. It is derived from ratePercent which corresponds to
        tenor of the point on the zero coupon curve.
    end_date : ~datetime.date
        The date used to define the end date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    par_rate_percent : float
        The par rate percent of the curve computed for the given curve point.
    rate_percent : float
        The rate percent of the zero coupon curve computed for the given curve
        point.
    start_date : ~datetime.date
        The date used to define the start date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    tenor : str
        The code indicating the period between startDate and endDate of the
        zero coupon curve (e.g., '1M', '6M', '4Y').
    """

    discount_factor: Optional[float] = rest_field(name="discountFactor")
    """The ratio used to calculate the present value of future cash flows at valuationDate. It is
     derived from ratePercent which corresponds to tenor of the point on the zero coupon curve."""
    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date used to define the end date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    par_rate_percent: Optional[float] = rest_field(name="parRatePercent")
    """The par rate percent of the curve computed for the given curve point."""
    rate_percent: Optional[float] = rest_field(name="ratePercent")
    """The rate percent of the zero coupon curve computed for the given curve point."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The date used to define the start date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between startDate and endDate of the zero coupon curve (e.g.,
     '1M', '6M', '4Y')."""

    @overload
    def __init__(
        self,
        *,
        discount_factor: Optional[float] = None,
        end_date: Optional[datetime.date] = None,
        par_rate_percent: Optional[float] = None,
        rate_percent: Optional[float] = None,
        start_date: Optional[datetime.date] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveRequestItem(_model_base.Model):
    """CreditCurveRequestItem.

    Attributes
    ----------
    constituents : ~analyticsapi.models.CreditConstituents
    curve_definition : ~analyticsapi.models.CreditCurveDefinition
    curve_parameters : ~analyticsapi.models.CreditCurveParameters
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    """

    constituents: Optional["_models.CreditConstituents"] = rest_field()
    curve_definition: Optional["_models.CreditCurveDefinition"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.CreditCurveParameters"] = rest_field(name="curveParameters")
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.CreditConstituents"] = None,
        curve_definition: Optional["_models.CreditCurveDefinition"] = None,
        curve_parameters: Optional["_models.CreditCurveParameters"] = None,
        curve_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurveResponse(_model_base.Model):
    """CreditCurveResponse.

    Attributes
    ----------
    data : ~analyticsapi.models.CreditCurveDefinitionResponse
        Required.
    """

    data: "_models.CreditCurveDefinitionResponse" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.CreditCurveDefinitionResponse",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CreditCurveSearchDefinition(_model_base.Model):
    """CreditCurveSearchDefinition.

    Attributes
    ----------
    business_sector : str or ~analyticsapi.models.BusinessSectorEnum
        TRBC business sector of the economic sector. Known values are:
        "AcademicAndEducationalServices", "AppliedResources",
        "AutomobilesAndAutoParts", "BankingAndInvestmentServices", "Chemicals",
        "CollectiveInvestments", "ConsumerGoodsConglomerates",
        "CyclicalConsumerProducts", "CyclicalConsumerServices",
        "EnergyFossilFuels", "FinancialTechnologyAndInfrastructure",
        "FoodAndBeverages", "FoodAndDrugRetailing", "GovernmentActivity",
        "HealthcareServicesAndEquipment", "IndustrialAndCommercialServices",
        "IndustrialGoods", "InstitutionsAssociationsAndOrganizations",
        "Insurance", "InvestmentHoldingCompanies", "MineralResources",
        "PersonalAndHouseholdProductsAndServices",
        "PharmaceuticalsAndMedicalResearch", "RealEstate", "RenewableEnergy",
        "Retailers", "SoftwareAndITServices", "TechnologyEquipment",
        "TelecommunicationsServices", "Transportation", "Uranium", and
        "Utilities".
    country : str
        Country code of the issuer defined with Alpha-2 Code ISO 3166 country
        code convention.
    currency : str
        Bond curve currency code.
    curve_sub_type : str or ~analyticsapi.models.CurveSubTypeEnum
        Get curveSubType. Known values are: "BondCarry",
        "BreakevenInflationCurve", "CDSCreditIndex", "CapFloorVolatility",
        "CentralBankInterestRateProbability", "CommercialPaperBenchmark",
        "CorporateBondBenchmark", "CorporateBondPar", "CorporateBondSpread",
        "CorporateBondZero", "CorporateCDSCredit", "CorporateCashCredit",
        "CorporateIssuer", "Covered", "Deposit", "ForwardGovernmentBondZero",
        "ForwardGovernmentPar", "ForwardInflation", "ForwardRateAgreementZero",
        "ForwardStartingSwap", "GovernmentBenchmark",
        "GovernmentBondBenchmark", "GovernmentBondVolatility",
        "GovernmentCDSCredit", "GovernmentCashCredit",
        "GovernmentStripBenchmark", "InflationLinkedBenchmark",
        "InflationLinkedZero", "InterbankOfferRate", "InterestRateSwap",
        "InterestRateVolatility", "MunicipalBenchmark", "OvernightIndexSwap",
        "OvernightIndexSwapZero", "SemiSovereignCashCredit",
        "ShortTermInterestRateFuturesZero",
        "SolvencyIICorporateCreditSprdRating",
        "SolvencyIICoveredPfandbriefIssuer",
        "SolvencyIIFinancialCreditSprdRating",
        "SolvencyIIInterestRateSwapYield", "SolvencyIILiquiditySpread",
        "SolvencyIIPfandbriefYieldByCurrency", "SolvencyIIStructuredABSRating",
        "SolvencyIIStructuredMBSRating", "SolvencyIISwapDerivedZero",
        "SolvencyIITreasuryVersusIRSSpread", "SovereignAgencyBenchmark",
        "SwapCarry", "SwapPar", "SwapZero", "SwaptionVolatility", and
        "TreasurySpread".
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    economic_sector : str or ~analyticsapi.models.EconomicSectorEnum
        TRBC economic sector of the issuer.  Available values are:
        BasicMaterials, Consumer Cyclicals, Consumer Non-Cyclicals, Energy,
        Financials, Healthcare, Industrials, Technology, Utilities. Known
        values are: "AcademicAndEducationalServices", "BasicMaterials",
        "ConsumerCyclicals", "ConsumerNonCyclicals", "Energy", "Financials",
        "GovernmentActivity", "Healthcare", "Industrials",
        "InstitutionsAssociationsAndOrganizations", "RealEstate", "Technology",
        and "Utilities".
    id : str
        Id of the curve definition.
    industry : str or ~analyticsapi.models.IndustryEnum
        TRBC industry of the industry group. Known values are:
        "AdvancedMedicalEquipmentAndTechnology", "AdvertisingAndMarketing",
        "AerospaceAndDefense", "AgriculturalChemicals", "Airlines",
        "AirportOperatorsAndServices", "Aluminum", "ApparelAndAccessories",
        "ApparelAndAccessoriesRetailers", "AppliancesToolsAndHousewares",
        "AutoAndTruckManufacturers", "AutoTruckAndMotorcycleParts",
        "AutoVehiclesPartsAndServiceRetailers", "Banks",
        "BiotechnologyAndMedicalResearch", "BlockchainAndCryptocurrency",
        "Brewers", "Broadcasting", "BusinessSupportServices",
        "BusinessSupportSupplies", "CasinosAndGaming", "CharityOrganizations",
        "CivicAndSocialOrganizations", "ClosedEndFunds", "Coal",
        "CommercialPrintingServices", "CommercialREITs", "CommodityChemicals",
        "CommunicationsAndNetworking", "ComputerAndElectronicsRetailers",
        "ComputerHardware", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConstructionSuppliesAndFixtures",
        "ConsumerGoodsConglomerates", "ConsumerLending", "ConsumerPublishing",
        "CorporateFinancialServices",
        "CourierPostalAirFreightAndLandbasedLogistics", "CrowdCollaboration",
        "DepartmentStores", "DiscountStores", "DistillersAndWineries",
        "DiversifiedChemicals", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedInvestmentServices", "DiversifiedMining",
        "DiversifiedREITs", "DrugRetailers", "ElectricUtilities",
        "ElectricalComponentsAndEquipment", "ElectronicEquipmentAndParts",
        "EmploymentServices", "EntertainmentProduction",
        "EnvironmentalOrganizations", "EnvironmentalServicesAndEquipment",
        "ExchangeTradedFunds",
        "FinancialAndCommodityMarketOperatorsAndServiceProviders",
        "FinancialTechnology", "FishingAndFarming", "FoodProcessing",
        "FoodRetailAndDistribution", "Footwear", "ForestAndWoodProducts",
        "Gold", "GovernmentAdministrationActivities",
        "GovernmentAndGovernmentFinance", "GroundFreightAndLogistics",
        "HealthcareFacilitiesAndServices", "HeavyElectricalEquipment",
        "HeavyMachineryAndVehicles", "HighwaysAndRailTracks",
        "HomeFurnishings", "HomeFurnishingsRetailers",
        "HomeImprovementProductsAndServicesRetailers", "Homebuilding",
        "HotelsMotelsAndCruiseLines", "HouseholdElectronics",
        "HouseholdProducts", "ITServicesAndConsulting",
        "IndependentPowerProducers", "IndustrialMachineryAndEquipment",
        "InsuranceFunds", "IntegratedHardwareAndSoftware",
        "IntegratedOilAndGas", "IntegratedTelecommunicationsServices",
        "InvestmentBankingAndBrokerageServices", "InvestmentHoldingCompanies",
        "InvestmentManagementAndFundOperators", "IronAndSteel",
        "LegalAndSafetyPublicServices", "LeisureAndRecreation",
        "LifeAndHealthInsurance", "ManagedHealthcare",
        "MarineFreightAndLogistics", "MarinePortServices",
        "MedicalEquipmentSuppliesAndDistribution",
        "MiningSupportServicesAndEquipment",
        "MiscellaneousEducationalServiceProviders",
        "MiscellaneousInfrastructure", "MiscellaneousSpecialtyRetailers",
        "MultilineInsuranceAndBrokers", "MultilineUtilities", "MutualFunds",
        "NationalSecurityAndInternationalAffairs", "NaturalGasUtilities",
        "NonAlcoholicBeverages", "NonGoldPreciousMetalsAndMinerals",
        "NonPaperContainersAndPackaging", "OfficeEquipment",
        "OilAndGasDrilling", "OilAndGasExplorationAndProduction",
        "OilAndGasRefiningAndMarketing", "OilAndGasTransportationServices",
        "OilRelatedServicesAndEquipment", "OnlineServices", "PaperPackaging",
        "PaperProducts", "PassengerTransportationGroundAndSea", "PensionFunds",
        "PersonalProducts", "PersonalServices", "Pharmaceuticals",
        "PhonesAndHandheldDevices", "ProfessionalAndBusinessEducation",
        "ProfessionalInformationServices", "ProfessionalOrganizations",
        "PropertyAndCasualtyInsurance",
        "RealEstateRentalDevelopmentAndOperations", "RealEstateServices",
        "RecreationalProducts", "Reinsurance", "ReligiousOrganizations",
        "RenewableEnergyEquipmentAndServices", "RenewableFuels",
        "ResidentialREITs", "RestaurantsAndBars", "SchoolCollegeAndUniversity",
        "SemiconductorEquipmentAndTesting", "Semiconductors", "Shipbuilding",
        "Software", "SpecializedREITs", "SpecialtyChemicals",
        "SpecialtyMiningAndMetals", "TextilesAndLeatherGoods",
        "TiresAndRubberProducts", "Tobacco", "ToysAndChildrenProducts",
        "UKInvestmentTrusts", "Uranium", "WaterAndRelatedUtilities", and
        "WirelessTelecommunicationsServices".
    industry_group : str or ~analyticsapi.models.IndustryGroupEnum
        TRBC industry group of the business sector. Known values are:
        "AerospaceAndDefense", "AutomobilesAndAutoParts",
        "BankingAndInvestmentServices", "BankingServices", "Beverages",
        "BiotechnologyAndMedicalResearch", "Chemicals", "Coal",
        "CollectiveInvestments", "CommunicationsAndNetworking",
        "ComputersPhonesAndHouseholdElectronics", "ConstructionAndEngineering",
        "ConstructionMaterials", "ConsumerGoodsConglomerates",
        "ContainersAndPackaging", "DiversifiedIndustrialGoodsWholesale",
        "DiversifiedRetail", "ElectricUtilitiesAndIPPs",
        "ElectronicEquipmentAndParts", "FinancialTechnologyAndInfrastructure",
        "FoodAndDrugRetailing", "FoodAndTobacco",
        "FreightAndLogisticsServices", "GovernmentActivity",
        "HealthcareEquipmentAndSupplies", "HealthcareProvidersAndServices",
        "HomebuildingAndConstructionSupplies",
        "HotelsAndEntertainmentServices", "HouseholdGoods",
        "InstitutionsAssociationsAndOrganizations", "Insurance",
        "IntegratedHardwareAndSoftware",
        "InvestmentBankingAndInvestmentServices", "InvestmentHoldingCompanies",
        "LeisureProducts", "MachineryToolsHeavyVehiclesTrainsAndShips",
        "MediaAndPublishing", "MetalsAndMining",
        "MiscellaneousEducationalService", "MultilineUtilities",
        "NaturalGasUtilities", "OfficeEquipment", "OilAndGas",
        "OilAndGasRelatedEquipmentAndServices", "PaperAndForestProducts",
        "PassengerTransportationServices",
        "PersonalAndHouseholdProductsAndServices", "Pharmaceuticals",
        "ProfessionalAndBusinessEducation",
        "ProfessionalAndCommercialServices", "Providers",
        "RealEstateOperations", "RenewableEnergy",
        "ResidentialAndCommercialREITs", "SchoolCollegeAndUniversity",
        "SemiconductorsAndSemiconductorEquipment", "SoftwareAndITServices",
        "SpecialtyRetailers", "TelecommunicationsServices",
        "TextilesAndApparel", "TransportInfrastructure", "Uranium", and
        "WaterAndRelatedUtilities".
    is_currency_country_originator : bool
    issuer_type : str or ~analyticsapi.models.IssuerTypeEnum
        Type of the issuer. Available values are: Agency, Corporate, Munis,
        NonFinancials, Sovereign, Supranational. Known values are: "Agency",
        "Corporate", "Munis", "NonFinancials", "Sovereign", and
        "Supranational".
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        Get mainConstituentAssetClass. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    name : str
        Get name.
    rating : str or ~analyticsapi.models.RatingEnum
        Get rating. Known values are: "A", "A1", "A2", "A3", "AA", "AAA",
        "AAHigh", "AALow", "AAMinus", "AAPlus", "AHigh", "ALow", "AMinus",
        "APlus", "Aa1", "Aa2", "Aa3", "Aaa", "B", "B1", "B2", "B3", "BB",
        "BBB", "BBBHigh", "BBBLow", "BBBMinus", "BBBPlus", "BBHigh", "BBLow",
        "BBMinus", "BBPlus", "BHigh", "BLow", "BMinus", "BPlus", "Ba1", "Ba2",
        "Ba3", "Baa1", "Baa2", "Baa3", "C", "CC", "CCC", "CCCHigh", "CCCLow",
        "CCCMinus", "CCCPlus", "CCHigh", "CCLow", "CHigh", "CLow", "Ca",
        "Caa1", "Caa2", "Caa3", "D", "DD", "DDD", "F1", "F1Plus", "F2", and
        "F3".
    rating_scale_source : str or ~analyticsapi.models.RatingScaleSourceEnum
        Get ratingScaleSource. Known values are: "DBRS", "Fitch", "Moodys",
        "Refinitiv", and "SAndP".
    reference_entity : str
        Code to define the reference entity.
    reference_entity_type : str or ~analyticsapi.models.ReferenceEntityTypeEnum
        Type of the reference entity (mandatory if referenceEntity is defined).
        Available values are:   - ChainRic   - BondIsin   - BondRic   -
        OrganisationId   - Ticker. Known values are: "BondIsin", "BondRic",
        "ChainRic", "OrganisationId", and "Ticker".
    seniority : str or ~analyticsapi.models.CurvesAndSurfacesSeniorityEnum
        Get seniority. Known values are:
        "JuniorSecuredOrJuniorSubordinatedSecured",
        "JuniorUnsecuredOrJuniorSubordinatedUnsecured", "Secured",
        "SeniorNonPreferred", "SeniorPreferred", "SeniorSecured",
        "SeniorSecuredFirstAndRefundingMortgage", "SeniorSecuredFirstLien",
        "SeniorSecuredFirstMortgage",
        "SeniorSecuredGeneralAndRefundingMortgage", "SeniorSecuredMortgage",
        "SeniorSecuredSecondLien", "SeniorSecuredSecondMortgage",
        "SeniorSecuredThirdMortgage", "SeniorSubordinatedSecured",
        "SeniorSubordinatedUnsecured", "SeniorUnsecured",
        "SubordinatedSecured", "SubordinatedUnsecured", and "Unsecured".
    source : str
        Source or contributor code Default value is \\"Refinitiv\\".
    valuation_date : ~datetime.date
        Get valuationDate.
    """

    business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = rest_field(name="businessSector")
    """TRBC business sector of the economic sector. Known values are:
     \"AcademicAndEducationalServices\", \"AppliedResources\", \"AutomobilesAndAutoParts\",
     \"BankingAndInvestmentServices\", \"Chemicals\", \"CollectiveInvestments\",
     \"ConsumerGoodsConglomerates\", \"CyclicalConsumerProducts\", \"CyclicalConsumerServices\",
     \"EnergyFossilFuels\", \"FinancialTechnologyAndInfrastructure\", \"FoodAndBeverages\",
     \"FoodAndDrugRetailing\", \"GovernmentActivity\", \"HealthcareServicesAndEquipment\",
     \"IndustrialAndCommercialServices\", \"IndustrialGoods\",
     \"InstitutionsAssociationsAndOrganizations\", \"Insurance\", \"InvestmentHoldingCompanies\",
     \"MineralResources\", \"PersonalAndHouseholdProductsAndServices\",
     \"PharmaceuticalsAndMedicalResearch\", \"RealEstate\", \"RenewableEnergy\", \"Retailers\",
     \"SoftwareAndITServices\", \"TechnologyEquipment\", \"TelecommunicationsServices\",
     \"Transportation\", \"Uranium\", and \"Utilities\"."""
    country: Optional[str] = rest_field()
    """Country code of the issuer defined with Alpha-2 Code ISO 3166 country code convention."""
    currency: Optional[str] = rest_field()
    """Bond curve currency code."""
    curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = rest_field(name="curveSubType")
    """Get curveSubType. Known values are: \"BondCarry\", \"BreakevenInflationCurve\",
     \"CDSCreditIndex\", \"CapFloorVolatility\", \"CentralBankInterestRateProbability\",
     \"CommercialPaperBenchmark\", \"CorporateBondBenchmark\", \"CorporateBondPar\",
     \"CorporateBondSpread\", \"CorporateBondZero\", \"CorporateCDSCredit\",
     \"CorporateCashCredit\", \"CorporateIssuer\", \"Covered\", \"Deposit\",
     \"ForwardGovernmentBondZero\", \"ForwardGovernmentPar\", \"ForwardInflation\",
     \"ForwardRateAgreementZero\", \"ForwardStartingSwap\", \"GovernmentBenchmark\",
     \"GovernmentBondBenchmark\", \"GovernmentBondVolatility\", \"GovernmentCDSCredit\",
     \"GovernmentCashCredit\", \"GovernmentStripBenchmark\", \"InflationLinkedBenchmark\",
     \"InflationLinkedZero\", \"InterbankOfferRate\", \"InterestRateSwap\",
     \"InterestRateVolatility\", \"MunicipalBenchmark\", \"OvernightIndexSwap\",
     \"OvernightIndexSwapZero\", \"SemiSovereignCashCredit\", \"ShortTermInterestRateFuturesZero\",
     \"SolvencyIICorporateCreditSprdRating\", \"SolvencyIICoveredPfandbriefIssuer\",
     \"SolvencyIIFinancialCreditSprdRating\", \"SolvencyIIInterestRateSwapYield\",
     \"SolvencyIILiquiditySpread\", \"SolvencyIIPfandbriefYieldByCurrency\",
     \"SolvencyIIStructuredABSRating\", \"SolvencyIIStructuredMBSRating\",
     \"SolvencyIISwapDerivedZero\", \"SolvencyIITreasuryVersusIRSSpread\",
     \"SovereignAgencyBenchmark\", \"SwapCarry\", \"SwapPar\", \"SwapZero\", \"SwaptionVolatility\",
     and \"TreasurySpread\"."""
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""
    economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = rest_field(name="economicSector")
    """TRBC economic sector of the issuer.  Available values are: BasicMaterials, Consumer Cyclicals,
     Consumer Non-Cyclicals, Energy, Financials, Healthcare, Industrials, Technology, Utilities.
     Known values are: \"AcademicAndEducationalServices\", \"BasicMaterials\",
     \"ConsumerCyclicals\", \"ConsumerNonCyclicals\", \"Energy\", \"Financials\",
     \"GovernmentActivity\", \"Healthcare\", \"Industrials\",
     \"InstitutionsAssociationsAndOrganizations\", \"RealEstate\", \"Technology\", and
     \"Utilities\"."""
    id: Optional[str] = rest_field()
    """Id of the curve definition."""
    industry: Optional[Union[str, "_models.IndustryEnum"]] = rest_field()
    """TRBC industry of the industry group. Known values are:
     \"AdvancedMedicalEquipmentAndTechnology\", \"AdvertisingAndMarketing\",
     \"AerospaceAndDefense\", \"AgriculturalChemicals\", \"Airlines\",
     \"AirportOperatorsAndServices\", \"Aluminum\", \"ApparelAndAccessories\",
     \"ApparelAndAccessoriesRetailers\", \"AppliancesToolsAndHousewares\",
     \"AutoAndTruckManufacturers\", \"AutoTruckAndMotorcycleParts\",
     \"AutoVehiclesPartsAndServiceRetailers\", \"Banks\", \"BiotechnologyAndMedicalResearch\",
     \"BlockchainAndCryptocurrency\", \"Brewers\", \"Broadcasting\", \"BusinessSupportServices\",
     \"BusinessSupportSupplies\", \"CasinosAndGaming\", \"CharityOrganizations\",
     \"CivicAndSocialOrganizations\", \"ClosedEndFunds\", \"Coal\", \"CommercialPrintingServices\",
     \"CommercialREITs\", \"CommodityChemicals\", \"CommunicationsAndNetworking\",
     \"ComputerAndElectronicsRetailers\", \"ComputerHardware\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConstructionSuppliesAndFixtures\", \"ConsumerGoodsConglomerates\",
     \"ConsumerLending\", \"ConsumerPublishing\", \"CorporateFinancialServices\",
     \"CourierPostalAirFreightAndLandbasedLogistics\", \"CrowdCollaboration\", \"DepartmentStores\",
     \"DiscountStores\", \"DistillersAndWineries\", \"DiversifiedChemicals\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedInvestmentServices\",
     \"DiversifiedMining\", \"DiversifiedREITs\", \"DrugRetailers\", \"ElectricUtilities\",
     \"ElectricalComponentsAndEquipment\", \"ElectronicEquipmentAndParts\", \"EmploymentServices\",
     \"EntertainmentProduction\", \"EnvironmentalOrganizations\",
     \"EnvironmentalServicesAndEquipment\", \"ExchangeTradedFunds\",
     \"FinancialAndCommodityMarketOperatorsAndServiceProviders\", \"FinancialTechnology\",
     \"FishingAndFarming\", \"FoodProcessing\", \"FoodRetailAndDistribution\", \"Footwear\",
     \"ForestAndWoodProducts\", \"Gold\", \"GovernmentAdministrationActivities\",
     \"GovernmentAndGovernmentFinance\", \"GroundFreightAndLogistics\",
     \"HealthcareFacilitiesAndServices\", \"HeavyElectricalEquipment\",
     \"HeavyMachineryAndVehicles\", \"HighwaysAndRailTracks\", \"HomeFurnishings\",
     \"HomeFurnishingsRetailers\", \"HomeImprovementProductsAndServicesRetailers\",
     \"Homebuilding\", \"HotelsMotelsAndCruiseLines\", \"HouseholdElectronics\",
     \"HouseholdProducts\", \"ITServicesAndConsulting\", \"IndependentPowerProducers\",
     \"IndustrialMachineryAndEquipment\", \"InsuranceFunds\", \"IntegratedHardwareAndSoftware\",
     \"IntegratedOilAndGas\", \"IntegratedTelecommunicationsServices\",
     \"InvestmentBankingAndBrokerageServices\", \"InvestmentHoldingCompanies\",
     \"InvestmentManagementAndFundOperators\", \"IronAndSteel\", \"LegalAndSafetyPublicServices\",
     \"LeisureAndRecreation\", \"LifeAndHealthInsurance\", \"ManagedHealthcare\",
     \"MarineFreightAndLogistics\", \"MarinePortServices\",
     \"MedicalEquipmentSuppliesAndDistribution\", \"MiningSupportServicesAndEquipment\",
     \"MiscellaneousEducationalServiceProviders\", \"MiscellaneousInfrastructure\",
     \"MiscellaneousSpecialtyRetailers\", \"MultilineInsuranceAndBrokers\", \"MultilineUtilities\",
     \"MutualFunds\", \"NationalSecurityAndInternationalAffairs\", \"NaturalGasUtilities\",
     \"NonAlcoholicBeverages\", \"NonGoldPreciousMetalsAndMinerals\",
     \"NonPaperContainersAndPackaging\", \"OfficeEquipment\", \"OilAndGasDrilling\",
     \"OilAndGasExplorationAndProduction\", \"OilAndGasRefiningAndMarketing\",
     \"OilAndGasTransportationServices\", \"OilRelatedServicesAndEquipment\", \"OnlineServices\",
     \"PaperPackaging\", \"PaperProducts\", \"PassengerTransportationGroundAndSea\",
     \"PensionFunds\", \"PersonalProducts\", \"PersonalServices\", \"Pharmaceuticals\",
     \"PhonesAndHandheldDevices\", \"ProfessionalAndBusinessEducation\",
     \"ProfessionalInformationServices\", \"ProfessionalOrganizations\",
     \"PropertyAndCasualtyInsurance\", \"RealEstateRentalDevelopmentAndOperations\",
     \"RealEstateServices\", \"RecreationalProducts\", \"Reinsurance\", \"ReligiousOrganizations\",
     \"RenewableEnergyEquipmentAndServices\", \"RenewableFuels\", \"ResidentialREITs\",
     \"RestaurantsAndBars\", \"SchoolCollegeAndUniversity\", \"SemiconductorEquipmentAndTesting\",
     \"Semiconductors\", \"Shipbuilding\", \"Software\", \"SpecializedREITs\",
     \"SpecialtyChemicals\", \"SpecialtyMiningAndMetals\", \"TextilesAndLeatherGoods\",
     \"TiresAndRubberProducts\", \"Tobacco\", \"ToysAndChildrenProducts\", \"UKInvestmentTrusts\",
     \"Uranium\", \"WaterAndRelatedUtilities\", and \"WirelessTelecommunicationsServices\"."""
    industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = rest_field(name="industryGroup")
    """TRBC industry group of the business sector. Known values are: \"AerospaceAndDefense\",
     \"AutomobilesAndAutoParts\", \"BankingAndInvestmentServices\", \"BankingServices\",
     \"Beverages\", \"BiotechnologyAndMedicalResearch\", \"Chemicals\", \"Coal\",
     \"CollectiveInvestments\", \"CommunicationsAndNetworking\",
     \"ComputersPhonesAndHouseholdElectronics\", \"ConstructionAndEngineering\",
     \"ConstructionMaterials\", \"ConsumerGoodsConglomerates\", \"ContainersAndPackaging\",
     \"DiversifiedIndustrialGoodsWholesale\", \"DiversifiedRetail\", \"ElectricUtilitiesAndIPPs\",
     \"ElectronicEquipmentAndParts\", \"FinancialTechnologyAndInfrastructure\",
     \"FoodAndDrugRetailing\", \"FoodAndTobacco\", \"FreightAndLogisticsServices\",
     \"GovernmentActivity\", \"HealthcareEquipmentAndSupplies\", \"HealthcareProvidersAndServices\",
     \"HomebuildingAndConstructionSupplies\", \"HotelsAndEntertainmentServices\",
     \"HouseholdGoods\", \"InstitutionsAssociationsAndOrganizations\", \"Insurance\",
     \"IntegratedHardwareAndSoftware\", \"InvestmentBankingAndInvestmentServices\",
     \"InvestmentHoldingCompanies\", \"LeisureProducts\",
     \"MachineryToolsHeavyVehiclesTrainsAndShips\", \"MediaAndPublishing\", \"MetalsAndMining\",
     \"MiscellaneousEducationalService\", \"MultilineUtilities\", \"NaturalGasUtilities\",
     \"OfficeEquipment\", \"OilAndGas\", \"OilAndGasRelatedEquipmentAndServices\",
     \"PaperAndForestProducts\", \"PassengerTransportationServices\",
     \"PersonalAndHouseholdProductsAndServices\", \"Pharmaceuticals\",
     \"ProfessionalAndBusinessEducation\", \"ProfessionalAndCommercialServices\", \"Providers\",
     \"RealEstateOperations\", \"RenewableEnergy\", \"ResidentialAndCommercialREITs\",
     \"SchoolCollegeAndUniversity\", \"SemiconductorsAndSemiconductorEquipment\",
     \"SoftwareAndITServices\", \"SpecialtyRetailers\", \"TelecommunicationsServices\",
     \"TextilesAndApparel\", \"TransportInfrastructure\", \"Uranium\", and
     \"WaterAndRelatedUtilities\"."""
    is_currency_country_originator: Optional[bool] = rest_field(name="isCurrencyCountryOriginator")
    issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = rest_field(name="issuerType")
    """Type of the issuer. Available values are: Agency, Corporate, Munis, NonFinancials, Sovereign,
     Supranational. Known values are: \"Agency\", \"Corporate\", \"Munis\", \"NonFinancials\",
     \"Sovereign\", and \"Supranational\"."""
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """Get mainConstituentAssetClass. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    name: Optional[str] = rest_field()
    """Get name."""
    rating: Optional[Union[str, "_models.RatingEnum"]] = rest_field()
    """Get rating. Known values are: \"A\", \"A1\", \"A2\", \"A3\", \"AA\", \"AAA\", \"AAHigh\",
     \"AALow\", \"AAMinus\", \"AAPlus\", \"AHigh\", \"ALow\", \"AMinus\", \"APlus\", \"Aa1\",
     \"Aa2\", \"Aa3\", \"Aaa\", \"B\", \"B1\", \"B2\", \"B3\", \"BB\", \"BBB\", \"BBBHigh\",
     \"BBBLow\", \"BBBMinus\", \"BBBPlus\", \"BBHigh\", \"BBLow\", \"BBMinus\", \"BBPlus\",
     \"BHigh\", \"BLow\", \"BMinus\", \"BPlus\", \"Ba1\", \"Ba2\", \"Ba3\", \"Baa1\", \"Baa2\",
     \"Baa3\", \"C\", \"CC\", \"CCC\", \"CCCHigh\", \"CCCLow\", \"CCCMinus\", \"CCCPlus\",
     \"CCHigh\", \"CCLow\", \"CHigh\", \"CLow\", \"Ca\", \"Caa1\", \"Caa2\", \"Caa3\", \"D\",
     \"DD\", \"DDD\", \"F1\", \"F1Plus\", \"F2\", and \"F3\"."""
    rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = rest_field(name="ratingScaleSource")
    """Get ratingScaleSource. Known values are: \"DBRS\", \"Fitch\", \"Moodys\", \"Refinitiv\", and
     \"SAndP\"."""
    reference_entity: Optional[str] = rest_field(name="referenceEntity")
    """Code to define the reference entity."""
    reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = rest_field(
        name="referenceEntityType"
    )
    """Type of the reference entity (mandatory if referenceEntity is defined). Available values are:
     - ChainRic   - BondIsin   - BondRic   - OrganisationId   - Ticker. Known values are:
     \"BondIsin\", \"BondRic\", \"ChainRic\", \"OrganisationId\", and \"Ticker\"."""
    seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = rest_field()
    """Get seniority. Known values are: \"JuniorSecuredOrJuniorSubordinatedSecured\",
     \"JuniorUnsecuredOrJuniorSubordinatedUnsecured\", \"Secured\", \"SeniorNonPreferred\",
     \"SeniorPreferred\", \"SeniorSecured\", \"SeniorSecuredFirstAndRefundingMortgage\",
     \"SeniorSecuredFirstLien\", \"SeniorSecuredFirstMortgage\",
     \"SeniorSecuredGeneralAndRefundingMortgage\", \"SeniorSecuredMortgage\",
     \"SeniorSecuredSecondLien\", \"SeniorSecuredSecondMortgage\", \"SeniorSecuredThirdMortgage\",
     \"SeniorSubordinatedSecured\", \"SeniorSubordinatedUnsecured\", \"SeniorUnsecured\",
     \"SubordinatedSecured\", \"SubordinatedUnsecured\", and \"Unsecured\"."""
    source: Optional[str] = rest_field()
    """Source or contributor code Default value is \\"Refinitiv\\"."""
    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """Get valuationDate."""

    @overload
    def __init__(
        self,
        *,
        business_sector: Optional[Union[str, "_models.BusinessSectorEnum"]] = None,
        country: Optional[str] = None,
        currency: Optional[str] = None,
        curve_sub_type: Optional[Union[str, "_models.CurveSubTypeEnum"]] = None,
        curve_tag: Optional[str] = None,
        economic_sector: Optional[Union[str, "_models.EconomicSectorEnum"]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        industry: Optional[Union[str, "_models.IndustryEnum"]] = None,
        industry_group: Optional[Union[str, "_models.IndustryGroupEnum"]] = None,
        is_currency_country_originator: Optional[bool] = None,
        issuer_type: Optional[Union[str, "_models.IssuerTypeEnum"]] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        name: Optional[str] = None,
        rating: Optional[Union[str, "_models.RatingEnum"]] = None,
        rating_scale_source: Optional[Union[str, "_models.RatingScaleSourceEnum"]] = None,
        reference_entity: Optional[str] = None,
        reference_entity_type: Optional[Union[str, "_models.ReferenceEntityTypeEnum"]] = None,
        seniority: Optional[Union[str, "_models.CurvesAndSurfacesSeniorityEnum"]] = None,
        source: Optional[str] = None,
        valuation_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditCurvesResponse(_model_base.Model):
    """CreditCurvesResponse.

    Attributes
    ----------
    data : list[~analyticsapi.models.CreditCurvesResponseItem]
        Get data.  The default value is None, needs to be assigned before
        using.
    """

    data: Optional[List["_models.CreditCurvesResponseItem"]] = rest_field()
    """Get data."""

    @overload
    def __init__(
        self,
        data: Optional[List["_models.CreditCurvesResponseItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CreditCurvesResponseItem(_model_base.Model):
    """CreditCurvesResponseItem.

    Attributes
    ----------
    constituents : ~analyticsapi.models.CreditConstituentsOutput
    curve_definition : ~analyticsapi.models.CreditCurveDefinitionOutput
    curve_parameters : ~analyticsapi.models.CreditCurveParameters
    curve_points : list[~analyticsapi.models.CreditCurvePoint]
        Get curvePoints.  The default value is None, needs to be assigned
        before using.
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    invalid_constituents : ~analyticsapi.models.CreditConstituentsOutput
    processing_information : list[~analyticsapi.models.ProcessingInformation]
        Get processingInformation.  The default value is None, needs to be
        assigned before using.
    """

    constituents: Optional["_models.CreditConstituentsOutput"] = rest_field()
    curve_definition: Optional["_models.CreditCurveDefinitionOutput"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.CreditCurveParameters"] = rest_field(name="curveParameters")
    curve_points: Optional[List["_models.CreditCurvePoint"]] = rest_field(name="curvePoints")
    """Get curvePoints."""
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""
    invalid_constituents: Optional["_models.CreditConstituentsOutput"] = rest_field(name="invalidConstituents")
    processing_information: Optional[List["_models.ProcessingInformation"]] = rest_field(name="processingInformation")
    """Get processingInformation."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.CreditConstituentsOutput"] = None,
        curve_definition: Optional["_models.CreditCurveDefinitionOutput"] = None,
        curve_parameters: Optional["_models.CreditCurveParameters"] = None,
        curve_points: Optional[List["_models.CreditCurvePoint"]] = None,
        curve_tag: Optional[str] = None,
        invalid_constituents: Optional["_models.CreditConstituentsOutput"] = None,
        processing_information: Optional[List["_models.ProcessingInformation"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditDefaultSwapInstrument(_model_base.Model):
    """CreditDefaultSwapInstrument.

    Attributes
    ----------
    fields : ~analyticsapi.models.CurvesAndSurfacesBidAskFields
    formula : str
        The formula used to adjust market data values of the instrument's Bid
        and Ask price side. For example, '100-marketPrice'.
    formula_parameters : list[~analyticsapi.models.FormulaParameter]
        The list of formula parameters used to adjust market data values of the
        instrument's Bid and Ask price side.  The default value is None, needs
        to be assigned before using.
    instrument_definition : ~analyticsapi.models.CreditDefaultSwapInstrumentDefinition
    """

    fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """The formula used to adjust market data values of the instrument's Bid and Ask price side. For
     example, '100-marketPrice'."""
    formula_parameters: Optional[List["_models.FormulaParameter"]] = rest_field(name="formulaParameters")
    """The list of formula parameters used to adjust market data values of the instrument's Bid and
     Ask price side."""
    instrument_definition: Optional["_models.CreditDefaultSwapInstrumentDefinition"] = rest_field(
        name="instrumentDefinition"
    )

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameter"]] = None,
        instrument_definition: Optional["_models.CreditDefaultSwapInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditDefaultSwapInstrumentDefinition(_model_base.Model):
    """CreditDefaultSwapInstrumentDefinition.

    Attributes
    ----------
    instrument_code : str
        Code to define the instrument. Only RIC is supported.
    quotation_mode : str or ~analyticsapi.models.CurvesAndSurfacesQuotationModeEnum
        Quotation of the instrument. Known values are: "CashCleanPrice",
        "CashGrossPrice", "Discount", "DiscountMargin", "MoneyMarketYield",
        "Outright", "ParYield", "PercentCleanPrice", "PercentGrossPrice",
        "Price", "SimpleMargin", "Spread", "SwapPoint",
        "SwapPointInAbsoluteUnit", "Upfront", "Yield", and "ZeroCoupon".
    template : str
        A reference to a Adfin instrument contract or the Adfin detailed
        contract.
    tenor : str
        Tenor of the instrument code.
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Code to define the instrument. Only RIC is supported."""
    quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = rest_field(
        name="quotationMode"
    )
    """Quotation of the instrument. Known values are: \"CashCleanPrice\", \"CashGrossPrice\",
     \"Discount\", \"DiscountMargin\", \"MoneyMarketYield\", \"Outright\", \"ParYield\",
     \"PercentCleanPrice\", \"PercentGrossPrice\", \"Price\", \"SimpleMargin\", \"Spread\",
     \"SwapPoint\", \"SwapPointInAbsoluteUnit\", \"Upfront\", \"Yield\", and \"ZeroCoupon\"."""
    template: Optional[str] = rest_field()
    """A reference to a Adfin instrument contract or the Adfin detailed contract."""
    tenor: Optional[str] = rest_field()
    """Tenor of the instrument code."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = None,
        template: Optional[str] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditDefaultSwapInstrumentOutput(_model_base.Model):
    """CreditDefaultSwapInstrumentOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CreditDefaultSwapInstrumentDefinition
    status_message : str
        Get statusMessage.
    """

    fields: Optional["_models.BidAskFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CreditDefaultSwapInstrumentDefinition"] = rest_field(
        name="instrumentDefinition"
    )
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.CreditDefaultSwapInstrumentDefinition"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditDefaultSwapsInstrumentDescription(_model_base.Model):
    """CreditDefaultSwapsInstrumentDescription.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsDescription
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterDescription]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CreditDefaultSwapInstrumentDefinition
    """

    fields: Optional["_models.BidAskFieldsDescription"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CreditDefaultSwapInstrumentDefinition"] = rest_field(
        name="instrumentDefinition"
    )

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsDescription"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = None,
        instrument_definition: Optional["_models.CreditDefaultSwapInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditInstruments(_model_base.Model):
    """CreditInstruments.

    Attributes
    ----------
    bonds : list[~analyticsapi.models.BondInstrument]
        Get bonds.  The default value is None, needs to be assigned before
        using.
    credit_default_swaps : list[~analyticsapi.models.CreditDefaultSwapInstrument]
        Get creditDefaultSwaps.  The default value is None, needs to be
        assigned before using.
    deposits : list[~analyticsapi.models.CurvesAndSurfacesInstrument]
        Get deposits.  The default value is None, needs to be assigned before
        using.
    """

    bonds: Optional[List["_models.BondInstrument"]] = rest_field()
    """Get bonds."""
    credit_default_swaps: Optional[List["_models.CreditDefaultSwapInstrument"]] = rest_field(name="creditDefaultSwaps")
    """Get creditDefaultSwaps."""
    deposits: Optional[List["_models.CurvesAndSurfacesInstrument"]] = rest_field()
    """Get deposits."""

    @overload
    def __init__(
        self,
        *,
        bonds: Optional[List["_models.BondInstrument"]] = None,
        credit_default_swaps: Optional[List["_models.CreditDefaultSwapInstrument"]] = None,
        deposits: Optional[List["_models.CurvesAndSurfacesInstrument"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CreditInstrumentsOutput(_model_base.Model):
    """CreditInstrumentsOutput.

    Attributes
    ----------
    bonds : list[~analyticsapi.models.BondInstrumentOutput]
        Get bonds.  The default value is None, needs to be assigned before
        using.
    credit_default_swaps : list[~analyticsapi.models.CreditDefaultSwapInstrumentOutput]
        Get creditDefaultSwaps.  The default value is None, needs to be
        assigned before using.
    deposits : list[~analyticsapi.models.DepositInstrumentOutput]
        Get deposits.  The default value is None, needs to be assigned before
        using.
    """

    bonds: Optional[List["_models.BondInstrumentOutput"]] = rest_field()
    """Get bonds."""
    credit_default_swaps: Optional[List["_models.CreditDefaultSwapInstrumentOutput"]] = rest_field(
        name="creditDefaultSwaps"
    )
    """Get creditDefaultSwaps."""
    deposits: Optional[List["_models.DepositInstrumentOutput"]] = rest_field()
    """Get deposits."""

    @overload
    def __init__(
        self,
        *,
        bonds: Optional[List["_models.BondInstrumentOutput"]] = None,
        credit_default_swaps: Optional[List["_models.CreditDefaultSwapInstrumentOutput"]] = None,
        deposits: Optional[List["_models.DepositInstrumentOutput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CrossCurencySwapOverride(_model_base.Model):
    """An object that contains the cross currency swap properties that can be overridden.

    Attributes
    ----------
    start_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the cross
        currency swap start date.
    end_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the cross
        currency swap end date.
    amount : float
        The principal amount of the cross currency swap in the base currency.
    contra_amount : float
        The principal amount of the cross currency swap in the contra currency.
    fixed_rate : ~analyticsapi.models.Rate
    spread : ~analyticsapi.models.Rate
    paid_leg : str or ~analyticsapi.models.PaidLegEnum
        A flag that defines whether the first leg or the second leg of the
        cross currency swap is paid. Known values are: "FirstLeg" and
        "SecondLeg".
    """

    start_date: Optional["_models.Date"] = rest_field(name="startDate")
    """An object that contains properties to define and adjust the cross currency swap start date."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """An object that contains properties to define and adjust the cross currency swap end date."""
    amount: Optional[float] = rest_field()
    """The principal amount of the cross currency swap in the base currency."""
    contra_amount: Optional[float] = rest_field(name="contraAmount")
    """The principal amount of the cross currency swap in the contra currency."""
    fixed_rate: Optional["_models.Rate"] = rest_field(name="fixedRate")
    spread: Optional["_models.Rate"] = rest_field()
    paid_leg: Optional[Union[str, "_models.PaidLegEnum"]] = rest_field(name="paidLeg")
    """A flag that defines whether the first leg or the second leg of the cross currency swap is paid.
     Known values are: \"FirstLeg\" and \"SecondLeg\"."""

    @overload
    def __init__(
        self,
        *,
        start_date: Optional["_models.Date"] = None,
        end_date: Optional["_models.Date"] = None,
        amount: Optional[float] = None,
        contra_amount: Optional[float] = None,
        fixed_rate: Optional["_models.Rate"] = None,
        spread: Optional["_models.Rate"] = None,
        paid_leg: Optional[Union[str, "_models.PaidLegEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CrossCurrencyCurveDefinitionPricing(_model_base.Model):
    """CrossCurrencyCurveDefinitionPricing.

    Attributes
    ----------
    base_currency : str
        The base currency in the FxCross currency pair. It is expressed in ISO
        4217 alphabetical format (e.g., 'EUR').
    base_index_name : str
        The name of the floating rate index (e.g., 'ESTR') applied to the base
        currency.
    constituent_override_mode : str or ~analyticsapi.models.ConstituentOverrideModeEnum
        A method to use the default constituents. The possible values are:   *
        MergeWithDefinition: merge the default constituents and the user
        constituents from the input request,   * ReplaceDefinition: replace the
        default constituents by the user constituents from the input request,
        The default value is 'ReplaceDefinition'.  If the
        ignoreExistingDefinition is true, the constituentOverrideMode is set to
        ReplaceDefinition. Known values are: "MergeWithDefinition" and
        "ReplaceDefinition".
    id : str
        The identifier of the cross currency definition.
    ignore_existing_definition : bool
    is_non_deliverable : bool
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        The asset class used to generate the zero coupon curve. The possible
        values are:   * FxForward   * Swap. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    name : str
        The name of the curve (e.g., 'EUR USD FxCross').
    quoted_currency : str
        The quoted currency in the FxCross currency pair. It is expressed in
        ISO 4217 alphabetical format (e.g., 'USD').
    quoted_index_name : str
        The name of the floating rate index (e.g., 'SOFR') applied to the
        quoted currency.
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the generated cross currency curve is sensitive.
        The possible value is: CrossCurrency. Known values are: "Credit",
        "CrossCurrency", "Inflation", and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of a curve.
        Curves created by Refinitiv have the 'Refinitiv' source.
    """

    base_currency: Optional[str] = rest_field(name="baseCurrency")
    """The base currency in the FxCross currency pair. It is expressed in ISO 4217 alphabetical format
     (e.g., 'EUR')."""
    base_index_name: Optional[str] = rest_field(name="baseIndexName")
    """The name of the floating rate index (e.g., 'ESTR') applied to the base currency."""
    constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = rest_field(
        name="constituentOverrideMode"
    )
    """A method to use the default constituents. The possible values are:   * MergeWithDefinition:
     merge the default constituents and the user constituents from the input request,   *
     ReplaceDefinition: replace the default constituents by the user constituents from the input
     request, The default value is 'ReplaceDefinition'.  If the ignoreExistingDefinition is true,
     the constituentOverrideMode is set to ReplaceDefinition. Known values are:
     \"MergeWithDefinition\" and \"ReplaceDefinition\"."""
    id: Optional[str] = rest_field()
    """The identifier of the cross currency definition."""
    ignore_existing_definition: Optional[bool] = rest_field(name="ignoreExistingDefinition")
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """The asset class used to generate the zero coupon curve. The possible values are:   * FxForward
     * Swap. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\", \"Futures\",
     \"FxForward\", and \"Swap\"."""
    name: Optional[str] = rest_field()
    """The name of the curve (e.g., 'EUR USD FxCross')."""
    quoted_currency: Optional[str] = rest_field(name="quotedCurrency")
    """The quoted currency in the FxCross currency pair. It is expressed in ISO 4217 alphabetical
     format (e.g., 'USD')."""
    quoted_index_name: Optional[str] = rest_field(name="quotedIndexName")
    """The name of the floating rate index (e.g., 'SOFR') applied to the quoted currency."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the generated cross currency curve is sensitive. The possible value is:
     CrossCurrency. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of a curve. Curves created by Refinitiv
     have the 'Refinitiv' source."""

    @overload
    def __init__(
        self,
        *,
        base_currency: Optional[str] = None,
        base_index_name: Optional[str] = None,
        constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        ignore_existing_definition: Optional[bool] = None,
        is_non_deliverable: Optional[bool] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        name: Optional[str] = None,
        quoted_currency: Optional[str] = None,
        quoted_index_name: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CrossCurrencyInstrument(_model_base.Model):
    """CrossCurrencyInstrument.

    Attributes
    ----------
    fields : ~analyticsapi.models.CurvesAndSurfacesBidAskFields
    formula : str
        The formula used to adjust market data values of the instrument's Bid
        and Ask price side. For example, '100-marketPrice'.
    formula_parameters : list[~analyticsapi.models.FormulaParameter]
        The list of formula parameters used to adjust market data values of the
        instrument's Bid and Ask price side.  The default value is None, needs
        to be assigned before using.
    instrument_definition : ~analyticsapi.models.CrossCurrencyInstrumentDefinition
    """

    fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """The formula used to adjust market data values of the instrument's Bid and Ask price side. For
     example, '100-marketPrice'."""
    formula_parameters: Optional[List["_models.FormulaParameter"]] = rest_field(name="formulaParameters")
    """The list of formula parameters used to adjust market data values of the instrument's Bid and
     Ask price side."""
    instrument_definition: Optional["_models.CrossCurrencyInstrumentDefinition"] = rest_field(
        name="instrumentDefinition"
    )

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameter"]] = None,
        instrument_definition: Optional["_models.CrossCurrencyInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CrossCurrencyInstrumentDefinition(_model_base.Model):
    """CrossCurrencyInstrumentDefinition.

    Attributes
    ----------
    instrument_code : str
        The code used to define the instrument.
    is_non_deliverable : bool
    synthetic_instrument_code : str
        The code used to define the formula.
    template : str
        A reference to a style used to define the instrument.
    tenor : str
        The code indicating the instrument tenor (e.g., '6M', '1Y').
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    synthetic_instrument_code: Optional[str] = rest_field(name="syntheticInstrumentCode")
    """The code used to define the formula."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""
    tenor: Optional[str] = rest_field()
    """The code indicating the instrument tenor (e.g., '6M', '1Y')."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        is_non_deliverable: Optional[bool] = None,
        synthetic_instrument_code: Optional[str] = None,
        template: Optional[str] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CrossCurrencyInstrumentDefinitionOutput(_model_base.Model):
    """CrossCurrencyInstrumentDefinitionOutput.

    Attributes
    ----------
    end_date : ~datetime.date
        The date used to define the end date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    instrument_code : str
        The code used to define the instrument.
    is_non_deliverable : bool
    start_date : ~datetime.date
        The date used to define the start date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    synthetic_instrument_code : str
        The code used to define the formula.
    template : str
        A reference to a style used to define the instrument.
    tenor : str
        The code indicating the instrument tenor (e.g., '6M', '1Y').
    """

    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date used to define the end date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The date used to define the start date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    synthetic_instrument_code: Optional[str] = rest_field(name="syntheticInstrumentCode")
    """The code used to define the formula."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""
    tenor: Optional[str] = rest_field()
    """The code indicating the instrument tenor (e.g., '6M', '1Y')."""

    @overload
    def __init__(
        self,
        *,
        end_date: Optional[datetime.date] = None,
        instrument_code: Optional[str] = None,
        is_non_deliverable: Optional[bool] = None,
        start_date: Optional[datetime.date] = None,
        synthetic_instrument_code: Optional[str] = None,
        template: Optional[str] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CrossCurrencyInstrumentOutput(_model_base.Model):
    """CrossCurrencyInstrumentOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.CrossCurrencyInstrumentDefinitionOutput
    status_message : str
        Get statusMessage.
    """

    fields: Optional["_models.BidAskFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.CrossCurrencyInstrumentDefinitionOutput"] = rest_field(
        name="instrumentDefinition"
    )
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.CrossCurrencyInstrumentDefinitionOutput"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CrossCurrencyInstruments(_model_base.Model):
    """CrossCurrencyInstruments.

    Attributes
    ----------
    cross_currency_swaps : list[~analyticsapi.models.CrossCurrencyInstrument]
        The list of attributes for Cross Currency Swap contract used as
        constituents to generate the zero coupon curve.  The default value is
        None, needs to be assigned before using.
    fx_forwards : list[~analyticsapi.models.FxForwardInstrument]
        The list of attributes for Fx Forward contract used as constituents to
        generate the zero coupon curve.  The default value is None, needs to be
        assigned before using.
    fx_spot : ~analyticsapi.models.FxSpotInstrument
    interest_rate_swaps : list[~analyticsapi.models.CrossCurrencyInstrument]
        The list of attributes for Interest Rate Swap contract used as
        constituents to generate the zero coupon curve. It is used in case of
        non deliverable workflows.  The default value is None, needs to be
        assigned before using.
    overnight_index_swaps : list[~analyticsapi.models.CrossCurrencyInstrument]
        The list of attributes for Overnight Index Swap contract used as
        constituents to generate the zero coupon curve. It is used in case of
        non deliverable workflows.  The default value is None, needs to be
        assigned before using.
    sources : ~analyticsapi.models.CrossCurrencyInstrumentsSources
    """

    cross_currency_swaps: Optional[List["_models.CrossCurrencyInstrument"]] = rest_field(name="crossCurrencySwaps")
    """The list of attributes for Cross Currency Swap contract used as constituents to generate the
     zero coupon curve."""
    fx_forwards: Optional[List["_models.FxForwardInstrument"]] = rest_field(name="fxForwards")
    """The list of attributes for Fx Forward contract used as constituents to generate the zero coupon
     curve."""
    fx_spot: Optional["_models.FxSpotInstrument"] = rest_field(name="fxSpot")
    interest_rate_swaps: Optional[List["_models.CrossCurrencyInstrument"]] = rest_field(name="interestRateSwaps")
    """The list of attributes for Interest Rate Swap contract used as constituents to generate the
     zero coupon curve. It is used in case of non deliverable workflows."""
    overnight_index_swaps: Optional[List["_models.CrossCurrencyInstrument"]] = rest_field(name="overnightIndexSwaps")
    """The list of attributes for Overnight Index Swap contract used as constituents to generate the
     zero coupon curve. It is used in case of non deliverable workflows."""
    sources: Optional["_models.CrossCurrencyInstrumentsSources"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        cross_currency_swaps: Optional[List["_models.CrossCurrencyInstrument"]] = None,
        fx_forwards: Optional[List["_models.FxForwardInstrument"]] = None,
        fx_spot: Optional["_models.FxSpotInstrument"] = None,
        interest_rate_swaps: Optional[List["_models.CrossCurrencyInstrument"]] = None,
        overnight_index_swaps: Optional[List["_models.CrossCurrencyInstrument"]] = None,
        sources: Optional["_models.CrossCurrencyInstrumentsSources"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CrossCurrencyInstrumentsOutput(_model_base.Model):
    """CrossCurrencyInstrumentsOutput.

    Attributes
    ----------
    cross_currency_swaps : list[~analyticsapi.models.CrossCurrencyInstrumentOutput]
        Get crossCurrencySwaps.  The default value is None, needs to be
        assigned before using.
    fx_forwards : list[~analyticsapi.models.FxForwardInstrumentOutput]
        Get fxForwards.  The default value is None, needs to be assigned before
        using.
    fx_spot : ~analyticsapi.models.FxSpotInstrumentOutput
    interest_rate_swaps : list[~analyticsapi.models.CrossCurrencyInstrumentOutput]
        Get interestRateSwaps.  The default value is None, needs to be assigned
        before using.
    overnight_index_swaps : list[~analyticsapi.models.CrossCurrencyInstrumentOutput]
        Get overnightIndexSwaps.  The default value is None, needs to be
        assigned before using.
    """

    cross_currency_swaps: Optional[List["_models.CrossCurrencyInstrumentOutput"]] = rest_field(
        name="crossCurrencySwaps"
    )
    """Get crossCurrencySwaps."""
    fx_forwards: Optional[List["_models.FxForwardInstrumentOutput"]] = rest_field(name="fxForwards")
    """Get fxForwards."""
    fx_spot: Optional["_models.FxSpotInstrumentOutput"] = rest_field(name="fxSpot")
    interest_rate_swaps: Optional[List["_models.CrossCurrencyInstrumentOutput"]] = rest_field(name="interestRateSwaps")
    """Get interestRateSwaps."""
    overnight_index_swaps: Optional[List["_models.CrossCurrencyInstrumentOutput"]] = rest_field(
        name="overnightIndexSwaps"
    )
    """Get overnightIndexSwaps."""

    @overload
    def __init__(
        self,
        *,
        cross_currency_swaps: Optional[List["_models.CrossCurrencyInstrumentOutput"]] = None,
        fx_forwards: Optional[List["_models.FxForwardInstrumentOutput"]] = None,
        fx_spot: Optional["_models.FxSpotInstrumentOutput"] = None,
        interest_rate_swaps: Optional[List["_models.CrossCurrencyInstrumentOutput"]] = None,
        overnight_index_swaps: Optional[List["_models.CrossCurrencyInstrumentOutput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CrossCurrencyInstrumentsSources(_model_base.Model):
    """CrossCurrencyInstrumentsSources.

    Attributes
    ----------
    fx_forward : ~analyticsapi.models.FxForwardInstrumentsSource
    fx_spot : ~analyticsapi.models.FxSpotInstrumentsSource
    """

    fx_forward: Optional["_models.FxForwardInstrumentsSource"] = rest_field(name="fxForward")
    fx_spot: Optional["_models.FxSpotInstrumentsSource"] = rest_field(name="fxSpot")

    @overload
    def __init__(
        self,
        *,
        fx_forward: Optional["_models.FxForwardInstrumentsSource"] = None,
        fx_spot: Optional["_models.FxSpotInstrumentsSource"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CrossCurrencySwapTemplateDefinition(InstrumentTemplateDefinition, discriminator="CrossCurrencySwap"):
    """CrossCurrencySwapTemplateDefinition.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.CROSS_CURRENCY_SWAP
        Required. A cross currency swap contract.
    template : ~analyticsapi.models.IrSwapDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.CROSS_CURRENCY_SWAP] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. A cross currency swap contract."""
    template: "_models.IrSwapDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.IrSwapDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.CROSS_CURRENCY_SWAP, **kwargs)


class CurencyBasisSwapOverride(_model_base.Model):
    """An object that contains the currency basis swap properties that can be overridden.

    Attributes
    ----------
    start_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the currency
        basis swap start date.
    end_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the currency
        basis swap end date.
    amount : float
        The principal amount of the currency basis swap in the base currency.
    contra_amount : float
        The principal amount of the currency basis swap in the contra currency.
    first_spread : ~analyticsapi.models.Rate
    second_spread : ~analyticsapi.models.Rate
    paid_leg : str or ~analyticsapi.models.PaidLegEnum
        A flag that defines whether the first leg or the second leg of the
        currency basis swap is paid. Known values are: "FirstLeg" and
        "SecondLeg".
    """

    start_date: Optional["_models.Date"] = rest_field(name="startDate")
    """An object that contains properties to define and adjust the currency basis swap start date."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """An object that contains properties to define and adjust the currency basis swap end date."""
    amount: Optional[float] = rest_field()
    """The principal amount of the currency basis swap in the base currency."""
    contra_amount: Optional[float] = rest_field(name="contraAmount")
    """The principal amount of the currency basis swap in the contra currency."""
    first_spread: Optional["_models.Rate"] = rest_field(name="firstSpread")
    second_spread: Optional["_models.Rate"] = rest_field(name="secondSpread")
    paid_leg: Optional[Union[str, "_models.PaidLegEnum"]] = rest_field(name="paidLeg")
    """A flag that defines whether the first leg or the second leg of the currency basis swap is paid.
     Known values are: \"FirstLeg\" and \"SecondLeg\"."""

    @overload
    def __init__(
        self,
        *,
        start_date: Optional["_models.Date"] = None,
        end_date: Optional["_models.Date"] = None,
        amount: Optional[float] = None,
        contra_amount: Optional[float] = None,
        first_spread: Optional["_models.Rate"] = None,
        second_spread: Optional["_models.Rate"] = None,
        paid_leg: Optional[Union[str, "_models.PaidLegEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxConstituent(ABC, _model_base.Model):
    """An object to define constituents that are used to construct the curve.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    CurrencyBasisSwapConstituent, DepositFxConstituent, FxForwardConstituent, FxSpotConstituent

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.FxConstituentEnum
        The type of the instrument used as a constituent. Required. Known
        values are: "FxSpot", "FxForward", "CurrencyBasisSwap", and "Deposit".
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The type of the instrument used as a constituent. Required. Known values are: \"FxSpot\",
     \"FxForward\", \"CurrencyBasisSwap\", and \"Deposit\"."""
    quote: Optional["_models.Quote"] = rest_field()
    """An object to define the quote of the instrument used as a constituent."""
    status: Optional[List[str]] = rest_field(visibility=["read"])
    """A message is returned if the constituent cannot be identified, or access for a user to the
     instrument used as a constituent is denied."""

    @overload
    def __init__(
        self,
        *,
        type: str,
        quote: Optional["_models.Quote"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurrencyBasisSwapConstituent(FxConstituent, discriminator="CurrencyBasisSwap"):
    """An object defining a currency basis swap constituent of an fx forward curve.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.CURRENCY_BASIS_SWAP
        The type of the instrument used as a constituent. Required.
    definition : ~analyticsapi.models.CurrencyBasisSwapConstituentDefinition
        An object to define the instrument used as a constituent.
    """

    type: Literal[FxConstituentEnum.CURRENCY_BASIS_SWAP] = rest_discriminator(name="type")  # type: ignore
    """The type of the instrument used as a constituent. Required."""
    definition: Optional["_models.CurrencyBasisSwapConstituentDefinition"] = rest_field()
    """An object to define the instrument used as a constituent."""

    @overload
    def __init__(
        self,
        *,
        quote: Optional["_models.Quote"] = None,
        definition: Optional["_models.CurrencyBasisSwapConstituentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=FxConstituentEnum.CURRENCY_BASIS_SWAP, **kwargs)


class CurrencyBasisSwapConstituentDefinition(_model_base.Model):
    """The definition of a currency basis swap instrument used as a constituent of an fx forward
    curve.

    Attributes
    ----------
    tenor : str
        The code indicating the tenor of the instrument used as a constituent
        (e.g., '1M', '1Y'). Required.
    template : str
        A pre-defined template can be used as an input by the user. It is the
        currency code of the constituent.
    """

    tenor: str = rest_field()
    """The code indicating the tenor of the instrument used as a constituent (e.g., '1M', '1Y').
     Required."""
    template: Optional[str] = rest_field()
    """A pre-defined template can be used as an input by the user. It is the currency code of the
     constituent."""

    @overload
    def __init__(
        self,
        *,
        tenor: str,
        template: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurrencyBasisSwapTemplateDefinition(InstrumentTemplateDefinition, discriminator="CurrencyBasisSwap"):
    """CurrencyBasisSwapTemplateDefinition.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.CURRENCY_BASIS_SWAP
        Required. A currency basis swap contract.
    template : ~analyticsapi.models.IrSwapDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.CURRENCY_BASIS_SWAP] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. A currency basis swap contract."""
    template: "_models.IrSwapDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.IrSwapDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.CURRENCY_BASIS_SWAP, **kwargs)


class Curve(ABC, _model_base.Model):
    """An object to define a Curve depending on its type.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    DividendCurve, FxOutrightCurve, IrZcCurve

    Attributes
    ----------
    curve_type : str or ~analyticsapi.models.CurveTypeEnum
        The type of the curve. Required. Known values are: "IrZcCurve",
        "FxOutrightCurve", and "DividendCurve".
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    curve_type: str = rest_discriminator(name="curveType")
    """The type of the curve. Required. Known values are: \"IrZcCurve\", \"FxOutrightCurve\", and
     \"DividendCurve\"."""

    @overload
    def __init__(
        self,
        curve_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["curve_type"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CurveCalculationParameters(_model_base.Model):
    """An object that contains parameters used to define how the curve is constructed from the
    constituents.

    Attributes
    ----------
    valuation_date : ~datetime.date
        The date on which the curve is constructed. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01'). The valuation date
        should not be in the future. Default is Today.
    valuation_time : ~analyticsapi.models.ValuationTime
        an object to define the time on witch the curve is constructed.
    curve_tenors : list[str]
        An array of user-defined tenors for which curve points to be computed.
        The values are expressed in:

        * time period code for tenors (e.g., '1M', '1Y'),
        * ISO 8601 format 'YYYY-MM-DD' for dates (e.g., '2023-01-01').  The default value is None,
        needs to be assigned before using.
    """

    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """The date on which the curve is constructed. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2023-01-01').
     The valuation date should not be in the future. Default is Today."""
    valuation_time: Optional["_models.ValuationTime"] = rest_field(name="valuationTime")
    """an object to define the time on witch the curve is constructed."""
    curve_tenors: Optional[List[str]] = rest_field(name="curveTenors")
    """An array of user-defined tenors for which curve points to be computed. The values are expressed
     in:
     
     
     * time period code for tenors (e.g., '1M', '1Y'),
     * ISO 8601 format 'YYYY-MM-DD' for dates (e.g., '2023-01-01')."""

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.date] = None,
        valuation_time: Optional["_models.ValuationTime"] = None,
        curve_tenors: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurveDataPoint(_model_base.Model):
    """An object that represents a curve point.

    Attributes
    ----------
    date : ~datetime.date
        The date of the zero coupon value. Required.
    value : float
        The zero coupon value. Required.
    """

    date: datetime.date = rest_field()
    """The date of the zero coupon value. Required."""
    value: float = rest_field()
    """The zero coupon value. Required."""

    @overload
    def __init__(
        self,
        *,
        date: datetime.date,
        value: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurveDetailsRequest(_model_base.Model):
    """CurveDetailsRequest.

    Attributes
    ----------
    curves : list[~analyticsapi.models.CurveSearch]
        The default value is None, needs to be assigned before using.
    """

    curves: Optional[List["_models.CurveSearch"]] = rest_field()

    @overload
    def __init__(
        self,
        curves: Optional[List["_models.CurveSearch"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["curves"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CurveInfo(_model_base.Model):
    """CurveInfo.

    Attributes
    ----------
    creation_date_time : ~datetime.datetime
        Get creationDateTime.
    creation_user_id : str
        Get creationUserId.
    update_date_time : ~datetime.datetime
        Get updateDateTime.
    update_user_id : str
        Get updateUserId.
    version : str
        Get version.
    """

    creation_date_time: Optional[datetime.datetime] = rest_field(name="creationDateTime", format="rfc3339")
    """Get creationDateTime."""
    creation_user_id: Optional[str] = rest_field(name="creationUserId")
    """Get creationUserId."""
    update_date_time: Optional[datetime.datetime] = rest_field(name="updateDateTime", format="rfc3339")
    """Get updateDateTime."""
    update_user_id: Optional[str] = rest_field(name="updateUserId")
    """Get updateUserId."""
    version: Optional[str] = rest_field()
    """Get version."""

    @overload
    def __init__(
        self,
        *,
        creation_date_time: Optional[datetime.datetime] = None,
        creation_user_id: Optional[str] = None,
        update_date_time: Optional[datetime.datetime] = None,
        update_user_id: Optional[str] = None,
        version: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurveMultiShift(_model_base.Model):
    """CurveMultiShift.

    Attributes
    ----------
    period : ~decimal.Decimal
        Months from the settlement date. The last month must match the horizon
        date.
    curve_shifts : list[~analyticsapi.models.ApimCurveShift]
        The default value is None, needs to be assigned before using.
    """

    period: Optional[decimal.Decimal] = rest_field()
    """Months from the settlement date. The last month must match the horizon date."""
    curve_shifts: Optional[List["_models.ApimCurveShift"]] = rest_field(name="curveShifts")

    @overload
    def __init__(
        self,
        *,
        period: Optional[decimal.Decimal] = None,
        curve_shifts: Optional[List["_models.ApimCurveShift"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurvePoint(_model_base.Model):
    """CurvePoint.

    Attributes
    ----------
    rate : ~decimal.Decimal
    term : ~decimal.Decimal
    """

    rate: Optional[decimal.Decimal] = rest_field()
    term: Optional[decimal.Decimal] = rest_field()

    @overload
    def __init__(
        self,
        *,
        rate: Optional[decimal.Decimal] = None,
        term: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurvePointRelatedInstruments(_model_base.Model):
    """An object that contains the instrument used to calculate the curve point.

    Attributes
    ----------
    instrument_code : str
        The code to define the instrument used to calculate the curve point.
        Required.
    """

    instrument_code: str = rest_field(name="instrumentCode")
    """The code to define the instrument used to calculate the curve point. Required."""

    @overload
    def __init__(
        self,
        instrument_code: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["instrument_code"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class CurvesAndSurfacesBidAskFields(_model_base.Model):
    """CurvesAndSurfacesBidAskFields.

    Attributes
    ----------
    ask : ~analyticsapi.models.FieldFormulaDoubleValue
    bid : ~analyticsapi.models.FieldFormulaDoubleValue
    """

    ask: Optional["_models.FieldFormulaDoubleValue"] = rest_field()
    bid: Optional["_models.FieldFormulaDoubleValue"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        ask: Optional["_models.FieldFormulaDoubleValue"] = None,
        bid: Optional["_models.FieldFormulaDoubleValue"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurvesAndSurfacesConvexityAdjustment(_model_base.Model):
    """CurvesAndSurfacesConvexityAdjustment.

    Attributes
    ----------
    mean_reversion_percent : float
        The mean reversion speed rate used to calculate convexity adjustment of
        the curve. The value is expressed in percentages. Mandatory when
        useConvexityAdjustment is set to 'true' and volatilityPercent of the
        'convexityAdjustment' object property is specified.
    volatility_percent : float
        The volatility percent used to calculate convexity adjustment of the
        curve. The value is expressed in percentages. Mandatory when
        useConvexityAdjustment is set to 'true' and meanReversionPercent of the
        'convexityAdjustment' object property is specified.
    """

    mean_reversion_percent: Optional[float] = rest_field(name="meanReversionPercent")
    """The mean reversion speed rate used to calculate convexity adjustment of the curve. The value is
     expressed in percentages. Mandatory when useConvexityAdjustment is set to 'true' and
     volatilityPercent of the 'convexityAdjustment' object property is specified."""
    volatility_percent: Optional[float] = rest_field(name="volatilityPercent")
    """The volatility percent used to calculate convexity adjustment of the curve. The value is
     expressed in percentages. Mandatory when useConvexityAdjustment is set to 'true' and
     meanReversionPercent of the 'convexityAdjustment' object property is specified."""

    @overload
    def __init__(
        self,
        *,
        mean_reversion_percent: Optional[float] = None,
        volatility_percent: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurvesAndSurfacesInstrument(_model_base.Model):
    """CurvesAndSurfacesInstrument.

    Attributes
    ----------
    fields : ~analyticsapi.models.CurvesAndSurfacesBidAskFields
    formula : str
        The formula used to adjust market data values of the instrument's Bid
        and Ask price side. For example, '100-marketPrice'.
    formula_parameters : list[~analyticsapi.models.FormulaParameter]
        The list of formula parameters used to adjust market data values of the
        instrument's Bid and Ask price side.  The default value is None, needs
        to be assigned before using.
    instrument_definition : ~analyticsapi.models.InstrumentDefinition
    """

    fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """The formula used to adjust market data values of the instrument's Bid and Ask price side. For
     example, '100-marketPrice'."""
    formula_parameters: Optional[List["_models.FormulaParameter"]] = rest_field(name="formulaParameters")
    """The list of formula parameters used to adjust market data values of the instrument's Bid and
     Ask price side."""
    instrument_definition: Optional["_models.InstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameter"]] = None,
        instrument_definition: Optional["_models.InstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurvesAndSurfacesValuationTime(_model_base.Model):
    """CurvesAndSurfacesValuationTime.

    Attributes
    ----------
    city_name : str
        The city name according to Market Identifier Code (MIC) (e.g., 'NEW
        YORK') See ISO 10383 for reference.
    local_time : str
        Local time or other words time in offset timezone. The value is
        expressed in ISO 8601 format: [hh]:[mm]:[ss] (e.g., '14:00:00').
    market_identifier_code : str
        The Market Identifier Code (MIC) used to identify securities trading
        exchanges, regulated and non-regulated trading markets. The MIC is a
        four alphanumeric character code, and is defined in ISO 10383 (e.g.,
        'XNAS' for NASDAQ).   See ISO 10383 for reference.
    time_zone_offset : str
        Time offsets from UTC. The value is expressed in ISO 8601 format:
        [hh]:[mm] (e.g., '+05:00').
    """

    city_name: Optional[str] = rest_field(name="cityName")
    """The city name according to Market Identifier Code (MIC) (e.g., 'NEW YORK')  See ISO 10383 for
     reference."""
    local_time: Optional[str] = rest_field(name="localTime")
    """Local time or other words time in offset timezone. The value is expressed in ISO 8601 format:
     [hh]:[mm]:[ss] (e.g., '14:00:00')."""
    market_identifier_code: Optional[str] = rest_field(name="marketIdentifierCode")
    """The Market Identifier Code (MIC) used to identify securities trading exchanges, regulated and
     non-regulated trading markets. The MIC is a four alphanumeric character code, and is defined in
     ISO 10383 (e.g., 'XNAS' for NASDAQ).   See ISO 10383 for reference."""
    time_zone_offset: Optional[str] = rest_field(name="timeZoneOffset")
    """Time offsets from UTC. The value is expressed in ISO 8601 format: [hh]:[mm] (e.g., '+05:00')."""

    @overload
    def __init__(
        self,
        *,
        city_name: Optional[str] = None,
        local_time: Optional[str] = None,
        market_identifier_code: Optional[str] = None,
        time_zone_offset: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurveSearch(_model_base.Model):
    """CurveSearch.

    Attributes
    ----------
    curve_id : str
    curve_type : str
        Is one of the following types: Literal["GVT"], Literal["GVT_TSYM"],
        Literal["GVT_TSYM_MUNI"], Literal["GVT_AGN"], Literal["GVT_MUNI"],
        Literal["GVT_BUND"], Literal["SWAP"], Literal["SWAP_RFR"],
        Literal["SWAP_MUNI"]
    currency : str
    expand_curve : bool
    pricing_date : ~datetime.date
    show_spot_rate : bool
    show_forward_rate : bool
    show_discount_factor : bool
    forward_period : float
    implied_forward_delay : float
    index : str
    use_live_curve : bool
    """

    curve_id: Optional[str] = rest_field(name="curveId")
    curve_type: Optional[
        Literal["GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN", "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI"]
    ] = rest_field(name="curveType")
    """Is one of the following types: Literal[\"GVT\"], Literal[\"GVT_TSYM\"],
     Literal[\"GVT_TSYM_MUNI\"], Literal[\"GVT_AGN\"], Literal[\"GVT_MUNI\"], Literal[\"GVT_BUND\"],
     Literal[\"SWAP\"], Literal[\"SWAP_RFR\"], Literal[\"SWAP_MUNI\"]"""
    currency: Optional[str] = rest_field()
    expand_curve: Optional[bool] = rest_field(name="expandCurve")
    pricing_date: Optional[datetime.date] = rest_field(name="pricingDate")
    show_spot_rate: Optional[bool] = rest_field(name="showSpotRate")
    show_forward_rate: Optional[bool] = rest_field(name="showForwardRate")
    show_discount_factor: Optional[bool] = rest_field(name="showDiscountFactor")
    forward_period: Optional[float] = rest_field(name="forwardPeriod")
    implied_forward_delay: Optional[float] = rest_field(name="impliedForwardDelay")
    index: Optional[str] = rest_field()
    use_live_curve: Optional[bool] = rest_field(name="useLiveCurve")

    @overload
    def __init__(
        self,
        *,
        curve_id: Optional[str] = None,
        curve_type: Optional[
            Literal[
                "GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN", "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI"
            ]
        ] = None,
        currency: Optional[str] = None,
        expand_curve: Optional[bool] = None,
        pricing_date: Optional[datetime.date] = None,
        show_spot_rate: Optional[bool] = None,
        show_forward_rate: Optional[bool] = None,
        show_discount_factor: Optional[bool] = None,
        forward_period: Optional[float] = None,
        implied_forward_delay: Optional[float] = None,
        index: Optional[str] = None,
        use_live_curve: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CurveTypeAndCurrency(_model_base.Model):
    """CurveTypeAndCurrency.

    Attributes
    ----------
    curve_type : str
        Is one of the following types: Literal["GVT"], Literal["GVT_TSYM"],
        Literal["GVT_TSYM_MUNI"], Literal["GVT_AGN"], Literal["GVT_MUNI"],
        Literal["GVT_BUND"], Literal["SWAP"], Literal["SWAP_RFR"],
        Literal["SWAP_MUNI"]
    currency : str
        Currency of the curveType.
    retrieve_curve : bool
        Return curve rates as part of the response.
    user_defined : ~analyticsapi.models.JsonRef
        Optional. Reference to user defined curve. This can either be request
        id or name associated with the user defined object.
    snapshot : str
        Is either a Literal["4PM"] type or a Literal["EOD"] type.
    """

    curve_type: Optional[
        Literal["GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN", "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI"]
    ] = rest_field(name="curveType")
    """Is one of the following types: Literal[\"GVT\"], Literal[\"GVT_TSYM\"],
     Literal[\"GVT_TSYM_MUNI\"], Literal[\"GVT_AGN\"], Literal[\"GVT_MUNI\"], Literal[\"GVT_BUND\"],
     Literal[\"SWAP\"], Literal[\"SWAP_RFR\"], Literal[\"SWAP_MUNI\"]"""
    currency: Optional[str] = rest_field()
    """Currency of the curveType."""
    retrieve_curve: Optional[bool] = rest_field(name="retrieveCurve")
    """Return curve rates as part of the response."""
    user_defined: Optional["_models.JsonRef"] = rest_field(name="userDefined")
    """Optional. Reference to user defined curve. This can either be request id or name associated
     with the user defined object."""
    snapshot: Optional[Literal["4PM", "EOD"]] = rest_field()
    """Is either a Literal[\"4PM\"] type or a Literal[\"EOD\"] type."""

    @overload
    def __init__(
        self,
        *,
        curve_type: Optional[
            Literal[
                "GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN", "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI"
            ]
        ] = None,
        currency: Optional[str] = None,
        retrieve_curve: Optional[bool] = None,
        user_defined: Optional["_models.JsonRef"] = None,
        snapshot: Optional[Literal["4PM", "EOD"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class CustomScenario(_model_base.Model):
    """CustomScenario.

    Attributes
    ----------
    assume_call : bool
        Applicable for CMBS with a clean up call. If true, remaining balance is
        called once clean up call threshold is reached.
    delay : bool
        If true, prepay and default rates are delayed until the first payment
        the bondholder is entitled to receive. If false, rates apply at the
        first payment, regardless if the bondholder is entitled to receive it.
        Greatly impacts IOs.
    delay_balloon_maturity : bool
        If true, deals where the scheduled balloon payment occurs in the month
        prior to the settlement date, users can delay the maturity by one month
        to prevent pricing errors.
    defeasance : str
        Set collateral defeasance assumption. Is one of the following types:
        Literal["AUTO"], Literal["OPEN"], Literal["MATURITY"]
    prepayment : ~analyticsapi.models.CmbsPrepayment
    defaults : ~analyticsapi.models.Balloon
    balloon_extend : ~analyticsapi.models.Balloon
    balloon_default : ~analyticsapi.models.Balloon
    """

    assume_call: Optional[bool] = rest_field(name="assumeCall")
    """Applicable for CMBS with a clean up call. If true, remaining balance is called once clean up
     call threshold is reached."""
    delay: Optional[bool] = rest_field()
    """If true, prepay and default rates are delayed until the first payment the bondholder is
     entitled to receive. If false, rates apply at the first payment, regardless if the bondholder
     is entitled to receive it. Greatly impacts IOs."""
    delay_balloon_maturity: Optional[bool] = rest_field(name="delayBalloonMaturity")
    """If true, deals where the scheduled balloon payment occurs in the month prior to the settlement
     date, users can delay the maturity by one month to prevent pricing errors."""
    defeasance: Optional[Literal["AUTO", "OPEN", "MATURITY"]] = rest_field()
    """Set collateral defeasance assumption. Is one of the following types: Literal[\"AUTO\"],
     Literal[\"OPEN\"], Literal[\"MATURITY\"]"""
    prepayment: Optional["_models.CmbsPrepayment"] = rest_field()
    defaults: Optional["_models.Balloon"] = rest_field()
    balloon_extend: Optional["_models.Balloon"] = rest_field(name="balloonExtend")
    balloon_default: Optional["_models.Balloon"] = rest_field(name="balloonDefault")

    @overload
    def __init__(
        self,
        *,
        assume_call: Optional[bool] = None,
        delay: Optional[bool] = None,
        delay_balloon_maturity: Optional[bool] = None,
        defeasance: Optional[Literal["AUTO", "OPEN", "MATURITY"]] = None,
        prepayment: Optional["_models.CmbsPrepayment"] = None,
        defaults: Optional["_models.Balloon"] = None,
        balloon_extend: Optional["_models.Balloon"] = None,
        balloon_default: Optional["_models.Balloon"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataTable(_model_base.Model):
    """DataTable.

    Attributes
    ----------
    column_details : list[~analyticsapi.models.DataTableColumnDetail]
        The default value is None, needs to be assigned before using.
    data : list[dict[str, any]]
        The default value is None, needs to be assigned before using.
    """

    column_details: Optional[List["_models.DataTableColumnDetail"]] = rest_field(name="columnDetails")
    data: Optional[List[Dict[str, Any]]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        column_details: Optional[List["_models.DataTableColumnDetail"]] = None,
        data: Optional[List[Dict[str, Any]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DataTableColumnDetail(_model_base.Model):
    """DataTableColumnDetail.

    Attributes
    ----------
    header : str
    field : str
    format : str
    """

    header: Optional[str] = rest_field()
    field: Optional[str] = rest_field()
    format: Optional[str] = rest_field()

    @overload
    def __init__(
        self,
        *,
        header: Optional[str] = None,
        field: Optional[str] = None,
        format: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DatedRate(_model_base.Model):
    """An object that defines the effective date for the associated rate.

    Attributes
    ----------
    date : ~datetime.date
        The effective date of the associated rate. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    rate : ~analyticsapi.models.Rate
        An object that defines the rate value that becomes effective on the
        associated date. Required.
    """

    date: Optional[datetime.date] = rest_field()
    """The effective date of the associated rate. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01')."""
    rate: "_models.Rate" = rest_field()
    """An object that defines the rate value that becomes effective on the associated date. Required."""

    @overload
    def __init__(
        self,
        *,
        rate: "_models.Rate",
        date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DatedValue(_model_base.Model):
    """An object that defines a date-value pair.

    Attributes
    ----------
    date : ~datetime.date
        The effective date of the associated value. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., 2021-01-01). Required.
    value : float
        The value that becomes effective on the associated date. Required.
    """

    date: datetime.date = rest_field()
    """The effective date of the associated value. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., 2021-01-01). Required."""
    value: float = rest_field()
    """The value that becomes effective on the associated date. Required."""

    @overload
    def __init__(
        self,
        *,
        date: datetime.date,
        value: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DayWeight(_model_base.Model):
    """DayWeight.

    Attributes
    ----------
    date : ~datetime.datetime
    weight : float
    """

    date: Optional[datetime.datetime] = rest_field(format="rfc3339")
    weight: Optional[float] = rest_field()

    @overload
    def __init__(
        self,
        *,
        date: Optional[datetime.datetime] = None,
        weight: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DefaultBondQuote(_model_base.Model):
    """DefaultBondQuote.

    Attributes
    ----------
    quotation_mode : str or ~analyticsapi.models.QuotationModeEnum
        Known values are: "Unknown", "CashCleanPrice", "CashGrossPrice",
        "PercentCleanPrice", "PercentGrossPrice", "Yield", "MoneyMarketYield",
        "Discount", "Spread", "SimpleMargin", and "DiscountMargin".
    quotation_value : float
    """

    quotation_mode: Optional[Union[str, "_models.QuotationModeEnum"]] = rest_field(name="quotationMode")
    """Known values are: \"Unknown\", \"CashCleanPrice\", \"CashGrossPrice\", \"PercentCleanPrice\",
     \"PercentGrossPrice\", \"Yield\", \"MoneyMarketYield\", \"Discount\", \"Spread\",
     \"SimpleMargin\", and \"DiscountMargin\"."""
    quotation_value: Optional[float] = rest_field(name="quotationValue")

    @overload
    def __init__(
        self,
        *,
        quotation_mode: Optional[Union[str, "_models.QuotationModeEnum"]] = None,
        quotation_value: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DefaultDials(_model_base.Model):
    """DefaultDials.

    Attributes
    ----------
    prepayment_decay : ~decimal.Decimal
    credit_score_base : ~decimal.Decimal
    credit_score_slope : ~decimal.Decimal
    loan_to_value_base : ~decimal.Decimal
    loan_to_value_slope : ~decimal.Decimal
    loan_size_base : ~decimal.Decimal
    loan_size_slope : ~decimal.Decimal
    arm_spike_height : ~decimal.Decimal
    arm_spike_length : ~decimal.Decimal
    io_spike_height : ~decimal.Decimal
    io_spike_length : ~decimal.Decimal
    io_spike_elbow : ~decimal.Decimal
    turnover_multiplier : ~analyticsapi.models.ScalarAndVectorWithCollateral
    refi_multiplier : ~analyticsapi.models.ScalarAndVectorWithCollateral
    refi_elbow_shift : ~analyticsapi.models.ScalarAndVectorWithCollateral
    default_multiplier : ~analyticsapi.models.ScalarAndVectorWithCollateral
    curtailment_multiplier : ~analyticsapi.models.ScalarAndVectorWithCollateral
    sato_elbow_shift_multiplier : ~analyticsapi.models.ScalarAndVectorWithCollateral
    turnover_seasoning : ~analyticsapi.models.ScalarAndVector
    turnover_lockin : ~analyticsapi.models.ScalarAndVector
    refi_curve_steepness : ~analyticsapi.models.ScalarAndVector
    refi_burnout : ~analyticsapi.models.ScalarAndVector
    refi_seasoning : ~analyticsapi.models.ScalarAndVector
    refi_media_effect : ~analyticsapi.models.ScalarAndVector
    cashouts : ~analyticsapi.models.ScalarAndVector
    agency_eligibility : ~analyticsapi.models.ScalarAndVector
    ps_spread_shift : ~analyticsapi.models.ScalarAndVector
    ps_spread_steepness : ~analyticsapi.models.ScalarAndVector
    ps_spread_rate : ~analyticsapi.models.ScalarAndVector
    ps_spread_floor : ~analyticsapi.models.ScalarAndVector
    refi_capacity_constraint : ~analyticsapi.models.ScalarAndVector
    refi_fha_to_conventional : ~analyticsapi.models.ScalarAndVector
    upfront_mortgage_insurance_premium : ~analyticsapi.models.ScalarAndVector
    annual_mortgage_insurance_premium : ~analyticsapi.models.ScalarAndVector
    broker_costs : ~analyticsapi.models.ScalarAndVector
    broker_response : ~analyticsapi.models.ScalarAndVector
    broker_intensity : ~analyticsapi.models.ScalarAndVector
    broker_refi_ramp : ~analyticsapi.models.ScalarAndVector
    correspondent_costs : ~analyticsapi.models.ScalarAndVector
    correspondent_response : ~analyticsapi.models.ScalarAndVector
    correspondent_intensity : ~analyticsapi.models.ScalarAndVector
    correspondent_refi_ramp : ~analyticsapi.models.ScalarAndVector
    retail_costs : ~analyticsapi.models.ScalarAndVector
    retail_response : ~analyticsapi.models.ScalarAndVector
    retail_intensity : ~analyticsapi.models.ScalarAndVector
    retail_refi_ramp : ~analyticsapi.models.ScalarAndVector
    online_refi_multiplier : ~analyticsapi.models.ScalarAndVector
    prepay_vector_shift : ~analyticsapi.models.ScalarAndVector
    cash_window_s_curve_multiplier : ~analyticsapi.models.ScalarAndVector
    cash_window_s_curve_slope : ~analyticsapi.models.ScalarAndVector
    cash_window_s_curve_elbow_shift : ~analyticsapi.models.ScalarAndVector
    sato_elbow_shift_age_decay_multiplier : ~analyticsapi.models.ScalarAndVector
    property_inspection_waiver_multiplier : ~analyticsapi.models.ScalarAndVector
    """

    prepayment_decay: Optional[decimal.Decimal] = rest_field(name="prepaymentDecay")
    credit_score_base: Optional[decimal.Decimal] = rest_field(name="creditScoreBase")
    credit_score_slope: Optional[decimal.Decimal] = rest_field(name="creditScoreSlope")
    loan_to_value_base: Optional[decimal.Decimal] = rest_field(name="loanToValueBase")
    loan_to_value_slope: Optional[decimal.Decimal] = rest_field(name="loanToValueSlope")
    loan_size_base: Optional[decimal.Decimal] = rest_field(name="loanSizeBase")
    loan_size_slope: Optional[decimal.Decimal] = rest_field(name="loanSizeSlope")
    arm_spike_height: Optional[decimal.Decimal] = rest_field(name="armSpikeHeight")
    arm_spike_length: Optional[decimal.Decimal] = rest_field(name="armSpikeLength")
    io_spike_height: Optional[decimal.Decimal] = rest_field(name="ioSpikeHeight")
    io_spike_length: Optional[decimal.Decimal] = rest_field(name="ioSpikeLength")
    io_spike_elbow: Optional[decimal.Decimal] = rest_field(name="ioSpikeElbow")
    turnover_multiplier: Optional["_models.ScalarAndVectorWithCollateral"] = rest_field(name="turnoverMultiplier")
    refi_multiplier: Optional["_models.ScalarAndVectorWithCollateral"] = rest_field(name="refiMultiplier")
    refi_elbow_shift: Optional["_models.ScalarAndVectorWithCollateral"] = rest_field(name="refiElbowShift")
    default_multiplier: Optional["_models.ScalarAndVectorWithCollateral"] = rest_field(name="defaultMultiplier")
    curtailment_multiplier: Optional["_models.ScalarAndVectorWithCollateral"] = rest_field(name="curtailmentMultiplier")
    sato_elbow_shift_multiplier: Optional["_models.ScalarAndVectorWithCollateral"] = rest_field(
        name="satoElbowShiftMultiplier"
    )
    turnover_seasoning: Optional["_models.ScalarAndVector"] = rest_field(name="turnoverSeasoning")
    turnover_lockin: Optional["_models.ScalarAndVector"] = rest_field(name="turnoverLockin")
    refi_curve_steepness: Optional["_models.ScalarAndVector"] = rest_field(name="refiCurveSteepness")
    refi_burnout: Optional["_models.ScalarAndVector"] = rest_field(name="refiBurnout")
    refi_seasoning: Optional["_models.ScalarAndVector"] = rest_field(name="refiSeasoning")
    refi_media_effect: Optional["_models.ScalarAndVector"] = rest_field(name="refiMediaEffect")
    cashouts: Optional["_models.ScalarAndVector"] = rest_field()
    agency_eligibility: Optional["_models.ScalarAndVector"] = rest_field(name="agencyEligibility")
    ps_spread_shift: Optional["_models.ScalarAndVector"] = rest_field(name="psSpreadShift")
    ps_spread_steepness: Optional["_models.ScalarAndVector"] = rest_field(name="psSpreadSteepness")
    ps_spread_rate: Optional["_models.ScalarAndVector"] = rest_field(name="psSpreadRate")
    ps_spread_floor: Optional["_models.ScalarAndVector"] = rest_field(name="psSpreadFloor")
    refi_capacity_constraint: Optional["_models.ScalarAndVector"] = rest_field(name="refiCapacityConstraint")
    refi_fha_to_conventional: Optional["_models.ScalarAndVector"] = rest_field(name="refiFHAToConventional")
    upfront_mortgage_insurance_premium: Optional["_models.ScalarAndVector"] = rest_field(
        name="upfrontMortgageInsurancePremium"
    )
    annual_mortgage_insurance_premium: Optional["_models.ScalarAndVector"] = rest_field(
        name="annualMortgageInsurancePremium"
    )
    broker_costs: Optional["_models.ScalarAndVector"] = rest_field(name="brokerCosts")
    broker_response: Optional["_models.ScalarAndVector"] = rest_field(name="brokerResponse")
    broker_intensity: Optional["_models.ScalarAndVector"] = rest_field(name="brokerIntensity")
    broker_refi_ramp: Optional["_models.ScalarAndVector"] = rest_field(name="brokerRefiRamp")
    correspondent_costs: Optional["_models.ScalarAndVector"] = rest_field(name="correspondentCosts")
    correspondent_response: Optional["_models.ScalarAndVector"] = rest_field(name="correspondentResponse")
    correspondent_intensity: Optional["_models.ScalarAndVector"] = rest_field(name="correspondentIntensity")
    correspondent_refi_ramp: Optional["_models.ScalarAndVector"] = rest_field(name="correspondentRefiRamp")
    retail_costs: Optional["_models.ScalarAndVector"] = rest_field(name="retailCosts")
    retail_response: Optional["_models.ScalarAndVector"] = rest_field(name="retailResponse")
    retail_intensity: Optional["_models.ScalarAndVector"] = rest_field(name="retailIntensity")
    retail_refi_ramp: Optional["_models.ScalarAndVector"] = rest_field(name="retailRefiRamp")
    online_refi_multiplier: Optional["_models.ScalarAndVector"] = rest_field(name="onlineRefiMultiplier")
    prepay_vector_shift: Optional["_models.ScalarAndVector"] = rest_field(name="prepayVectorShift")
    cash_window_s_curve_multiplier: Optional["_models.ScalarAndVector"] = rest_field(name="cashWindowSCurveMultiplier")
    cash_window_s_curve_slope: Optional["_models.ScalarAndVector"] = rest_field(name="cashWindowSCurveSlope")
    cash_window_s_curve_elbow_shift: Optional["_models.ScalarAndVector"] = rest_field(name="cashWindowSCurveElbowShift")
    sato_elbow_shift_age_decay_multiplier: Optional["_models.ScalarAndVector"] = rest_field(
        name="satoElbowShiftAgeDecayMultiplier"
    )
    property_inspection_waiver_multiplier: Optional["_models.ScalarAndVector"] = rest_field(
        name="propertyInspectionWaiverMultiplier"
    )

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        prepayment_decay: Optional[decimal.Decimal] = None,
        credit_score_base: Optional[decimal.Decimal] = None,
        credit_score_slope: Optional[decimal.Decimal] = None,
        loan_to_value_base: Optional[decimal.Decimal] = None,
        loan_to_value_slope: Optional[decimal.Decimal] = None,
        loan_size_base: Optional[decimal.Decimal] = None,
        loan_size_slope: Optional[decimal.Decimal] = None,
        arm_spike_height: Optional[decimal.Decimal] = None,
        arm_spike_length: Optional[decimal.Decimal] = None,
        io_spike_height: Optional[decimal.Decimal] = None,
        io_spike_length: Optional[decimal.Decimal] = None,
        io_spike_elbow: Optional[decimal.Decimal] = None,
        turnover_multiplier: Optional["_models.ScalarAndVectorWithCollateral"] = None,
        refi_multiplier: Optional["_models.ScalarAndVectorWithCollateral"] = None,
        refi_elbow_shift: Optional["_models.ScalarAndVectorWithCollateral"] = None,
        default_multiplier: Optional["_models.ScalarAndVectorWithCollateral"] = None,
        curtailment_multiplier: Optional["_models.ScalarAndVectorWithCollateral"] = None,
        sato_elbow_shift_multiplier: Optional["_models.ScalarAndVectorWithCollateral"] = None,
        turnover_seasoning: Optional["_models.ScalarAndVector"] = None,
        turnover_lockin: Optional["_models.ScalarAndVector"] = None,
        refi_curve_steepness: Optional["_models.ScalarAndVector"] = None,
        refi_burnout: Optional["_models.ScalarAndVector"] = None,
        refi_seasoning: Optional["_models.ScalarAndVector"] = None,
        refi_media_effect: Optional["_models.ScalarAndVector"] = None,
        cashouts: Optional["_models.ScalarAndVector"] = None,
        agency_eligibility: Optional["_models.ScalarAndVector"] = None,
        ps_spread_shift: Optional["_models.ScalarAndVector"] = None,
        ps_spread_steepness: Optional["_models.ScalarAndVector"] = None,
        ps_spread_rate: Optional["_models.ScalarAndVector"] = None,
        ps_spread_floor: Optional["_models.ScalarAndVector"] = None,
        refi_capacity_constraint: Optional["_models.ScalarAndVector"] = None,
        refi_fha_to_conventional: Optional["_models.ScalarAndVector"] = None,
        upfront_mortgage_insurance_premium: Optional["_models.ScalarAndVector"] = None,
        annual_mortgage_insurance_premium: Optional["_models.ScalarAndVector"] = None,
        broker_costs: Optional["_models.ScalarAndVector"] = None,
        broker_response: Optional["_models.ScalarAndVector"] = None,
        broker_intensity: Optional["_models.ScalarAndVector"] = None,
        broker_refi_ramp: Optional["_models.ScalarAndVector"] = None,
        correspondent_costs: Optional["_models.ScalarAndVector"] = None,
        correspondent_response: Optional["_models.ScalarAndVector"] = None,
        correspondent_intensity: Optional["_models.ScalarAndVector"] = None,
        correspondent_refi_ramp: Optional["_models.ScalarAndVector"] = None,
        retail_costs: Optional["_models.ScalarAndVector"] = None,
        retail_response: Optional["_models.ScalarAndVector"] = None,
        retail_intensity: Optional["_models.ScalarAndVector"] = None,
        retail_refi_ramp: Optional["_models.ScalarAndVector"] = None,
        online_refi_multiplier: Optional["_models.ScalarAndVector"] = None,
        prepay_vector_shift: Optional["_models.ScalarAndVector"] = None,
        cash_window_s_curve_multiplier: Optional["_models.ScalarAndVector"] = None,
        cash_window_s_curve_slope: Optional["_models.ScalarAndVector"] = None,
        cash_window_s_curve_elbow_shift: Optional["_models.ScalarAndVector"] = None,
        sato_elbow_shift_age_decay_multiplier: Optional["_models.ScalarAndVector"] = None,
        property_inspection_waiver_multiplier: Optional["_models.ScalarAndVector"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DepositConstituentDefinition(_model_base.Model):
    """The definition of a deposit instrument used as a constituent of an interest rate curve.

    Attributes
    ----------
    tenor : str
        The code indicating the tenor of the instrument used as a constituent
        (e.g., '1M', '1Y'). Required.
    template : str
        A pre-defined template can be used as an input by the user. It is the
        currency code of the constituent. Required.
    """

    tenor: str = rest_field()
    """The code indicating the tenor of the instrument used as a constituent (e.g., '1M', '1Y').
     Required."""
    template: str = rest_field()
    """A pre-defined template can be used as an input by the user. It is the currency code of the
     constituent. Required."""

    @overload
    def __init__(
        self,
        *,
        tenor: str,
        template: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SingleInterestRatePaymentDefinition(_model_base.Model):
    """An object that defines the single interest rate payment (e.g., on a term deposit).

    Attributes
    ----------
    notional : ~analyticsapi.models.Amount
        An object that defines the notional amount of the instrument. Required.
    rate : ~analyticsapi.models.InterestRateDefinition
        An object that defines the rate. Required.
    start_date : ~analyticsapi.models.Date
        An object that defines the start date of the interest payment period.
        Required.
    end_date : ~analyticsapi.models.Date
        An object that defines the end date of the interest payment period.
        Required.
    payment_offset : ~analyticsapi.models.OffsetDefinition
        An object that defines how the payment dates are derived from the
        interest period dates.
    settlement_type : str or ~analyticsapi.models.SettlementType
        An indicator that specifies how the payment is settled (e.g.,
        'Physical', 'Cash'). Known values are: "Cash" and "Physical".
    """

    notional: "_models.Amount" = rest_field()
    """An object that defines the notional amount of the instrument. Required."""
    rate: "_models.InterestRateDefinition" = rest_field()
    """An object that defines the rate. Required."""
    start_date: "_models.Date" = rest_field(name="startDate")
    """An object that defines the start date of the interest payment period. Required."""
    end_date: "_models.Date" = rest_field(name="endDate")
    """An object that defines the end date of the interest payment period. Required."""
    payment_offset: Optional["_models.OffsetDefinition"] = rest_field(name="paymentOffset")
    """An object that defines how the payment dates are derived from the interest period dates."""
    settlement_type: Optional[Union[str, "_models.SettlementType"]] = rest_field(name="settlementType")
    """An indicator that specifies how the payment is settled (e.g., 'Physical', 'Cash'). Known values
     are: \"Cash\" and \"Physical\"."""

    @overload
    def __init__(
        self,
        *,
        notional: "_models.Amount",
        rate: "_models.InterestRateDefinition",
        start_date: "_models.Date",
        end_date: "_models.Date",
        payment_offset: Optional["_models.OffsetDefinition"] = None,
        settlement_type: Optional[Union[str, "_models.SettlementType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DepositDefinition(SingleInterestRatePaymentDefinition):
    """DepositDefinition.

    Attributes
    ----------
    notional : ~analyticsapi.models.Amount
        An object that defines the notional amount of the instrument. Required.
    rate : ~analyticsapi.models.InterestRateDefinition
        An object that defines the rate. Required.
    start_date : ~analyticsapi.models.Date
        An object that defines the start date of the interest payment period.
        Required.
    end_date : ~analyticsapi.models.Date
        An object that defines the end date of the interest payment period.
        Required.
    payment_offset : ~analyticsapi.models.OffsetDefinition
        An object that defines how the payment dates are derived from the
        interest period dates.
    settlement_type : str or ~analyticsapi.models.SettlementType
        An indicator that specifies how the payment is settled (e.g.,
        'Physical', 'Cash'). Known values are: "Cash" and "Physical".
    """

    @overload
    def __init__(
        self,
        *,
        notional: "_models.Amount",
        rate: "_models.InterestRateDefinition",
        start_date: "_models.Date",
        end_date: "_models.Date",
        payment_offset: Optional["_models.OffsetDefinition"] = None,
        settlement_type: Optional[Union[str, "_models.SettlementType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DepositDefinitionTemplate(InstrumentTemplateDefinition, discriminator="Deposit"):
    """DepositDefinitionTemplate.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.DEPOSIT
        Required. An interest rate deposit contract.
    template : ~analyticsapi.models.DepositDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.DEPOSIT] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. An interest rate deposit contract."""
    template: "_models.DepositDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.DepositDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.DEPOSIT, **kwargs)


class DepositFxConstituent(FxConstituent, discriminator="Deposit"):
    """An object defining a deposit constituent of an fx forward curve.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.DEPOSIT
        The type of the instrument used as a constituent. Required.
    definition : ~analyticsapi.models.DepositConstituentDefinition
        An object to define the instrument used as a constituent.
    """

    type: Literal[FxConstituentEnum.DEPOSIT] = rest_discriminator(name="type")  # type: ignore
    """The type of the instrument used as a constituent. Required."""
    definition: Optional["_models.DepositConstituentDefinition"] = rest_field()
    """An object to define the instrument used as a constituent."""

    @overload
    def __init__(
        self,
        *,
        quote: Optional["_models.Quote"] = None,
        definition: Optional["_models.DepositConstituentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=FxConstituentEnum.DEPOSIT, **kwargs)


class DepositInstrumentOutput(_model_base.Model):
    """DepositInstrumentOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.InstrumentDefinition
    status_message : str
        Get statusMessage.
    """

    fields: Optional["_models.BidAskFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.InstrumentDefinition"] = rest_field(name="instrumentDefinition")
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.InstrumentDefinition"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DepositInstrumentsSource(_model_base.Model):
    """DepositInstrumentsSource.

    Attributes
    ----------
    is_implied : bool
    islamic_product_category : str or ~analyticsapi.models.IslamicProductCategoryEnum
        Islamic Product Category of the deposit. Known values are: "Mudarabah",
        "Murabaha", and "Wakala".
    market_data_location : str or ~analyticsapi.models.MarketDataLocationEnum
        Get marketDataLocation. Known values are: "Offshore" and "Onshore".
    source : str
        The instruments source.
    tenors : list[str]
        The non standard tenors list used to compute instruments from source.
        Possible values are: \\"Odd\\", \\"Long\\", \\"IMM\\", \\"BOM\\",
        \\"EOM\\", and tenor value e.g. \\"20Y\\"  By default instruments will
        be computed using following standard tenors : \\"ON\\",\\"TN\\",\\"SN\\
        ",\\"SW\\",\\"1M\\",\\"2M\\",\\"3M\\",\\"6M\\",\\"9M\\",\\"1Y\\",\\"2Y\
        \". The default value is None, needs to be assigned before using.
    """

    is_implied: Optional[bool] = rest_field(name="isImplied")
    islamic_product_category: Optional[Union[str, "_models.IslamicProductCategoryEnum"]] = rest_field(
        name="islamicProductCategory"
    )
    """Islamic Product Category of the deposit. Known values are: \"Mudarabah\", \"Murabaha\", and
     \"Wakala\"."""
    market_data_location: Optional[Union[str, "_models.MarketDataLocationEnum"]] = rest_field(name="marketDataLocation")
    """Get marketDataLocation. Known values are: \"Offshore\" and \"Onshore\"."""
    source: Optional[str] = rest_field()
    """The instruments source."""
    tenors: Optional[List[str]] = rest_field()
    """The non standard tenors list used to compute instruments from source. Possible values are:
     \\"Odd\\", \\"Long\\", \\"IMM\\", \\"BOM\\", \\"EOM\\", and tenor value e.g. \\"20Y\\"  By
     default instruments will be computed using following standard tenors :
     \\"ON\\",\\"TN\\",\\"SN\\",\\"SW\\",\\"1M\\",\\"2M\\",\\"3M\\",\\"6M\\",\\"9M\\",\\"1Y\\",\\"2Y\\"."""

    @overload
    def __init__(
        self,
        *,
        is_implied: Optional[bool] = None,
        islamic_product_category: Optional[Union[str, "_models.IslamicProductCategoryEnum"]] = None,
        market_data_location: Optional[Union[str, "_models.MarketDataLocationEnum"]] = None,
        source: Optional[str] = None,
        tenors: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrConstituent(ABC, _model_base.Model):
    """An object that defines the constituents used to construct a curve.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    DepositIrConstituent, FloatingRateIndexConstituent, ForwardRateAgreementConstituent,
    InterestRateSwapConstituent, OvernightIndexSwapConstituent, StirFutureConstituent,
    TenorBasisSwapConstituent

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.IrConstituentEnum
        The type of interest rate instrument used as a constituent to construct
        the curve. Required. Known values are: "FloatingRateIndex", "Deposit",
        "StirFuture", "ForwardRateAgreement", "InterestRateSwap",
        "OvernightIndexSwap", and "TenorBasisSwap".
    index : str
        This is the reference Index of the curve that the constituent
        contributes to. For instance (e.g. LIBOR 3M). Required.
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
        Required.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    type: str = rest_discriminator(name="type")
    """The type of interest rate instrument used as a constituent to construct the curve. Required.
     Known values are: \"FloatingRateIndex\", \"Deposit\", \"StirFuture\", \"ForwardRateAgreement\",
     \"InterestRateSwap\", \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    index: str = rest_field()
    """This is the reference Index of the curve that the constituent contributes to. For instance
     (e.g. LIBOR 3M). Required."""
    quote: "_models.Quote" = rest_field()
    """An object to define the quote of the instrument used as a constituent. Required."""
    status: Optional[List[str]] = rest_field(visibility=["read"])
    """A message is returned if the constituent cannot be identified, or access for a user to the
     instrument used as a constituent is denied."""

    @overload
    def __init__(
        self,
        *,
        type: str,
        index: str,
        quote: "_models.Quote",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DepositIrConstituent(IrConstituent, discriminator="Deposit"):
    """An object defining a deposit constituent of an interest rate curve.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    index : str
        This is the reference Index of the curve that the constituent
        contributes to. For instance (e.g. LIBOR 3M). Required.
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
        Required.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.DEPOSIT
        Required.
    definition : ~analyticsapi.models.DepositConstituentDefinition
        Required.
    """

    type: Literal[IrConstituentEnum.DEPOSIT] = rest_discriminator(name="type")  # type: ignore
    """Required."""
    definition: "_models.DepositConstituentDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        *,
        index: str,
        quote: "_models.Quote",
        definition: "_models.DepositConstituentDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=IrConstituentEnum.DEPOSIT, **kwargs)


class Description(_model_base.Model):
    """Description.

    Attributes
    ----------
    summary : str
        A summary of information about the resource. Limited to 500 characters.
    tags : list[str]
        User-defined tags to identify the resource. Limited to 5 items of up to
        50 characters each. To change the tags, reassign the new tag list, e.g.
        my_curve.description.tags = new_tags. Direct operation on the tag list
        using append, remove, etc., e.g.
        my_curve.description.tags.remove('tag_1'), will not change the actual
        tag list of the Description object.  The default value is None, needs
        to be assigned before using.
    """

    summary: Optional[str] = rest_field()
    """A summary of information about the resource. Limited to 500 characters."""
    tags: Optional[List[str]] = rest_field()
    """User-defined tags to identify the resource. Limited to 5 items of up to 50 characters each.
     To change the tags, reassign the new tag list, e.g. my_curve.description.tags = new_tags.
     Direct operation on the tag list using append, remove, etc., e.g.
     my_curve.description.tags.remove('tag_1'), will not change the actual tag list of the
     Description object."""

    @overload
    def __init__(
        self,
        *,
        summary: Optional[str] = None,
        tags: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DiscountCurveAssignment(_model_base.Model):
    """An object that describes a discount curve reference with its currency.

    Attributes
    ----------
    currency : str
        The currency code of the discount curve. Required.
    curve : str
        The reference to an interest rate curve stored in the platform.
        Required.
    """

    currency: str = rest_field()
    """The currency code of the discount curve. Required."""
    curve: str = rest_field()
    """The reference to an interest rate curve stored in the platform. Required."""

    @overload
    def __init__(
        self,
        *,
        currency: str,
        curve: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DiscountMarketDataAssignmentKey(_model_base.Model):
    """DiscountMarketDataAssignmentKey.

    Attributes
    ----------
    currency : str
    index_name : str
    instrument_tag : str
    instrument_type : str
    """

    currency: Optional[str] = rest_field()
    index_name: Optional[str] = rest_field(name="indexName")
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    instrument_type: Optional[str] = rest_field(name="instrumentType")

    @overload
    def __init__(
        self,
        *,
        currency: Optional[str] = None,
        index_name: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        instrument_type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DiscountMarketDataAssignmentKeyAssignmentItem(_model_base.Model):  # pylint: disable=name-too-long
    """DiscountMarketDataAssignmentKeyAssignmentItem.

    Attributes
    ----------
    assignment : ~analyticsapi.models.AssignmentKey
    where : ~analyticsapi.models.DiscountMarketDataAssignmentKey
    """

    assignment: Optional["_models.AssignmentKey"] = rest_field()
    where: Optional["_models.DiscountMarketDataAssignmentKey"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        assignment: Optional["_models.AssignmentKey"] = None,
        where: Optional["_models.DiscountMarketDataAssignmentKey"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Distribution(_model_base.Model):
    """Distribution.

    Attributes
    ----------
    state : dict[str, ~decimal.Decimal]
    servicer : dict[str, ~decimal.Decimal]
    """

    state: Optional[Dict[str, decimal.Decimal]] = rest_field()
    servicer: Optional[Dict[str, decimal.Decimal]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        state: Optional[Dict[str, decimal.Decimal]] = None,
        servicer: Optional[Dict[str, decimal.Decimal]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Dividend(_model_base.Model):
    """An object that describes the dividend parameters.

    Attributes
    ----------
    dividend_type : str or ~analyticsapi.models.DividendTypeEnum
        The type of the dividend. Known values are: "Default", "None",
        "Discrete", and "Yield".
    value : ~analyticsapi.models.Rate
        An object that describes the dividend value.
    """

    dividend_type: Optional[Union[str, "_models.DividendTypeEnum"]] = rest_field(name="dividendType")
    """The type of the dividend. Known values are: \"Default\", \"None\", \"Discrete\", and \"Yield\"."""
    value: Optional["_models.Rate"] = rest_field()
    """An object that describes the dividend value."""

    @overload
    def __init__(
        self,
        *,
        dividend_type: Optional[Union[str, "_models.DividendTypeEnum"]] = None,
        value: Optional["_models.Rate"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DividendCurve(Curve, discriminator="DividendCurve"):
    """The model defining the output of dividend curve calculation.

    Attributes
    ----------
    curve_type : str or ~analyticsapi.models.DIVIDEND_CURVE
        Required.
    points : list[~analyticsapi.models.DividendCurvePoint]
        The list of output points. Required.  The default value is None, needs
        to be assigned before using.
    """

    curve_type: Literal[CurveTypeEnum.DIVIDEND_CURVE] = rest_discriminator(name="curveType")  # type: ignore
    """Required."""
    points: List["_models.DividendCurvePoint"] = rest_field()
    """The list of output points. Required."""

    @overload
    def __init__(
        self,
        points: List["_models.DividendCurvePoint"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, curve_type=CurveTypeEnum.DIVIDEND_CURVE, **kwargs)


class DividendCurvePoint(_model_base.Model):
    """An object that contains the values applied to the dividend curve point.

    Attributes
    ----------
    ex_dividend_date : ~datetime.date
        The ex-dividend date. Required.
    payment_date : ~datetime.date
        The dividend payment date. Required.
    amount : ~analyticsapi.models.Amount
        The dividend amount. Required.
    yield_property : float
        The dividend expressed as percent. Required.
    """

    ex_dividend_date: datetime.date = rest_field(name="exDividendDate")
    """The ex-dividend date. Required."""
    payment_date: datetime.date = rest_field(name="paymentDate")
    """The dividend payment date. Required."""
    amount: "_models.Amount" = rest_field()
    """The dividend amount. Required."""
    yield_property: float = rest_field(name="yield")
    """The dividend expressed as percent. Required."""

    @overload
    def __init__(
        self,
        *,
        ex_dividend_date: datetime.date,
        payment_date: datetime.date,
        amount: "_models.Amount",
        yield_property: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DoubleBarrierOtcOptionOverride(_model_base.Model):
    """An object that contains the properties of a double barrier OTC option that can be overridden.

    Attributes
    ----------
    strike : float
        The set price at which the option holder can buy or sell the underlying
        asset. The value is expressed according to the market convention linked
        to the underlying asset.
    end_date : ~analyticsapi.models.Date
        An object that defines the maturity or expiry date of an option
        instrument.
    underlying_code : str
        The code (a RIC) used to define the underlying asset.
    option_type : str or ~analyticsapi.models.CallPutEnum
        An indicator of whether an option instrument is a call or a put. Known
        values are: "Call" and "Put".
    notional_amount : float
        The notional amount of an option instrument.
    barrier_up_level : float
        The price used as an up barrier level.
    barrier_down_level : float
        The price used as a down barrier level.
    barrier_up_rebate_amount : ~analyticsapi.models.Amount
        An object that specifies the rebate amount provided to investors when
        an up barrier option is not able to be exercised and becomes worthless.
    barrier_down_rebate_amount : ~analyticsapi.models.Amount
        An object that specifies the rebate amount provided to investors when a
        down barrier option is not able to be exercised and becomes worthless.
    """

    strike: Optional[float] = rest_field()
    """The set price at which the option holder can buy or sell the underlying asset. The value is
     expressed according to the market convention linked to the underlying asset."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """An object that defines the maturity or expiry date of an option instrument."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The code (a RIC) used to define the underlying asset."""
    option_type: Optional[Union[str, "_models.CallPutEnum"]] = rest_field(name="optionType")
    """An indicator of whether an option instrument is a call or a put. Known values are: \"Call\" and
     \"Put\"."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of an option instrument."""
    barrier_up_level: Optional[float] = rest_field(name="barrierUpLevel")
    """The price used as an up barrier level."""
    barrier_down_level: Optional[float] = rest_field(name="barrierDownLevel")
    """The price used as a down barrier level."""
    barrier_up_rebate_amount: Optional["_models.Amount"] = rest_field(name="barrierUpRebateAmount")
    """An object that specifies the rebate amount provided to investors when an up barrier option is
     not able to be exercised and becomes worthless."""
    barrier_down_rebate_amount: Optional["_models.Amount"] = rest_field(name="barrierDownRebateAmount")
    """An object that specifies the rebate amount provided to investors when a down barrier option is
     not able to be exercised and becomes worthless."""

    @overload
    def __init__(
        self,
        *,
        strike: Optional[float] = None,
        end_date: Optional["_models.Date"] = None,
        underlying_code: Optional[str] = None,
        option_type: Optional[Union[str, "_models.CallPutEnum"]] = None,
        notional_amount: Optional[float] = None,
        barrier_up_level: Optional[float] = None,
        barrier_down_level: Optional[float] = None,
        barrier_up_rebate_amount: Optional["_models.Amount"] = None,
        barrier_down_rebate_amount: Optional["_models.Amount"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DoubleBarrierOtcOptionTemplate(InstrumentTemplateDefinition, discriminator="DoubleBarrierOtcOption"):
    """DoubleBarrierOtcOptionTemplate.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.DOUBLE_BARRIER_OTC_OPTION
        Required. Double Barrier OTC Option contract.
    template : ~analyticsapi.models.OptionDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.DOUBLE_BARRIER_OTC_OPTION] = rest_discriminator(name="instrumentType")  # type: ignore
    """Required. Double Barrier OTC Option contract."""
    template: "_models.OptionDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.OptionDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.DOUBLE_BARRIER_OTC_OPTION, **kwargs)


class DoubleBinaryOtcOptionOverride(_model_base.Model):
    """An object that contains the properties of a double binary OTC option that can be overridden.

    Attributes
    ----------
    strike : float
        The set price at which the option holder can buy or sell the underlying
        asset. The value is expressed according to the market convention linked
        to the underlying asset.
    end_date : ~analyticsapi.models.Date
        An object that defines the maturity or expiry date of an option
        instrument.
    underlying_code : str
        The code (a RIC) used to define the underlying asset.
    option_type : str or ~analyticsapi.models.CallPutEnum
        An indicator of whether an option instrument is a call or a put. Known
        values are: "Call" and "Put".
    notional_amount : float
        The notional amount of an option instrument.
    binary_up_level : float
        The price used as an up binary level.
    binary_down_level : float
        The price used as a down binary level.
    payout_amount : ~analyticsapi.models.Amount
        The payout amount of a binary option.
    payment_type : str or ~analyticsapi.models.PaymentTypeEnum
        The type of a binary option based on when it is paid out. Known values
        are: "Immediate" and "Deferred".
    """

    strike: Optional[float] = rest_field()
    """The set price at which the option holder can buy or sell the underlying asset. The value is
     expressed according to the market convention linked to the underlying asset."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """An object that defines the maturity or expiry date of an option instrument."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The code (a RIC) used to define the underlying asset."""
    option_type: Optional[Union[str, "_models.CallPutEnum"]] = rest_field(name="optionType")
    """An indicator of whether an option instrument is a call or a put. Known values are: \"Call\" and
     \"Put\"."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of an option instrument."""
    binary_up_level: Optional[float] = rest_field(name="binaryUpLevel")
    """The price used as an up binary level."""
    binary_down_level: Optional[float] = rest_field(name="binaryDownLevel")
    """The price used as a down binary level."""
    payout_amount: Optional["_models.Amount"] = rest_field(name="payoutAmount")
    """The payout amount of a binary option."""
    payment_type: Optional[Union[str, "_models.PaymentTypeEnum"]] = rest_field(name="paymentType")
    """The type of a binary option based on when it is paid out. Known values are: \"Immediate\" and
     \"Deferred\"."""

    @overload
    def __init__(
        self,
        *,
        strike: Optional[float] = None,
        end_date: Optional["_models.Date"] = None,
        underlying_code: Optional[str] = None,
        option_type: Optional[Union[str, "_models.CallPutEnum"]] = None,
        notional_amount: Optional[float] = None,
        binary_up_level: Optional[float] = None,
        binary_down_level: Optional[float] = None,
        payout_amount: Optional["_models.Amount"] = None,
        payment_type: Optional[Union[str, "_models.PaymentTypeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class DoubleBinaryOtcOptionTemplate(InstrumentTemplateDefinition, discriminator="DoubleBinaryOtcOption"):
    """DoubleBinaryOtcOptionTemplate.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.DOUBLE_BINARY_OTC_OPTION
        Required. Double Binary OTC Option contract.
    template : ~analyticsapi.models.OptionDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.DOUBLE_BINARY_OTC_OPTION] = rest_discriminator(name="instrumentType")  # type: ignore
    """Required. Double Binary OTC Option contract."""
    template: "_models.OptionDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.OptionDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.DOUBLE_BINARY_OTC_OPTION, **kwargs)


class Duration(ABC, _model_base.Model):
    """An object to determine the duration of the holiday.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    FullDayDuration, HalfDayDuration

    Attributes
    ----------
    duration_type : str or ~analyticsapi.models.DurationType
        The type of the holiday duration. Possible values are: FullDayDuration
        or HalfDayDuration. Required. Known values are: "FullDayDuration" and
        "HalfDayDuration".
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    duration_type: str = rest_discriminator(name="durationType")
    """The type of the holiday duration. Possible values are: FullDayDuration or HalfDayDuration.
     Required. Known values are: \"FullDayDuration\" and \"HalfDayDuration\"."""

    @overload
    def __init__(
        self,
        duration_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["duration_type"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class EqOptionVolSurfaceChoice(_model_base.Model):
    """The object to provide either a reference to an equity volatility surface stored in the platform
    or 3rd party volatilities.

    Attributes
    ----------
    reference : str
        The reference to a volatility surface stored in the platform.
    surface : ~analyticsapi.models.EqVolSurfaceInput
        The volatility surface data.
    """

    reference: Optional[str] = rest_field()
    """The reference to a volatility surface stored in the platform."""
    surface: Optional["_models.EqVolSurfaceInput"] = rest_field()
    """The volatility surface data."""

    @overload
    def __init__(
        self,
        *,
        reference: Optional[str] = None,
        surface: Optional["_models.EqVolSurfaceInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EqVolSurfaceInput(_model_base.Model):
    """The object defining the 3rd party equity volatility surface.

    Attributes
    ----------
    strike_type : str or ~analyticsapi.models.StrikeTypeEnum
        The property that defines the type of the strikes provided in the
        surface points. Required. Known values are: "Absolute", "BasisPoint",
        "Delta", "Moneyness", "Percent", and "Relative".
    model_type : str or ~analyticsapi.models.VolModelTypeEnum
        The property that defines the type of the model (Normal or LogNormal)
        of the volatilities provided in the surface points. Required. Known
        values are: "Normal" and "LogNormal".
    points : list[~analyticsapi.models.VolSurfacePoint]
        The list of volatility points. Required.  The default value is None,
        needs to be assigned before using.
    entity_code : str
        The code of the reference entity. Required.
    """

    strike_type: Union[str, "_models.StrikeTypeEnum"] = rest_field(name="strikeType")
    """The property that defines the type of the strikes provided in the surface points. Required.
     Known values are: \"Absolute\", \"BasisPoint\", \"Delta\", \"Moneyness\", \"Percent\", and
     \"Relative\"."""
    model_type: Union[str, "_models.VolModelTypeEnum"] = rest_field(name="modelType")
    """The property that defines the type of the model (Normal or LogNormal) of the volatilities
     provided in the surface points. Required. Known values are: \"Normal\" and \"LogNormal\"."""
    points: List["_models.VolSurfacePoint"] = rest_field()
    """The list of volatility points. Required."""
    entity_code: str = rest_field(name="entityCode")
    """The code of the reference entity. Required."""

    @overload
    def __init__(
        self,
        *,
        strike_type: Union[str, "_models.StrikeTypeEnum"],
        model_type: Union[str, "_models.VolModelTypeEnum"],
        points: List["_models.VolSurfacePoint"],
        entity_code: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ErrorDetails(_model_base.Model):
    """ErrorDetails.

    Attributes
    ----------
    key : str
        The specification of the request in which an error occurs.
    reason : str
        The reason for returning the error message.
    """

    key: Optional[str] = rest_field()
    """The specification of the request in which an error occurs."""
    reason: Optional[str] = rest_field()
    """The reason for returning the error message."""

    @overload
    def __init__(
        self,
        *,
        key: Optional[str] = None,
        reason: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ErrorResponse(_model_base.Model):
    """ErrorResponse.

    Attributes
    ----------
    code : str
        The code of the error message.
    errors : list[~analyticsapi.models.ErrorDetails]
        The error information details in case of a blocking error in
        calculation.  The default value is None, needs to be assigned before
        using.
    id : str
        The identifier of the error message.
    message : str
        The error message in case of a blocking error in calculation.
    status : str
        The status of the error message.
    """

    code: Optional[str] = rest_field()
    """The code of the error message."""
    errors: Optional[List["_models.ErrorDetails"]] = rest_field()
    """The error information details in case of a blocking error in calculation."""
    id: Optional[str] = rest_field()
    """The identifier of the error message."""
    message: Optional[str] = rest_field()
    """The error message in case of a blocking error in calculation."""
    status: Optional[str] = rest_field()
    """The status of the error message."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        errors: Optional[List["_models.ErrorDetails"]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        message: Optional[str] = None,
        status: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EtiSurfaceDefinition(_model_base.Model):
    """The volatility surface definition for a listed instrument (e.g. equity, indices).

    Attributes
    ----------
    clean_instrument_code : str
    exchange : str
        Specifies the exchange to be used to retrieve the underlying data.
    instrument_code : str
        The code (RIC for equities and indices and RICROOT for Futures.) that
        represents the instrument. The format for equities and indices is
        xxx@RIC (Example: VOD.L@RIC) The format for Futures is xx@RICROOT
        (Example: CL@RICROOT).
    is_future_underlying : bool
    is_lme_future_underlying : bool
    """

    clean_instrument_code: Optional[str] = rest_field(name="cleanInstrumentCode")
    exchange: Optional[str] = rest_field()
    """Specifies the exchange to be used to retrieve the underlying data."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code (RIC for equities and indices and RICROOT for Futures.) that represents the
     instrument.
     The format for equities and indices is xxx@RIC (Example: VOD.L@RIC)
     The format for Futures is xx@RICROOT (Example: CL@RICROOT)."""
    is_future_underlying: Optional[bool] = rest_field(name="isFutureUnderlying")
    is_lme_future_underlying: Optional[bool] = rest_field(name="isLmeFutureUnderlying")

    @overload
    def __init__(
        self,
        *,
        clean_instrument_code: Optional[str] = None,
        exchange: Optional[str] = None,
        instrument_code: Optional[str] = None,
        is_future_underlying: Optional[bool] = None,
        is_lme_future_underlying: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EtiSurfaceParameters(_model_base.Model):
    """The parameters needed to define the volatility surface for a listed instrument (e.g. equity,
    indices).

    Attributes
    ----------
    calculation_date : ~datetime.datetime
        The date the volatility surface is generated.
    filters : ~analyticsapi.models.SurfaceFilters
    input_volatility_type : str or ~analyticsapi.models.InputVolatilityTypeEnum
        Specifies the type of volatility used as an input of the model
        (calculated Implied Volatility, Settlement)

        * Settle: [DEPRECATED] The service uses the settlement volatility to build the volatility
        surface
        * Quoted: The service uses the quoted volatility to build the volatility surface
        * Implied: The service internally calculates implied volatilities for the option universe
        before building the surface

        Default value is "Implied". Known values are: "Implied", "LogNormalVolatility",
        "NormalVolatility", "Quoted", and "Settle".
    moneyness_type : str or ~analyticsapi.models.MoneynessTypeEnum
        The enumerate that specifies the moneyness type to use for calibration.

        * Spot
        * Fwd
        * Sigma

        Optional. Default value is "Spot". Known values are: "Fwd", "Sigma", and "Spot".
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        Specifies whether bid, ask or mid is used to build the surface. Known
        values are: "Ask", "Bid", "Last", and "Mid".
    smile_by_smile_arbitrage_check : bool
        Smile by Smile Arbitrage Check for building the surface Default value :
        TRUE.
    svi_alpha_extrapolation : bool
        Svi Alpha Extrapolation for building the surface Default value : TRUE.
    time_stamp : str or ~analyticsapi.models.CurvesAndSurfacesTimeStampEnum
        Define how the timestamp is selected:

        * Open: the opening value of the valuationDate or if not available the close of the previous
        day is used.
        * Default: the latest snapshot is used when valuationDate is today, the close price when
        valuationDate is in the past. Known values are: "Close", "Default", "Open", and "Settle".
    volatility_model : str or ~analyticsapi.models.CurvesAndSurfacesVolatilityModelEnum
        The quantitative model used to generate the volatility surface. This
        may depend on the asset class. Known values are: "CubicSpline", "SABR",
        "SSVI", "SVI", and "TwinLognormal".
    weights : list[~analyticsapi.models.MoneynessWeight]
        Specifies the list of calibration weight.  The default value is None,
        needs to be assigned before using.
    x_axis : str or ~analyticsapi.models.XAxisEnum
        Specifies the unit for the x axis (e.g. Date, Tenor). Known values are:
        "Date", "Delta", "Expiry", "Moneyness", "Strike", and "Tenor".
    y_axis : str or ~analyticsapi.models.YAxisEnum
        Specifies the unit for the y axis (e.g. Strike, Delta). This may depend
        on the asset class. For Fx Volatility Surface, we support both Delta
        and Strike. Known values are: "Date", "Delta", "Expiry", "Moneyness",
        "Strike", and "Tenor".
    """

    calculation_date: Optional[datetime.datetime] = rest_field(name="calculationDate", format="rfc3339")
    """The date the volatility surface is generated."""
    filters: Optional["_models.SurfaceFilters"] = rest_field()
    input_volatility_type: Optional[Union[str, "_models.InputVolatilityTypeEnum"]] = rest_field(
        name="inputVolatilityType"
    )
    """Specifies the type of volatility used as an input of the model (calculated Implied Volatility,
     Settlement)
     
     
     * Settle: [DEPRECATED] The service uses the settlement volatility to build the volatility
     surface
     * Quoted: The service uses the quoted volatility to build the volatility surface
     * Implied: The service internally calculates implied volatilities for the option universe
     before building the surface
     
     Default value is \"Implied\". Known values are: \"Implied\", \"LogNormalVolatility\",
     \"NormalVolatility\", \"Quoted\", and \"Settle\"."""
    moneyness_type: Optional[Union[str, "_models.MoneynessTypeEnum"]] = rest_field(name="moneynessType")
    """The enumerate that specifies the moneyness type to use for calibration.
     
     
     * Spot
     * Fwd
     * Sigma
     
     Optional. Default value is \"Spot\". Known values are: \"Fwd\", \"Sigma\", and \"Spot\"."""
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """Specifies whether bid, ask or mid is used to build the surface. Known values are: \"Ask\",
     \"Bid\", \"Last\", and \"Mid\"."""
    smile_by_smile_arbitrage_check: Optional[bool] = rest_field(name="smileBySmileArbitrageCheck")
    """Smile by Smile Arbitrage Check for building the surface
     Default value : TRUE."""
    svi_alpha_extrapolation: Optional[bool] = rest_field(name="sviAlphaExtrapolation")
    """Svi Alpha Extrapolation for building the surface
     Default value : TRUE."""
    time_stamp: Optional[Union[str, "_models.CurvesAndSurfacesTimeStampEnum"]] = rest_field(name="timeStamp")
    """Define how the timestamp is selected:
     
     
     * Open: the opening value of the valuationDate or if not available the close of the previous
     day is used.
     * Default: the latest snapshot is used when valuationDate is today, the close price when
     valuationDate is in the past. Known values are: \"Close\", \"Default\", \"Open\", and
     \"Settle\"."""
    volatility_model: Optional[Union[str, "_models.CurvesAndSurfacesVolatilityModelEnum"]] = rest_field(
        name="volatilityModel"
    )
    """The quantitative model used to generate the volatility surface. This may depend on the asset
     class. Known values are: \"CubicSpline\", \"SABR\", \"SSVI\", \"SVI\", and \"TwinLognormal\"."""
    weights: Optional[List["_models.MoneynessWeight"]] = rest_field()
    """Specifies the list of calibration weight."""
    x_axis: Optional[Union[str, "_models.XAxisEnum"]] = rest_field(name="xAxis")
    """Specifies the unit for the x axis (e.g. Date, Tenor). Known values are: \"Date\", \"Delta\",
     \"Expiry\", \"Moneyness\", \"Strike\", and \"Tenor\"."""
    y_axis: Optional[Union[str, "_models.YAxisEnum"]] = rest_field(name="yAxis")
    """Specifies the unit for the y axis (e.g. Strike, Delta). This may depend on the asset class.
     For Fx Volatility Surface, we support both Delta and Strike. Known values are: \"Date\",
     \"Delta\", \"Expiry\", \"Moneyness\", \"Strike\", and \"Tenor\"."""

    @overload
    def __init__(
        self,
        *,
        calculation_date: Optional[datetime.datetime] = None,
        filters: Optional["_models.SurfaceFilters"] = None,
        input_volatility_type: Optional[Union[str, "_models.InputVolatilityTypeEnum"]] = None,
        moneyness_type: Optional[Union[str, "_models.MoneynessTypeEnum"]] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        smile_by_smile_arbitrage_check: Optional[bool] = None,
        svi_alpha_extrapolation: Optional[bool] = None,
        time_stamp: Optional[Union[str, "_models.CurvesAndSurfacesTimeStampEnum"]] = None,
        volatility_model: Optional[Union[str, "_models.CurvesAndSurfacesVolatilityModelEnum"]] = None,
        weights: Optional[List["_models.MoneynessWeight"]] = None,
        x_axis: Optional[Union[str, "_models.XAxisEnum"]] = None,
        y_axis: Optional[Union[str, "_models.YAxisEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class EtiVolatilitySurfaceRequestItem(_model_base.Model):
    """EtiVolatilitySurfaceRequestItem.

    Attributes
    ----------
    surface_layout : ~analyticsapi.models.SurfaceOutput
    surface_parameters : ~analyticsapi.models.EtiSurfaceParameters
    surface_tag : str
    underlying_definition : ~analyticsapi.models.EtiSurfaceDefinition
    underlying_type : str or ~analyticsapi.models.CurvesAndSurfacesUnderlyingTypeEnum
        The type of the underlying used to generate the volatility surface.
        Known values are: "Cap", "Eti", "Fx", and "Swaption".
    """

    surface_layout: Optional["_models.SurfaceOutput"] = rest_field(name="surfaceLayout")
    surface_parameters: Optional["_models.EtiSurfaceParameters"] = rest_field(name="surfaceParameters")
    surface_tag: Optional[str] = rest_field(name="surfaceTag")
    underlying_definition: Optional["_models.EtiSurfaceDefinition"] = rest_field(name="underlyingDefinition")
    underlying_type: Optional[Union[str, "_models.CurvesAndSurfacesUnderlyingTypeEnum"]] = rest_field(
        name="underlyingType"
    )
    """The type of the underlying used to generate the volatility surface. Known values are: \"Cap\",
     \"Eti\", \"Fx\", and \"Swaption\"."""

    @overload
    def __init__(
        self,
        *,
        surface_layout: Optional["_models.SurfaceOutput"] = None,
        surface_parameters: Optional["_models.EtiSurfaceParameters"] = None,
        surface_tag: Optional[str] = None,
        underlying_definition: Optional["_models.EtiSurfaceDefinition"] = None,
        underlying_type: Optional[Union[str, "_models.CurvesAndSurfacesUnderlyingTypeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExerciseDefinition(_model_base.Model):
    """An object that defines the exercise settings of an option instrument.

    Attributes
    ----------
    strike : float
        The set price at which the option holder can buy or sell the underlying
        asset. The value is expressed according to the market convention linked
        to the underlying asset. Required for all OTC options except binary
        options. The value must be in percentage for forward start option. Do
        not specify strike as an input for a binary option or when solving for
        a strike value.
    schedule : ~analyticsapi.models.ScheduleDefinition
        An object that defines the exercise schedule of an option instrument.
    exercise_style : str or ~analyticsapi.models.ExerciseStyleEnum
        The style of an option instrument based on its exercise restrictions.
        Note that all exercise styles may not apply to certain types of option
        instruments. Known values are: "European", "American", and "Bermudan".
    """

    strike: Optional[float] = rest_field()
    """The set price at which the option holder can buy or sell the underlying asset. The value is
     expressed according to the market convention linked to the underlying asset.
     Required for all OTC options except binary options.
     The value must be in percentage for forward start option.
     Do not specify strike as an input for a binary option or when solving for a strike value."""
    schedule: Optional["_models.ScheduleDefinition"] = rest_field()
    """An object that defines the exercise schedule of an option instrument."""
    exercise_style: Optional[Union[str, "_models.ExerciseStyleEnum"]] = rest_field(name="exerciseStyle")
    """The style of an option instrument based on its exercise restrictions. Note that all exercise
     styles may not apply to certain types of option instruments. Known values are: \"European\",
     \"American\", and \"Bermudan\"."""

    @overload
    def __init__(
        self,
        *,
        strike: Optional[float] = None,
        schedule: Optional["_models.ScheduleDefinition"] = None,
        exercise_style: Optional[Union[str, "_models.ExerciseStyleEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ExtraSettings(_model_base.Model):
    """ExtraSettings.

    Attributes
    ----------
    include_partials : bool
        Optional additional pricing settings.
    option_model : str or ~analyticsapi.models.OptionModel
        OASEDUR is recommended, returns OAS and option adjusted measures. OAS
        returns CMO OAS only. Known values are: "OAS", "OASEDUR", and
        "YCMARGIN".
    use_oas_to_call : bool
        Calculate CMO OAS to the call date, not maturity date.
    partial_vega : bool
        Calculate partial vegas.
    other_durations : bool
        Calculate the following specialized durations - GNMA/FNMA spread
        duration, prepay duration, primary secondary spread duration, refi
        elbow duration, refi prepay duration, turnover prepay duration, and
        volatility duration.
    volatility_duration : bool
        Calculate volatility duration.
    prepay_duration : bool
        Calculate prepay duration.
    refi_elbow_duration : bool
        Calculate refi elbow duration.
    current_coupon_spread_sensitivity : bool
        Calculate current coupon spread duration.
    refi_prepay_duration : bool
        Calculate prepay duration.
    turnover_prepay_duration : bool
        Calculate turnover prepay duration.
    primary_secondary_spread_duration : bool
        Calculate primary secondary spread duration.
    index_spread_duration : bool
        Calculate index spread duration.
    partials : ~analyticsapi.models.Partials
        Optional, and only to be used if includePartials = true.
    """

    include_partials: Optional[bool] = rest_field(name="includePartials")
    """Optional additional pricing settings."""
    option_model: Optional[Union[str, "_models.OptionModel"]] = rest_field(name="optionModel")
    """OASEDUR is recommended, returns OAS and option adjusted measures. OAS returns CMO OAS only.
     Known values are: \"OAS\", \"OASEDUR\", and \"YCMARGIN\"."""
    use_oas_to_call: Optional[bool] = rest_field(name="useOASToCall")
    """Calculate CMO OAS to the call date, not maturity date."""
    partial_vega: Optional[bool] = rest_field(name="partialVega")
    """Calculate partial vegas."""
    other_durations: Optional[bool] = rest_field(name="otherDurations")
    """Calculate the following specialized durations - GNMA/FNMA spread duration, prepay duration,
     primary secondary spread duration, refi elbow duration, refi prepay duration, turnover prepay
     duration, and volatility duration."""
    volatility_duration: Optional[bool] = rest_field(name="volatilityDuration")
    """Calculate volatility duration."""
    prepay_duration: Optional[bool] = rest_field(name="prepayDuration")
    """Calculate prepay duration."""
    refi_elbow_duration: Optional[bool] = rest_field(name="refiElbowDuration")
    """Calculate refi elbow duration."""
    current_coupon_spread_sensitivity: Optional[bool] = rest_field(name="currentCouponSpreadSensitivity")
    """Calculate current coupon spread duration."""
    refi_prepay_duration: Optional[bool] = rest_field(name="refiPrepayDuration")
    """Calculate prepay duration."""
    turnover_prepay_duration: Optional[bool] = rest_field(name="turnoverPrepayDuration")
    """Calculate turnover prepay duration."""
    primary_secondary_spread_duration: Optional[bool] = rest_field(name="primarySecondarySpreadDuration")
    """Calculate primary secondary spread duration."""
    index_spread_duration: Optional[bool] = rest_field(name="indexSpreadDuration")
    """Calculate index spread duration."""
    partials: Optional["_models.Partials"] = rest_field()
    """Optional, and only to be used if includePartials = true."""

    @overload
    def __init__(
        self,
        *,
        include_partials: Optional[bool] = None,
        option_model: Optional[Union[str, "_models.OptionModel"]] = None,
        use_oas_to_call: Optional[bool] = None,
        partial_vega: Optional[bool] = None,
        other_durations: Optional[bool] = None,
        volatility_duration: Optional[bool] = None,
        prepay_duration: Optional[bool] = None,
        refi_elbow_duration: Optional[bool] = None,
        current_coupon_spread_sensitivity: Optional[bool] = None,
        refi_prepay_duration: Optional[bool] = None,
        turnover_prepay_duration: Optional[bool] = None,
        primary_secondary_spread_duration: Optional[bool] = None,
        index_spread_duration: Optional[bool] = None,
        partials: Optional["_models.Partials"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldDateOutput(_model_base.Model):
    """FieldDateOutput.

    Attributes
    ----------
    is_delayed : bool
    is_overridden : bool
    market_value : ~datetime.date
        The market value of date side of the instrument. It is returned in the
        response only if value is overridden in the request.
    value : ~datetime.date
        The date price side value of the instrument. If not overridden in the
        request, it returns the market value of the instrument.
    """

    is_delayed: Optional[bool] = rest_field(name="isDelayed")
    is_overridden: Optional[bool] = rest_field(name="isOverridden")
    market_value: Optional[datetime.date] = rest_field(name="marketValue")
    """The market value of date side of the instrument. It is returned in the response only if value
     is overridden in the request."""
    value: Optional[datetime.date] = rest_field()
    """The date price side value of the instrument. If not overridden in the request, it returns the
     market value of the instrument."""

    @overload
    def __init__(
        self,
        *,
        is_delayed: Optional[bool] = None,
        is_overridden: Optional[bool] = None,
        market_value: Optional[datetime.date] = None,
        value: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldDateValue(_model_base.Model):
    """FieldDateValue.

    Attributes
    ----------
    historical_fid_priority : list[str]
        The list of historical Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    real_time_fid_priority : list[str]
        The list of real-time Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    value : ~datetime.date
        Get value.
    """

    historical_fid_priority: Optional[List[str]] = rest_field(name="historicalFidPriority")
    """The list of historical Fid (field identifier) name used to get the market data."""
    real_time_fid_priority: Optional[List[str]] = rest_field(name="realTimeFidPriority")
    """The list of real-time Fid (field identifier) name used to get the market data."""
    value: Optional[datetime.date] = rest_field()
    """Get value."""

    @overload
    def __init__(
        self,
        *,
        historical_fid_priority: Optional[List[str]] = None,
        real_time_fid_priority: Optional[List[str]] = None,
        value: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldDefinition(_model_base.Model):
    """An object that contains the identifiers of the market data fields used for real-time and time
    series requests.

    Attributes
    ----------
    real_time_fid_priority : list[str]
        An array of real-time Fid (field identifier) names used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    historical_fid_priority : list[str]
        An array of historical Fid (field identifier) names used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    """

    real_time_fid_priority: Optional[List[str]] = rest_field(name="realTimeFidPriority")
    """An array of real-time Fid (field identifier) names used to get the market data."""
    historical_fid_priority: Optional[List[str]] = rest_field(name="historicalFidPriority")
    """An array of historical Fid (field identifier) names used to get the market data."""

    @overload
    def __init__(
        self,
        *,
        real_time_fid_priority: Optional[List[str]] = None,
        historical_fid_priority: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldDescription(_model_base.Model):
    """FieldDescription.

    Attributes
    ----------
    historical_fid_priority : list[str]
        The list of historical Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    real_time_fid_priority : list[str]
        The list of real-time Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    """

    historical_fid_priority: Optional[List[str]] = rest_field(name="historicalFidPriority")
    """The list of historical Fid (field identifier) name used to get the market data."""
    real_time_fid_priority: Optional[List[str]] = rest_field(name="realTimeFidPriority")
    """The list of real-time Fid (field identifier) name used to get the market data."""

    @overload
    def __init__(
        self,
        *,
        historical_fid_priority: Optional[List[str]] = None,
        real_time_fid_priority: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldDoubleOutput(_model_base.Model):
    """FieldDoubleOutput.

    Attributes
    ----------
    is_delayed : bool
    is_overridden : bool
    market_value : float
        The market value of the price side of the instrument. It is returned in
        the response only if value is overridden in the request.
    value : float
        The price side value of the instrument. If not overridden in the
        request, it returns the market value of the instrument.
    """

    is_delayed: Optional[bool] = rest_field(name="isDelayed")
    is_overridden: Optional[bool] = rest_field(name="isOverridden")
    market_value: Optional[float] = rest_field(name="marketValue")
    """The market value of the price side of the instrument. It is returned in the response only if
     value is overridden in the request."""
    value: Optional[float] = rest_field()
    """The price side value of the instrument. If not overridden in the request, it returns the market
     value of the instrument."""

    @overload
    def __init__(
        self,
        *,
        is_delayed: Optional[bool] = None,
        is_overridden: Optional[bool] = None,
        market_value: Optional[float] = None,
        value: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldDoubleValue(_model_base.Model):
    """FieldDoubleValue.

    Attributes
    ----------
    historical_fid_priority : list[str]
        The list of historical Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    real_time_fid_priority : list[str]
        The list of real-time Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    value : float
        The price side value of the instrument.
    """

    historical_fid_priority: Optional[List[str]] = rest_field(name="historicalFidPriority")
    """The list of historical Fid (field identifier) name used to get the market data."""
    real_time_fid_priority: Optional[List[str]] = rest_field(name="realTimeFidPriority")
    """The list of real-time Fid (field identifier) name used to get the market data."""
    value: Optional[float] = rest_field()
    """The price side value of the instrument."""

    @overload
    def __init__(
        self,
        *,
        historical_fid_priority: Optional[List[str]] = None,
        real_time_fid_priority: Optional[List[str]] = None,
        value: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldFormulaDescription(_model_base.Model):
    """FieldFormulaDescription.

    Attributes
    ----------
    formula : str
        The formula name used to adjust the market data value.
    historical_fid_priority : list[str]
        The list of historical Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    real_time_fid_priority : list[str]
        The list of real-time Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    """

    formula: Optional[str] = rest_field()
    """The formula name used to adjust the market data value."""
    historical_fid_priority: Optional[List[str]] = rest_field(name="historicalFidPriority")
    """The list of historical Fid (field identifier) name used to get the market data."""
    real_time_fid_priority: Optional[List[str]] = rest_field(name="realTimeFidPriority")
    """The list of real-time Fid (field identifier) name used to get the market data."""

    @overload
    def __init__(
        self,
        *,
        formula: Optional[str] = None,
        historical_fid_priority: Optional[List[str]] = None,
        real_time_fid_priority: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldFormulaDoubleOutput(_model_base.Model):
    """FieldFormulaDoubleOutput.

    Attributes
    ----------
    formula : str
        The formula name used to adjust the market data value.
    is_delayed : bool
    is_overridden : bool
    market_value : float
        The market value of the price side of the instrument. It is returned in
        the response only if value is overridden in the request.
    value : float
        The price side value of the instrument. If not overridden in the
        request, it returns the market value of the instrument.
    """

    formula: Optional[str] = rest_field()
    """The formula name used to adjust the market data value."""
    is_delayed: Optional[bool] = rest_field(name="isDelayed")
    is_overridden: Optional[bool] = rest_field(name="isOverridden")
    market_value: Optional[float] = rest_field(name="marketValue")
    """The market value of the price side of the instrument. It is returned in the response only if
     value is overridden in the request."""
    value: Optional[float] = rest_field()
    """The price side value of the instrument. If not overridden in the request, it returns the market
     value of the instrument."""

    @overload
    def __init__(
        self,
        *,
        formula: Optional[str] = None,
        is_delayed: Optional[bool] = None,
        is_overridden: Optional[bool] = None,
        market_value: Optional[float] = None,
        value: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldFormulaDoubleValue(_model_base.Model):
    """FieldFormulaDoubleValue.

    Attributes
    ----------
    formula : str
        The formula name used to adjust the market data value.
    historical_fid_priority : list[str]
        The list of historical Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    real_time_fid_priority : list[str]
        The list of real-time Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    value : float
        The price side value of the instrument.
    """

    formula: Optional[str] = rest_field()
    """The formula name used to adjust the market data value."""
    historical_fid_priority: Optional[List[str]] = rest_field(name="historicalFidPriority")
    """The list of historical Fid (field identifier) name used to get the market data."""
    real_time_fid_priority: Optional[List[str]] = rest_field(name="realTimeFidPriority")
    """The list of real-time Fid (field identifier) name used to get the market data."""
    value: Optional[float] = rest_field()
    """The price side value of the instrument."""

    @overload
    def __init__(
        self,
        *,
        formula: Optional[str] = None,
        historical_fid_priority: Optional[List[str]] = None,
        real_time_fid_priority: Optional[List[str]] = None,
        value: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldTimeOutput(_model_base.Model):
    """FieldTimeOutput.

    Attributes
    ----------
    is_delayed : bool
    is_overridden : bool
    market_value : str
        Get marketValue.
    value : str
        Get value.
    """

    is_delayed: Optional[bool] = rest_field(name="isDelayed")
    is_overridden: Optional[bool] = rest_field(name="isOverridden")
    market_value: Optional[str] = rest_field(name="marketValue")
    """Get marketValue."""
    value: Optional[str] = rest_field()
    """Get value."""

    @overload
    def __init__(
        self,
        *,
        is_delayed: Optional[bool] = None,
        is_overridden: Optional[bool] = None,
        market_value: Optional[str] = None,
        value: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldTimeValue(_model_base.Model):
    """FieldTimeValue.

    Attributes
    ----------
    historical_fid_priority : list[str]
        The list of historical Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    real_time_fid_priority : list[str]
        The list of real-time Fid (field identifier) name used to get the
        market data.  The default value is None, needs to be assigned before
        using.
    value : str
        Get value.
    """

    historical_fid_priority: Optional[List[str]] = rest_field(name="historicalFidPriority")
    """The list of historical Fid (field identifier) name used to get the market data."""
    real_time_fid_priority: Optional[List[str]] = rest_field(name="realTimeFidPriority")
    """The list of real-time Fid (field identifier) name used to get the market data."""
    value: Optional[str] = rest_field()
    """Get value."""

    @overload
    def __init__(
        self,
        *,
        historical_fid_priority: Optional[List[str]] = None,
        real_time_fid_priority: Optional[List[str]] = None,
        value: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FieldValue(_model_base.Model):
    """An object that contains the bid and ask quotes and related attributes for the instrument.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    value : float
        The quote value of the instrument. Required.
    is_overridden : bool
        An indicator whether the value is overridden. It returns only 'true' if
        value is overridden in the request.
    market_value : float
        The quote retrieved from the market. It is returned in the response
        only if the value is overridden in the request.
    """

    value: float = rest_field()
    """The quote value of the instrument. Required."""
    is_overridden: Optional[bool] = rest_field(name="isOverridden", visibility=["read"])
    """An indicator whether the value is overridden. It returns only 'true' if value is overridden in
     the request."""
    market_value: Optional[float] = rest_field(name="marketValue", visibility=["read"])
    """The quote retrieved from the market. It is returned in the response only if the value is
     overridden in the request."""

    @overload
    def __init__(
        self,
        value: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FinancialContractResponse(_model_base.Model):
    """The tabular response of the Financial Contract API of the Quantitative Analytics service.

    Attributes
    ----------
    data : list[any]
        The list that contains the values of requested fields for each
        Financial Contract definition sent.Financial Contracts appears in the
        rows and fields in the columns.  The default value is None, needs to be
        assigned before using.
    headers : list[~analyticsapi.models.Header]
        The column headers of the requested fields.  The default value is None,
        needs to be assigned before using.
    statuses : list[int]
        A list that contains the status of each calculation requested. Each
        code is described in the "Messages" property. Codes higher than 1000
        represents errors.  The default value is None, needs to be assigned
        before using.
    """

    data: Optional[List[Any]] = rest_field()
    """The list that contains the values of requested fields for each Financial Contract definition
     sent.Financial Contracts appears in the rows and fields in the columns."""
    headers: Optional[List["_models.Header"]] = rest_field()
    """The column headers of the requested fields."""
    statuses: Optional[List[int]] = rest_field()
    """A list that contains the status of each calculation requested. Each code is described in the
     \"Messages\" property. Codes higher than 1000 represents errors."""

    @overload
    def __init__(
        self,
        *,
        data: Optional[List[Any]] = None,
        headers: Optional[List["_models.Header"]] = None,
        statuses: Optional[List[int]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateDefinition(ABC, _model_base.Model):
    """An object that defines the interest rate settings.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    FixedRateDefinition, FloatingRateDefinition, StepRateDefinition

    Attributes
    ----------
    interest_rate_type : str or ~analyticsapi.models.InterestRateTypeEnum
        The interest rate type. Required. Known values are: "FixedRate",
        "StepRate", "FloatingRate", and "FloatingRateFormula".
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    interest_rate_type: str = rest_discriminator(name="interestRateType")
    """The interest rate type. Required. Known values are: \"FixedRate\", \"StepRate\",
     \"FloatingRate\", and \"FloatingRateFormula\"."""

    @overload
    def __init__(
        self,
        interest_rate_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["interest_rate_type"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FixedRateDefinition(InterestRateDefinition, discriminator="FixedRate"):
    """An object that defines a fixed rate.

    Attributes
    ----------
    interest_rate_type : str or ~analyticsapi.models.FIXED_RATE
        The type of interest rate that is defined as a fixed rate. Required. A
        fixed interest rate.
    rate : ~analyticsapi.models.Rate
        An object that defines the interest rate value used to derive fixed
        interest payments. Required.
    first_accrual_date : ~datetime.date
        The date from which the interest starts accruing. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    """

    interest_rate_type: Literal[InterestRateTypeEnum.FIXED_RATE] = rest_discriminator(name="interestRateType")  # type: ignore # pylint: disable=line-too-long
    """The type of interest rate that is defined as a fixed rate. Required. A fixed interest rate."""
    rate: "_models.Rate" = rest_field()
    """An object that defines the interest rate value used to derive fixed interest payments.
     Required."""
    first_accrual_date: Optional[datetime.date] = rest_field(name="firstAccrualDate")
    """The date from which the interest starts accruing. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01')."""

    @overload
    def __init__(
        self,
        *,
        rate: "_models.Rate",
        first_accrual_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, interest_rate_type=InterestRateTypeEnum.FIXED_RATE, **kwargs)


class FlatteningShift(_model_base.Model):
    """FlatteningShift.

    Attributes
    ----------
    amount : float
        Amount of shifting, applied to points depending on shift method
        selected. Can be measured in basis points/percents/future price based
        points. Also can be expressed as multiplier for relative shift type.
    ignore_quotation_scale : bool
    shift_type : str or ~analyticsapi.models.ShiftTypeEnum
        The type of shifting. The possible values are:   * Additive: the amount
        of shifting is added to the corresponding curve point,   * Relative:
        the curve point is multiplied by the amount of shifting (e.g., if
        amount = 1, the curve point value will be doubled),   * Scaled: the
        curve point is scaled by the value of the shifting amount (e.g., if
        amount = 1.1, the curve point value will multiplied by this value).
        Known values are: "Additive", "Relative", and "Scaled".
    shift_unit : str or ~analyticsapi.models.ShiftUnitEnum
        The unit that describes the amount of shifting. The possible values
        are:   * Absolute: the amount of shifting is expressed in absolute
        value.   * Bp: the amount of shifting is expressed in basis points,   *
        Percent: the amount of shifting is expressed in percentages,. Known
        values are: "Absolute", "Bp", and "Percent".
    """

    amount: Optional[float] = rest_field()
    """Amount of shifting, applied to points depending on shift method selected. Can be measured in
     basis points/percents/future price based points. Also can be expressed as multiplier for
     relative shift type."""
    ignore_quotation_scale: Optional[bool] = rest_field(name="ignoreQuotationScale")
    shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = rest_field(name="shiftType")
    """The type of shifting. The possible values are:   * Additive: the amount of shifting is added to
     the corresponding curve point,   * Relative: the curve point is multiplied by the amount of
     shifting (e.g., if amount = 1, the curve point value will be doubled),   * Scaled: the curve
     point is scaled by the value of the shifting amount (e.g., if amount = 1.1, the curve point
     value will multiplied by this value). Known values are: \"Additive\", \"Relative\", and
     \"Scaled\"."""
    shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = rest_field(name="shiftUnit")
    """The unit that describes the amount of shifting. The possible values are:   * Absolute: the
     amount of shifting is expressed in absolute value.   * Bp: the amount of shifting is expressed
     in basis points,   * Percent: the amount of shifting is expressed in percentages,. Known values
     are: \"Absolute\", \"Bp\", and \"Percent\"."""

    @overload
    def __init__(
        self,
        *,
        amount: Optional[float] = None,
        ignore_quotation_scale: Optional[bool] = None,
        shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = None,
        shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FloaterSettings(_model_base.Model):
    """FloaterSettings.

    Attributes
    ----------
    use_forward_index : bool
        Additional optional settings for floating rate bonds.
    forward_index_rate : float
        Optional. Spread over Forward Index. If used, do not use
        forwardIndexVector.
    index_projections : list[~analyticsapi.models.IndexProjection]
        The default value is None, needs to be assigned before using.
    finance_rate : float
        Optional, the financing rate used when if solving for the forward price
        is requested.
    calculate_to_maturity : bool
        Optional. Used for fix-to-float bonds. If true analytics are calculated
        to the maturity date, otherwise the fixed-to-float date.
    """

    use_forward_index: Optional[bool] = rest_field(name="useForwardIndex")
    """Additional optional settings for floating rate bonds."""
    forward_index_rate: Optional[float] = rest_field(name="forwardIndexRate")
    """Optional. Spread over Forward Index. If used, do not use forwardIndexVector."""
    index_projections: Optional[List["_models.IndexProjection"]] = rest_field(name="indexProjections")
    finance_rate: Optional[float] = rest_field(name="financeRate")
    """Optional, the financing rate used when if solving for the forward price is requested."""
    calculate_to_maturity: Optional[bool] = rest_field(name="calculateToMaturity")
    """Optional. Used for fix-to-float bonds. If true analytics are calculated to the maturity date,
     otherwise the fixed-to-float date."""

    @overload
    def __init__(
        self,
        *,
        use_forward_index: Optional[bool] = None,
        forward_index_rate: Optional[float] = None,
        index_projections: Optional[List["_models.IndexProjection"]] = None,
        finance_rate: Optional[float] = None,
        calculate_to_maturity: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FloatingRateDefinition(InterestRateDefinition, discriminator="FloatingRate"):
    """An object that defines a floating rate.

    Attributes
    ----------
    interest_rate_type : str or ~analyticsapi.models.FLOATING_RATE
        The type of interest rate that is defined as a floating rate. Required.
        A floating interest rate.
    index : str
        The identifier of the floating rate index definition (GUID or URI).
        Note that a URI must be at least 2 and at most 102 characters long,
        start with an alphanumeric character, and contain only alphanumeric
        characters, slashes and underscores. Example:
        "70e69888-b814-4a4e-a837-dc3f422ee7df" or "LSEG/USD_SOFR_ON". These are
        example values and not real indexes, as the ID and space/name may
        change across different environments. Required.
    spread_schedule : list[~analyticsapi.models.DatedRate]
        An array of objects that represents the sequence of spreads (in basis
        points) applied to the index value. If not defined, a flat spread of 0
        basis point is applied. The default value is None, needs to be assigned
        before using.
    compounding : ~analyticsapi.models.IndexCompoundingDefinition
        An object that defines the use of index compounding.
    reset_dates : ~analyticsapi.models.ResetDatesDefinition
        An object that defines the reset of index fixing dates.
    leverage : ~decimal.Decimal
        The leverage applied to the index value.
    cap : ~analyticsapi.models.CapFloorDefinition
        An object that defines a cap option.
    floor : ~analyticsapi.models.CapFloorDefinition
        An object that defines a floor option.
    front_stub_index : ~analyticsapi.models.StubIndexReferences
        An object that defines how the reference rate of the front stub period
        is calculated.
    back_stub_index : ~analyticsapi.models.StubIndexReferences
        An object that defines how the reference rate of the back stub period
        is calculated.
    """

    interest_rate_type: Literal[InterestRateTypeEnum.FLOATING_RATE] = rest_discriminator(name="interestRateType")  # type: ignore # pylint: disable=line-too-long
    """The type of interest rate that is defined as a floating rate. Required. A floating interest
     rate."""
    index: str = rest_field()
    """The identifier of the floating rate index definition (GUID or URI).
     Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
     character, and contain only alphanumeric characters, slashes and underscores.
     Example: \"70e69888-b814-4a4e-a837-dc3f422ee7df\" or \"LSEG/USD_SOFR_ON\".
     These are example values and not real indexes, as the ID and space/name may change across
     different environments. Required."""
    spread_schedule: Optional[List["_models.DatedRate"]] = rest_field(name="spreadSchedule")
    """An array of objects that represents the sequence of spreads (in basis points) applied to the
     index value. If not defined, a flat spread of 0 basis point is applied."""
    compounding: Optional["_models.IndexCompoundingDefinition"] = rest_field()
    """An object that defines the use of index compounding."""
    reset_dates: Optional["_models.ResetDatesDefinition"] = rest_field(name="resetDates")
    """An object that defines the reset of index fixing dates."""
    leverage: Optional[decimal.Decimal] = rest_field()
    """The leverage applied to the index value."""
    cap: Optional["_models.CapFloorDefinition"] = rest_field()
    """An object that defines a cap option."""
    floor: Optional["_models.CapFloorDefinition"] = rest_field()
    """An object that defines a floor option."""
    front_stub_index: Optional["_models.StubIndexReferences"] = rest_field(name="frontStubIndex")
    """An object that defines how the reference rate of the front stub period is calculated."""
    back_stub_index: Optional["_models.StubIndexReferences"] = rest_field(name="backStubIndex")
    """An object that defines how the reference rate of the back stub period is calculated."""

    @overload
    def __init__(
        self,
        *,
        index: str,
        spread_schedule: Optional[List["_models.DatedRate"]] = None,
        compounding: Optional["_models.IndexCompoundingDefinition"] = None,
        reset_dates: Optional["_models.ResetDatesDefinition"] = None,
        leverage: Optional[decimal.Decimal] = None,
        cap: Optional["_models.CapFloorDefinition"] = None,
        floor: Optional["_models.CapFloorDefinition"] = None,
        front_stub_index: Optional["_models.StubIndexReferences"] = None,
        back_stub_index: Optional["_models.StubIndexReferences"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, interest_rate_type=InterestRateTypeEnum.FLOATING_RATE, **kwargs)


class FloatingRateIndex(_model_base.Model):
    """A model template defining a resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.FLOATING_RATE_INDEX
        Property defining the type of the resource.
    id : str
        Unique identifier of the FloatingRateIndex.
    location : ~analyticsapi.models.Location
        Object defining the location of the FloatingRateIndex in the platform.
        Required.
    description : ~analyticsapi.models.Description
        Object defining metadata for the FloatingRateIndex.
    definition : ~analyticsapi.models.FloatingRateIndexDefinition
        Object defining the FloatingRateIndex. Required.
    """

    type: Optional[Literal[ResourceType.FLOATING_RATE_INDEX]] = rest_field(
        visibility=["read"], default=ResourceType.FLOATING_RATE_INDEX
    )
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the FloatingRateIndex."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining the location of the FloatingRateIndex in the platform. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining metadata for the FloatingRateIndex."""
    definition: "_models.FloatingRateIndexDefinition" = rest_field()
    """Object defining the FloatingRateIndex. Required."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        definition: "_models.FloatingRateIndexDefinition",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FloatingRateIndexCollectionLinks(_model_base.Model):
    """FloatingRateIndexCollectionLinks.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FloatingRateIndexCollectionResponse(_model_base.Model):
    """A model template describing a paged response.

    Attributes
    ----------
    data : list[~analyticsapi.models.FloatingRateIndexInfo]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.FloatingRateIndexCollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.FloatingRateIndexInfo"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.FloatingRateIndexCollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.FloatingRateIndexInfo"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.FloatingRateIndexCollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FloatingRateIndexConstituent(IrConstituent, discriminator="FloatingRateIndex"):
    """An object defining a floating rate index constituent of an interest rate curve.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    index : str
        This is the reference Index of the curve that the constituent
        contributes to. For instance (e.g. LIBOR 3M). Required.
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
        Required.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.FLOATING_RATE_INDEX
        Required.
    definition : ~analyticsapi.models.FloatingRateIndexConstituentDefinition
        Required.
    """

    type: Literal[IrConstituentEnum.FLOATING_RATE_INDEX] = rest_discriminator(name="type")  # type: ignore
    """Required."""
    definition: "_models.FloatingRateIndexConstituentDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        *,
        index: str,
        quote: "_models.Quote",
        definition: "_models.FloatingRateIndexConstituentDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=IrConstituentEnum.FLOATING_RATE_INDEX, **kwargs)


class FloatingRateIndexConstituentDefinition(_model_base.Model):
    """The definition of a floating rate index used as a constituent of an interest rate curve.

    Attributes
    ----------
    year_basis : str or ~analyticsapi.models.YearBasisEnum
        The code describing the number of days in a year (360, 365...).
        Required. Known values are: "YB_252", "YB_360", "YB_364", "YB_365",
        "YB_36525", "YB_366", and "YB_Actual".
    rounding : ~analyticsapi.models.RoundingDefinition
        An object defining how the index value is rounded.
    tenor : str
        The code indicating the tenor of the instrument used as a constituent
        (e.g., '1M', '1Y'). Required.
    template : str
        A pre-defined template can be used as an input by the user. It is the
        currency code of the constituent. Required.
    """

    year_basis: Union[str, "_models.YearBasisEnum"] = rest_field(name="yearBasis")
    """The code describing the number of days in a year (360, 365...). Required. Known values are:
     \"YB_252\", \"YB_360\", \"YB_364\", \"YB_365\", \"YB_36525\", \"YB_366\", and \"YB_Actual\"."""
    rounding: Optional["_models.RoundingDefinition"] = rest_field()
    """An object defining how the index value is rounded."""
    tenor: str = rest_field()
    """The code indicating the tenor of the instrument used as a constituent (e.g., '1M', '1Y').
     Required."""
    template: str = rest_field()
    """A pre-defined template can be used as an input by the user. It is the currency code of the
     constituent. Required."""

    @overload
    def __init__(
        self,
        *,
        year_basis: Union[str, "_models.YearBasisEnum"],
        tenor: str,
        template: str,
        rounding: Optional["_models.RoundingDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FloatingRateIndexDefinition(_model_base.Model):
    """An object that defines the reference index of a floating rate.

    Attributes
    ----------
    currency : str
        The currency of the reference index. The value is expressed in ISO 4217
        alphabetical format (e.g., 'GBP'). Required.
    name : str
        The name of the floating rate index (e.g., 'EURIBOR'). Required.
    tenor : str
        The period code indicating the tenor of the underlying floating rate
        index (e.g., '1M', '1Y'). Required.
    year_basis : str or ~analyticsapi.models.YearBasisEnum
        The period length in days for the year used to calculate the time
        fraction and depends on the year basis convention applied. Required.
        Known values are: "YB_252", "YB_360", "YB_364", "YB_365", "YB_36525",
        "YB_366", and "YB_Actual".
    rounding : ~analyticsapi.models.RoundingDefinition
        An object that defines how rounding is applied to the reference
        floating rate index. Required.
    quote_definition : ~analyticsapi.models.QuoteDefinition
        An object that defines the attributes for getting the floating rate
        index quote. Required.
    """

    currency: str = rest_field()
    """The currency of the reference index. The value is expressed in ISO 4217 alphabetical format
     (e.g., 'GBP'). Required."""
    name: str = rest_field()
    """The name of the floating rate index (e.g., 'EURIBOR'). Required."""
    tenor: str = rest_field()
    """The period code indicating the tenor of the underlying floating rate index (e.g., '1M', '1Y').
     Required."""
    year_basis: Union[str, "_models.YearBasisEnum"] = rest_field(name="yearBasis")
    """The period length in days for the year used to calculate the time fraction and depends on the
     year basis convention applied. Required. Known values are: \"YB_252\", \"YB_360\", \"YB_364\",
     \"YB_365\", \"YB_36525\", \"YB_366\", and \"YB_Actual\"."""
    rounding: "_models.RoundingDefinition" = rest_field()
    """An object that defines how rounding is applied to the reference floating rate index. Required."""
    quote_definition: "_models.QuoteDefinition" = rest_field(name="quoteDefinition")
    """An object that defines the attributes for getting the floating rate index quote. Required."""

    @overload
    def __init__(
        self,
        *,
        currency: str,
        name: str,
        tenor: str,
        year_basis: Union[str, "_models.YearBasisEnum"],
        rounding: "_models.RoundingDefinition",
        quote_definition: "_models.QuoteDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FloatingRateIndexInfo(_model_base.Model):
    """A model template defining the partial description of the resource returned by the GET list
    service.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.FLOATING_RATE_INDEX
        Property defining the type of the resource.
    id : str
        Unique identifier of the FloatingRateIndex.
    location : ~analyticsapi.models.Location
        Object defining metadata for the FloatingRateIndex. Required.
    description : ~analyticsapi.models.Description
        Object defining the FloatingRateIndex.
    """

    type: Optional[Literal[ResourceType.FLOATING_RATE_INDEX]] = rest_field(
        visibility=["read"], default=ResourceType.FLOATING_RATE_INDEX
    )
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the FloatingRateIndex."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining metadata for the FloatingRateIndex. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining the FloatingRateIndex."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FloatingRateIndexResponse(_model_base.Model):
    """A model template describing a single response.

    Attributes
    ----------
    data : ~analyticsapi.models.FloatingRateIndex
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.FloatingRateIndex" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.FloatingRateIndex",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FormulaParameter(_model_base.Model):
    """FormulaParameter.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFormulaFields
    instrument_code : str
        The code used to define the instrument. The possible values for each
        asset type are listed here. Mandatory to retrieve the market data when
        formulaParameters is specified.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        The name indicating which data is used for the formula calculation
        (e.g., 'marketPrice'). Mandatory to retrieve the market data.
    """

    fields: Optional["_models.BidAskFormulaFields"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument. The possible values for each asset type are listed
     here. Mandatory to retrieve the market data when formulaParameters is specified."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """The name indicating which data is used for the formula calculation (e.g., 'marketPrice').
     Mandatory to retrieve the market data."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFormulaFields"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FormulaParameterDescription(_model_base.Model):
    """FormulaParameterDescription.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsFormulaDescription
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    fields: Optional["_models.BidAskFieldsFormulaDescription"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsFormulaDescription"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FormulaParameterOutput(_model_base.Model):
    """FormulaParameterOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsFormulaOutput
    instrument_code : str
        Get instrumentCode.
    instrument_type : str or ~analyticsapi.models.InstrumentTypeEnum
        Get instrumentType. Known values are: "Bond", "BondFutures",
        "CalendarSpread", "CreditDefaultSwap", "CrossCurrencySwap", "Deposit",
        "Fra", "Futures", "FxForward", "FxSpot", "InflationSwap",
        "InterProductSpread", "InterestRateSwap", "OvernightIndexSwap", and
        "TenorBasisSwap".
    name : str
        Get name.
    """

    fields: Optional["_models.BidAskFieldsFormulaOutput"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = rest_field(name="instrumentType")
    """Get instrumentType. Known values are: \"Bond\", \"BondFutures\", \"CalendarSpread\",
     \"CreditDefaultSwap\", \"CrossCurrencySwap\", \"Deposit\", \"Fra\", \"Futures\", \"FxForward\",
     \"FxSpot\", \"InflationSwap\", \"InterProductSpread\", \"InterestRateSwap\",
     \"OvernightIndexSwap\", and \"TenorBasisSwap\"."""
    name: Optional[str] = rest_field()
    """Get name."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsFormulaOutput"] = None,
        instrument_code: Optional[str] = None,
        instrument_type: Optional[Union[str, "_models.InstrumentTypeEnum"]] = None,
        name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardCurveAssignment(_model_base.Model):
    """An object that describes a forward curve reference with its index.

    Attributes
    ----------
    index : str
        The floating rate index identifier. Required.
    curve : str
        The reference to an interest rate curve stored in the platform.
        Required.
    """

    index: str = rest_field()
    """The floating rate index identifier. Required."""
    curve: str = rest_field()
    """The reference to an interest rate curve stored in the platform. Required."""

    @overload
    def __init__(
        self,
        *,
        index: str,
        curve: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardMarketDataAssignmentKey(_model_base.Model):
    """ForwardMarketDataAssignmentKey.

    Attributes
    ----------
    currency : str
    discounting_tenor : str
    index_name : str
    index_tenor : str
    instrument_tag : str
    instrument_type : str
    """

    currency: Optional[str] = rest_field()
    discounting_tenor: Optional[str] = rest_field(name="discountingTenor")
    index_name: Optional[str] = rest_field(name="indexName")
    index_tenor: Optional[str] = rest_field(name="indexTenor")
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    instrument_type: Optional[str] = rest_field(name="instrumentType")

    @overload
    def __init__(
        self,
        *,
        currency: Optional[str] = None,
        discounting_tenor: Optional[str] = None,
        index_name: Optional[str] = None,
        index_tenor: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        instrument_type: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardMarketDataAssignmentKeyAssignmentItem(_model_base.Model):  # pylint: disable=name-too-long
    """ForwardMarketDataAssignmentKeyAssignmentItem.

    Attributes
    ----------
    assignment : ~analyticsapi.models.AssignmentKey
    where : ~analyticsapi.models.ForwardMarketDataAssignmentKey
    """

    assignment: Optional["_models.AssignmentKey"] = rest_field()
    where: Optional["_models.ForwardMarketDataAssignmentKey"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        assignment: Optional["_models.AssignmentKey"] = None,
        where: Optional["_models.ForwardMarketDataAssignmentKey"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardRateAgreementAnalyticsResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """ForwardRateAgreementAnalyticsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.ForwardRateAgreementDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.ForwardRateAgreementPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.ForwardRateAgreementAnalyticsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketDataQps
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.ForwardRateAgreementDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.ForwardRateAgreementPricingParameters"] = rest_field(
        name="pricingPreferences"
    )
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.ForwardRateAgreementAnalyticsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketDataQps"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.ForwardRateAgreementDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.ForwardRateAgreementPricingParameters"] = None,
        analytics: Optional[List["_models.ForwardRateAgreementAnalyticsResponseWithError"]] = None,
        market_data: Optional["_models.MarketDataQps"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardRateAgreementAnalyticsResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    tabular_data : ~analyticsapi.models.FinancialContractResponse
        Standard Financial Contract Analytics in tabular format.
    cashflows : ~analyticsapi.models.ForwardRateAgreementCashflows
        Response categorized under Cashflows.
    description : ~analyticsapi.models.ForwardRateAgreementDescription
        Response categorized under Description.
    nominal_measures : ~analyticsapi.models.ForwardRateAgreementNominalMeasures
        Response categorized under Nominal measures.
    pricing_analysis : ~analyticsapi.models.ForwardRateAgreementPricingAnalysis
        Response categorized under Pricing analysis.
    valuation : ~analyticsapi.models.ForwardRateAgreementValuation
        Response categorized under Valuation.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    tabular_data: Optional["_models.FinancialContractResponse"] = rest_field(name="tabularData")
    """Standard Financial Contract Analytics in tabular format."""
    cashflows: Optional["_models.ForwardRateAgreementCashflows"] = rest_field()
    """Response categorized under Cashflows."""
    description: Optional["_models.ForwardRateAgreementDescription"] = rest_field()
    """Response categorized under Description."""
    nominal_measures: Optional["_models.ForwardRateAgreementNominalMeasures"] = rest_field(name="nominalMeasures")
    """Response categorized under Nominal measures."""
    pricing_analysis: Optional["_models.ForwardRateAgreementPricingAnalysis"] = rest_field(name="pricingAnalysis")
    """Response categorized under Pricing analysis."""
    valuation: Optional["_models.ForwardRateAgreementValuation"] = rest_field()
    """Response categorized under Valuation."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        tabular_data: Optional["_models.FinancialContractResponse"] = None,
        cashflows: Optional["_models.ForwardRateAgreementCashflows"] = None,
        description: Optional["_models.ForwardRateAgreementDescription"] = None,
        nominal_measures: Optional["_models.ForwardRateAgreementNominalMeasures"] = None,
        pricing_analysis: Optional["_models.ForwardRateAgreementPricingAnalysis"] = None,
        valuation: Optional["_models.ForwardRateAgreementValuation"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardRateAgreementCalculationResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.ForwardRateAgreementAnalyticsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.ForwardRateAgreementAnalyticsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.ForwardRateAgreementAnalyticsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class ForwardRateAgreementCashflows(_model_base.Model):
    """Cashflows Object.

    Attributes
    ----------
    cash_flows : list[any]
        The information on the contract's cash flows during its lifetime. It
        consists of the following properties:

        * instrumentType: the instrument type for which cash flows are computed,
        * payments: the array of properties which define all instruments cash flows (paid and
        received) during its lifetime.

        For more details, please refer here.  The default value is None, needs to be assigned before
        using.
    """

    cash_flows: Optional[List[Any]] = rest_field(name="cashFlows")
    """The information on the contract's cash flows during its lifetime. It consists of the following
     properties:
     
     
     * instrumentType: the instrument type for which cash flows are computed,
     * payments: the array of properties which define all instruments cash flows (paid and
     received) during its lifetime.
     
     For more details, please refer here."""

    @overload
    def __init__(
        self,
        cash_flows: Optional[List[Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["cash_flows"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class ForwardRateAgreementConstituent(IrConstituent, discriminator="ForwardRateAgreement"):
    """An object defining forward rate agreement constituent of an interest rate curve.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    index : str
        This is the reference Index of the curve that the constituent
        contributes to. For instance (e.g. LIBOR 3M). Required.
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
        Required.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.FORWARD_RATE_AGREEMENT
        The type of constituent. ForwardRateAgreement is the only valid value.
        Required.
    definition : ~analyticsapi.models.ForwardRateAgreementConstituentDefinition
        An object to define the Forward Rate Agreement used as a constituent.
        Required.
    """

    type: Literal[IrConstituentEnum.FORWARD_RATE_AGREEMENT] = rest_discriminator(name="type")  # type: ignore
    """The type of constituent. ForwardRateAgreement is the only valid value. Required."""
    definition: "_models.ForwardRateAgreementConstituentDefinition" = rest_field()
    """An object to define the Forward Rate Agreement used as a constituent. Required."""

    @overload
    def __init__(
        self,
        *,
        index: str,
        quote: "_models.Quote",
        definition: "_models.ForwardRateAgreementConstituentDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=IrConstituentEnum.FORWARD_RATE_AGREEMENT, **kwargs)


class ForwardRateAgreementConstituentDefinition(_model_base.Model):  # pylint: disable=name-too-long
    """The definition of a forward rate Agreement instrument used as a constituent of an interest rate
    curve.

    Attributes
    ----------
    tenor : str
        The code indicating the tenor of the instrument used as a constituent
        (e.g., '1M', '1Y'). Required.
    template : str
        A pre-defined template can be used as an input by the user. It is the
        currency code of the constituent.
    """

    tenor: str = rest_field()
    """The code indicating the tenor of the instrument used as a constituent (e.g., '1M', '1Y').
     Required."""
    template: Optional[str] = rest_field()
    """A pre-defined template can be used as an input by the user. It is the currency code of the
     constituent."""

    @overload
    def __init__(
        self,
        *,
        tenor: str,
        template: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardRateAgreementDefinition(_model_base.Model):
    """ForwardRateAgreementDefinition.

    Attributes
    ----------
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). If instrumentCode is not defined, either:

        * endDate, or
        * endTenor, or
        * tenor + [startDate, or startTenor] must be provided.

        If instrumentCode is defined, the value comes from the instrument reference data.
    end_tenor : str
        The code indicating the period from ValuationDate to EndDate of the
        instrument (e.g., '10M'). If instrumentCode is not defined, either:

        * endDate, or
        * endTenor, or
        * tenor + [startDate, or startTenor] must be provided.

        If instrumentCode is defined, the value comes from the instrument reference data.
    fixed_rate_percent : float
        The fixed interest rate used to derive future fixed interest payments
        of the instrument (FRA rate negotiated by counterparties). The value is
        expressed in percentages. Mandatory to calculate the market value of
        the instrument. By default, it is equal to ParRatePercent.
    fixing_date : ~datetime.datetime
    index_name : str
        The name of the floating rate index (e.g., 'EURIBOR'). The default
        value depends on the notional currency.
    index_tenor : str
        The period code indicating the tenor of the underlying (reference)
        floating rate index (e.g., '1M', '1Y'). If instrumentCode is defined,
        the value comes from the instrument reference data. Otherwise, tenor is
        used.
    instrument_code : str
        The code used to define the instrument.
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    interest_calculation_method : str or ~analyticsapi.models.InterestCalculationMethodEnum
        The Day Count Basis method used to calculate the coupon interest
        payments. The default value depends on the notional currency. Known
        values are: "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German",
        "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
        "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual",
        "Dcb_30_Actual_ISDA", "Dcb_30E_360_ISMA", "Dcb_Actual_360",
        "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
        "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB",
        "Dcb_WorkingDays_252", "Dcb_Actual_365L", "Dcb_Actual_365P",
        "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525",
        "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
    notional_amount : float
        The notional amount of the instrument. The default value is 1000000.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g., 'EUR'). Mandatory if
        instrumentCode is not defined. If instrumentCode is defined, the value
        comes from the instrument reference data.
    payment_business_day_convention : str or ~analyticsapi.models.PaymentBusinessDayConventionEnum
        The method to adjust dates to a working day. Optional. Default value is
        'ModifiedFollowing'. Known values are: "ModifiedFollowing",
        "NextBusinessDay", "PreviousBusinessDay", "NoMoving",
        "EveryThirdWednesday", and "BbswModifiedFollowing".
    start_date : ~datetime.datetime
        The code indicating the period from ValuationDate, or SpotDate to
        StartDate of the instrument (e.g., '1M'). If instrumentCode is not
        defined, either startDate or startTenor must be provided. If
        instrumentCode is defined, the value comes from the instrument
        reference data.
    start_tenor : str
        The code indicating the period from ValuationDate, or SpotDate to
        StartDate of the instrument (e.g., '1M'). If instrumentCode is not
        defined, either startDate or startTenor must be provided. If
        instrumentCode is defined, the value comes from the instrument
        reference data.
    tenor : str
        The code indicating the period between StartDate and EndDate of the
        instrument (e.g., '6M', '1Y'). If instrumentCode is not defined,
        either:

        * endDate, or
        * endTenor, or
        * tenor + [startDate, or startTenor] must be provided.

        If instrumentCode is defined, the value comes from the instrument reference data.
    trade_date : ~datetime.datetime
        The date when the instrument is traded. The value is expressed in ISO
        8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
        By default, it equals to marketDataDate, or valuationDate, or today's
        date.
    """

    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     If instrumentCode is not defined, either:
     
     
     * endDate, or
     * endTenor, or
     * tenor + [startDate, or startTenor] must be provided.
     
     If instrumentCode is defined, the value comes from the instrument reference data."""
    end_tenor: Optional[str] = rest_field(name="endTenor")
    """The code indicating the period from ValuationDate to EndDate of the instrument (e.g., '10M').
     If instrumentCode is not defined, either:
     
     
     * endDate, or
     * endTenor, or
     * tenor + [startDate, or startTenor] must be provided.
     
     If instrumentCode is defined, the value comes from the instrument reference data."""
    fixed_rate_percent: Optional[float] = rest_field(name="fixedRatePercent")
    """The fixed interest rate used to derive future fixed interest payments of the instrument (FRA
     rate negotiated by counterparties). The value is expressed in percentages.
     Mandatory to calculate the market value of the instrument.
     By default, it is equal to ParRatePercent."""
    fixing_date: Optional[datetime.datetime] = rest_field(name="fixingDate", format="rfc3339")
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., 'EURIBOR').
     The default value depends on the notional currency."""
    index_tenor: Optional[str] = rest_field(name="indexTenor")
    """The period code indicating the tenor of the underlying (reference) floating rate index (e.g.,
     '1M', '1Y').
     If instrumentCode is defined, the value comes from the instrument reference data. Otherwise,
     tenor is used."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = rest_field(
        name="interestCalculationMethod"
    )
    """The Day Count Basis method used to calculate the coupon interest payments.
     The default value depends on the notional currency. Known values are: \"Dcb_30_360\",
     \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\",
     \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\",
     \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\",
     \"Dcb_Actual_365_CanadianConvention\", and \"Dcb_Constant\"."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument.
     The default value is 1000000."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g., 'EUR').
     Mandatory if instrumentCode is not defined. If instrumentCode is defined, the value comes from
     the instrument reference data."""
    payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = rest_field(
        name="paymentBusinessDayConvention"
    )
    """The method to adjust dates to a working day.
     Optional. Default value is 'ModifiedFollowing'. Known values are: \"ModifiedFollowing\",
     \"NextBusinessDay\", \"PreviousBusinessDay\", \"NoMoving\", \"EveryThirdWednesday\", and
     \"BbswModifiedFollowing\"."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The code indicating the period from ValuationDate, or SpotDate to StartDate of the instrument
     (e.g., '1M').
     If instrumentCode is not defined, either startDate or startTenor must be provided.
     If instrumentCode is defined, the value comes from the instrument reference data."""
    start_tenor: Optional[str] = rest_field(name="startTenor")
    """The code indicating the period from ValuationDate, or SpotDate to StartDate of the instrument
     (e.g., '1M').
     If instrumentCode is not defined, either startDate or startTenor must be provided.
     If instrumentCode is defined, the value comes from the instrument reference data."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between StartDate and EndDate of the instrument (e.g., '6M',
     '1Y').
     If instrumentCode is not defined, either:
     
     
     * endDate, or
     * endTenor, or
     * tenor + [startDate, or startTenor] must be provided.
     
     If instrumentCode is defined, the value comes from the instrument reference data."""
    trade_date: Optional[datetime.datetime] = rest_field(name="tradeDate", format="rfc3339")
    """The date when the instrument is traded. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, it equals to marketDataDate, or valuationDate, or today's date."""

    @overload
    def __init__(
        self,
        *,
        end_date: Optional[datetime.datetime] = None,
        end_tenor: Optional[str] = None,
        fixed_rate_percent: Optional[float] = None,
        fixing_date: Optional[datetime.datetime] = None,
        index_name: Optional[str] = None,
        index_tenor: Optional[str] = None,
        instrument_code: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = None,
        notional_amount: Optional[float] = None,
        notional_ccy: Optional[str] = None,
        payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = None,
        start_date: Optional[datetime.datetime] = None,
        start_tenor: Optional[str] = None,
        tenor: Optional[str] = None,
        trade_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardRateAgreementDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.ForwardRateAgreementDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.ForwardRateAgreementDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.ForwardRateAgreementDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardRateAgreementDescription(_model_base.Model):
    """Description Object.

    Attributes
    ----------
    instrument_type : str
        The type of instrument defined in the request.  The possible values are
        listed  here  .
    instrument_code : str
        The code used to define the instrument.
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    instrument_description : str
        The label that describes the instrument.
    trade_date : ~datetime.datetime
        The date when the instrument is traded. The value is expressed in ISO
        8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
    spot_date : ~datetime.datetime
        The date when a spot transaction is settled. The date is defined by the
        market conventions. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
    fixing_date : ~datetime.datetime
        The date at which the settlement amount of the instrument is
        calculated. This date is defined as [  StartDate  - 2WD]. The value is
        expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    start_date : ~datetime.datetime
        The start date of the instrument. The value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    tenor : str
        The code indicating the period between  StartDate  and  EndDate  of the
        instrument (e.g., '6M', '1Y').
    calendar : str
        A list of comma-separated calendar codes to adjust dates (e.g., 'EMU'
        or 'USA'). It is the calendar associated with the market conventions
        depending on the notional currency. The possible values are listed
        here  .
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g., 'USD').
    notional_amount : float
        The notional amount of the instrument.
    report_ccy : str
        The currency code set for the fields ending with '  xxxInReportCcy  '.
        The value is expressed in ISO 4217 alphabetical format (e.g., '  USD
        ').
    interest_calculation_method : str
        The day count basis method used to calculate the interest payments. The
        possible values are listed  here  .
    index_name : str
        The name of the floating rate index (e.g., 'EURIBOR'). The possible
        values depending on the currency are listed  here  .
    index_tenor : str
        The period code indicating the tenor of the underlying floating rate
        index (e.g., '1M', '1Y').
    price_side : str
        The price side of the instrument which comes from the instrument's
        quote or from the curve (derived from quotes) used to value the
        instrument. The possible values are:

        * Bid,
        * Ask,
        * Mid.
    forward_curve_name : str
        The name of the zero-coupon curve used to derive forward index values
        for the instrument. Examples could be as follows:

        * EUR EURIBOR 6M: a zero-coupon curve bootstrapped from EURIBOR 6M swaps,
        * USD LIBOR OIS disc. COP COIBR OIS: a cross-currency curve COP COIBR OIS discounted by USD
        LIBOR OIS.
    discount_curve_name : str
        The name of the zero-coupon curve used to discount the instrument's
        cash flows. Specifying data for this curve can be set using the market
        data section. By default, the discount curve is found from the
        instrument's currency and frequency.
    error_code : str
        The code of  ErrorMessage  .
    error_message : str
        The error message in case of a blocking error in calculation.
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    instrument_type: Optional[str] = rest_field(name="instrumentType")
    """The type of instrument defined in the request.  The possible values are listed  here  ."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    instrument_description: Optional[str] = rest_field(name="instrumentDescription")
    """The label that describes the instrument."""
    trade_date: Optional[datetime.datetime] = rest_field(name="tradeDate", format="rfc3339")
    """The date when the instrument is traded. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    spot_date: Optional[datetime.datetime] = rest_field(name="spotDate", format="rfc3339")
    """The date when a spot transaction is settled. The date is defined by the market conventions. The
     value is expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
     '2021-01-01T00:00:00Z')."""
    fixing_date: Optional[datetime.datetime] = rest_field(name="fixingDate", format="rfc3339")
    """The date at which the settlement amount of the instrument is calculated. This date is defined
     as [  StartDate  - 2WD]. The value is expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z
     (e.g., '2021-01-01T00:00:00Z')."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between  StartDate  and  EndDate  of the instrument (e.g., '6M',
     '1Y')."""
    calendar: Optional[str] = rest_field()
    """A list of comma-separated calendar codes to adjust dates (e.g., 'EMU' or 'USA'). It is the
     calendar associated with the market conventions depending on the notional currency. The
     possible values are listed  here  ."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g., 'USD')."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with '  xxxInReportCcy  '. The value is expressed
     in ISO 4217 alphabetical format (e.g., '  USD  ')."""
    interest_calculation_method: Optional[str] = rest_field(name="interestCalculationMethod")
    """The day count basis method used to calculate the interest payments. The possible values are
     listed  here  ."""
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., 'EURIBOR'). The possible values depending on the
     currency are listed  here  ."""
    index_tenor: Optional[str] = rest_field(name="indexTenor")
    """The period code indicating the tenor of the underlying floating rate index (e.g., '1M', '1Y')."""
    price_side: Optional[str] = rest_field(name="priceSide")
    """The price side of the instrument which comes from the instrument's quote or from the curve
     (derived from quotes) used to value the instrument. The possible values are:
     
     
     * Bid,
     * Ask,
     * Mid."""
    forward_curve_name: Optional[str] = rest_field(name="forwardCurveName")
    """The name of the zero-coupon curve used to derive forward index values for the instrument.
     Examples could be as follows:
     
     
     * EUR EURIBOR 6M: a zero-coupon curve bootstrapped from EURIBOR 6M swaps,
     * USD LIBOR OIS disc. COP COIBR OIS: a cross-currency curve COP COIBR OIS discounted by USD
     LIBOR OIS."""
    discount_curve_name: Optional[str] = rest_field(name="discountCurveName")
    """The name of the zero-coupon curve used to discount the instrument's cash flows. Specifying data
     for this curve can be set using the market data section. By default, the discount curve is
     found from the instrument's currency and frequency."""
    error_code: Optional[str] = rest_field(name="errorCode")
    """The code of  ErrorMessage  ."""
    error_message: Optional[str] = rest_field(name="errorMessage")
    """The error message in case of a blocking error in calculation."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        instrument_type: Optional[str] = None,
        instrument_code: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        instrument_description: Optional[str] = None,
        trade_date: Optional[datetime.datetime] = None,
        spot_date: Optional[datetime.datetime] = None,
        fixing_date: Optional[datetime.datetime] = None,
        start_date: Optional[datetime.datetime] = None,
        end_date: Optional[datetime.datetime] = None,
        tenor: Optional[str] = None,
        calendar: Optional[str] = None,
        notional_ccy: Optional[str] = None,
        notional_amount: Optional[float] = None,
        report_ccy: Optional[str] = None,
        interest_calculation_method: Optional[str] = None,
        index_name: Optional[str] = None,
        index_tenor: Optional[str] = None,
        price_side: Optional[str] = None,
        forward_curve_name: Optional[str] = None,
        discount_curve_name: Optional[str] = None,
        error_code: Optional[str] = None,
        error_message: Optional[str] = None,
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardRateAgreementNominalMeasures(_model_base.Model):
    """Nominal measures Object.

    Attributes
    ----------
    pv01_bp : float
        The sensitivity of the net present value to a  1 bp  parallel shift in
        the yield curve. The value is expressed in basis points.
    """

    pv01_bp: Optional[float] = rest_field(name="pv01Bp")
    """The sensitivity of the net present value to a  1 bp  parallel shift in the yield curve. The
     value is expressed in basis points."""

    @overload
    def __init__(
        self,
        pv01_bp: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["pv01_bp"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class ForwardRateAgreementPricingAnalysis(_model_base.Model):
    """Pricing analysis Object.

    Attributes
    ----------
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    discount_factor : float
        The ratio used to calculate the present value of the future cash flows
        of the instrument.
    fixed_rate_percent : float
        The interest rate used to derive future fixed interest payments of the
        instrument. The value is expressed in percentages.
    par_rate_percent : float
        The fixed interest rate of the instrument at which in theory
        MarketValueInDealCcy  = 0. The value is expressed in percentages.
    spread_bp : float
        The spread applied to the floating interest rate of the instrument. The
        value is expressed in basis points. For more details on the field
        calculation, please refer here.
    """

    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    discount_factor: Optional[float] = rest_field(name="discountFactor")
    """The ratio used to calculate the present value of the future cash flows of the instrument."""
    fixed_rate_percent: Optional[float] = rest_field(name="fixedRatePercent")
    """The interest rate used to derive future fixed interest payments of the instrument. The value is
     expressed in percentages."""
    par_rate_percent: Optional[float] = rest_field(name="parRatePercent")
    """The fixed interest rate of the instrument at which in theory  MarketValueInDealCcy  = 0. The
     value is expressed in percentages."""
    spread_bp: Optional[float] = rest_field(name="spreadBp")
    """The spread applied to the floating interest rate of the instrument. The value is expressed in
     basis points.
     For more details on the field calculation, please refer here."""

    @overload
    def __init__(
        self,
        *,
        market_data_date: Optional[datetime.datetime] = None,
        valuation_date: Optional[datetime.datetime] = None,
        discount_factor: Optional[float] = None,
        fixed_rate_percent: Optional[float] = None,
        par_rate_percent: Optional[float] = None,
        spread_bp: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardRateAgreementPricingParameters(_model_base.Model):
    """ForwardRateAgreementPricingParameters.

    Attributes
    ----------
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).
        Optional. By default, marketDataDate is valuationDate or today.
    price_side : str or ~analyticsapi.models.PriceSideEnum
        The price side of the instrument which comes from the instrument's
        quote or from the curve (derived from quotes) used to value the
        instrument. The possible values are: Bid, Ask, Mid. Optional. The
        default value is 'Mid'. Known values are: "Mid", "Bid", "Ask", and
        "Last".
    report_ccy : str
        The currency code set for the fields ending with 'xxxInReportCcy'. The
        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
        Optional. No default value applies.
    tenor_reference_date : str or ~analyticsapi.models.TenorReferenceDateEnum
        The reference date for the computation of the start and end dates from
        the tenor. The possible values are:

        * ValuationDate: StartDate is computed as [ValuationDate + StartTenor], EndDate is computed as
        [ValuationDate + EndTenor],
        * SpotDate: StartDate is computed as [ValuationDate + spot lag + StartTenor], EndDate is
        computed as [ValuationDate + spot lag + EndTenor].

        The default value is 'ValuationDate'. Known values are: "SpotDate" and "ValuationDate".
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It can't be greater than today's date. By
        default, it equals to marketDataDate or today's date.
    """

    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It should be less or equal to
     valuationDate).
     Optional. By default, marketDataDate is valuationDate or today."""
    price_side: Optional[Union[str, "_models.PriceSideEnum"]] = rest_field(name="priceSide")
    """The price side of the instrument which comes from the instrument's quote or from the curve
     (derived from quotes) used to value the instrument.
     The possible values are: Bid, Ask, Mid.
     Optional. The default value is 'Mid'. Known values are: \"Mid\", \"Bid\", \"Ask\", and
     \"Last\"."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with 'xxxInReportCcy'. The value is expressed in
     ISO 4217 alphabetical format (e.g., 'USD').
     Optional. No default value applies."""
    tenor_reference_date: Optional[Union[str, "_models.TenorReferenceDateEnum"]] = rest_field(name="tenorReferenceDate")
    """The reference date for the computation of the start and end dates from the tenor. The possible
     values are:
     
     
     * ValuationDate: StartDate is computed as [ValuationDate + StartTenor], EndDate is computed as
     [ValuationDate + EndTenor],
     * SpotDate: StartDate is computed as [ValuationDate + spot lag + StartTenor], EndDate is
     computed as [ValuationDate + spot lag + EndTenor].
     
     The default value is 'ValuationDate'. Known values are: \"SpotDate\" and \"ValuationDate\"."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It can't be greater than today's
     date.
     By default, it equals to marketDataDate or today's date."""

    @overload
    def __init__(
        self,
        *,
        market_data_date: Optional[datetime.datetime] = None,
        price_side: Optional[Union[str, "_models.PriceSideEnum"]] = None,
        report_ccy: Optional[str] = None,
        tenor_reference_date: Optional[Union[str, "_models.TenorReferenceDateEnum"]] = None,
        valuation_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ForwardRateAgreementValuation(_model_base.Model):
    """Valuation Object.

    Attributes
    ----------
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency.
    market_value_in_report_ccy : float
        The market value of the instrument. The value is expressed in the
        reporting currency.
    """

    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value of the instrument. The value is expressed in the reporting currency."""

    @overload
    def __init__(
        self,
        *,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FraDefinition(SingleInterestRatePaymentDefinition):
    """FraDefinition.

    Attributes
    ----------
    notional : ~analyticsapi.models.Amount
        An object that defines the notional amount of the instrument. Required.
    rate : ~analyticsapi.models.InterestRateDefinition
        An object that defines the rate. Required.
    start_date : ~analyticsapi.models.Date
        An object that defines the start date of the interest payment period.
        Required.
    end_date : ~analyticsapi.models.Date
        An object that defines the end date of the interest payment period.
        Required.
    payment_offset : ~analyticsapi.models.OffsetDefinition
        An object that defines how the payment dates are derived from the
        interest period dates.
    settlement_type : str or ~analyticsapi.models.SettlementType
        An indicator that specifies how the payment is settled (e.g.,
        'Physical', 'Cash'). Known values are: "Cash" and "Physical".
    reference_rate : ~analyticsapi.models.Rate
        Required.
    """

    reference_rate: "_models.Rate" = rest_field(name="referenceRate")
    """Required."""

    @overload
    def __init__(
        self,
        *,
        notional: "_models.Amount",
        rate: "_models.InterestRateDefinition",
        start_date: "_models.Date",
        end_date: "_models.Date",
        reference_rate: "_models.Rate",
        payment_offset: Optional["_models.OffsetDefinition"] = None,
        settlement_type: Optional[Union[str, "_models.SettlementType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["reference_rate"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FraDefinitionTemplate(InstrumentTemplateDefinition, discriminator="ForwardRateAgreement"):
    """FraDefinitionTemplate.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.FORWARD_RATE_AGREEMENT
        Required. A foward rate agreement contract.
    template : ~analyticsapi.models.FraDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.FORWARD_RATE_AGREEMENT] = rest_discriminator(name="instrumentType")  # type: ignore
    """Required. A foward rate agreement contract."""
    template: "_models.FraDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.FraDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.FORWARD_RATE_AGREEMENT, **kwargs)


class FullDayDuration(Duration, discriminator="FullDayDuration"):
    """An object to determine the duration of the holiday taking into account a full day.

    Attributes
    ----------
    duration_type : str or ~analyticsapi.models.FULL_DAY_DURATION
        The type of the holiday duration. Only FullDayDuration value applies.
        Required. Full day holidays.
    full_day : int
        The number of full calendar days to determine the duration of the
        holiday. The minimum value is 1. Required.
    """

    duration_type: Literal[DurationType.FULL_DAY_DURATION] = rest_discriminator(name="durationType")  # type: ignore
    """The type of the holiday duration. Only FullDayDuration value applies. Required. Full day
     holidays."""
    full_day: int = rest_field(name="fullDay")
    """The number of full calendar days to determine the duration of the holiday. The minimum value is
     1. Required."""

    @overload
    def __init__(
        self,
        full_day: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, duration_type=DurationType.FULL_DAY_DURATION, **kwargs)


class FutureDate(Date, discriminator="FutureDate"):
    """FutureDate.

    Attributes
    ----------
    date_moving_convention : str or ~analyticsapi.models.DateMovingConvention
        The method to adjust dates to working days. The possible values are:
        ModifiedFollowing: dates are adjusted to the next business day
        convention unless it goes into the next month. In such case, the
        previous business day convention is used, NextBusinessDay: dates are
        moved to the following working day, PreviousBusinessDay: dates are
        moved to the preceding working day, NoMoving: dates are not adjusted,
        EveryThirdWednesday: dates are moved to the third Wednesday of the
        month, or to the next working day if the third Wednesday is not a
        working day, BbswModifiedFollowing: dates are adjusted to the next
        business day convention unless it goes into the next month, or crosses
        mid-month (15th). In such case, the previous business day convention is
        used. Default is ModifiedFollowing. Known values are:
        "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay",
        "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing".
    calendars : list[str]
        An array of calendars that should be used for the date adjustment.
        Typically the calendars are derived based on the instruments currency
        or crossCurrency code.  The default value is None, needs to be assigned
        before using.
    date_type : str or ~analyticsapi.models.FUTURE_DATE
        Required. The date is defined as adjusteable according the
        BusinessDayAdjustmentDefinition and the FutureDateCalculationMethod
    calculation_method : str or ~analyticsapi.models.FutureDateCalculationMethodEnum
        Required. Known values are: "SecondFriday", "ThirdWednesday",
        "FirstWorkingDay", "LastWorkingDay", "FirstCalendarDay",
        "FifteenthCalendarDay", and "NZL".
    month : str or ~analyticsapi.models.MonthEnum
        Required. Known values are: "January", "February", "March", "April",
        "May", "June", "July", "August", "September", "October", "November",
        and "December".
    year : int
        Required.
    """

    date_type: Literal[DateType.FUTURE_DATE] = rest_discriminator(name="dateType")  # type: ignore
    """Required. The date is defined as adjusteable according the BusinessDayAdjustmentDefinition and
     the FutureDateCalculationMethod"""
    calculation_method: Union[str, "_models.FutureDateCalculationMethodEnum"] = rest_field(name="calculationMethod")
    """Required. Known values are: \"SecondFriday\", \"ThirdWednesday\", \"FirstWorkingDay\",
     \"LastWorkingDay\", \"FirstCalendarDay\", \"FifteenthCalendarDay\", and \"NZL\"."""
    month: Union[str, "_models.MonthEnum"] = rest_field()
    """Required. Known values are: \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",
     \"July\", \"August\", \"September\", \"October\", \"November\", and \"December\"."""
    year: int = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        *,
        calculation_method: Union[str, "_models.FutureDateCalculationMethodEnum"],
        month: Union[str, "_models.MonthEnum"],
        year: int,
        date_moving_convention: Optional[Union[str, "_models.DateMovingConvention"]] = None,
        calendars: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, date_type=DateType.FUTURE_DATE, **kwargs)


class FuturesInstrumentDefinition(_model_base.Model):
    """FuturesInstrumentDefinition.

    Attributes
    ----------
    instrument_code : str
        Get instrumentCode.
    quotation_mode : str or ~analyticsapi.models.CurvesAndSurfacesQuotationModeEnum
        The quotation defining the price type of the instrument. The possible
        values are:   * ZeroCoupon   * ParYield. Known values are:
        "CashCleanPrice", "CashGrossPrice", "Discount", "DiscountMargin",
        "MoneyMarketYield", "Outright", "ParYield", "PercentCleanPrice",
        "PercentGrossPrice", "Price", "SimpleMargin", "Spread", "SwapPoint",
        "SwapPointInAbsoluteUnit", "Upfront", "Yield", and "ZeroCoupon".
    synthetic_instrument_code : str
        The code used to define the formula.
    template : str
        A reference to a style used to define the instrument.
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = rest_field(
        name="quotationMode"
    )
    """The quotation defining the price type of the instrument. The possible values are:   *
     ZeroCoupon   * ParYield. Known values are: \"CashCleanPrice\", \"CashGrossPrice\",
     \"Discount\", \"DiscountMargin\", \"MoneyMarketYield\", \"Outright\", \"ParYield\",
     \"PercentCleanPrice\", \"PercentGrossPrice\", \"Price\", \"SimpleMargin\", \"Spread\",
     \"SwapPoint\", \"SwapPointInAbsoluteUnit\", \"Upfront\", \"Yield\", and \"ZeroCoupon\"."""
    synthetic_instrument_code: Optional[str] = rest_field(name="syntheticInstrumentCode")
    """The code used to define the formula."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = None,
        synthetic_instrument_code: Optional[str] = None,
        template: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FuturesInstrumentDefinitionOutput(_model_base.Model):
    """FuturesInstrumentDefinitionOutput.

    Attributes
    ----------
    end_date : ~datetime.date
        The date used to define the end date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    instrument_code : str
        Get instrumentCode.
    quotation_mode : str or ~analyticsapi.models.CurvesAndSurfacesQuotationModeEnum
        The quotation defining the price type of the instrument. The possible
        values are:   * ZeroCoupon   * ParYield. Known values are:
        "CashCleanPrice", "CashGrossPrice", "Discount", "DiscountMargin",
        "MoneyMarketYield", "Outright", "ParYield", "PercentCleanPrice",
        "PercentGrossPrice", "Price", "SimpleMargin", "Spread", "SwapPoint",
        "SwapPointInAbsoluteUnit", "Upfront", "Yield", and "ZeroCoupon".
    start_date : ~datetime.date
        The date used to define the start date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    synthetic_instrument_code : str
        The code used to define the formula.
    template : str
        A reference to a style used to define the instrument.
    """

    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date used to define the end date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Get instrumentCode."""
    quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = rest_field(
        name="quotationMode"
    )
    """The quotation defining the price type of the instrument. The possible values are:   *
     ZeroCoupon   * ParYield. Known values are: \"CashCleanPrice\", \"CashGrossPrice\",
     \"Discount\", \"DiscountMargin\", \"MoneyMarketYield\", \"Outright\", \"ParYield\",
     \"PercentCleanPrice\", \"PercentGrossPrice\", \"Price\", \"SimpleMargin\", \"Spread\",
     \"SwapPoint\", \"SwapPointInAbsoluteUnit\", \"Upfront\", \"Yield\", and \"ZeroCoupon\"."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The date used to define the start date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    synthetic_instrument_code: Optional[str] = rest_field(name="syntheticInstrumentCode")
    """The code used to define the formula."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""

    @overload
    def __init__(
        self,
        *,
        end_date: Optional[datetime.date] = None,
        instrument_code: Optional[str] = None,
        quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = None,
        start_date: Optional[datetime.date] = None,
        synthetic_instrument_code: Optional[str] = None,
        template: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FuturesInstrumentDescription(_model_base.Model):
    """FuturesInstrumentDescription.

    Attributes
    ----------
    basis : list[str]
        Get basis.  The default value is None, needs to be assigned before
        using.
    fields : ~analyticsapi.models.BidAskFieldsDescription
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterDescription]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.FuturesInstrumentDefinition
    """

    basis: Optional[List[str]] = rest_field()
    """Get basis."""
    fields: Optional["_models.BidAskFieldsDescription"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.FuturesInstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        basis: Optional[List[str]] = None,
        fields: Optional["_models.BidAskFieldsDescription"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = None,
        instrument_definition: Optional["_models.FuturesInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxAnalyticsDescription(_model_base.Model):
    """The object that contains the analytic fields that describe the instrument.

    Attributes
    ----------
    valuation_date : ~datetime.date
        The date at which the instrument is valued. The date is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    start_date : ~analyticsapi.models.AdjustedDate
        "An object describing a start date of the instrument.".
    end_date : ~analyticsapi.models.AdjustedDate
        "An object describing a maturity date of the instrument.".
    """

    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """The date at which the instrument is valued. The date is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z')."""
    start_date: Optional["_models.AdjustedDate"] = rest_field(name="startDate")
    """\"An object describing a start date of the instrument.\"."""
    end_date: Optional["_models.AdjustedDate"] = rest_field(name="endDate")
    """\"An object describing a maturity date of the instrument.\"."""

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.date] = None,
        start_date: Optional["_models.AdjustedDate"] = None,
        end_date: Optional["_models.AdjustedDate"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxCurveInput(_model_base.Model):
    """The object defining the 3rd party fx curve.

    Attributes
    ----------
    fx_type : str or ~analyticsapi.models.FxRateTypeEnum
        The type of values provided (outright rates or swap points). Required.
        Known values are: "Outright" and "Swapoint".
    points : list[~analyticsapi.models.CurveDataPoint]
        The list of dates and values. Required.  The default value is None,
        needs to be assigned before using.
    fx_cross_code : str
        The ISO code of the cross currency pair. Required.
    """

    fx_type: Union[str, "_models.FxRateTypeEnum"] = rest_field(name="fxType")
    """The type of values provided (outright rates or swap points). Required. Known values are:
     \"Outright\" and \"Swapoint\"."""
    points: List["_models.CurveDataPoint"] = rest_field()
    """The list of dates and values. Required."""
    fx_cross_code: str = rest_field(name="fxCrossCode")
    """The ISO code of the cross currency pair. Required."""

    @overload
    def __init__(
        self,
        *,
        fx_type: Union[str, "_models.FxRateTypeEnum"],
        points: List["_models.CurveDataPoint"],
        fx_cross_code: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForward(_model_base.Model):
    """Object defining a FxForward resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.FX_FORWARD
        Property defining the type of the resource.
    id : str
        Unique identifier of the FxForward.
    location : ~analyticsapi.models.Location
        Object defining the location of the FxForward in the platform.
        Required.
    description : ~analyticsapi.models.Description
        Object defining metadata for the FxForward.
    definition : ~analyticsapi.models.FxForwardDefinition
        Object defining the FxForward. Required.
    """

    type: Optional[Literal[ResourceType.FX_FORWARD]] = rest_field(visibility=["read"], default=ResourceType.FX_FORWARD)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the FxForward."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining the location of the FxForward in the platform. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining metadata for the FxForward."""
    definition: "_models.FxForwardDefinition" = rest_field()
    """Object defining the FxForward. Required."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        definition: "_models.FxForwardDefinition",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardAnalyticsDescription(FxAnalyticsDescription):
    """The object that contains the analytic fields that describe the instrument.

    Attributes
    ----------
    valuation_date : ~datetime.date
        The date at which the instrument is valued. The date is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    start_date : ~analyticsapi.models.AdjustedDate
        "An object describing a start date of the instrument.".
    end_date : ~analyticsapi.models.AdjustedDate
        "An object describing a maturity date of the instrument.".
    """

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.date] = None,
        start_date: Optional["_models.AdjustedDate"] = None,
        end_date: Optional["_models.AdjustedDate"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardAnalyticsPricingOnResourceResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """FxForwardAnalyticsPricingOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.FxForward
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.FxPricingParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.FxForwardAnalyticsPricingResponseWithError
        The result of the calculation request.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    resource: Optional["_models.FxForward"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.FxPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.FxForwardAnalyticsPricingResponseWithError"] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.FxForward"] = None,
        pricing_preferences: Optional["_models.FxPricingParameters"] = None,
        analytics: Optional["_models.FxForwardAnalyticsPricingResponseWithError"] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardAnalyticsPricingResponseData(_model_base.Model):
    """FxForwardAnalyticsPricingResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.FxForwardDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.FxPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.FxForwardAnalyticsPricingResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.FxForwardDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.FxPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.FxForwardAnalyticsPricingResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.FxForwardDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.FxPricingParameters"] = None,
        analytics: Optional[List["_models.FxForwardAnalyticsPricingResponseWithError"]] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardAnalyticsPricingResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    description : ~analyticsapi.models.FxForwardAnalyticsDescription
        The analytics fields that describe the instrument.
    pricing_analysis : ~analyticsapi.models.FxForwardPricingAnalysis
        The analytics fields that are linked to a pre-trade analysis of the
        instrument.
    greeks : ~analyticsapi.models.FxForwardRisk
        The analytics fields that are linked to a risk analysis of the
        instrument.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    description: Optional["_models.FxForwardAnalyticsDescription"] = rest_field()
    """The analytics fields that describe the instrument."""
    pricing_analysis: Optional["_models.FxForwardPricingAnalysis"] = rest_field(name="pricingAnalysis")
    """The analytics fields that are linked to a pre-trade analysis of the instrument."""
    greeks: Optional["_models.FxForwardRisk"] = rest_field()
    """The analytics fields that are linked to a risk analysis of the instrument."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        description: Optional["_models.FxForwardAnalyticsDescription"] = None,
        pricing_analysis: Optional["_models.FxForwardPricingAnalysis"] = None,
        greeks: Optional["_models.FxForwardRisk"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardAnalyticsValuationOnResourceResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """FxForwardAnalyticsValuationOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.FxForward
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.FxPricingParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.FxForwardAnalyticsValuationResponseWithError
        The result of the calculation request.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    resource: Optional["_models.FxForward"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.FxPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.FxForwardAnalyticsValuationResponseWithError"] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.FxForward"] = None,
        pricing_preferences: Optional["_models.FxPricingParameters"] = None,
        analytics: Optional["_models.FxForwardAnalyticsValuationResponseWithError"] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardAnalyticsValuationResponseData(_model_base.Model):
    """FxForwardAnalyticsValuationResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.FxForwardDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.FxPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.FxForwardAnalyticsValuationResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.FxForwardDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.FxPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.FxForwardAnalyticsValuationResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.FxForwardDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.FxPricingParameters"] = None,
        analytics: Optional[List["_models.FxForwardAnalyticsValuationResponseWithError"]] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardAnalyticsValuationResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    description : ~analyticsapi.models.FxForwardAnalyticsDescription
        The analytics fields that describe the instrument.
    valuation : ~analyticsapi.models.FxForwardValuation
        The analytics fields that are linked to a post-trade analysis of the
        instrument.
    greeks : ~analyticsapi.models.FxForwardRisk
        The analytics fields that are linked to a risk analysis of the
        instrument.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    description: Optional["_models.FxForwardAnalyticsDescription"] = rest_field()
    """The analytics fields that describe the instrument."""
    valuation: Optional["_models.FxForwardValuation"] = rest_field()
    """The analytics fields that are linked to a post-trade analysis of the instrument."""
    greeks: Optional["_models.FxForwardRisk"] = rest_field()
    """The analytics fields that are linked to a risk analysis of the instrument."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        description: Optional["_models.FxForwardAnalyticsDescription"] = None,
        valuation: Optional["_models.FxForwardValuation"] = None,
        greeks: Optional["_models.FxForwardRisk"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardArrayPriceResponse(_model_base.Model):
    """Object defining the response of a pricing request for a collection of FxForward instruments.

    Attributes
    ----------
    data : ~analyticsapi.models.FxForwardAnalyticsPricingResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.FxForwardAnalyticsPricingResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxForwardAnalyticsPricingResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxForwardArrayValuationResponse(_model_base.Model):
    """Object defining the response of a valuation request for a collection of FxForward instruments.

    Attributes
    ----------
    data : ~analyticsapi.models.FxForwardAnalyticsValuationResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.FxForwardAnalyticsValuationResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxForwardAnalyticsValuationResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxForwardCollectionLinks(_model_base.Model):
    """Object defining the related links available for a collection of FxForward instruments.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCollectionResponse(_model_base.Model):
    """Object defining the paged response for a collection of FxForward instruments.

    Attributes
    ----------
    data : list[~analyticsapi.models.FxForwardInfo]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.FxForwardCollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.FxForwardInfo"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.FxForwardCollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.FxForwardInfo"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.FxForwardCollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardConstituent(FxConstituent, discriminator="FxForward"):
    """An object defining an fx forward constituent of an fx forward curve.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.FX_FORWARD
        The type of the instrument used as a constituent. FxForward is the only
        valid value. Required.
    definition : ~analyticsapi.models.FxForwardConstituentDefinition
        An object to define the instrument used as a constituent.
    """

    type: Literal[FxConstituentEnum.FX_FORWARD] = rest_discriminator(name="type")  # type: ignore
    """The type of the instrument used as a constituent. FxForward is the only valid value. Required."""
    definition: Optional["_models.FxForwardConstituentDefinition"] = rest_field()
    """An object to define the instrument used as a constituent."""

    @overload
    def __init__(
        self,
        *,
        quote: Optional["_models.Quote"] = None,
        definition: Optional["_models.FxForwardConstituentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=FxConstituentEnum.FX_FORWARD, **kwargs)


class FxForwardConstituentDefinition(_model_base.Model):
    """The definition of an fx forward instrument used as a constituent of an fx forward curve.

    Attributes
    ----------
    tenor : str
        The code indicating the tenor of the instrument used as a constituent
        (e.g., '1M', '1Y'). Required.
    template : str
        A pre-defined template can be used as an input by the user. It is the
        currency code of the constituent. Required.
    """

    tenor: str = rest_field()
    """The code indicating the tenor of the instrument used as a constituent (e.g., '1M', '1Y').
     Required."""
    template: str = rest_field()
    """A pre-defined template can be used as an input by the user. It is the currency code of the
     constituent. Required."""

    @overload
    def __init__(
        self,
        *,
        tenor: str,
        template: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurve(_model_base.Model):
    """A model defining a FxForward Curve resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.FX_FORWARD_CURVE
        Property defining the type of the resource.
    id : str
        Unique identifier of the FxForwardCurve.
    location : ~analyticsapi.models.Location
        Object defining the location of the FxForwardCurve in the platform.
        Required.
    description : ~analyticsapi.models.Description
        Object defining metadata for the FxForwardCurve.
    definition : ~analyticsapi.models.FxForwardCurveDefinition
        Object defining the FxForwardCurve. Required.
    """

    type: Optional[Literal[ResourceType.FX_FORWARD_CURVE]] = rest_field(
        visibility=["read"], default=ResourceType.FX_FORWARD_CURVE
    )
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the FxForwardCurve."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining the location of the FxForwardCurve in the platform. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining metadata for the FxForwardCurve."""
    definition: "_models.FxForwardCurveDefinition" = rest_field()
    """Object defining the FxForwardCurve. Required."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        definition: "_models.FxForwardCurveDefinition",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveCalculateArrayResponse(_model_base.Model):
    """A model describing the response returned for a FxForward curve calculation request where the
    curve is provided as part of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.FxForwardCurveDataResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.FxForwardCurveDataResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxForwardCurveDataResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxForwardCurveCalculateResponse(_model_base.Model):
    """A model describing the response returned for a FxForward curve calculation request performed on
    an exsting curve.

    Attributes
    ----------
    data : ~analyticsapi.models.FxForwardCurveDataOnResourceResponseData
        Required.
    """

    data: "_models.FxForwardCurveDataOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxForwardCurveDataOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxForwardCurveCalculationParameters(CurveCalculationParameters):
    """An object that contains parameters used to define how the Fx Forward curve is constructed from
    the constituents.

    Attributes
    ----------
    valuation_date : ~datetime.date
        The date on which the curve is constructed. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01'). The valuation date
        should not be in the future. Default is Today.
    valuation_time : ~analyticsapi.models.ValuationTime
        an object to define the time on witch the curve is constructed.
    curve_tenors : list[str]
        An array of user-defined tenors for which curve points to be computed.
        The values are expressed in:

        * time period code for tenors (e.g., '1M', '1Y'),
        * ISO 8601 format 'YYYY-MM-DD' for dates (e.g., '2023-01-01').  The default value is None,
        needs to be assigned before using.
    fx_forward_curve_calculation_preferences : ~analyticsapi.models.FxForwardCurveCalculationPreferences
        An object to define calculation preferences for the curve.
    """

    fx_forward_curve_calculation_preferences: Optional["_models.FxForwardCurveCalculationPreferences"] = rest_field(
        name="fxForwardCurveCalculationPreferences"
    )
    """An object to define calculation preferences for the curve."""

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.date] = None,
        valuation_time: Optional["_models.ValuationTime"] = None,
        curve_tenors: Optional[List[str]] = None,
        fx_forward_curve_calculation_preferences: Optional["_models.FxForwardCurveCalculationPreferences"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["fx_forward_curve_calculation_preferences"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxForwardCurveCalculationPreferences(_model_base.Model):
    """An object to define calculation preferences for the curve.

    Attributes
    ----------
    extrapolation_mode : str or ~analyticsapi.models.ExtrapolationMode
        The extrapolation method used in the curve bootstrapping. The default
        is Constant. Known values are: "Constant" and "Linear".
    interpolation_mode : str or ~analyticsapi.models.FxForwardCurveInterpolationMode
        The interpolation method used in the curve bootstrapping. The default
        is Linear. Known values are: "CubicSpline", "Constant", and "Linear".
    use_delayed_data_if_denied : bool
        An indicator of whether the delayed data defined in request is used.
        The default is false.
    ignore_invalid_instruments : bool
        An indicator of whether invalid instruments are ignored for the curve
        construction. The default is true.
    ignore_pivot_currency_holidays : bool
        An indicator of whether holidays of the pivot currency are included or
        not in the pricing when dates are calculated. The default is false.
    """

    extrapolation_mode: Optional[Union[str, "_models.ExtrapolationMode"]] = rest_field(name="extrapolationMode")
    """The extrapolation method used in the curve bootstrapping. The default is Constant. Known values
     are: \"Constant\" and \"Linear\"."""
    interpolation_mode: Optional[Union[str, "_models.FxForwardCurveInterpolationMode"]] = rest_field(
        name="interpolationMode"
    )
    """The interpolation method used in the curve bootstrapping. The default is Linear. Known values
     are: \"CubicSpline\", \"Constant\", and \"Linear\"."""
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")
    """An indicator of whether the delayed data defined in request is used. The default is false."""
    ignore_invalid_instruments: Optional[bool] = rest_field(name="ignoreInvalidInstruments")
    """An indicator of whether invalid instruments are ignored for the curve construction. The default
     is true."""
    ignore_pivot_currency_holidays: Optional[bool] = rest_field(name="ignorePivotCurrencyHolidays")
    """An indicator of whether holidays of the pivot currency are included or not in the pricing when
     dates are calculated. The default is false."""

    @overload
    def __init__(
        self,
        *,
        extrapolation_mode: Optional[Union[str, "_models.ExtrapolationMode"]] = None,
        interpolation_mode: Optional[Union[str, "_models.FxForwardCurveInterpolationMode"]] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
        ignore_invalid_instruments: Optional[bool] = None,
        ignore_pivot_currency_holidays: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveChoice(_model_base.Model):
    """Object that represents an FxForward curve in one of two ways: Provide either a reference to a
    curve saved on the platform, or a list of data points.

    Attributes
    ----------
    reference : str
        The identifier of the FX curve definition resource (UUID or URI). The
        default space is LSEG if not provided in URI format.
    curve : ~analyticsapi.models.FxCurveInput
        An object to define the curve data points.
    """

    reference: Optional[str] = rest_field()
    """The identifier of the FX curve definition resource (UUID or URI). The default space is LSEG if
     not provided in URI format."""
    curve: Optional["_models.FxCurveInput"] = rest_field()
    """An object to define the curve data points."""

    @overload
    def __init__(
        self,
        *,
        reference: Optional[str] = None,
        curve: Optional["_models.FxCurveInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveCollectionLinks(_model_base.Model):
    """FxForwardCurveCollectionLinks.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveCollectionResponse(_model_base.Model):
    """A model describing a paged FXForward Curve response.

    Attributes
    ----------
    data : list[~analyticsapi.models.FxForwardCurveInfo]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.FxForwardCurveCollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.FxForwardCurveInfo"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.FxForwardCurveCollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.FxForwardCurveInfo"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.FxForwardCurveCollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveDataOnResourceResponseData(_model_base.Model):
    """FxForwardCurveDataOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.FxForwardCurve
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.FxForwardCurveCalculationParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.FxForwardCurveDataResponseWithError
        The result of the calculation request.
    """

    resource: Optional["_models.FxForwardCurve"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.FxForwardCurveCalculationParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.FxForwardCurveDataResponseWithError"] = rest_field()
    """The result of the calculation request."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.FxForwardCurve"] = None,
        pricing_preferences: Optional["_models.FxForwardCurveCalculationParameters"] = None,
        analytics: Optional["_models.FxForwardCurveDataResponseWithError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveDataResponseData(_model_base.Model):
    """FxForwardCurveDataResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.FxForwardCurveDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.FxForwardCurveCalculationParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.FxForwardCurveDataResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    """

    definitions: Optional[List["_models.FxForwardCurveDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.FxForwardCurveCalculationParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.FxForwardCurveDataResponseWithError"]] = rest_field()
    """The result of the calculation request."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.FxForwardCurveDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.FxForwardCurveCalculationParameters"] = None,
        analytics: Optional[List["_models.FxForwardCurveDataResponseWithError"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveDataResponseWithError(_model_base.Model):
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    constituents : list[~analyticsapi.models.FxConstituent]
        An array of objects describing constituents of the curve.  The default
        value is None, needs to be assigned before using.
    outright_curve : ~analyticsapi.models.FxOutrightCurveDescription
        An object that contains curve points and curve type. Required.
    underlying_curves : list[~analyticsapi.models.Curve]
        An object that contains the underlying curves used to construct the
        curve.  The default value is None, needs to be assigned before using.
    invalid_constituents : list[~analyticsapi.models.FxConstituent]
        An array of objects to define constituents that are part of the curve
        definition but cannot be used during the curve construction.  The
        default value is None, needs to be assigned before using.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    constituents: Optional[List["_models.FxConstituent"]] = rest_field()
    """An array of objects describing constituents of the curve."""
    outright_curve: "_models.FxOutrightCurveDescription" = rest_field(name="outrightCurve")
    """An object that contains curve points and curve type. Required."""
    underlying_curves: Optional[List["_models.Curve"]] = rest_field(name="underlyingCurves")
    """An object that contains the underlying curves used to construct the curve."""
    invalid_constituents: Optional[List["_models.FxConstituent"]] = rest_field(name="invalidConstituents")
    """An array of objects to define constituents that are part of the curve definition but cannot be
     used during the curve construction."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        outright_curve: "_models.FxOutrightCurveDescription",
        constituents: Optional[List["_models.FxConstituent"]] = None,
        underlying_curves: Optional[List["_models.Curve"]] = None,
        invalid_constituents: Optional[List["_models.FxConstituent"]] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveDefinition(_model_base.Model):
    """An object that defines the Fx Forward Curve resource. If only the cross currency pair is
    provided, with no optional details, the service will try to build a curve 'on the fly' from the
    list constituents available for this currency pair.
    If there is no direct quotation, the service will attempt to use a reference currency (first
    selecting USD, then EUR). In this case the return will be derived from the underlying curves
    constructed for each currency against the reference currency.
    If the reference currency and/or constituents are provided, the service will use them to create
    a custom curve. For a better result, please use the LSEG curve if it exists for a cross
    currency pair.
    The list type properties will not be initialized as empty list by default. A list of objects
    should be assigned first before adding new elements.

    Attributes
    ----------
    cross_currency : str
        A string to define the cross currency pair of the curve, expressed in
        ISO 4217 alphabetical format (e.g., 'EURCHF'). Value is limited to
        maximum of 6 characters. Required.
    reference_currency : str
        A string to define the reference currency for the cross currency pair
        of the curve, expressed in ISO 4217 alphabetical format (e.g., 'EUR').
        Value is limited to maximum of 3 characters. Optional. The reference
        currency is not used:

        * when a curve definition is created from FX spot and FX Foward instruments (on the fly
        request) available for the requested currency pair,
        * when curve points are calculated using an LSEG curve available for the requested currency
        pair.

        If a curve defintion with the same crossCurrency code dosn't exist, USD will be used as the
        reference currency.
        When the reference currency is provided (e.g., USD), constituents are calculated for each
        currency of the currency pair against the reference currency (e.g., EURUSD and GBPUSD).
        Please note that a reference currency must be provided:

        * when constituents are overridden using a pivot currency (e.g., EURUSD and GBPUSD),
        * when a non-standard quotation of the existing curve is used (except when one of the
        currencies is USD or EUR).

        The reference currency should be left empty if the quotation is direct or if the template used
        quotes the cross currency directly.
    constituents : list[~analyticsapi.models.FxConstituent]
        An array of objects to define constituents that are used to construct
        the curve. If not provided, constituents are retrieved from the market
        data.

        * If there is a pivot currency, two sets of constituents are required, each composed of 1
        FxSpot and at least one other constituent.
        * If there is no pivot currency (i.e. a direct cross currency), only one set of constituents is
        needed, with 1 FxSpot and at least one other constituent.

        Optional.  The default value is None, needs to be assigned before using.
    discount_curves : list[~analyticsapi.models.DiscountCurveAssignment]
        The list of interest rate curve assignments to be used as discount
        curves.  The default value is None, needs to be assigned before using.
    forward_curves : list[~analyticsapi.models.ForwardCurveAssignment]
        The list of interest rate curve assignments used to generate forward
        interest rates.  The default value is None, needs to be assigned before
        using.
    """

    cross_currency: str = rest_field(name="crossCurrency")
    """A string to define the cross currency pair of the curve, expressed in ISO 4217 alphabetical
     format (e.g., 'EURCHF'). Value is limited to maximum of 6 characters. Required."""
    reference_currency: Optional[str] = rest_field(name="referenceCurrency")
    """A string to define the reference currency for the cross currency pair of the curve, expressed
     in ISO 4217 alphabetical format (e.g., 'EUR'). Value is limited to maximum of 3 characters.
     Optional.
     The reference currency is not used:
     
     
     * when a curve definition is created from FX spot and FX Foward instruments (on the fly
     request) available for the requested currency pair,
     * when curve points are calculated using an LSEG curve available for the requested currency
     pair.
     
     If a curve defintion with the same crossCurrency code dosn't exist, USD will be used as the
     reference currency.
     When the reference currency is provided (e.g., USD), constituents are calculated for each
     currency of the currency pair against the reference currency (e.g., EURUSD and GBPUSD).
     Please note that a reference currency must be provided:
     
     
     * when constituents are overridden using a pivot currency (e.g., EURUSD and GBPUSD),
     * when a non-standard quotation of the existing curve is used (except when one of the
     currencies is USD or EUR).
     
     The reference currency should be left empty if the quotation is direct or if the template used
     quotes the cross currency directly."""
    constituents: Optional[List["_models.FxConstituent"]] = rest_field()
    """An array of objects to define constituents that are used to construct the curve. If not
     provided, constituents are retrieved from the market data.
     
     
     * If there is a pivot currency, two sets of constituents are required, each composed of 1
     FxSpot and at least one other constituent.
     * If there is no pivot currency (i.e. a direct cross currency), only one set of constituents is
     needed, with 1 FxSpot and at least one other constituent.
     
     Optional."""
    discount_curves: Optional[List["_models.DiscountCurveAssignment"]] = rest_field(name="discountCurves")
    """The list of interest rate curve assignments to be used as discount curves."""
    forward_curves: Optional[List["_models.ForwardCurveAssignment"]] = rest_field(name="forwardCurves")
    """The list of interest rate curve assignments used to generate forward interest rates."""

    @overload
    def __init__(
        self,
        *,
        cross_currency: str,
        reference_currency: Optional[str] = None,
        constituents: Optional[List["_models.FxConstituent"]] = None,
        discount_curves: Optional[List["_models.DiscountCurveAssignment"]] = None,
        forward_curves: Optional[List["_models.ForwardCurveAssignment"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.FxForwardCurveDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.FxForwardCurveDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.FxForwardCurveDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveInfo(_model_base.Model):
    """A model partially describing the FXForward Curve returned by the GET list service.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.FX_FORWARD_CURVE
        Property defining the type of the resource.
    id : str
        Unique identifier of the FxForwardCurve.
    location : ~analyticsapi.models.Location
        Object defining metadata for the FxForwardCurve. Required.
    description : ~analyticsapi.models.Description
        Object defining the FxForwardCurve.
    """

    type: Optional[Literal[ResourceType.FX_FORWARD_CURVE]] = rest_field(
        visibility=["read"], default=ResourceType.FX_FORWARD_CURVE
    )
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the FxForwardCurve."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining metadata for the FxForwardCurve. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining the FxForwardCurve."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardCurveResponse(_model_base.Model):
    """A model template describing a single response.

    Attributes
    ----------
    data : ~analyticsapi.models.FxForwardCurve
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.FxForwardCurve" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.FxForwardCurve",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotDefinition(_model_base.Model):
    """Definition of the Fx Spot.

    Attributes
    ----------
    quoted_currency : str
        Quoted currency code, expressed in ISO 4217 alphabetical format (e.g.,
        'CHF'). Required.
    base_currency : str
        Base  currency code, expressed in ISO 4217 alphabetical format (e.g.,
        'CHF'). Required.
    deal_amount : float
        The amount of the deal (base) currency bought or sold.
    contra_amount : float
        The amount of the quoted currency exchanged to buy or sell the
        dealAmount of the base currency. Either contraAmount or rate can be
        specified, but not both. Otherwise, an error will be returned. If
        contraAmount is not provided, it is calculated as dealAmount  FX rate.
        If contraAmount is provided, the FX rate is calculated as contraAmount
         dealAmount.
    rate : ~analyticsapi.models.FxRate
        An object that defines the exchange rate agreed by counterparties.
        Either rate or contraAmount can be specified, but not both. Otherwise,
        an error will be returned. If rate is not provided, it is calculated as
        contraAmount  dealAmount or retrieved from market data. If rate is
        provided, contraAmount is calculated as dealAmount  FX rate.
    start_date : ~analyticsapi.models.Date
        The start date of the instrument. Possible values are: AdjustableDate
        object - requires a date expressed in ISO 8601 format: YYYY-MM-DD
        (e.g., '2021-01-01'). Or a RelativeAdjustableDate - requires a tenor
        expressed as a code indicating the period between
        referenceDate(default=startDate) to endDate of the instrument (e.g.,
        '6M', '1Y'). Only NextBusinessDay is supported for
        DateMovingConvention. For spot date, tenor can only be "SN" (spot next)
        or "SW" (spot week). Default is a spot date.
    end_date : ~analyticsapi.models.Date
        The maturity date of the instrument. Possible values are:
        AdjustableDate object - requires a date expressed in ISO 8601 format:
        YYYY-MM-DD (e.g., '2021-01-01'). Or a RelativeAdjustableDate - requires
        a tenor expressed as a code indicating the period between
        referenceDate(default=startDate) to endDate of the instrument (e.g.,
        '6M', '1Y'). Only NextBusinessDay is supported for
        DateMovingConvention. For spot date, tenor can only be "SN" (spot next)
        or "SW" (spot week).
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) who will pay the contraAmount and receive
        the dealAmount. Known values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) who will receive the contraAmount and pay
        the dealAmount. Known values are: "Party1" and "Party2".
    """

    quoted_currency: str = rest_field(name="quotedCurrency")
    """Quoted currency code, expressed in ISO 4217 alphabetical format (e.g., 'CHF'). Required."""
    base_currency: str = rest_field(name="baseCurrency")
    """Base  currency code, expressed in ISO 4217 alphabetical format (e.g., 'CHF'). Required."""
    deal_amount: Optional[float] = rest_field(name="dealAmount")
    """The amount of the deal (base) currency bought or sold."""
    contra_amount: Optional[float] = rest_field(name="contraAmount")
    """The amount of the quoted currency exchanged to buy or sell the dealAmount of the base currency.
     Either contraAmount or rate can be specified, but not both. Otherwise, an error will be
     returned.
     If contraAmount is not provided, it is calculated as dealAmount  FX rate.
     If contraAmount is provided, the FX rate is calculated as contraAmount  dealAmount."""
    rate: Optional["_models.FxRate"] = rest_field()
    """An object that defines the exchange rate agreed by counterparties.
     Either rate or contraAmount can be specified, but not both. Otherwise, an error will be
     returned.
     If rate is not provided, it is calculated as contraAmount  dealAmount or retrieved from market
     data.
     If rate is provided, contraAmount is calculated as dealAmount  FX rate."""
    start_date: Optional["_models.Date"] = rest_field(name="startDate")
    """The start date of the instrument. Possible values are: AdjustableDate object - requires a date
     expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
     Or a RelativeAdjustableDate - requires a tenor expressed as a code indicating the period
     between referenceDate(default=startDate) to endDate of the instrument (e.g., '6M', '1Y').
     Only NextBusinessDay is supported for DateMovingConvention.
     For spot date, tenor can only be \"SN\" (spot next) or \"SW\" (spot week).
     Default is a spot date."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """The maturity date of the instrument. Possible values are: AdjustableDate object - requires a
     date expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
     Or a RelativeAdjustableDate - requires a tenor expressed as a code indicating the period
     between referenceDate(default=startDate) to endDate of the instrument (e.g., '6M', '1Y').
     Only NextBusinessDay is supported for DateMovingConvention.
     For spot date, tenor can only be \"SN\" (spot next) or \"SW\" (spot week)."""
    payer: Optional[Union[str, "_models.PartyEnum"]] = rest_field()
    """The party (Party1 or Party2) who will pay the contraAmount and receive the dealAmount. Known
     values are: \"Party1\" and \"Party2\"."""
    receiver: Optional[Union[str, "_models.PartyEnum"]] = rest_field()
    """The party (Party1 or Party2) who will receive the contraAmount and pay the dealAmount. Known
     values are: \"Party1\" and \"Party2\"."""

    @overload
    def __init__(
        self,
        *,
        quoted_currency: str,
        base_currency: str,
        deal_amount: Optional[float] = None,
        contra_amount: Optional[float] = None,
        rate: Optional["_models.FxRate"] = None,
        start_date: Optional["_models.Date"] = None,
        end_date: Optional["_models.Date"] = None,
        payer: Optional[Union[str, "_models.PartyEnum"]] = None,
        receiver: Optional[Union[str, "_models.PartyEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardDefinition(FxSpotDefinition):
    """Definition of the Fx Forward.

    Attributes
    ----------
    quoted_currency : str
        Quoted currency code, expressed in ISO 4217 alphabetical format (e.g.,
        'CHF'). Required.
    base_currency : str
        Base  currency code, expressed in ISO 4217 alphabetical format (e.g.,
        'CHF'). Required.
    deal_amount : float
        The amount of the deal (base) currency bought or sold.
    contra_amount : float
        The amount of the quoted currency exchanged to buy or sell the
        dealAmount of the base currency. Either contraAmount or rate can be
        specified, but not both. Otherwise, an error will be returned. If
        contraAmount is not provided, it is calculated as dealAmount  FX rate.
        If contraAmount is provided, the FX rate is calculated as contraAmount
         dealAmount.
    rate : ~analyticsapi.models.FxRate
        An object that defines the exchange rate agreed by counterparties.
        Either rate or contraAmount can be specified, but not both. Otherwise,
        an error will be returned. If rate is not provided, it is calculated as
        contraAmount  dealAmount or retrieved from market data. If rate is
        provided, contraAmount is calculated as dealAmount  FX rate.
    start_date : ~analyticsapi.models.Date
        The start date of the instrument. Possible values are: AdjustableDate
        object - requires a date expressed in ISO 8601 format: YYYY-MM-DD
        (e.g., '2021-01-01'). Or a RelativeAdjustableDate - requires a tenor
        expressed as a code indicating the period between
        referenceDate(default=startDate) to endDate of the instrument (e.g.,
        '6M', '1Y'). Only NextBusinessDay is supported for
        DateMovingConvention. For spot date, tenor can only be "SN" (spot next)
        or "SW" (spot week). Default is a spot date.
    end_date : ~analyticsapi.models.Date
        The maturity date of the instrument. Possible values are:
        AdjustableDate object - requires a date expressed in ISO 8601 format:
        YYYY-MM-DD (e.g., '2021-01-01'). Or a RelativeAdjustableDate - requires
        a tenor expressed as a code indicating the period between
        referenceDate(default=startDate) to endDate of the instrument (e.g.,
        '6M', '1Y'). Only NextBusinessDay is supported for
        DateMovingConvention. For spot date, tenor can only be "SN" (spot next)
        or "SW" (spot week).
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) who will pay the contraAmount and receive
        the dealAmount. Known values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) who will receive the contraAmount and pay
        the dealAmount. Known values are: "Party1" and "Party2".
    settlement_type : str or ~analyticsapi.models.SettlementType
        The Flag that specifies how the instrument is settled (e.g. Physical,
        Cash). Known values are: "Cash" and "Physical".
    """

    settlement_type: Optional[Union[str, "_models.SettlementType"]] = rest_field(name="settlementType")
    """The Flag that specifies how the instrument is settled (e.g. Physical, Cash). Known values are:
     \"Cash\" and \"Physical\"."""

    @overload
    def __init__(
        self,
        *,
        quoted_currency: str,
        base_currency: str,
        deal_amount: Optional[float] = None,
        contra_amount: Optional[float] = None,
        rate: Optional["_models.FxRate"] = None,
        start_date: Optional["_models.Date"] = None,
        end_date: Optional["_models.Date"] = None,
        payer: Optional[Union[str, "_models.PartyEnum"]] = None,
        receiver: Optional[Union[str, "_models.PartyEnum"]] = None,
        settlement_type: Optional[Union[str, "_models.SettlementType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["settlement_type"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxForwardDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.FxForwardDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.FxForwardDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.FxForwardDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardFromTemplateResponse(_model_base.Model):
    """Object defining the response to the creation of a FxForward from a reference to a template and
    a list of overridden values.

    Attributes
    ----------
    data : ~analyticsapi.models.FxForwardDefinition
        An object that describes the instrument generated by the request.
        Required.
    """

    data: "_models.FxForwardDefinition" = rest_field()
    """An object that describes the instrument generated by the request. Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxForwardDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxForwardInfo(_model_base.Model):
    """Object defining the related links available on a FxForward resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.FX_FORWARD
        Property defining the type of the resource.
    id : str
        Unique identifier of the FxForward.
    location : ~analyticsapi.models.Location
        Object defining metadata for the FxForward. Required.
    description : ~analyticsapi.models.Description
        Object defining the FxForward.
    """

    type: Optional[Literal[ResourceType.FX_FORWARD]] = rest_field(visibility=["read"], default=ResourceType.FX_FORWARD)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the FxForward."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining metadata for the FxForward. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining the FxForward."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardInstrument(_model_base.Model):
    """FxForwardInstrument.

    Attributes
    ----------
    fields : ~analyticsapi.models.CurvesAndSurfacesBidAskFields
    formula : str
        The formula used to adjust market data values of the instrument's Bid
        and Ask price side. For example, '100-marketPrice'.
    formula_parameters : list[~analyticsapi.models.FormulaParameter]
        The list of formula parameters used to adjust market data values of the
        instrument's Bid and Ask price side.  The default value is None, needs
        to be assigned before using.
    instrument_definition : ~analyticsapi.models.FxForwardInstrumentDefinition
    """

    fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """The formula used to adjust market data values of the instrument's Bid and Ask price side. For
     example, '100-marketPrice'."""
    formula_parameters: Optional[List["_models.FormulaParameter"]] = rest_field(name="formulaParameters")
    """The list of formula parameters used to adjust market data values of the instrument's Bid and
     Ask price side."""
    instrument_definition: Optional["_models.FxForwardInstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameter"]] = None,
        instrument_definition: Optional["_models.FxForwardInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardInstrumentDefinition(_model_base.Model):
    """FxForwardInstrumentDefinition.

    Attributes
    ----------
    instrument_code : str
        The code used to define the instrument.
    is_non_deliverable : bool
    quotation_mode : str or ~analyticsapi.models.CurvesAndSurfacesQuotationModeEnum
        Get quotationMode. Known values are: "CashCleanPrice",
        "CashGrossPrice", "Discount", "DiscountMargin", "MoneyMarketYield",
        "Outright", "ParYield", "PercentCleanPrice", "PercentGrossPrice",
        "Price", "SimpleMargin", "Spread", "SwapPoint",
        "SwapPointInAbsoluteUnit", "Upfront", "Yield", and "ZeroCoupon".
    synthetic_instrument_code : str
        The code used to define the formula.
    template : str
        A reference to a style used to define the instrument.
    tenor : str
        The code indicating the instrument tenor (e.g., '6M', '1Y').
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = rest_field(
        name="quotationMode"
    )
    """Get quotationMode. Known values are: \"CashCleanPrice\", \"CashGrossPrice\", \"Discount\",
     \"DiscountMargin\", \"MoneyMarketYield\", \"Outright\", \"ParYield\", \"PercentCleanPrice\",
     \"PercentGrossPrice\", \"Price\", \"SimpleMargin\", \"Spread\", \"SwapPoint\",
     \"SwapPointInAbsoluteUnit\", \"Upfront\", \"Yield\", and \"ZeroCoupon\"."""
    synthetic_instrument_code: Optional[str] = rest_field(name="syntheticInstrumentCode")
    """The code used to define the formula."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""
    tenor: Optional[str] = rest_field()
    """The code indicating the instrument tenor (e.g., '6M', '1Y')."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        is_non_deliverable: Optional[bool] = None,
        quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = None,
        synthetic_instrument_code: Optional[str] = None,
        template: Optional[str] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardInstrumentDefinitionOutput(_model_base.Model):
    """FxForwardInstrumentDefinitionOutput.

    Attributes
    ----------
    end_date : ~datetime.date
        The date used to define the end date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    instrument_code : str
        The code used to define the instrument.
    is_non_deliverable : bool
    quotation_mode : str or ~analyticsapi.models.CurvesAndSurfacesQuotationModeEnum
        Get quotationMode. Known values are: "CashCleanPrice",
        "CashGrossPrice", "Discount", "DiscountMargin", "MoneyMarketYield",
        "Outright", "ParYield", "PercentCleanPrice", "PercentGrossPrice",
        "Price", "SimpleMargin", "Spread", "SwapPoint",
        "SwapPointInAbsoluteUnit", "Upfront", "Yield", and "ZeroCoupon".
    start_date : ~datetime.date
        The date used to define the start date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    synthetic_instrument_code : str
        The code used to define the formula.
    template : str
        A reference to a style used to define the instrument.
    tenor : str
        The code indicating the instrument tenor (e.g., '6M', '1Y').
    """

    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date used to define the end date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = rest_field(
        name="quotationMode"
    )
    """Get quotationMode. Known values are: \"CashCleanPrice\", \"CashGrossPrice\", \"Discount\",
     \"DiscountMargin\", \"MoneyMarketYield\", \"Outright\", \"ParYield\", \"PercentCleanPrice\",
     \"PercentGrossPrice\", \"Price\", \"SimpleMargin\", \"Spread\", \"SwapPoint\",
     \"SwapPointInAbsoluteUnit\", \"Upfront\", \"Yield\", and \"ZeroCoupon\"."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The date used to define the start date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    synthetic_instrument_code: Optional[str] = rest_field(name="syntheticInstrumentCode")
    """The code used to define the formula."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""
    tenor: Optional[str] = rest_field()
    """The code indicating the instrument tenor (e.g., '6M', '1Y')."""

    @overload
    def __init__(
        self,
        *,
        end_date: Optional[datetime.date] = None,
        instrument_code: Optional[str] = None,
        is_non_deliverable: Optional[bool] = None,
        quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = None,
        start_date: Optional[datetime.date] = None,
        synthetic_instrument_code: Optional[str] = None,
        template: Optional[str] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardInstrumentOutput(_model_base.Model):
    """FxForwardInstrumentOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.FxForwardInstrumentDefinitionOutput
    status_message : str
        Get statusMessage.
    """

    fields: Optional["_models.BidAskFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.FxForwardInstrumentDefinitionOutput"] = rest_field(
        name="instrumentDefinition"
    )
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.FxForwardInstrumentDefinitionOutput"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardInstrumentsSource(_model_base.Model):
    """FxForwardInstrumentsSource.

    Attributes
    ----------
    is_executable : bool
    is_non_deliverable : bool
    market_data_location : str or ~analyticsapi.models.MarketDataLocationEnum
        Get marketDataLocation. Known values are: "Offshore" and "Onshore".
    quotation_mode : str or ~analyticsapi.models.CurvesAndSurfacesQuotationModeEnum
        Get quotationMode. Known values are: "CashCleanPrice",
        "CashGrossPrice", "Discount", "DiscountMargin", "MoneyMarketYield",
        "Outright", "ParYield", "PercentCleanPrice", "PercentGrossPrice",
        "Price", "SimpleMargin", "Spread", "SwapPoint",
        "SwapPointInAbsoluteUnit", "Upfront", "Yield", and "ZeroCoupon".
    source : str
        The instruments source.
    tenors : list[str]
        The non standard tenors list used to compute instruments from source.
        Possible values are: \\"Odd\\", \\"Long\\", \\"IMM\\", \\"BOM\\",
        \\"EOM\\", and tenor value e.g. \\"20Y\\"  By default instruments will
        be computed using following standard tenors : \\"ON\\",\\"TN\\",\\"SN\\
        ",\\"SW\\",\\"1M\\",\\"2M\\",\\"3M\\",\\"6M\\",\\"9M\\",\\"1Y\\",\\"2Y\
        \". The default value is None, needs to be assigned before using.
    """

    is_executable: Optional[bool] = rest_field(name="isExecutable")
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    market_data_location: Optional[Union[str, "_models.MarketDataLocationEnum"]] = rest_field(name="marketDataLocation")
    """Get marketDataLocation. Known values are: \"Offshore\" and \"Onshore\"."""
    quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = rest_field(
        name="quotationMode"
    )
    """Get quotationMode. Known values are: \"CashCleanPrice\", \"CashGrossPrice\", \"Discount\",
     \"DiscountMargin\", \"MoneyMarketYield\", \"Outright\", \"ParYield\", \"PercentCleanPrice\",
     \"PercentGrossPrice\", \"Price\", \"SimpleMargin\", \"Spread\", \"SwapPoint\",
     \"SwapPointInAbsoluteUnit\", \"Upfront\", \"Yield\", and \"ZeroCoupon\"."""
    source: Optional[str] = rest_field()
    """The instruments source."""
    tenors: Optional[List[str]] = rest_field()
    """The non standard tenors list used to compute instruments from source. Possible values are:
     \\"Odd\\", \\"Long\\", \\"IMM\\", \\"BOM\\", \\"EOM\\", and tenor value e.g. \\"20Y\\"  By
     default instruments will be computed using following standard tenors :
     \\"ON\\",\\"TN\\",\\"SN\\",\\"SW\\",\\"1M\\",\\"2M\\",\\"3M\\",\\"6M\\",\\"9M\\",\\"1Y\\",\\"2Y\\"."""

    @overload
    def __init__(
        self,
        *,
        is_executable: Optional[bool] = None,
        is_non_deliverable: Optional[bool] = None,
        market_data_location: Optional[Union[str, "_models.MarketDataLocationEnum"]] = None,
        quotation_mode: Optional[Union[str, "_models.CurvesAndSurfacesQuotationModeEnum"]] = None,
        source: Optional[str] = None,
        tenors: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardOverride(_model_base.Model):
    """Object that can be used to override the built-in properties of a FxForward template in a
    request.

    Attributes
    ----------
    deal_amount : float
        The amount of the deal.
    contra_amount : float
        The amount expressed in the foreign currency. It is required if no Fx
        Rate is provided.
    rate : ~analyticsapi.models.FxRate
        The exchange rate of the transaction. It is required if no contraAmount
        is provided.
    start_date : ~analyticsapi.models.Date
        The effective date of the deal.
    end_date : ~analyticsapi.models.Date
        The maturity date of the deal.
    settlement_type : str or ~analyticsapi.models.SettlementType
        The type of settlement (Cash or Physical). This used to identify non
        deliverable forwards. Known values are: "Cash" and "Physical".
    """

    deal_amount: Optional[float] = rest_field(name="dealAmount")
    """The amount of the deal."""
    contra_amount: Optional[float] = rest_field(name="contraAmount")
    """The amount expressed in the foreign currency. It is required if no Fx Rate is provided."""
    rate: Optional["_models.FxRate"] = rest_field()
    """The exchange rate of the transaction. It is required if no contraAmount is provided."""
    start_date: Optional["_models.Date"] = rest_field(name="startDate")
    """The effective date of the deal."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """The maturity date of the deal."""
    settlement_type: Optional[Union[str, "_models.SettlementType"]] = rest_field(name="settlementType")
    """The type of settlement (Cash or Physical). This used to identify non deliverable forwards.
     Known values are: \"Cash\" and \"Physical\"."""

    @overload
    def __init__(
        self,
        *,
        deal_amount: Optional[float] = None,
        contra_amount: Optional[float] = None,
        rate: Optional["_models.FxRate"] = None,
        start_date: Optional["_models.Date"] = None,
        end_date: Optional["_models.Date"] = None,
        settlement_type: Optional[Union[str, "_models.SettlementType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardPriceResponse(_model_base.Model):
    """Object defining the response of a pricing request for a FxForward instrument that exists in the
    platform.

    Attributes
    ----------
    data : ~analyticsapi.models.FxForwardAnalyticsPricingOnResourceResponseData
        Required.
    """

    data: "_models.FxForwardAnalyticsPricingOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxForwardAnalyticsPricingOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxPricingAnalysis(_model_base.Model):
    """The object that contains the analytic fields that are linked to a pre-trade analysis of the
    instrument.

    Attributes
    ----------
    fx_spot : ~analyticsapi.models.BidAskSimpleValues
        The spot price for the currency pair. The field returns the following
        values: Bid (Bid value) and Ask (Ask value).
    deal_amount : float
        The amount of the deal (base) currency bought or sold.
    contra_amount : float
        The amount of contraCcy exchanged to buy or sell the amount of the deal
        (base) currency.
    """

    fx_spot: Optional["_models.BidAskSimpleValues"] = rest_field(name="fxSpot")
    """The spot price for the currency pair. The field returns the following values: Bid (Bid value)
     and Ask (Ask value)."""
    deal_amount: Optional[float] = rest_field(name="dealAmount")
    """The amount of the deal (base) currency bought or sold."""
    contra_amount: Optional[float] = rest_field(name="contraAmount")
    """The amount of contraCcy exchanged to buy or sell the amount of the deal (base) currency."""

    @overload
    def __init__(
        self,
        *,
        fx_spot: Optional["_models.BidAskSimpleValues"] = None,
        deal_amount: Optional[float] = None,
        contra_amount: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardPricingAnalysis(FxPricingAnalysis):
    """The object that contains the analytic fields that are linked to a pre-trade analysis of the
    instrument.

    Attributes
    ----------
    fx_spot : ~analyticsapi.models.BidAskSimpleValues
        The spot price for the currency pair. The field returns the following
        values: Bid (Bid value) and Ask (Ask value).
    deal_amount : float
        The amount of the deal (base) currency bought or sold.
    contra_amount : float
        The amount of contraCcy exchanged to buy or sell the amount of the deal
        (base) currency.
    fx_swaps_ccy1 : ~analyticsapi.models.BidAskSimpleValues
        FX Swap points for the currency 1 against the reference currency. By
        default, the reference currency is USD.
    fx_swaps_ccy2 : ~analyticsapi.models.BidAskSimpleValues
        FX Swap points for the currency 2 against the reference currency. By
        default, the reference currency is USD.
    fx_swaps_ccy1_ccy2 : ~analyticsapi.models.BidAskSimpleValues
        FX Swap points for the FX cross currency pair.
    fx_outright_ccy1_ccy2 : ~analyticsapi.models.BidAskSimpleValues
        FX outright rate for the FX cross currency pair.
    rate : float
        The contractual exchange rate agreed by counterparties. Required.
    settlement_amount : float
        Settlement amount in case of an FxNonDeliverableForward (NDF) contract.
        The value is expressed in the settlement currency.
    """

    fx_swaps_ccy1: Optional["_models.BidAskSimpleValues"] = rest_field(name="fxSwapsCcy1")
    """FX Swap points for the currency 1 against the reference currency. By default, the reference
     currency is USD."""
    fx_swaps_ccy2: Optional["_models.BidAskSimpleValues"] = rest_field(name="fxSwapsCcy2")
    """FX Swap points for the currency 2 against the reference currency. By default, the reference
     currency is USD."""
    fx_swaps_ccy1_ccy2: Optional["_models.BidAskSimpleValues"] = rest_field(name="fxSwapsCcy1Ccy2")
    """FX Swap points for the FX cross currency pair."""
    fx_outright_ccy1_ccy2: Optional["_models.BidAskSimpleValues"] = rest_field(name="fxOutrightCcy1Ccy2")
    """FX outright rate for the FX cross currency pair."""
    rate: float = rest_field()
    """The contractual exchange rate agreed by counterparties. Required."""
    settlement_amount: Optional[float] = rest_field(name="settlementAmount")
    """Settlement amount in case of an FxNonDeliverableForward (NDF) contract. The value is expressed
     in the settlement currency."""

    @overload
    def __init__(
        self,
        *,
        rate: float,
        fx_spot: Optional["_models.BidAskSimpleValues"] = None,
        deal_amount: Optional[float] = None,
        contra_amount: Optional[float] = None,
        fx_swaps_ccy1: Optional["_models.BidAskSimpleValues"] = None,
        fx_swaps_ccy2: Optional["_models.BidAskSimpleValues"] = None,
        fx_swaps_ccy1_ccy2: Optional["_models.BidAskSimpleValues"] = None,
        fx_outright_ccy1_ccy2: Optional["_models.BidAskSimpleValues"] = None,
        settlement_amount: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardResponse(_model_base.Model):
    """Object defining the response for a single FxForward instrument.

    Attributes
    ----------
    data : ~analyticsapi.models.FxForward
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.FxForward" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.FxForward",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxRisk(_model_base.Model):
    """The object that contains the analytic fields that are linked to a risk analysis of the
    instrument.

    Attributes
    ----------
    delta_percent : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in percentages.
    delta_amount_in_deal_ccy : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in the deal currency.
    delta_amount_in_contra_ccy : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in the contra (quote) currency.
    """

    delta_percent: Optional[float] = rest_field(name="deltaPercent")
    """The change in the instrument's price or market value caused by a one-unit change in the price
     of the underlying asset, or by 1bp change in the swap rate for a swaption, or by 100bp change
     in the outright for FX instruments. The value is expressed in percentages."""
    delta_amount_in_deal_ccy: Optional[float] = rest_field(name="deltaAmountInDealCcy")
    """The change in the instrument's price or market value caused by a one-unit change in the price
     of the underlying asset, or by 1bp change in the swap rate for a swaption, or by 100bp change
     in the outright for FX instruments. The value is expressed in the deal currency."""
    delta_amount_in_contra_ccy: Optional[float] = rest_field(name="deltaAmountInContraCcy")
    """The change in the instrument's price or market value caused by a one-unit change in the price
     of the underlying asset, or by 1bp change in the swap rate for a swaption, or by 100bp change
     in the outright for FX instruments. The value is expressed in the contra (quote) currency."""

    @overload
    def __init__(
        self,
        *,
        delta_percent: Optional[float] = None,
        delta_amount_in_deal_ccy: Optional[float] = None,
        delta_amount_in_contra_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardRisk(FxRisk):
    """The object that contains the analytic fields that are linked to a risk analysis of the
    instrument.

    Attributes
    ----------
    delta_percent : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in percentages.
    delta_amount_in_deal_ccy : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in the deal currency.
    delta_amount_in_contra_ccy : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in the contra (quote) currency.
    """

    @overload
    def __init__(
        self,
        *,
        delta_percent: Optional[float] = None,
        delta_amount_in_deal_ccy: Optional[float] = None,
        delta_amount_in_contra_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardTemplateDefinition(InstrumentTemplateDefinition, discriminator="FxForward"):
    """FxForwardTemplateDefinition.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.FX_FORWARD
        Required. A FX forward contract contract.
    template : ~analyticsapi.models.FxForwardDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.FX_FORWARD] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. A FX forward contract contract."""
    template: "_models.FxForwardDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.FxForwardDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.FX_FORWARD, **kwargs)


class FxValuation(_model_base.Model):
    """The object that contains the analytic fields that are linked to a post-trade analysis of the
    instrument.

    Attributes
    ----------
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency.
    market_value_in_contra_ccy : float
        The market value of the instrument. The value is expressed in the
        contra (quote) currency.
    market_value_in_report_ccy : float
        The present value of the future cash flow in the reporting currency.
    """

    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency."""
    market_value_in_contra_ccy: Optional[float] = rest_field(name="marketValueInContraCcy")
    """The market value of the instrument. The value is expressed in the contra (quote) currency."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The present value of the future cash flow in the reporting currency."""

    @overload
    def __init__(
        self,
        *,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_contra_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxForwardValuation(FxValuation):
    """The object that contains the analytic fields that are linked to a post-trade analysis of the
    instrument.

    Attributes
    ----------
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency.
    market_value_in_contra_ccy : float
        The market value of the instrument. The value is expressed in the
        contra (quote) currency.
    market_value_in_report_ccy : float
        The present value of the future cash flow in the reporting currency.
    discount_factor : float
        The ratio derived from EndDate and used to calculate the present value
        of future cash flow for the instrument at MarketDataDate.
    """

    discount_factor: Optional[float] = rest_field(name="discountFactor")
    """The ratio derived from EndDate and used to calculate the present value of future cash flow for
     the instrument at MarketDataDate."""

    @overload
    def __init__(
        self,
        *,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_contra_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
        discount_factor: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["discount_factor"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxForwardValuationResponse(_model_base.Model):
    """Object defining the response of a valuation request for a FxForward instrument that exists in
    the platform.

    Attributes
    ----------
    data : ~analyticsapi.models.FxForwardAnalyticsValuationOnResourceResponseData
        Required.
    """

    data: "_models.FxForwardAnalyticsValuationOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxForwardAnalyticsValuationOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxOptionVolSurfaceChoice(_model_base.Model):
    """The object to provide either a reference to an fx volatility surface stored in the platform or
    3rd party volatilities.

    Attributes
    ----------
    reference : str
        The reference to a volatility surface stored in the platform.
    surface : ~analyticsapi.models.FxVolSurfaceInput
        The volatility surface data.
    """

    reference: Optional[str] = rest_field()
    """The reference to a volatility surface stored in the platform."""
    surface: Optional["_models.FxVolSurfaceInput"] = rest_field()
    """The volatility surface data."""

    @overload
    def __init__(
        self,
        *,
        reference: Optional[str] = None,
        surface: Optional["_models.FxVolSurfaceInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxOutrightCurve(Curve, discriminator="FxOutrightCurve"):
    """The model defining the output of an fx forward curve calculation.

    Attributes
    ----------
    curve_type : str or ~analyticsapi.models.FX_OUTRIGHT_CURVE
        Required.
    cross_currency : str
        The ISO code of the cross currency pair. Required.
    points : list[~analyticsapi.models.FxOutrightCurvePoint]
        The list of output points. Required.  The default value is None, needs
        to be assigned before using.
    """

    curve_type: Literal[CurveTypeEnum.FX_OUTRIGHT_CURVE] = rest_discriminator(name="curveType")  # type: ignore
    """Required."""
    cross_currency: str = rest_field(name="crossCurrency")
    """The ISO code of the cross currency pair. Required."""
    points: List["_models.FxOutrightCurvePoint"] = rest_field()
    """The list of output points. Required."""

    @overload
    def __init__(
        self,
        *,
        cross_currency: str,
        points: List["_models.FxOutrightCurvePoint"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, curve_type=CurveTypeEnum.FX_OUTRIGHT_CURVE, **kwargs)


class FxOutrightCurveDescription(_model_base.Model):
    """An object to define a FX Outright Curve.

    Attributes
    ----------
    curve_type : str or ~analyticsapi.models.FX_OUTRIGHT_CURVE
        Required.
    cross_currency : str
        The ISO code of the cross currency pair. Required.
    points : list[~analyticsapi.models.FxOutrightCurvePoint]
        The list of output points. Required.  The default value is None, needs
        to be assigned before using.
    """

    curve_type: Literal[CurveTypeEnum.FX_OUTRIGHT_CURVE] = rest_field(name="curveType")
    """Required."""
    cross_currency: str = rest_field(name="crossCurrency")
    """The ISO code of the cross currency pair. Required."""
    points: List["_models.FxOutrightCurvePoint"] = rest_field()
    """The list of output points. Required."""

    @overload
    def __init__(
        self,
        *,
        curve_type: Literal[CurveTypeEnum.FX_OUTRIGHT_CURVE],
        cross_currency: str,
        points: List["_models.FxOutrightCurvePoint"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxOutrightCurvePoint(_model_base.Model):
    """An object that contains the values applied to the FX Forward curve point.

    Attributes
    ----------
    start_date : ~datetime.date
        The start date of the curve point tenor. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
    tenor : str
        The code indicating the period between the start date and the end date
        of the curve point (e.g., '1M', 1Y'). Required.
    end_date : ~datetime.date
        The end date of the curve point tenor. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
    outright : ~analyticsapi.models.BidAskMidSimpleValues
        The outright exchange rate between the two currencies. Required.
    instruments : list[~analyticsapi.models.CurvePointRelatedInstruments]
        An array of objects that contains instruments used to calculate the
        curve point.  The default value is None, needs to be assigned before
        using.
    """

    start_date: datetime.date = rest_field(name="startDate")
    """The start date of the curve point tenor. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., '2023-01-01'). Required."""
    tenor: str = rest_field()
    """The code indicating the period between the start date and the end date of the curve point
     (e.g., '1M', 1Y'). Required."""
    end_date: datetime.date = rest_field(name="endDate")
    """The end date of the curve point tenor. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., '2023-01-01'). Required."""
    outright: "_models.BidAskMidSimpleValues" = rest_field()
    """The outright exchange rate between the two currencies. Required."""
    instruments: Optional[List["_models.CurvePointRelatedInstruments"]] = rest_field()
    """An array of objects that contains instruments used to calculate the curve point."""

    @overload
    def __init__(
        self,
        *,
        start_date: datetime.date,
        tenor: str,
        end_date: datetime.date,
        outright: "_models.BidAskMidSimpleValues",
        instruments: Optional[List["_models.CurvePointRelatedInstruments"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxPricingParameters(BasePricingParameters):
    """An object that describes Fx-related calculation parameters.

    Attributes
    ----------
    valuation_date : ~datetime.date
        The date on which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). The valuation date
        should be less than or equal to the instrument's end date. If not
        provided, today's date will be used as the default valuation date.
    report_currency : str
        The reporting currency. The value is expressed in ISO 4217 alphabetical
        format (e.g., 'GBP'). Default is USD.
    ignore_reference_currency_holidays : bool
        Boolean property that determines if reference currencys holidays are
        taken into account during date calculation.
    reference_currency : str
        An object to specify the reference currency.
    """

    ignore_reference_currency_holidays: Optional[bool] = rest_field(name="ignoreReferenceCurrencyHolidays")
    """Boolean property that determines if reference currencys holidays are taken into account during
     date calculation."""
    reference_currency: Optional[str] = rest_field(name="referenceCurrency")
    """An object to specify the reference currency."""

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.date] = None,
        report_currency: Optional[str] = None,
        ignore_reference_currency_holidays: Optional[bool] = None,
        reference_currency: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxRate(_model_base.Model):
    """Definition of a FX rate.

    Attributes
    ----------
    value : float
        The contractual exchange rate agreed by the parties.
    scaling_factor : float
        The factor used for quoting cross currency rates.
    rate_precision : int
        Number of decimal digits of precision for the FX rate value.
    """

    value: Optional[float] = rest_field()
    """The contractual exchange rate agreed by the parties."""
    scaling_factor: Optional[float] = rest_field(name="scalingFactor")
    """The factor used for quoting cross currency rates."""
    rate_precision: Optional[int] = rest_field(name="ratePrecision")
    """Number of decimal digits of precision for the FX rate value."""

    @overload
    def __init__(
        self,
        *,
        value: Optional[float] = None,
        scaling_factor: Optional[float] = None,
        rate_precision: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpot(_model_base.Model):
    """Object defning an Fx Spot resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.FX_SPOT
        Property defining the type of the resource.
    id : str
        Unique identifier of the FxSpot.
    location : ~analyticsapi.models.Location
        Object defining the location of the FxSpot in the platform. Required.
    description : ~analyticsapi.models.Description
        Object defining metadata for the FxSpot.
    definition : ~analyticsapi.models.FxSpotDefinition
        Object defining the FxSpot. Required.
    """

    type: Optional[Literal[ResourceType.FX_SPOT]] = rest_field(visibility=["read"], default=ResourceType.FX_SPOT)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the FxSpot."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining the location of the FxSpot in the platform. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining metadata for the FxSpot."""
    definition: "_models.FxSpotDefinition" = rest_field()
    """Object defining the FxSpot. Required."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        definition: "_models.FxSpotDefinition",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotAnalyticsDescription(FxAnalyticsDescription):
    """The object that contains the analytic fields that describe the instrument.

    Attributes
    ----------
    valuation_date : ~datetime.date
        The date at which the instrument is valued. The date is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z').
    start_date : ~analyticsapi.models.AdjustedDate
        "An object describing a start date of the instrument.".
    end_date : ~analyticsapi.models.AdjustedDate
        "An object describing a maturity date of the instrument.".
    """

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.date] = None,
        start_date: Optional["_models.AdjustedDate"] = None,
        end_date: Optional["_models.AdjustedDate"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotAnalyticsPricingOnResourceResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """FxSpotAnalyticsPricingOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.FxSpot
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.FxPricingParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.FxSpotAnalyticsPricingResponseWithError
        The result of the calculation request.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    resource: Optional["_models.FxSpot"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.FxPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.FxSpotAnalyticsPricingResponseWithError"] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.FxSpot"] = None,
        pricing_preferences: Optional["_models.FxPricingParameters"] = None,
        analytics: Optional["_models.FxSpotAnalyticsPricingResponseWithError"] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotAnalyticsPricingResponseData(_model_base.Model):
    """FxSpotAnalyticsPricingResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.FxSpotDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.FxPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.FxSpotAnalyticsPricingResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.FxSpotDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.FxPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.FxSpotAnalyticsPricingResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.FxSpotDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.FxPricingParameters"] = None,
        analytics: Optional[List["_models.FxSpotAnalyticsPricingResponseWithError"]] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotAnalyticsPricingResponseWithError(_model_base.Model):
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    description : ~analyticsapi.models.FxSpotAnalyticsDescription
        The analytic fields that describe the instrument.
    pricing_analysis : ~analyticsapi.models.FxSpotPricingAnalysis
        The analytic fields that are linked to a pre-trade analysis of the
        instrument.
    greeks : ~analyticsapi.models.FxSpotRisk
        The analytic fields that are linked to a risk analysis of the
        instrument.
    processing_information : list[str]
        A list of messages providing additional information about the
        processing of the request.  The default value is None, needs to be
        assigned before using.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    description: Optional["_models.FxSpotAnalyticsDescription"] = rest_field()
    """The analytic fields that describe the instrument."""
    pricing_analysis: Optional["_models.FxSpotPricingAnalysis"] = rest_field(name="pricingAnalysis")
    """The analytic fields that are linked to a pre-trade analysis of the instrument."""
    greeks: Optional["_models.FxSpotRisk"] = rest_field()
    """The analytic fields that are linked to a risk analysis of the instrument."""
    processing_information: Optional[List[str]] = rest_field(name="processingInformation")
    """A list of messages providing additional information about the processing of the request."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        description: Optional["_models.FxSpotAnalyticsDescription"] = None,
        pricing_analysis: Optional["_models.FxSpotPricingAnalysis"] = None,
        greeks: Optional["_models.FxSpotRisk"] = None,
        processing_information: Optional[List[str]] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotAnalyticsValuationOnResourceResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """FxSpotAnalyticsValuationOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.FxSpot
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.FxPricingParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.FxSpotAnalyticsValuationResponseWithError
        The result of the calculation request.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    resource: Optional["_models.FxSpot"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.FxPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.FxSpotAnalyticsValuationResponseWithError"] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.FxSpot"] = None,
        pricing_preferences: Optional["_models.FxPricingParameters"] = None,
        analytics: Optional["_models.FxSpotAnalyticsValuationResponseWithError"] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotAnalyticsValuationResponseData(_model_base.Model):
    """FxSpotAnalyticsValuationResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.FxSpotDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.FxPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.FxSpotAnalyticsValuationResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.FxSpotDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.FxPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.FxSpotAnalyticsValuationResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.FxSpotDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.FxPricingParameters"] = None,
        analytics: Optional[List["_models.FxSpotAnalyticsValuationResponseWithError"]] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotAnalyticsValuationResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    description : ~analyticsapi.models.FxSpotAnalyticsDescription
        The analytic fields that describe the instrument.
    valuation : ~analyticsapi.models.FxSpotValuation
        The analytic fields that are linked to a post-trade analysis of the
        instrument.
    greeks : ~analyticsapi.models.FxSpotRisk
        The analytic fields that are linked to a risk analysis of the
        instrument.
    processing_information : list[str]
        A list of messages providing additional information about the
        processing of the request.  The default value is None, needs to be
        assigned before using.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    description: Optional["_models.FxSpotAnalyticsDescription"] = rest_field()
    """The analytic fields that describe the instrument."""
    valuation: Optional["_models.FxSpotValuation"] = rest_field()
    """The analytic fields that are linked to a post-trade analysis of the instrument."""
    greeks: Optional["_models.FxSpotRisk"] = rest_field()
    """The analytic fields that are linked to a risk analysis of the instrument."""
    processing_information: Optional[List[str]] = rest_field(name="processingInformation")
    """A list of messages providing additional information about the processing of the request."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        description: Optional["_models.FxSpotAnalyticsDescription"] = None,
        valuation: Optional["_models.FxSpotValuation"] = None,
        greeks: Optional["_models.FxSpotRisk"] = None,
        processing_information: Optional[List[str]] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotArrayPriceResponse(_model_base.Model):
    """Object defining the response of a pricing request for a collection of FxSpot instruments.

    Attributes
    ----------
    data : ~analyticsapi.models.FxSpotAnalyticsPricingResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.FxSpotAnalyticsPricingResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxSpotAnalyticsPricingResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxSpotArrayValuationResponse(_model_base.Model):
    """Object defining the response of a valuation request for a collection of FxSpot instruments.

    Attributes
    ----------
    data : ~analyticsapi.models.FxSpotAnalyticsValuationResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.FxSpotAnalyticsValuationResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxSpotAnalyticsValuationResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxSpotCollectionLinks(_model_base.Model):
    """Object defining the related links available for a collection of FxSpot instruments.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotCollectionResponse(_model_base.Model):
    """Object defining the paged response for a collection of FxSpot instruments.

    Attributes
    ----------
    data : list[~analyticsapi.models.FxSpotInfo]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.FxSpotCollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.FxSpotInfo"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.FxSpotCollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.FxSpotInfo"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.FxSpotCollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotConstituent(FxConstituent, discriminator="FxSpot"):
    """An object defining an fx spot constituent of an fx forward curve.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.FX_SPOT
        The type of the instrument used as a constituent. FxSpot is the only
        valid value. Required.
    definition : ~analyticsapi.models.FxSpotConstituentDefinition
        An object to define the instrument used as a constituent.
    """

    type: Literal[FxConstituentEnum.FX_SPOT] = rest_discriminator(name="type")  # type: ignore
    """The type of the instrument used as a constituent. FxSpot is the only valid value. Required."""
    definition: Optional["_models.FxSpotConstituentDefinition"] = rest_field()
    """An object to define the instrument used as a constituent."""

    @overload
    def __init__(
        self,
        *,
        quote: Optional["_models.Quote"] = None,
        definition: Optional["_models.FxSpotConstituentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=FxConstituentEnum.FX_SPOT, **kwargs)


class FxSpotConstituentDefinition(_model_base.Model):
    """The definition of an fx spot instrument used as a constituent of an fx forward curve.

    Attributes
    ----------
    template : str
        A pre-defined template can be used as an input by the user.
    """

    template: Optional[str] = rest_field()
    """A pre-defined template can be used as an input by the user."""

    @overload
    def __init__(
        self,
        template: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["template"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxSpotDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.FxSpotDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.FxSpotDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.FxSpotDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotFromTemplateResponse(_model_base.Model):
    """Object defining the response of the creation of a FxSpot from a reference to a template and a
    list of overridden values.

    Attributes
    ----------
    data : ~analyticsapi.models.FxSpotDefinition
        An object that describes the instrument generated by the request.
        Required.
    """

    data: "_models.FxSpotDefinition" = rest_field()
    """An object that describes the instrument generated by the request. Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxSpotDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxSpotInfo(_model_base.Model):
    """Object defining the related links available on a FxSpot resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.FX_SPOT
        Property defining the type of the resource.
    id : str
        Unique identifier of the FxSpot.
    location : ~analyticsapi.models.Location
        Object defining metadata for the FxSpot. Required.
    description : ~analyticsapi.models.Description
        Object defining the FxSpot.
    """

    type: Optional[Literal[ResourceType.FX_SPOT]] = rest_field(visibility=["read"], default=ResourceType.FX_SPOT)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the FxSpot."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining metadata for the FxSpot. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining the FxSpot."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotInstrument(_model_base.Model):
    """FxSpotInstrument.

    Attributes
    ----------
    fields : ~analyticsapi.models.CurvesAndSurfacesBidAskFields
    formula : str
        The formula used to adjust market data values of the instrument's Bid
        and Ask price side. For example, '100-marketPrice'.
    formula_parameters : list[~analyticsapi.models.FormulaParameter]
        The list of formula parameters used to adjust market data values of the
        instrument's Bid and Ask price side.  The default value is None, needs
        to be assigned before using.
    instrument_definition : ~analyticsapi.models.FxSpotInstrumentDefinition
    """

    fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """The formula used to adjust market data values of the instrument's Bid and Ask price side. For
     example, '100-marketPrice'."""
    formula_parameters: Optional[List["_models.FormulaParameter"]] = rest_field(name="formulaParameters")
    """The list of formula parameters used to adjust market data values of the instrument's Bid and
     Ask price side."""
    instrument_definition: Optional["_models.FxSpotInstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameter"]] = None,
        instrument_definition: Optional["_models.FxSpotInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotInstrumentDefinition(_model_base.Model):
    """FxSpotInstrumentDefinition.

    Attributes
    ----------
    instrument_code : str
        The code used to define the instrument.
    synthetic_instrument_code : str
        The code used to define the formula.
    template : str
        A reference to a style used to define the instrument.
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    synthetic_instrument_code: Optional[str] = rest_field(name="syntheticInstrumentCode")
    """The code used to define the formula."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        synthetic_instrument_code: Optional[str] = None,
        template: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotInstrumentDefinitionOutput(_model_base.Model):
    """FxSpotInstrumentDefinitionOutput.

    Attributes
    ----------
    end_date : ~datetime.date
        The date used to define the end date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    instrument_code : str
        The code used to define the instrument.
    start_date : ~datetime.date
        The date used to define the start date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    synthetic_instrument_code : str
        The code used to define the formula.
    template : str
        A reference to a style used to define the instrument.
    """

    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date used to define the end date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The date used to define the start date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    synthetic_instrument_code: Optional[str] = rest_field(name="syntheticInstrumentCode")
    """The code used to define the formula."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""

    @overload
    def __init__(
        self,
        *,
        end_date: Optional[datetime.date] = None,
        instrument_code: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        synthetic_instrument_code: Optional[str] = None,
        template: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotInstrumentOutput(_model_base.Model):
    """FxSpotInstrumentOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.FxSpotInstrumentDefinitionOutput
    status_message : str
        Get statusMessage.
    """

    fields: Optional["_models.BidAskFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.FxSpotInstrumentDefinitionOutput"] = rest_field(
        name="instrumentDefinition"
    )
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.FxSpotInstrumentDefinitionOutput"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotInstrumentsSource(_model_base.Model):
    """FxSpotInstrumentsSource.

    Attributes
    ----------
    market_data_location : str or ~analyticsapi.models.MarketDataLocationEnum
        Get marketDataLocation. Known values are: "Offshore" and "Onshore".
    source : str
        The instruments source.
    """

    market_data_location: Optional[Union[str, "_models.MarketDataLocationEnum"]] = rest_field(name="marketDataLocation")
    """Get marketDataLocation. Known values are: \"Offshore\" and \"Onshore\"."""
    source: Optional[str] = rest_field()
    """The instruments source."""

    @overload
    def __init__(
        self,
        *,
        market_data_location: Optional[Union[str, "_models.MarketDataLocationEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotOverride(_model_base.Model):
    """Object that can be used to override the built-in properties of a FxSpot template in a request.

    Attributes
    ----------
    deal_amount : float
        The amount of the deal.
    contra_amount : float
        The amount expressed in the foreign currency. It is required if no Fx
        Rate is provided.
    rate : ~analyticsapi.models.FxRate
        The exchange rate of the transaction. It is required if no contraAmount
        is provided.
    start_date : ~analyticsapi.models.Date
        The effective date of the deal.
    end_date : ~analyticsapi.models.Date
        The maturity date of the deal.
    """

    deal_amount: Optional[float] = rest_field(name="dealAmount")
    """The amount of the deal."""
    contra_amount: Optional[float] = rest_field(name="contraAmount")
    """The amount expressed in the foreign currency. It is required if no Fx Rate is provided."""
    rate: Optional["_models.FxRate"] = rest_field()
    """The exchange rate of the transaction. It is required if no contraAmount is provided."""
    start_date: Optional["_models.Date"] = rest_field(name="startDate")
    """The effective date of the deal."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """The maturity date of the deal."""

    @overload
    def __init__(
        self,
        *,
        deal_amount: Optional[float] = None,
        contra_amount: Optional[float] = None,
        rate: Optional["_models.FxRate"] = None,
        start_date: Optional["_models.Date"] = None,
        end_date: Optional["_models.Date"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotPriceResponse(_model_base.Model):
    """Object defining the response of a pricing request for a FxSpot instrument that exists in the
    platform.

    Attributes
    ----------
    data : ~analyticsapi.models.FxSpotAnalyticsPricingOnResourceResponseData
        Required.
    """

    data: "_models.FxSpotAnalyticsPricingOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxSpotAnalyticsPricingOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxSpotPricingAnalysis(FxPricingAnalysis):
    """The object that contains the analytic fields that are linked to a pre-trade analysis of the
    instrument.

    Attributes
    ----------
    fx_spot : ~analyticsapi.models.BidAskSimpleValues
        The spot price for the currency pair. The field returns the following
        values: Bid (Bid value) and Ask (Ask value).
    deal_amount : float
        The amount of the deal (base) currency bought or sold.
    contra_amount : float
        The amount of contraCcy exchanged to buy or sell the amount of the deal
        (base) currency.
    """

    @overload
    def __init__(
        self,
        *,
        fx_spot: Optional["_models.BidAskSimpleValues"] = None,
        deal_amount: Optional[float] = None,
        contra_amount: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotResponse(_model_base.Model):
    """Object defining the response for a single FxSpot instrument.

    Attributes
    ----------
    data : ~analyticsapi.models.FxSpot
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.FxSpot" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.FxSpot",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotRisk(FxRisk):
    """The object that contains the analytic fields that are linked to a risk analysis of the
    instrument.

    Attributes
    ----------
    delta_percent : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in percentages.
    delta_amount_in_deal_ccy : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in the deal currency.
    delta_amount_in_contra_ccy : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in the contra (quote) currency.
    """

    @overload
    def __init__(
        self,
        *,
        delta_percent: Optional[float] = None,
        delta_amount_in_deal_ccy: Optional[float] = None,
        delta_amount_in_contra_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotTemplateDefinition(InstrumentTemplateDefinition, discriminator="FxSpot"):
    """FxSpotTemplateDefinition.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.FX_SPOT
        Required. A FX spot contract contract.
    template : ~analyticsapi.models.FxSpotDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.FX_SPOT] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. A FX spot contract contract."""
    template: "_models.FxSpotDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.FxSpotDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.FX_SPOT, **kwargs)


class FxSpotValuation(FxValuation):
    """The object that contains the analytic fields that are linked to a post-trade analysis of the
    instrument.

    Attributes
    ----------
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency.
    market_value_in_contra_ccy : float
        The market value of the instrument. The value is expressed in the
        contra (quote) currency.
    market_value_in_report_ccy : float
        The present value of the future cash flow in the reporting currency.
    """

    @overload
    def __init__(
        self,
        *,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_contra_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxSpotValuationResponse(_model_base.Model):
    """Object defining the response of a valuation request for a FxForxard instrument that exists in
    the platform.

    Attributes
    ----------
    data : ~analyticsapi.models.FxSpotAnalyticsValuationOnResourceResponseData
        Required.
    """

    data: "_models.FxSpotAnalyticsValuationOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.FxSpotAnalyticsValuationOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxVolatilityPricingParameters(_model_base.Model):
    """FxVolatilityPricingParameters.

    Attributes
    ----------
    atm_volatility_object : ~analyticsapi.models.BidAskMid
    butterfly10_dobject : ~analyticsapi.models.BidAskMid
    butterfly25_dobject : ~analyticsapi.models.BidAskMid
    calculation_date : ~datetime.datetime
        The date the volatility surface is generated.
    cutoff_time : str
        The cutoff time.
    cutoff_time_zone : str
        The cutoff time zone.
    domestic_deposit_rate_percent_object : ~analyticsapi.models.BidAskMid
    foreign_deposit_rate_percent_object : ~analyticsapi.models.BidAskMid
    forward_points_object : ~analyticsapi.models.BidAskMid
    fx_spot_object : ~analyticsapi.models.BidAskMid
    fx_swap_calculation_method : str or ~analyticsapi.models.CurvesAndSurfacesFxSwapCalculationMethodEnum
        The method we chose to price outrights using or not implied deposits.
        Possible values are: FxSwap (compute outrights using swap points),
        DepositCcy1ImpliedFromFxSwap (compute currency1 deposits using swap
        points), DepositCcy2ImpliedFromFxSwap (compute currency2 deposits using
        swap points). Optional. Defaults to 'FxSwap'. Known values are:
        "DepositCcy1ImpliedFromFxSwap", "DepositCcy2ImpliedFromFxSwap",
        "FxSwap", and "FxSwapImpliedFromDeposit".
    implied_volatility_object : ~analyticsapi.models.BidAskMid
    interpolation_weight : ~analyticsapi.models.InterpolationWeight
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        Specifies whether bid, ask, mid or settle is used to build the surface.
        If not precised, default to mid. Known values are: "Ask", "Bid",
        "Last", and "Mid".
    risk_reversal10_dobject : ~analyticsapi.models.BidAskMid
    risk_reversal25_dobject : ~analyticsapi.models.BidAskMid
    time_stamp : str or ~analyticsapi.models.CurvesAndSurfacesTimeStampEnum
        Define how the timestamp is selected:

        * Open: the opening value of the valuationDate or if not available the close of the previous
        day is used.
        * Default: the latest snapshot is used when valuationDate is today, the close price when
        valuationDate is in the past. Known values are: "Close", "Default", "Open", and "Settle".
    volatility_model : str or ~analyticsapi.models.CurvesAndSurfacesVolatilityModelEnum
        The quantitative model used to generate the volatility surface. This
        may depend on the asset class. For Fx Volatility Surface, we currently
        support the SVI model. Known values are: "CubicSpline", "SABR", "SSVI",
        "SVI", and "TwinLognormal".
    x_axis : str or ~analyticsapi.models.XAxisEnum
        Specifies the unit for the x axis (e.g. Date, Tenor). Known values are:
        "Date", "Delta", "Expiry", "Moneyness", "Strike", and "Tenor".
    y_axis : str or ~analyticsapi.models.YAxisEnum
        Specifies the unit for the y axis (e.g. Strike, Delta). This may depend
        on the asset class. For Fx Volatility Surface, we support both Delta
        and Strike. Known values are: "Date", "Delta", "Expiry", "Moneyness",
        "Strike", and "Tenor".
    """

    atm_volatility_object: Optional["_models.BidAskMid"] = rest_field(name="atmVolatilityObject")
    butterfly10_dobject: Optional["_models.BidAskMid"] = rest_field(name="butterfly10Dobject")
    butterfly25_dobject: Optional["_models.BidAskMid"] = rest_field(name="butterfly25Dobject")
    calculation_date: Optional[datetime.datetime] = rest_field(name="calculationDate", format="rfc3339")
    """The date the volatility surface is generated."""
    cutoff_time: Optional[str] = rest_field(name="cutoffTime")
    """The cutoff time."""
    cutoff_time_zone: Optional[str] = rest_field(name="cutoffTimeZone")
    """The cutoff time zone."""
    domestic_deposit_rate_percent_object: Optional["_models.BidAskMid"] = rest_field(
        name="domesticDepositRatePercentObject"
    )
    foreign_deposit_rate_percent_object: Optional["_models.BidAskMid"] = rest_field(
        name="foreignDepositRatePercentObject"
    )
    forward_points_object: Optional["_models.BidAskMid"] = rest_field(name="forwardPointsObject")
    fx_spot_object: Optional["_models.BidAskMid"] = rest_field(name="fxSpotObject")
    fx_swap_calculation_method: Optional[Union[str, "_models.CurvesAndSurfacesFxSwapCalculationMethodEnum"]] = (
        rest_field(name="fxSwapCalculationMethod")
    )
    """The method we chose to price outrights using or not implied deposits. Possible values are:
     FxSwap (compute outrights using swap points),
     DepositCcy1ImpliedFromFxSwap (compute currency1 deposits using swap points),
     DepositCcy2ImpliedFromFxSwap (compute currency2 deposits using swap points).
     Optional. Defaults to 'FxSwap'. Known values are: \"DepositCcy1ImpliedFromFxSwap\",
     \"DepositCcy2ImpliedFromFxSwap\", \"FxSwap\", and \"FxSwapImpliedFromDeposit\"."""
    implied_volatility_object: Optional["_models.BidAskMid"] = rest_field(name="impliedVolatilityObject")
    interpolation_weight: Optional["_models.InterpolationWeight"] = rest_field(name="interpolationWeight")
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """Specifies whether bid, ask, mid or settle is used to build the surface. If not precised,
     default to mid. Known values are: \"Ask\", \"Bid\", \"Last\", and \"Mid\"."""
    risk_reversal10_dobject: Optional["_models.BidAskMid"] = rest_field(name="riskReversal10Dobject")
    risk_reversal25_dobject: Optional["_models.BidAskMid"] = rest_field(name="riskReversal25Dobject")
    time_stamp: Optional[Union[str, "_models.CurvesAndSurfacesTimeStampEnum"]] = rest_field(name="timeStamp")
    """Define how the timestamp is selected:
     
     
     * Open: the opening value of the valuationDate or if not available the close of the previous
     day is used.
     * Default: the latest snapshot is used when valuationDate is today, the close price when
     valuationDate is in the past. Known values are: \"Close\", \"Default\", \"Open\", and
     \"Settle\"."""
    volatility_model: Optional[Union[str, "_models.CurvesAndSurfacesVolatilityModelEnum"]] = rest_field(
        name="volatilityModel"
    )
    """The quantitative model used to generate the volatility surface. This may depend on the asset
     class.
     For Fx Volatility Surface, we currently support the SVI model. Known values are:
     \"CubicSpline\", \"SABR\", \"SSVI\", \"SVI\", and \"TwinLognormal\"."""
    x_axis: Optional[Union[str, "_models.XAxisEnum"]] = rest_field(name="xAxis")
    """Specifies the unit for the x axis (e.g. Date, Tenor). Known values are: \"Date\", \"Delta\",
     \"Expiry\", \"Moneyness\", \"Strike\", and \"Tenor\"."""
    y_axis: Optional[Union[str, "_models.YAxisEnum"]] = rest_field(name="yAxis")
    """Specifies the unit for the y axis (e.g. Strike, Delta). This may depend on the asset class.
     For Fx Volatility Surface, we support both Delta and Strike. Known values are: \"Date\",
     \"Delta\", \"Expiry\", \"Moneyness\", \"Strike\", and \"Tenor\"."""

    @overload
    def __init__(
        self,
        *,
        atm_volatility_object: Optional["_models.BidAskMid"] = None,
        butterfly10_dobject: Optional["_models.BidAskMid"] = None,
        butterfly25_dobject: Optional["_models.BidAskMid"] = None,
        calculation_date: Optional[datetime.datetime] = None,
        cutoff_time: Optional[str] = None,
        cutoff_time_zone: Optional[str] = None,
        domestic_deposit_rate_percent_object: Optional["_models.BidAskMid"] = None,
        foreign_deposit_rate_percent_object: Optional["_models.BidAskMid"] = None,
        forward_points_object: Optional["_models.BidAskMid"] = None,
        fx_spot_object: Optional["_models.BidAskMid"] = None,
        fx_swap_calculation_method: Optional[Union[str, "_models.CurvesAndSurfacesFxSwapCalculationMethodEnum"]] = None,
        implied_volatility_object: Optional["_models.BidAskMid"] = None,
        interpolation_weight: Optional["_models.InterpolationWeight"] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        risk_reversal10_dobject: Optional["_models.BidAskMid"] = None,
        risk_reversal25_dobject: Optional["_models.BidAskMid"] = None,
        time_stamp: Optional[Union[str, "_models.CurvesAndSurfacesTimeStampEnum"]] = None,
        volatility_model: Optional[Union[str, "_models.CurvesAndSurfacesVolatilityModelEnum"]] = None,
        x_axis: Optional[Union[str, "_models.XAxisEnum"]] = None,
        y_axis: Optional[Union[str, "_models.YAxisEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxVolatilityStatisticsParameters(_model_base.Model):
    """FxVolatilityStatisticsParameters.

    Attributes
    ----------
    high_delta : float
    low_delta : float
    model : str
    nb_points : int
    """

    high_delta: Optional[float] = rest_field(name="highDelta")
    low_delta: Optional[float] = rest_field(name="lowDelta")
    model: Optional[str] = rest_field()
    nb_points: Optional[int] = rest_field(name="nbPoints")

    @overload
    def __init__(
        self,
        *,
        high_delta: Optional[float] = None,
        low_delta: Optional[float] = None,
        model: Optional[str] = None,
        nb_points: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxVolatilitySurfaceDefinition(_model_base.Model):
    """FxVolatilitySurfaceDefinition.

    Attributes
    ----------
    instrument_code : str
        The ISO code of the cross currency (e.g. 'EURCHF'). Mandatory.
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The ISO code of the cross currency (e.g. 'EURCHF').
     Mandatory."""

    @overload
    def __init__(
        self,
        instrument_code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["instrument_code"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class FxVolatilitySurfaceRequestItem(_model_base.Model):
    """FxVolatilitySurfaceRequestItem.

    Attributes
    ----------
    surface_layout : ~analyticsapi.models.SurfaceOutput
    surface_parameters : ~analyticsapi.models.FxVolatilityPricingParameters
    surface_statistics_parameters : ~analyticsapi.models.FxVolatilityStatisticsParameters
    surface_tag : str
    underlying_definition : ~analyticsapi.models.FxVolatilitySurfaceDefinition
    underlying_type : str or ~analyticsapi.models.CurvesAndSurfacesUnderlyingTypeEnum
        The type of the underlying used to generate the volatility surface.
        Known values are: "Cap", "Eti", "Fx", and "Swaption".
    """

    surface_layout: Optional["_models.SurfaceOutput"] = rest_field(name="surfaceLayout")
    surface_parameters: Optional["_models.FxVolatilityPricingParameters"] = rest_field(name="surfaceParameters")
    surface_statistics_parameters: Optional["_models.FxVolatilityStatisticsParameters"] = rest_field(
        name="surfaceStatisticsParameters"
    )
    surface_tag: Optional[str] = rest_field(name="surfaceTag")
    underlying_definition: Optional["_models.FxVolatilitySurfaceDefinition"] = rest_field(name="underlyingDefinition")
    underlying_type: Optional[Union[str, "_models.CurvesAndSurfacesUnderlyingTypeEnum"]] = rest_field(
        name="underlyingType"
    )
    """The type of the underlying used to generate the volatility surface. Known values are: \"Cap\",
     \"Eti\", \"Fx\", and \"Swaption\"."""

    @overload
    def __init__(
        self,
        *,
        surface_layout: Optional["_models.SurfaceOutput"] = None,
        surface_parameters: Optional["_models.FxVolatilityPricingParameters"] = None,
        surface_statistics_parameters: Optional["_models.FxVolatilityStatisticsParameters"] = None,
        surface_tag: Optional[str] = None,
        underlying_definition: Optional["_models.FxVolatilitySurfaceDefinition"] = None,
        underlying_type: Optional[Union[str, "_models.CurvesAndSurfacesUnderlyingTypeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class FxVolSurfaceInput(_model_base.Model):
    """The object defining the 3rd party fx volatility surface.

    Attributes
    ----------
    strike_type : str or ~analyticsapi.models.StrikeTypeEnum
        The property that defines the type of the strikes provided in the
        surface points. Required. Known values are: "Absolute", "BasisPoint",
        "Delta", "Moneyness", "Percent", and "Relative".
    model_type : str or ~analyticsapi.models.VolModelTypeEnum
        The property that defines the type of the model (Normal or LogNormal)
        of the volatilities provided in the surface points. Required. Known
        values are: "Normal" and "LogNormal".
    points : list[~analyticsapi.models.VolSurfacePoint]
        The list of volatility points. Required.  The default value is None,
        needs to be assigned before using.
    fx_cross_code : str
        The ISO code of the cross currency pair. Required.
    """

    strike_type: Union[str, "_models.StrikeTypeEnum"] = rest_field(name="strikeType")
    """The property that defines the type of the strikes provided in the surface points. Required.
     Known values are: \"Absolute\", \"BasisPoint\", \"Delta\", \"Moneyness\", \"Percent\", and
     \"Relative\"."""
    model_type: Union[str, "_models.VolModelTypeEnum"] = rest_field(name="modelType")
    """The property that defines the type of the model (Normal or LogNormal) of the volatilities
     provided in the surface points. Required. Known values are: \"Normal\" and \"LogNormal\"."""
    points: List["_models.VolSurfacePoint"] = rest_field()
    """The list of volatility points. Required."""
    fx_cross_code: str = rest_field(name="fxCrossCode")
    """The ISO code of the cross currency pair. Required."""

    @overload
    def __init__(
        self,
        *,
        strike_type: Union[str, "_models.StrikeTypeEnum"],
        model_type: Union[str, "_models.VolModelTypeEnum"],
        points: List["_models.VolSurfacePoint"],
        fx_cross_code: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GenerateDateScheduleResponse(_model_base.Model):
    """An object to define the response to a request to generate a date schedule.

    Attributes
    ----------
    data : list[~datetime.date]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.CollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List[datetime.date] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.CollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List[datetime.date],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.CollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GenerateHolidaysResponse(_model_base.Model):
    """Object defining the paged response for a collection of generated holidays.

    Attributes
    ----------
    data : list[~analyticsapi.models.Holiday]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.CollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.Holiday"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.CollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.Holiday"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.CollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class GenericNumericalMethod(_model_base.Model):
    """GenericNumericalMethod.

    Attributes
    ----------
    additional_points : int
        The number of points per year supplementary added to the generic-
        security time-grid; these overall points define the time-grid used by
        the model when it goes from one event of generic-security to the next
        one. Optional. The default value is 12.
    all_the_time_points_per_year : int
        The number of points per year used only by AllTheTime schedule type;
        AllTheTimePointsPerYear are points supplementary added to the generic-
        security time-grid; these overall points define the time-grid used by
        the model when it goes from one event of generic-security to the next
        one. Optional. The default value is 260.
    american_monte_carlo_method : str or ~analyticsapi.models.AmericanMonteCarloMethodEnum
        Specifies the variant of the American Monte Carlo method to use when
        'method' is set to 'AmericanMonteCarlo' value. The possible values are:

        * Andersen,
        * LongstaffSchwartz.
          Optional. The default value is 'Andersen'. Known values are: "Andersen" and
        "LongstaffSchwartz".
    method : str or ~analyticsapi.models.MethodEnum
        The name of numerical method to be used for pricing. The possible
        values are:

        * MonteCarlo,
        * Analytic,
        * AmericanMonteCarlo,
        * PDE(partial differential equation). Known values are: "MonteCarlo", "Analytic",
        "AmericanMonteCarlo", and "PDE".
    pde_space_step_count : int
        The number of space steps in the Partial Differential Equation (PDE)
        grid. It can be used if the 'method' property is set to 'PDE' value.
        Optional. The default value is 100.
    pde_standard_deviation_count : int
        The number of standard deviations used to control the geometry of the
        Partial Differential Equation (PDE) grid. It can be used if the
        'method' property is set to 'PDE' value. Optional. The default value is
        8.
    pde_time_step_count : int
        The number of time steps in the Partial Differential Equation (PDE)
        grid. It can be used if the 'method' property is set to 'PDE' value.
        Optional. The default value is 100.
    simulation_count : int
        The number of paths simulated during MonteCarlo method. The range of
        possible values is limited from 2 to 1000000. Optional.The default
        value is 5000.
    """

    additional_points: Optional[int] = rest_field(name="additionalPoints")
    """The number of points per year supplementary added to the generic-security time-grid; these
     overall points define the time-grid used by the model when it goes from one event of
     generic-security to the next one.
     Optional. The default value is 12."""
    all_the_time_points_per_year: Optional[int] = rest_field(name="allTheTimePointsPerYear")
    """The number of points per year used only by AllTheTime schedule type; AllTheTimePointsPerYear
     are points supplementary added to the generic-security time-grid; these overall points define
     the time-grid used by the model when it goes from one event of generic-security to the next
     one.
     Optional. The default value is 260."""
    american_monte_carlo_method: Optional[Union[str, "_models.AmericanMonteCarloMethodEnum"]] = rest_field(
        name="americanMonteCarloMethod"
    )
    """Specifies the variant of the American Monte Carlo method to use when 'method' is set to
     'AmericanMonteCarlo' value. The possible values are:
     
     
     * Andersen,
     * LongstaffSchwartz.
       Optional. The default value is 'Andersen'. Known values are: \"Andersen\" and
     \"LongstaffSchwartz\"."""
    method: Optional[Union[str, "_models.MethodEnum"]] = rest_field()
    """The name of numerical method to be used for pricing. The possible values are:
     
     
     * MonteCarlo,
     * Analytic,
     * AmericanMonteCarlo,
     * PDE(partial differential equation). Known values are: \"MonteCarlo\", \"Analytic\",
     \"AmericanMonteCarlo\", and \"PDE\"."""
    pde_space_step_count: Optional[int] = rest_field(name="pdeSpaceStepCount")
    """The number of space steps in the Partial Differential Equation (PDE) grid. It can be used if
     the 'method' property is set to 'PDE' value.
     Optional. The default value is 100."""
    pde_standard_deviation_count: Optional[int] = rest_field(name="pdeStandardDeviationCount")
    """The number of standard deviations used to control the geometry of the Partial Differential
     Equation (PDE) grid. It can be used if the 'method' property is set to 'PDE' value.
     Optional. The default value is 8."""
    pde_time_step_count: Optional[int] = rest_field(name="pdeTimeStepCount")
    """The number of time steps in the Partial Differential Equation (PDE) grid. It can be used if the
     'method' property is set to 'PDE' value.
     Optional. The default value is 100."""
    simulation_count: Optional[int] = rest_field(name="simulationCount")
    """The number of paths simulated during MonteCarlo method. The range of possible values is limited
     from 2 to 1000000.
     Optional.The default value is 5000."""

    @overload
    def __init__(
        self,
        *,
        additional_points: Optional[int] = None,
        all_the_time_points_per_year: Optional[int] = None,
        american_monte_carlo_method: Optional[Union[str, "_models.AmericanMonteCarloMethodEnum"]] = None,
        method: Optional[Union[str, "_models.MethodEnum"]] = None,
        pde_space_step_count: Optional[int] = None,
        pde_standard_deviation_count: Optional[int] = None,
        pde_time_step_count: Optional[int] = None,
        simulation_count: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Greeks(_model_base.Model):
    """An object that contains fields related to the common Greeks analytics.

    Attributes
    ----------
    delta : ~analyticsapi.models.Measure
        An object used to express the delta of an instrument, which is defined
        as the change in the instrument's price or market value caused by a
        one-unit change in the price of the underlying asset, or by a 1bp
        change in the swap rate for a swaption, or by a 100bp change in the
        outright for FX instruments.
    gamma : ~analyticsapi.models.Measure
        An object used to express the gamma of an instrument, which is defined
        as the change in the instrument's delta or DV01 per a one-unit change
        in the price of the underlying asset, or a 1 unit parallel shift in the
        curve representing the instrument.
    rho : ~analyticsapi.models.Measure
        An object used to express the rho of an instrument, which is defined as
        the change in the instrument's price per a 1% change in the risk-free
        interest rate.
    theta : ~analyticsapi.models.Measure
        An object used to express the theta of an instrument, which is defined
        as the change in the instrument's price or market value caused by a
        one-day decrease in its time to expiration.
    vega : ~analyticsapi.models.Measure
        An object used to express the vega of an instrument, which is defined
        as the change in the instrument's price per a 1bp change in the normal
        volatility (1% in lognormal volatility) of the underlying asset.
    """

    delta: Optional["_models.Measure"] = rest_field()
    """An object used to express the delta of an instrument, which is defined as the change in the
     instrument's price or market value caused by a one-unit change in the price of the underlying
     asset,
     or by a 1bp change in the swap rate for a swaption, or by a 100bp change in the outright for FX
     instruments."""
    gamma: Optional["_models.Measure"] = rest_field()
    """An object used to express the gamma of an instrument, which is defined as the change in the
     instrument's delta or DV01 per a one-unit change in the price of the underlying asset, or a 1
     unit parallel shift in the curve representing the instrument."""
    rho: Optional["_models.Measure"] = rest_field()
    """An object used to express the rho of an instrument, which is defined as the change in the
     instrument's price per a 1% change in the risk-free interest rate."""
    theta: Optional["_models.Measure"] = rest_field()
    """An object used to express the theta of an instrument, which is defined as the change in the
     instrument's price or market value caused by a one-day decrease in its time to expiration."""
    vega: Optional["_models.Measure"] = rest_field()
    """An object used to express the vega of an instrument, which is defined as the change in the
     instrument's price per a 1bp change in the normal volatility (1% in lognormal volatility) of
     the underlying asset."""

    @overload
    def __init__(
        self,
        *,
        delta: Optional["_models.Measure"] = None,
        gamma: Optional["_models.Measure"] = None,
        rho: Optional["_models.Measure"] = None,
        theta: Optional["_models.Measure"] = None,
        vega: Optional["_models.Measure"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class HalfDayDuration(Duration, discriminator="HalfDayDuration"):
    """An object to determine the duration of the holiday within one day.

    Attributes
    ----------
    duration_type : str or ~analyticsapi.models.HALF_DAY_DURATION
        The type of the holiday duration. Only HalfDayDuration value applies.
        Required. Half day holidays. Designed to account for the days the
        markets are open, but not for a full trading session.
    start_time : ~analyticsapi.models.Time
        An object to determine the start time of the holiday duration.
    end_time : ~analyticsapi.models.Time
        An object to determine the end time of the holiday duration.
    """

    duration_type: Literal[DurationType.HALF_DAY_DURATION] = rest_discriminator(name="durationType")  # type: ignore
    """The type of the holiday duration. Only HalfDayDuration value applies. Required. Half day
     holidays. Designed to account for the days the markets are open, but not for a full trading
     session."""
    start_time: Optional["_models.Time"] = rest_field(name="startTime")
    """An object to determine the start time of the holiday duration."""
    end_time: Optional["_models.Time"] = rest_field(name="endTime")
    """An object to determine the end time of the holiday duration."""

    @overload
    def __init__(
        self,
        *,
        start_time: Optional["_models.Time"] = None,
        end_time: Optional["_models.Time"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, duration_type=DurationType.HALF_DAY_DURATION, **kwargs)


class Header(_model_base.Model):
    """Header.

    Attributes
    ----------
    name : str
        Name of the field.
    type : str or ~analyticsapi.models.TypeEnum
        Type of the field. Known values are: "String", "Float", "DateTime",
        "Integer", "Object", "Date", "Bool", "StringArray", "FloatArray",
        "DateArray", "ObjectArray", and "InvalidField".
    """

    name: Optional[str] = rest_field()
    """Name of the field."""
    type: Optional[Union[str, "_models.TypeEnum"]] = rest_field(default="None")
    """Type of the field. Known values are: \"String\", \"Float\", \"DateTime\", \"Integer\",
     \"Object\", \"Date\", \"Bool\", \"StringArray\", \"FloatArray\", \"DateArray\",
     \"ObjectArray\", and \"InvalidField\"."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        type: Optional[Union[str, "_models.TypeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class HecmSettings(_model_base.Model):
    """HecmSettings.

    Attributes
    ----------
    draw_type : str
        Additional settings for HECM bonds. Is one of the following types:
        Literal["CONSTANT"], Literal["HDC"], Literal["MODEL"]
    draw_rate : float
        Required, method for determining draw amount.
    draw_vector : ~analyticsapi.models.Vector
        Number that specifies draw amount rate. Either drawRate or drawVector
        is required.
    """

    draw_type: Optional[Literal["CONSTANT", "HDC", "MODEL"]] = rest_field(name="drawType")
    """Additional settings for HECM bonds. Is one of the following types: Literal[\"CONSTANT\"],
     Literal[\"HDC\"], Literal[\"MODEL\"]"""
    draw_rate: Optional[float] = rest_field(name="drawRate")
    """Required, method for determining draw amount."""
    draw_vector: Optional["_models.Vector"] = rest_field(name="drawVector")
    """Number that specifies draw amount rate. Either drawRate or drawVector is required."""

    @overload
    def __init__(
        self,
        *,
        draw_type: Optional[Literal["CONSTANT", "HDC", "MODEL"]] = None,
        draw_rate: Optional[float] = None,
        draw_vector: Optional["_models.Vector"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class HestonEquityParameters(ModelParameters, discriminator="HestonEquity"):
    """An object that describes the Heston model parameters applied to the pricing of equity options.

    Attributes
    ----------
    type : str or ~analyticsapi.models.HESTON_EQUITY
        The type of the model used to determine the price of an instrument.
        Restricted to 'HestonEquity'. Required. The Heston model applied to the
        pricing of equity options.
    initial_volatility : ~analyticsapi.models.MarketVolatility
        An object that describes the parameters of the initial volatility.
    long_term_variance : float
        The long term volatility expressed in percentages.
    vol_mean_reversion : float
        The mean reversion of the volatility expressed in percentages.
    vol_of_vol : float
        The volatility of volatility value expressed in percentages.
    correlation : float
        The correlation between the underlying asset and its volatility. The
        value is expressed in percentages.
    dividend : ~analyticsapi.models.Dividend
        An object that describes the dividend parameters.
    """

    type: Literal[ModelTypeEnum.HESTON_EQUITY] = rest_discriminator(name="type")  # type: ignore
    """The type of the model used to determine the price of an instrument. Restricted to
     'HestonEquity'. Required. The Heston model applied to the pricing of equity options."""
    initial_volatility: Optional["_models.MarketVolatility"] = rest_field(name="initialVolatility")
    """An object that describes the parameters of the initial volatility."""
    long_term_variance: Optional[float] = rest_field(name="longTermVariance")
    """The long term volatility expressed in percentages."""
    vol_mean_reversion: Optional[float] = rest_field(name="volMeanReversion")
    """The mean reversion of the volatility expressed in percentages."""
    vol_of_vol: Optional[float] = rest_field(name="volOfVol")
    """The volatility of volatility value expressed in percentages."""
    correlation: Optional[float] = rest_field()
    """The correlation between the underlying asset and its volatility. The value is expressed in
     percentages."""
    dividend: Optional["_models.Dividend"] = rest_field()
    """An object that describes the dividend parameters."""

    @overload
    def __init__(
        self,
        *,
        initial_volatility: Optional["_models.MarketVolatility"] = None,
        long_term_variance: Optional[float] = None,
        vol_mean_reversion: Optional[float] = None,
        vol_of_vol: Optional[float] = None,
        correlation: Optional[float] = None,
        dividend: Optional["_models.Dividend"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=ModelTypeEnum.HESTON_EQUITY, **kwargs)


class Holiday(_model_base.Model):
    """Dates and names of holidays for a requested calendar.

    Attributes
    ----------
    date : ~datetime.date
        The date on which the holiday falls. The value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., 2024-01-01). Required.
    names : list[~analyticsapi.models.HolidayNames]
        An array of objects to define the holiday name, calendar and country in
        which that holiday falls.  The default value is None, needs to be
        assigned before using.
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    date: datetime.date = rest_field()
    """The date on which the holiday falls. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., 2024-01-01). Required."""
    names: Optional[List["_models.HolidayNames"]] = rest_field()
    """An array of objects to define the holiday name, calendar and country in which that holiday
     falls."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        date: datetime.date,
        names: Optional[List["_models.HolidayNames"]] = None,
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class HolidayNames(_model_base.Model):
    """An object to define the holiday name, calendar and country in which that holiday falls.

    Attributes
    ----------
    name : str
        The name of the holiday.
    calendars : list[str]
        An array of calendar defining objects for which the calculation is
        done.  The default value is None, needs to be assigned before using.
    countries : list[str]
        An array of country codes the holiday belongs to. For example, FRA for
        France, UKG for The United Kingdom.  The default value is None, needs
        to be assigned before using.
    """

    name: Optional[str] = rest_field()
    """The name of the holiday."""
    calendars: Optional[List[str]] = rest_field()
    """An array of calendar defining objects for which the calculation is done."""
    countries: Optional[List[str]] = rest_field()
    """An array of country codes the holiday belongs to. For example, FRA for France, UKG for The
     United Kingdom."""

    @overload
    def __init__(
        self,
        *,
        name: Optional[str] = None,
        calendars: Optional[List[str]] = None,
        countries: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class HolidayRule(_model_base.Model):
    """An object to set holiday rules for the calendar.

    Attributes
    ----------
    name : str
        The name of the holiday rule. An alphanumeric character (upper or lower
        case), followed by 1 to 75 characters: alpha numeric (upper and lower
        case) plus spaces, parentheses, dashes, equals and single quotes.
        Required.
    description : str
        The description of the holiday rule.
    duration : ~analyticsapi.models.Duration
        An object to determine the duration of the holiday. Either a number of
        days or the object describing half day holiday should be defined.
        Required.
    validity_period : ~analyticsapi.models.ValidityPeriod
        An object to determine the validity period. Required.
    when : ~analyticsapi.models.When
        An object to determine regular annual holiday rules for the calendar.
        Possible values are: AbsolutePositionWhen (for fixed holidays),
        RelativePositionWhen (for holidays that fall on a particular day of the
        week) or RelativeToRulePositionWhen (for holidays that are set by
        reference to another date). Required.
    """

    name: str = rest_field()
    """The name of the holiday rule. An alphanumeric character (upper or lower case), followed by 1 to
     75 characters: alpha numeric (upper and lower case) plus spaces, parentheses, dashes, equals
     and single quotes. Required."""
    description: Optional[str] = rest_field()
    """The description of the holiday rule."""
    duration: "_models.Duration" = rest_field()
    """An object to determine the duration of the holiday. Either a number of days or the object
     describing half day holiday should be defined. Required."""
    validity_period: "_models.ValidityPeriod" = rest_field(name="validityPeriod")
    """An object to determine the validity period. Required."""
    when: "_models.When" = rest_field()
    """An object to determine regular annual holiday rules for the calendar. Possible values are:
     AbsolutePositionWhen (for fixed holidays), RelativePositionWhen (for holidays that fall on a
     particular day of the week) or RelativeToRulePositionWhen (for holidays that are set by
     reference to another date). Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        duration: "_models.Duration",
        validity_period: "_models.ValidityPeriod",
        when: "_models.When",
        description: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class HorizonInfo(_model_base.Model):
    """HorizonInfo.

    Attributes
    ----------
    scenario_id : str
        Identification code of the scenario.
    level : str
        Horizon input price for the security. Input can be a price, yield,
        spread, OAS, etc.. See quick card for list of options.
    prepay : ~analyticsapi.models.RestPrepaySettings
    loss_settings : ~analyticsapi.models.LossSettings
    cmbs_scenario : ~analyticsapi.models.PricingScenario
    scenario_ref : ~analyticsapi.models.JsonScenRef
    """

    scenario_id: Optional[str] = rest_field(name="scenarioID")
    """Identification code of the scenario."""
    level: Optional[str] = rest_field()
    """Horizon input price for the security. Input can be a price, yield, spread, OAS, etc.. See quick
     card for list of options."""
    prepay: Optional["_models.RestPrepaySettings"] = rest_field()
    loss_settings: Optional["_models.LossSettings"] = rest_field(name="lossSettings")
    cmbs_scenario: Optional["_models.PricingScenario"] = rest_field(name="cmbsScenario")
    scenario_ref: Optional["_models.JsonScenRef"] = rest_field(name="scenarioRef")

    @overload
    def __init__(
        self,
        *,
        scenario_id: Optional[str] = None,
        level: Optional[str] = None,
        prepay: Optional["_models.RestPrepaySettings"] = None,
        loss_settings: Optional["_models.LossSettings"] = None,
        cmbs_scenario: Optional["_models.PricingScenario"] = None,
        scenario_ref: Optional["_models.JsonScenRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class HullWhiteParameters(_model_base.Model):
    """HullWhiteParameters.

    Attributes
    ----------
    flat_volatility_percent : float
    """

    flat_volatility_percent: Optional[float] = rest_field(name="flatVolatilityPercent")

    @overload
    def __init__(
        self,
        flat_volatility_percent: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["flat_volatility_percent"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class IdentifierInfo(_model_base.Model):
    """The main object containing the information to search for a security in Yield Book reference
    data given the string representing the identifier and the string for the type of identifier.
    For example, given "10YR" as the identifier, and "Identifier" as idType would be sufficient to
    search for reference data on a 10 Year US Treasury Bond.

    Attributes
    ----------
    identifier : str
        The string for the identifier to search for.
    id_type : str or ~analyticsapi.models.IdTypeEnum
        The type of convention for the input identifier. By Default, selecting
        SecurityID would allow the system to automatically select the correct
        type.Possible values are: "SecurityID", "CUSIP", "ISIN", "REGSISIN",
        "SEDOL", "Identifier", "ChinaInterbankCode", "ShanghaiExchangeCode",
        "ShenzhenExchangeCode", and "MXTickerID". Known values are:
        "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN", "REGSISIN", "SEDOL",
        "Identifier", "ChinaInterbankCode", "ShanghaiExchangeCode",
        "ShenzhenExchangeCode", and "MXTickerID".
    user_instrument : ~analyticsapi.models.JsonRef
        Container for possible User defined instrument input via JsonRef
        structure (see further documentation for more information).
    props : dict[str, any]
    """

    identifier: Optional[str] = rest_field()
    """The string for the identifier to search for."""
    id_type: Optional[Union[str, "_models.IdTypeEnum"]] = rest_field(name="idType")
    """The type of convention for the input identifier. By Default, selecting SecurityID would allow
     the system to automatically select the correct type.Possible values are: \"SecurityID\",
     \"CUSIP\", \"ISIN\", \"REGSISIN\", \"SEDOL\", \"Identifier\", \"ChinaInterbankCode\",
     \"ShanghaiExchangeCode\", \"ShenzhenExchangeCode\", and \"MXTickerID\". Known values are:
     \"SecurityIDEntry\", \"SecurityID\", \"CUSIP\", \"ISIN\", \"REGSISIN\", \"SEDOL\",
     \"Identifier\", \"ChinaInterbankCode\", \"ShanghaiExchangeCode\", \"ShenzhenExchangeCode\", and
     \"MXTickerID\"."""
    user_instrument: Optional["_models.JsonRef"] = rest_field(name="userInstrument")
    """Container for possible User defined instrument input via JsonRef structure (see further
     documentation for more information)."""
    props: Optional[Dict[str, Any]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        identifier: Optional[str] = None,
        id_type: Optional[Union[str, "_models.IdTypeEnum"]] = None,
        user_instrument: Optional["_models.JsonRef"] = None,
        props: Optional[Dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IncomeTaxCashflow(Cashflow, discriminator="IncomeTax"):
    """Lists the properties for Income tax payment type.

    Attributes
    ----------
    date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the payment
        date.
    amount : ~analyticsapi.models.Amount
        An object that defines the amount and currency of a payment. Required.
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that makes the payment. Required. Known
        values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that receives the payment. Required. Known
        values are: "Party1" and "Party2".
    occurrence : str or ~analyticsapi.models.PaymentOccurrenceEnum
        The timeline of the transaction. The possible values are: Historical:
        the cash flow date is earlier than the valuation date, Future: the cash
        flow date follows the valuation date and the cash flow is known,
        Projected: the cash flow date follows the valuation date and the cash
        flow is not set by the contract but estimated. Required. Known values
        are: "Historical", "Future", and "Projected".
    payment_type : str or ~analyticsapi.models.INCOME_TAX
        Required.
    """

    payment_type: Literal[CashFlowPaymentTypeEnum.INCOME_TAX] = rest_discriminator(name="paymentType")  # type: ignore
    """Required."""

    @overload
    def __init__(
        self,
        *,
        amount: "_models.Amount",
        payer: Union[str, "_models.PartyEnum"],
        receiver: Union[str, "_models.PartyEnum"],
        occurrence: Union[str, "_models.PaymentOccurrenceEnum"],
        date: Optional["_models.Date"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["payment_type"] = args[0]
            args = tuple()
        super().__init__(*args, payment_type=CashFlowPaymentTypeEnum.INCOME_TAX, **kwargs)


class IndexCompoundingDefinition(_model_base.Model):
    """An object that defines the use of index compounding.

    Attributes
    ----------
    observation_method : str or ~analyticsapi.models.IndexObservationMethodEnum
        (RFR) Method for determining the accrual observation period. The number
        of business days between the fixing date and the start or end date of
        the coupon period is determined by the index fixing lag. Required.
        Known values are: "Lookback", "PeriodShift", and "Mixed".
    lockout_period : int
        The period from the start date (inclusive) of the index lockout to the
        end date of the interest calculation period for which the reference
        rate is no longer updated. During this period the index of the day
        preceding the start date of the lockout period is applied to the
        remaining days of the interest period. The value is expressed in
        working days. Please note, that by (ISDA) definition the lockout method
        is applied only to payment periods (with Fixing) and not to future
        periods (with ZcCurve). Required.
    compounding_mode : str or ~analyticsapi.models.CompoundingModeEnum
        The mode used to define how the interest rate is calculated from the
        reset floating rates when the reset frequency is higher than the
        interest payment frequency (e.g., daily index reset with quarterly
        interest payments). Required. Known values are: "Compounding",
        "Average", "Constant", "AdjustedCompounded", and "MexicanCompounded".
    spread_compounding_mode : str or ~analyticsapi.models.SpreadCompoundingModeEnum
        The mode used to define how the spread is applied to a compound
        interest rate. It is only applied when compounding mode is set for the
        reference index. Required. Known values are: "IsdaCompounding",
        "IsdaFlatCompounding", and "NoCompounding".
    """

    observation_method: Union[str, "_models.IndexObservationMethodEnum"] = rest_field(name="observationMethod")
    """(RFR) Method for determining the accrual observation period. The number of business days
     between the fixing date and the start or end date of the coupon period is determined by the
     index fixing lag. Required. Known values are: \"Lookback\", \"PeriodShift\", and \"Mixed\"."""
    lockout_period: int = rest_field(name="lockoutPeriod")
    """The period from the start date (inclusive) of the index lockout to the end date of the interest
     calculation period for which the reference rate is no longer updated.
     During this period the index of the day preceding the start date of the lockout period is
     applied to the remaining days of the interest period.
     The value is expressed in working days.
     Please note, that by (ISDA) definition the lockout method is applied only to payment periods
     (with Fixing) and not to future periods (with ZcCurve). Required."""
    compounding_mode: Union[str, "_models.CompoundingModeEnum"] = rest_field(name="compoundingMode")
    """The mode used to define how the interest rate is calculated from the reset floating rates when
     the reset frequency is higher than the interest payment frequency (e.g., daily index reset with
     quarterly interest payments). Required. Known values are: \"Compounding\", \"Average\",
     \"Constant\", \"AdjustedCompounded\", and \"MexicanCompounded\"."""
    spread_compounding_mode: Union[str, "_models.SpreadCompoundingModeEnum"] = rest_field(name="spreadCompoundingMode")
    """The mode used to define how the spread is applied to a compound interest rate. It is only
     applied when compounding mode is set for the reference index. Required. Known values are:
     \"IsdaCompounding\", \"IsdaFlatCompounding\", and \"NoCompounding\"."""

    @overload
    def __init__(
        self,
        *,
        observation_method: Union[str, "_models.IndexObservationMethodEnum"],
        lockout_period: int,
        compounding_mode: Union[str, "_models.CompoundingModeEnum"],
        spread_compounding_mode: Union[str, "_models.SpreadCompoundingModeEnum"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexFixing(_model_base.Model):
    """Lists properties of IndexFixing object available for specified instrument.

    Attributes
    ----------
    accrual_end_date : ~datetime.date
        The end date of the accrual period. The value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., '2021-01-01'). Required.
    accrual_start_date : ~datetime.date
        The start date of the accrual period. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Required.
    cap_strike : ~analyticsapi.models.Rate
        The contractual strike rate of the cap. The value is expressed in
        percentages. Required.
    coupon_rate : ~analyticsapi.models.Rate
        Represents the annual coupon rate of the instrument expressed in
        percentages. Required.
    fixing_date : ~datetime.date
        The date of the coupon fixing. The value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., '2021-01-01'). Required.
    floor_strike : ~analyticsapi.models.Rate
        The contractual strike rate of the floor. The value is expressed in
        percentages. Required.
    forward_source : str or ~analyticsapi.models.IndexFixingForwardSourceEnum
        The source of the index fixing information. The possible values are:
        Fixing: for historic values, ZcCurve: for future values. Required.
        Known values are: "Fixing" and "ZcCurve".
    reference_rate : ~analyticsapi.models.Rate
        The value of the reference index at the fixing date. The value is
        expressed in percentages. Required.
    spread_bp : float
        The spread applied to the floating interest rate of the instrument. The
        value is expressed in basis points. Required.
    """

    accrual_end_date: datetime.date = rest_field(name="accrualEndDate")
    """The end date of the accrual period. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., '2021-01-01'). Required."""
    accrual_start_date: datetime.date = rest_field(name="accrualStartDate")
    """The start date of the accrual period. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., '2021-01-01'). Required."""
    cap_strike: "_models.Rate" = rest_field(name="capStrike")
    """The contractual strike rate of the cap. The value is expressed in percentages. Required."""
    coupon_rate: "_models.Rate" = rest_field(name="couponRate")
    """Represents the annual coupon rate of the instrument expressed in percentages. Required."""
    fixing_date: datetime.date = rest_field(name="fixingDate")
    """The date of the coupon fixing. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
     '2021-01-01'). Required."""
    floor_strike: "_models.Rate" = rest_field(name="floorStrike")
    """The contractual strike rate of the floor. The value is expressed in percentages. Required."""
    forward_source: Union[str, "_models.IndexFixingForwardSourceEnum"] = rest_field(name="forwardSource")
    """The source of the index fixing information. The possible values are:
     Fixing: for historic values,
     ZcCurve: for future values. Required. Known values are: \"Fixing\" and \"ZcCurve\"."""
    reference_rate: "_models.Rate" = rest_field(name="referenceRate")
    """The value of the reference index at the fixing date. The value is expressed in percentages.
     Required."""
    spread_bp: float = rest_field(name="spreadBp")
    """The spread applied to the floating interest rate of the instrument. The value is expressed in
     basis points. Required."""

    @overload
    def __init__(
        self,
        *,
        accrual_end_date: datetime.date,
        accrual_start_date: datetime.date,
        cap_strike: "_models.Rate",
        coupon_rate: "_models.Rate",
        fixing_date: datetime.date,
        floor_strike: "_models.Rate",
        forward_source: Union[str, "_models.IndexFixingForwardSourceEnum"],
        reference_rate: "_models.Rate",
        spread_bp: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndexLinkerSettings(_model_base.Model):
    """Optional. Used for Inflation-Linked Securities.

    Attributes
    ----------
    real_yield_beta : float
        Optional, number, allows users to override default realYieldBeta.
    """

    real_yield_beta: Optional[float] = rest_field(name="realYieldBeta")
    """Optional, number, allows users to override default realYieldBeta."""

    @overload
    def __init__(
        self,
        real_yield_beta: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["real_yield_beta"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class IndexProjection(_model_base.Model):
    """IndexProjection.

    Attributes
    ----------
    index : str
    term_unit : str
        Is either a Literal["MONTH"] type or a Literal["YEAR"] type.
    values_property : list[~analyticsapi.models.TermRatePair]
        The default value is None, needs to be assigned before using.
    """

    index: Optional[str] = rest_field()
    term_unit: Optional[Literal["MONTH", "YEAR"]] = rest_field(name="termUnit")
    """Is either a Literal[\"MONTH\"] type or a Literal[\"YEAR\"] type."""
    values_property: Optional[List["_models.TermRatePair"]] = rest_field(name="values")

    @overload
    def __init__(
        self,
        *,
        index: Optional[str] = None,
        term_unit: Optional[Literal["MONTH", "YEAR"]] = None,
        values_property: Optional[List["_models.TermRatePair"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndirectSourcesDeposits(_model_base.Model):
    """An object that defines the sources containing the market data for the deposit instruments used
    to create the curve definition.
    It applies when there is an indirect quotation for the currency pair of the curve.

    Attributes
    ----------
    base_fx_spot : str
        The source of FX spot for the base currency in the cross-currency pair
        of the curve against the reference currency.
    quoted_fx_spot : str
        The source of FX spot for the quoted currency in the cross-currency
        pair of the curve against the reference currency.
    base_deposit : str
        The source of deposits for the base currency in the cross-currency pair
        of the curve.
    quoted_deposit : str
        The source of deposits for the quoted currency in the cross-currency
        pair of the curve.
    """

    base_fx_spot: Optional[str] = rest_field(name="baseFxSpot")
    """The source of FX spot for the base currency in the cross-currency pair of the curve against the
     reference currency."""
    quoted_fx_spot: Optional[str] = rest_field(name="quotedFxSpot")
    """The source of FX spot for the quoted currency in the cross-currency pair of the curve against
     the reference currency."""
    base_deposit: Optional[str] = rest_field(name="baseDeposit")
    """The source of deposits for the base currency in the cross-currency pair of the curve."""
    quoted_deposit: Optional[str] = rest_field(name="quotedDeposit")
    """The source of deposits for the quoted currency in the cross-currency pair of the curve."""

    @overload
    def __init__(
        self,
        *,
        base_fx_spot: Optional[str] = None,
        quoted_fx_spot: Optional[str] = None,
        base_deposit: Optional[str] = None,
        quoted_deposit: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IndirectSourcesSwaps(_model_base.Model):
    """An object that defines the sources containing the market data for the FX forward instruments
    used to create the curve definition.
    It applies when there is an indirect quotation for the currency pair of the curve. If reference
    currency is not specified, quotedFxSpot and quotedFxForwards properties should be used to
    determine source.

    Attributes
    ----------
    base_fx_spot : str
        The source of FX spot for the base currency in the cross-currency pair.
    quoted_fx_spot : str
        The source of FX spot for the quoted currency in the cross-currency
        pair.
    base_fx_forwards : str
        The source of FX forwards for the base currency in the cross-currency
        pair.
    quoted_fx_forwards : str
        The source of FX forwards for the quoted currency in the cross-currency
        pair.
    """

    base_fx_spot: Optional[str] = rest_field(name="baseFxSpot")
    """The source of FX spot for the base currency in the cross-currency pair."""
    quoted_fx_spot: Optional[str] = rest_field(name="quotedFxSpot")
    """The source of FX spot for the quoted currency in the cross-currency pair."""
    base_fx_forwards: Optional[str] = rest_field(name="baseFxForwards")
    """The source of FX forwards for the base currency in the cross-currency pair."""
    quoted_fx_forwards: Optional[str] = rest_field(name="quotedFxForwards")
    """The source of FX forwards for the quoted currency in the cross-currency pair."""

    @overload
    def __init__(
        self,
        *,
        base_fx_spot: Optional[str] = None,
        quoted_fx_spot: Optional[str] = None,
        base_fx_forwards: Optional[str] = None,
        quoted_fx_forwards: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationConstituents(_model_base.Model):
    """The list of constituents used to construct the curve.

    Attributes
    ----------
    inflation_instruments : dict[str, ~analyticsapi.models.InflationInstruments]
        The list of attributes for inflation instruments used as constituents
        to construct the curve.  These attributes are applied to each currency
        which is used in calculation.
    """

    inflation_instruments: Optional[Dict[str, "_models.InflationInstruments"]] = rest_field(name="inflationInstruments")
    """The list of attributes for inflation instruments used as constituents to construct the curve.
     These attributes are applied to each currency which is used in calculation."""

    @overload
    def __init__(
        self,
        inflation_instruments: Optional[Dict[str, "_models.InflationInstruments"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["inflation_instruments"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InflationConstituentsDescription(_model_base.Model):
    """InflationConstituentsDescription.

    Attributes
    ----------
    inflation_swaps : list[~analyticsapi.models.InflationSwapsInstrumentDescription]
        Get inflationSwaps.  The default value is None, needs to be assigned
        before using.
    """

    inflation_swaps: Optional[List["_models.InflationSwapsInstrumentDescription"]] = rest_field(name="inflationSwaps")
    """Get inflationSwaps."""

    @overload
    def __init__(
        self,
        inflation_swaps: Optional[List["_models.InflationSwapsInstrumentDescription"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["inflation_swaps"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InflationConstituentsOutput(_model_base.Model):
    """InflationConstituentsOutput.

    Attributes
    ----------
    inflation_instruments : dict[str, ~analyticsapi.models.InflationInstrumentsOutput]
        Get inflationInstruments.
    """

    inflation_instruments: Optional[Dict[str, "_models.InflationInstrumentsOutput"]] = rest_field(
        name="inflationInstruments"
    )
    """Get inflationInstruments."""

    @overload
    def __init__(
        self,
        inflation_instruments: Optional[Dict[str, "_models.InflationInstrumentsOutput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["inflation_instruments"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InflationCurveCreateRequest(_model_base.Model):
    """interest rate curve definition.

    Attributes
    ----------
    curve_definition : ~analyticsapi.models.InflationCurveDefinitionDescriptionRequest
    overrides : list[~analyticsapi.models.OverrideBidAsk]
        Get overrides.  The default value is None, needs to be assigned before
        using.
    segments : list[~analyticsapi.models.InflationInstrumentsSegment]
        Get segments.  The default value is None, needs to be assigned before
        using.
    """

    curve_definition: Optional["_models.InflationCurveDefinitionDescriptionRequest"] = rest_field(
        name="curveDefinition"
    )
    overrides: Optional[List["_models.OverrideBidAsk"]] = rest_field()
    """Get overrides."""
    segments: Optional[List["_models.InflationInstrumentsSegment"]] = rest_field()
    """Get segments."""

    @overload
    def __init__(
        self,
        *,
        curve_definition: Optional["_models.InflationCurveDefinitionDescriptionRequest"] = None,
        overrides: Optional[List["_models.OverrideBidAsk"]] = None,
        segments: Optional[List["_models.InflationInstrumentsSegment"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurveDefinition(_model_base.Model):
    """InflationCurveDefinition.

    Attributes
    ----------
    country : str
        The country code of the curve origin. The value is defined with Alpha-2
        Code ISO 3166 country code convention (e.g., 'US').
    currency : str
        The currency code of the curve. The value is expressed in ISO 4217
        alphabetical format (e.g., 'USD').
    first_historical_availability_date : ~datetime.date
        The date starting from which the definition of the curve can be used.
        The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01').
    id : str
        The identifier of the inflation curve.
    inflation_index : ~analyticsapi.models.InflationIndex
    name : str
        The name of the curve (e.g., 'USD Inflation linked ZC Curve').
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the curve is sensitive. The possible value is:
        Inflation. Known values are: "Credit", "CrossCurrency", "Inflation",
        and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of the curve.
        Curves created by Refinitiv have the 'Refinitiv' source.
    """

    country: Optional[str] = rest_field()
    """The country code of the curve origin. The value is defined with Alpha-2 Code ISO 3166 country
     code convention (e.g., 'US')."""
    currency: Optional[str] = rest_field()
    """The currency code of the curve. The value is expressed in ISO 4217 alphabetical format (e.g.,
     'USD')."""
    first_historical_availability_date: Optional[datetime.date] = rest_field(name="firstHistoricalAvailabilityDate")
    """The date starting from which the definition of the curve can be used.  The value is expressed
     in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    id: Optional[str] = rest_field()
    """The identifier of the inflation curve."""
    inflation_index: Optional["_models.InflationIndex"] = rest_field(name="inflationIndex")
    name: Optional[str] = rest_field()
    """The name of the curve (e.g., 'USD Inflation linked ZC Curve')."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the curve is sensitive. The possible value is: Inflation. Known values
     are: \"Credit\", \"CrossCurrency\", \"Inflation\", and \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of the curve. Curves created by Refinitiv
     have the 'Refinitiv' source."""

    @overload
    def __init__(
        self,
        *,
        country: Optional[str] = None,
        currency: Optional[str] = None,
        first_historical_availability_date: Optional[datetime.date] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        inflation_index: Optional["_models.InflationIndex"] = None,
        name: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurveDefinitionDescriptionRequest(_model_base.Model):  # pylint: disable=name-too-long
    """InflationCurveDefinitionDescriptionRequest.

    Attributes
    ----------
    country : str
        The country code of the curve origin. The value is defined with Alpha-2
        Code ISO 3166 country code convention (e.g., 'US').
    currency : str
        The currency code of the curve. The value is expressed in ISO 4217
        alphabetical format (e.g., 'USD').
    definition_expiry_date : ~datetime.date
        The date after which curveDefinitions can not be used. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    inflation_index : ~analyticsapi.models.InflationIndexDescription
    name : str
        The name of the curve (e.g., 'USD Inflation linked ZC Curve').
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the curve is sensitive. The possible value is:
        Inflation. Known values are: "Credit", "CrossCurrency", "Inflation",
        and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of the curve.
        Curves created by Refinitiv have the 'Refinitiv' source.
    """

    country: Optional[str] = rest_field()
    """The country code of the curve origin. The value is defined with Alpha-2 Code ISO 3166 country
     code convention (e.g., 'US')."""
    currency: Optional[str] = rest_field()
    """The currency code of the curve. The value is expressed in ISO 4217 alphabetical format (e.g.,
     'USD')."""
    definition_expiry_date: Optional[datetime.date] = rest_field(name="definitionExpiryDate")
    """The date after which curveDefinitions can not be used. The value is expressed in ISO 8601
     format: YYYY-MM-DD (e.g., '2021-01-01')."""
    inflation_index: Optional["_models.InflationIndexDescription"] = rest_field(name="inflationIndex")
    name: Optional[str] = rest_field()
    """The name of the curve (e.g., 'USD Inflation linked ZC Curve')."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the curve is sensitive. The possible value is: Inflation. Known values
     are: \"Credit\", \"CrossCurrency\", \"Inflation\", and \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of the curve. Curves created by Refinitiv
     have the 'Refinitiv' source."""

    @overload
    def __init__(
        self,
        *,
        country: Optional[str] = None,
        currency: Optional[str] = None,
        definition_expiry_date: Optional[datetime.date] = None,
        inflation_index: Optional["_models.InflationIndexDescription"] = None,
        name: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurveDefinitionDescriptionResponse(_model_base.Model):  # pylint: disable=name-too-long
    """InflationCurveDefinitionDescriptionResponse.

    Attributes
    ----------
    country : str
        The country code of the curve origin. The value is defined with Alpha-2
        Code ISO 3166 country code convention (e.g., 'US').
    currency : str
        The currency code of the curve. The value is expressed in ISO 4217
        alphabetical format (e.g., 'USD').
    definition_expiry_date : ~datetime.date
        The date after which curveDefinitions can not be used. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    id : str
        The identifier of the inflation definition.
    inflation_index : ~analyticsapi.models.InflationIndexDescription
    name : str
        The name of the curve (e.g., 'USD Inflation linked ZC Curve').
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the curve is sensitive. The possible value is:
        Inflation. Known values are: "Credit", "CrossCurrency", "Inflation",
        and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of the curve.
        Curves created by Refinitiv have the 'Refinitiv' source.
    """

    country: Optional[str] = rest_field()
    """The country code of the curve origin. The value is defined with Alpha-2 Code ISO 3166 country
     code convention (e.g., 'US')."""
    currency: Optional[str] = rest_field()
    """The currency code of the curve. The value is expressed in ISO 4217 alphabetical format (e.g.,
     'USD')."""
    definition_expiry_date: Optional[datetime.date] = rest_field(name="definitionExpiryDate")
    """The date after which curveDefinitions can not be used. The value is expressed in ISO 8601
     format: YYYY-MM-DD (e.g., '2021-01-01')."""
    id: Optional[str] = rest_field()
    """The identifier of the inflation definition."""
    inflation_index: Optional["_models.InflationIndexDescription"] = rest_field(name="inflationIndex")
    name: Optional[str] = rest_field()
    """The name of the curve (e.g., 'USD Inflation linked ZC Curve')."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the curve is sensitive. The possible value is: Inflation. Known values
     are: \"Credit\", \"CrossCurrency\", \"Inflation\", and \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of the curve. Curves created by Refinitiv
     have the 'Refinitiv' source."""

    @overload
    def __init__(
        self,
        *,
        country: Optional[str] = None,
        currency: Optional[str] = None,
        definition_expiry_date: Optional[datetime.date] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        inflation_index: Optional["_models.InflationIndexDescription"] = None,
        name: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurveDefinitionItem(_model_base.Model):
    """The definition of the curve attributes needed to search the list of constituents that are used
    to construct the curve.  A unique curve definition must be defined.

    Attributes
    ----------
    constituent_override_mode : str or ~analyticsapi.models.ConstituentOverrideModeEnum
        The mode used to define if constituents which are derived from the
        curve definition should be merged with or replaced by the overridden
        constituents. The possible values are:   * MergeWithDefinition: merge
        the default constituents and the user constituents from the input
        request,   * ReplaceDefinition: replace the default constituents by the
        user constituents from the input request. Known values are:
        "MergeWithDefinition" and "ReplaceDefinition".
    country : str
        The country code of the curve origin. The value is defined with Alpha-2
        Code ISO 3166 country code convention (e.g., 'US').
    currency : str
        The currency code of the curve. The value is expressed in ISO 4217
        alphabetical format (e.g., 'USD').
    curve_tenors : list[str]
        The list of user-defined tenors or dates for which curvePoints to be
        computed.  The values are expressed in:   * time period code for tenors
        (e.g., '1M', '6M', '4Y'),   * ISO 8601 format 'YYYY-MM-DD' for dates
        (e.g., '2021-01-01'). If the curve point cannot be defined from a
        constituent, interpolation or extrapolation is used to calculate it.
        The default value is None, needs to be assigned before using.
    id : str
        The identifier of the inflation definition.
    ignore_existing_definition : bool
    inflation_index : ~analyticsapi.models.InflationIndex
    name : str
        The name of the curve (e.g., 'USD Inflation linked ZC Curve').
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the curve is sensitive. The possible value is:
        Inflation. Known values are: "Credit", "CrossCurrency", "Inflation",
        and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of the curve.
        Curves created by Refinitiv have the 'Refinitiv' source.
    """

    constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = rest_field(
        name="constituentOverrideMode"
    )
    """The mode used to define if constituents which are derived from the curve definition should be
     merged with or replaced by the overridden constituents. The possible values are:   *
     MergeWithDefinition: merge the default constituents and the user constituents from the input
     request,   * ReplaceDefinition: replace the default constituents by the user constituents from
     the input request. Known values are: \"MergeWithDefinition\" and \"ReplaceDefinition\"."""
    country: Optional[str] = rest_field()
    """The country code of the curve origin. The value is defined with Alpha-2 Code ISO 3166 country
     code convention (e.g., 'US')."""
    currency: Optional[str] = rest_field()
    """The currency code of the curve. The value is expressed in ISO 4217 alphabetical format (e.g.,
     'USD')."""
    curve_tenors: Optional[List[str]] = rest_field(name="curveTenors")
    """The list of user-defined tenors or dates for which curvePoints to be computed.  The values are
     expressed in:   * time period code for tenors (e.g., '1M', '6M', '4Y'),   * ISO 8601 format
     'YYYY-MM-DD' for dates (e.g., '2021-01-01'). If the curve point cannot be defined from a
     constituent, interpolation or extrapolation is used to calculate it."""
    id: Optional[str] = rest_field()
    """The identifier of the inflation definition."""
    ignore_existing_definition: Optional[bool] = rest_field(name="ignoreExistingDefinition")
    inflation_index: Optional["_models.InflationIndex"] = rest_field(name="inflationIndex")
    name: Optional[str] = rest_field()
    """The name of the curve (e.g., 'USD Inflation linked ZC Curve')."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the curve is sensitive. The possible value is: Inflation. Known values
     are: \"Credit\", \"CrossCurrency\", \"Inflation\", and \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of the curve. Curves created by Refinitiv
     have the 'Refinitiv' source."""

    @overload
    def __init__(
        self,
        *,
        constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = None,
        country: Optional[str] = None,
        currency: Optional[str] = None,
        curve_tenors: Optional[List[str]] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        ignore_existing_definition: Optional[bool] = None,
        inflation_index: Optional["_models.InflationIndex"] = None,
        name: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurveDefinitionResponse(_model_base.Model):
    """InflationCurveDefinitionResponse.

    Attributes
    ----------
    curve_definition : ~analyticsapi.models.InflationCurveDefinitionDescriptionResponse
    curve_info : ~analyticsapi.models.CurveInfo
    overrides : list[~analyticsapi.models.OverrideBidAsk]
        Get overrides.  The default value is None, needs to be assigned before
        using.
    segments : list[~analyticsapi.models.InflationInstrumentsSegment]
        Get segments.  The default value is None, needs to be assigned before
        using.
    """

    curve_definition: Optional["_models.InflationCurveDefinitionDescriptionResponse"] = rest_field(
        name="curveDefinition"
    )
    curve_info: Optional["_models.CurveInfo"] = rest_field(name="curveInfo")
    overrides: Optional[List["_models.OverrideBidAsk"]] = rest_field()
    """Get overrides."""
    segments: Optional[List["_models.InflationInstrumentsSegment"]] = rest_field()
    """Get segments."""

    @overload
    def __init__(
        self,
        *,
        curve_definition: Optional["_models.InflationCurveDefinitionDescriptionResponse"] = None,
        curve_info: Optional["_models.CurveInfo"] = None,
        overrides: Optional[List["_models.OverrideBidAsk"]] = None,
        segments: Optional[List["_models.InflationInstrumentsSegment"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurveDefinitionResponseItem(_model_base.Model):
    """InflationCurveDefinitionResponseItem.

    Attributes
    ----------
    curve_definitions : list[~analyticsapi.models.InflationCurveDefinition]
        The definition of attributes for the curve.  The default value is None,
        needs to be assigned before using.
    curve_tag : str
        A user-defined string to identify the curve. It can be used to link
        output results to the curve definition.  Limited to 40 characters. Only
        alphabetic, numeric and '- _.#=@' characters are supported.
    """

    curve_definitions: Optional[List["_models.InflationCurveDefinition"]] = rest_field(name="curveDefinitions")
    """The definition of attributes for the curve."""
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the curve. It can be used to link output results to the curve
     definition.  Limited to 40 characters. Only alphabetic, numeric and '- _.#=@' characters are
     supported."""

    @overload
    def __init__(
        self,
        *,
        curve_definitions: Optional[List["_models.InflationCurveDefinition"]] = None,
        curve_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurveDefinitionsResponse(_model_base.Model):
    """InflationCurveDefinitionsResponse.

    Attributes
    ----------
    data : list[~analyticsapi.models.InflationCurveDefinitionResponseItem]
        Get data.  The default value is None, needs to be assigned before
        using.
    """

    data: Optional[List["_models.InflationCurveDefinitionResponseItem"]] = rest_field()
    """Get data."""

    @overload
    def __init__(
        self,
        data: Optional[List["_models.InflationCurveDefinitionResponseItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InflationCurveGetDefinitionItem(_model_base.Model):
    """InflationCurveGetDefinitionItem.

    Attributes
    ----------
    country : str
        The country code of the curve origin. The value is defined with Alpha-2
        Code ISO 3166 country code convention (e.g., 'US').
    currency : str
        The currency code of the curve. The value is expressed in ISO 4217
        alphabetical format (e.g., 'USD').
    curve_tag : str
        A user-defined string to identify the curve. It can be used to link
        output results to the curve definition. Limited to 40 characters. Only
        alphabetic, numeric and '- _.#=@' characters are supported.
    id : str
        The identifier of the inflation definition.
    inflation_index : ~analyticsapi.models.InflationIndex
    name : str
        The name of the curve (e.g., 'USD Inflation linked ZC Curve').
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the curve is sensitive. The possible value is:
        Inflation. Known values are: "Credit", "CrossCurrency", "Inflation",
        and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of the curve.
        Curves created by Refinitiv have the 'Refinitiv' source.
    valuation_date : ~datetime.date
        The date used to define a list of curves or a unique curve that can be
        priced at this date.  This date must be less or equal to today's date.
        The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01').
    """

    country: Optional[str] = rest_field()
    """The country code of the curve origin. The value is defined with Alpha-2 Code ISO 3166 country
     code convention (e.g., 'US')."""
    currency: Optional[str] = rest_field()
    """The currency code of the curve. The value is expressed in ISO 4217 alphabetical format (e.g.,
     'USD')."""
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the curve. It can be used to link output results to the curve
     definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@' characters are
     supported."""
    id: Optional[str] = rest_field()
    """The identifier of the inflation definition."""
    inflation_index: Optional["_models.InflationIndex"] = rest_field(name="inflationIndex")
    name: Optional[str] = rest_field()
    """The name of the curve (e.g., 'USD Inflation linked ZC Curve')."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the curve is sensitive. The possible value is: Inflation. Known values
     are: \"Credit\", \"CrossCurrency\", \"Inflation\", and \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of the curve. Curves created by Refinitiv
     have the 'Refinitiv' source."""
    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """The date used to define a list of curves or a unique curve that can be priced at this date.
     This date must be less or equal to today's date.  The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01')."""

    @overload
    def __init__(
        self,
        *,
        country: Optional[str] = None,
        currency: Optional[str] = None,
        curve_tag: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        inflation_index: Optional["_models.InflationIndex"] = None,
        name: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
        valuation_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurveParameters(_model_base.Model):
    """InflationCurveParameters.

    Attributes
    ----------
    consumer_price_indexes : list[~analyticsapi.models.ConsumerPriceIndex]
        The list of consumer price indexes attributes used to construct the
        curve. This object property is used to override CPI points of the
        underlying curve.  The default value is None, needs to be assigned
        before using.
    ignore_invalid_instrument : bool
    interpolation_mode : str or ~analyticsapi.models.InterpolationModeEnum
        Get interpolationMode. Known values are: "AkimaMethod",
        "CubicDiscount", "CubicRate", "CubicSpline", "ForwardMonotoneConvex",
        "FritschButlandMethod", "Hermite", "KrugerMethod", "Linear", "Log",
        "MonotonicCubicNaturalSpline", "MonotonicHermiteCubic", "Step", and
        "TensionSpline".
    look_back_month : int
        Get lookBackMonth.
    market_data_look_back : ~analyticsapi.models.MarketDataLookBack
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        The quoted price side of the instrument to be used for the zero coupon
        curve construction. The possible values are:   * Bid   * Ask   * Mid
        The default value is 'Mid'. Known values are: "Ask", "Bid", "Last", and
        "Mid".
    seasonality : ~analyticsapi.models.InflationSeasonality
    use_delayed_data_if_denied : bool
    valuation_date : ~datetime.date
        The date at which the curve is constructed. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Only one parameter of
        valuationDate and valuationDateTime must be specified.
    valuation_date_time : ~datetime.datetime
        The date and time at which the curve is constructed. The value is
        expressed in ISO 8601 format: YYYY-MM-DDT00:00:00Z (e.g.,
        '2021-01-01T14:00:00Z' or '2021-01-01T14:00:00+02:00'). Only one
        parameter of valuationDate and valuationDateTime must be specified.
    valuation_time : ~analyticsapi.models.CurvesAndSurfacesValuationTime
    """

    consumer_price_indexes: Optional[List["_models.ConsumerPriceIndex"]] = rest_field(name="consumerPriceIndexes")
    """The list of consumer price indexes attributes used to construct the curve. This object property
     is used to override CPI points of the underlying curve."""
    ignore_invalid_instrument: Optional[bool] = rest_field(name="ignoreInvalidInstrument")
    interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = rest_field(name="interpolationMode")
    """Get interpolationMode. Known values are: \"AkimaMethod\", \"CubicDiscount\", \"CubicRate\",
     \"CubicSpline\", \"ForwardMonotoneConvex\", \"FritschButlandMethod\", \"Hermite\",
     \"KrugerMethod\", \"Linear\", \"Log\", \"MonotonicCubicNaturalSpline\",
     \"MonotonicHermiteCubic\", \"Step\", and \"TensionSpline\"."""
    look_back_month: Optional[int] = rest_field(name="lookBackMonth")
    """Get lookBackMonth."""
    market_data_look_back: Optional["_models.MarketDataLookBack"] = rest_field(name="marketDataLookBack")
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """The quoted price side of the instrument to be used for the zero coupon curve construction. The
     possible values are:   * Bid   * Ask   * Mid The default value is 'Mid'. Known values are:
     \"Ask\", \"Bid\", \"Last\", and \"Mid\"."""
    seasonality: Optional["_models.InflationSeasonality"] = rest_field()
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")
    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """The date at which the curve is constructed. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01'). Only one parameter of valuationDate and valuationDateTime must
     be specified."""
    valuation_date_time: Optional[datetime.datetime] = rest_field(name="valuationDateTime", format="rfc3339")
    """The date and time at which the curve is constructed. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT00:00:00Z (e.g., '2021-01-01T14:00:00Z' or '2021-01-01T14:00:00+02:00'). Only one
     parameter of valuationDate and valuationDateTime must be specified."""
    valuation_time: Optional["_models.CurvesAndSurfacesValuationTime"] = rest_field(name="valuationTime")

    @overload
    def __init__(
        self,
        *,
        consumer_price_indexes: Optional[List["_models.ConsumerPriceIndex"]] = None,
        ignore_invalid_instrument: Optional[bool] = None,
        interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = None,
        look_back_month: Optional[int] = None,
        market_data_look_back: Optional["_models.MarketDataLookBack"] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        seasonality: Optional["_models.InflationSeasonality"] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
        valuation_date: Optional[datetime.date] = None,
        valuation_date_time: Optional[datetime.datetime] = None,
        valuation_time: Optional["_models.CurvesAndSurfacesValuationTime"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurveParametersDescription(_model_base.Model):
    """InflationCurveParametersDescription.

    Attributes
    ----------
    interpolation_mode : str or ~analyticsapi.models.InterpolationModeEnum
        Get interpolationMode. Known values are: "AkimaMethod",
        "CubicDiscount", "CubicRate", "CubicSpline", "ForwardMonotoneConvex",
        "FritschButlandMethod", "Hermite", "KrugerMethod", "Linear", "Log",
        "MonotonicCubicNaturalSpline", "MonotonicHermiteCubic", "Step", and
        "TensionSpline".
    look_back_month : int
        Get lookBackMonth.
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        The quoted price side of the instrument to be used for the zero coupon
        curve construction. The possible values are:   * Bid   * Ask   * Mid
        The default value is 'Mid'. Known values are: "Ask", "Bid", "Last", and
        "Mid".
    use_delayed_data_if_denied : bool
    """

    interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = rest_field(name="interpolationMode")
    """Get interpolationMode. Known values are: \"AkimaMethod\", \"CubicDiscount\", \"CubicRate\",
     \"CubicSpline\", \"ForwardMonotoneConvex\", \"FritschButlandMethod\", \"Hermite\",
     \"KrugerMethod\", \"Linear\", \"Log\", \"MonotonicCubicNaturalSpline\",
     \"MonotonicHermiteCubic\", \"Step\", and \"TensionSpline\"."""
    look_back_month: Optional[int] = rest_field(name="lookBackMonth")
    """Get lookBackMonth."""
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """The quoted price side of the instrument to be used for the zero coupon curve construction. The
     possible values are:   * Bid   * Ask   * Mid The default value is 'Mid'. Known values are:
     \"Ask\", \"Bid\", \"Last\", and \"Mid\"."""
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")

    @overload
    def __init__(
        self,
        *,
        interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = None,
        look_back_month: Optional[int] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurveResponse(_model_base.Model):
    """InflationCurveResponse.

    Attributes
    ----------
    data : ~analyticsapi.models.InflationCurveDefinitionResponse
        Required.
    """

    data: "_models.InflationCurveDefinitionResponse" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.InflationCurveDefinitionResponse",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InflationCurves(_model_base.Model):
    """InflationCurves.

    Attributes
    ----------
    consumer_price_index_curve_points : list[~analyticsapi.models.ConsumerPriceIndexCurvePoint]
        The list of curve points and other attributes of the Consumer Price
        Index curve.  The default value is None, needs to be assigned before
        using.
    inflation_rate_curve_points : list[~analyticsapi.models.InflationRateCurvePoint]
        Get inflationRateCurvePoints.  The default value is None, needs to be
        assigned before using.
    seasonality_curve_points : list[~analyticsapi.models.InflationSeasonalityCurvePoint]
        Get seasonalityCurvePoints.  The default value is None, needs to be
        assigned before using.
    """

    consumer_price_index_curve_points: Optional[List["_models.ConsumerPriceIndexCurvePoint"]] = rest_field(
        name="consumerPriceIndexCurvePoints"
    )
    """The list of curve points and other attributes of the Consumer Price Index curve."""
    inflation_rate_curve_points: Optional[List["_models.InflationRateCurvePoint"]] = rest_field(
        name="inflationRateCurvePoints"
    )
    """Get inflationRateCurvePoints."""
    seasonality_curve_points: Optional[List["_models.InflationSeasonalityCurvePoint"]] = rest_field(
        name="seasonalityCurvePoints"
    )
    """Get seasonalityCurvePoints."""

    @overload
    def __init__(
        self,
        *,
        consumer_price_index_curve_points: Optional[List["_models.ConsumerPriceIndexCurvePoint"]] = None,
        inflation_rate_curve_points: Optional[List["_models.InflationRateCurvePoint"]] = None,
        seasonality_curve_points: Optional[List["_models.InflationSeasonalityCurvePoint"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurvesRequestItem(_model_base.Model):
    """InflationCurvesRequestItem.

    Attributes
    ----------
    constituents : ~analyticsapi.models.InflationConstituents
    curve_definition : ~analyticsapi.models.InflationCurveDefinitionItem
    curve_parameters : ~analyticsapi.models.InflationCurveParameters
    curve_tag : str
        A user-defined string to identify the curve. It can be used to link
        output results to the curve definition. Limited to 40 characters. Only
        alphabetic, numeric and '- _.#=@' characters are supported.
    """

    constituents: Optional["_models.InflationConstituents"] = rest_field()
    curve_definition: Optional["_models.InflationCurveDefinitionItem"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.InflationCurveParameters"] = rest_field(name="curveParameters")
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the curve. It can be used to link output results to the curve
     definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@' characters are
     supported."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.InflationConstituents"] = None,
        curve_definition: Optional["_models.InflationCurveDefinitionItem"] = None,
        curve_parameters: Optional["_models.InflationCurveParameters"] = None,
        curve_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationCurvesResponse(_model_base.Model):
    """InflationCurvesResponse.

    Attributes
    ----------
    data : list[~analyticsapi.models.InflationCurvesResponseItem]
        Get data.  The default value is None, needs to be assigned before
        using.
    """

    data: Optional[List["_models.InflationCurvesResponseItem"]] = rest_field()
    """Get data."""

    @overload
    def __init__(
        self,
        data: Optional[List["_models.InflationCurvesResponseItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InflationCurvesResponseItem(_model_base.Model):
    """InflationCurvesResponseItem.

    Attributes
    ----------
    constituents : ~analyticsapi.models.InflationConstituentsOutput
    curve_definition : ~analyticsapi.models.InflationCurveDefinitionItem
    curve_parameters : ~analyticsapi.models.InflationCurveParameters
    curve_tag : str
        A user-defined string to identify the curve.  It can be used to link
        output results to the curve definition. Limited to 40 characters. Only
        alphabetic, numeric and '- _.#=@' characters are supported.
    curves : ~analyticsapi.models.InflationCurves
    invalid_constituents : ~analyticsapi.models.InflationConstituentsOutput
    processing_information : list[~analyticsapi.models.ProcessingInformation]
        Get processingInformation.  The default value is None, needs to be
        assigned before using.
    underlying_curves : ~analyticsapi.models.InflationCurves
    """

    constituents: Optional["_models.InflationConstituentsOutput"] = rest_field()
    curve_definition: Optional["_models.InflationCurveDefinitionItem"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.InflationCurveParameters"] = rest_field(name="curveParameters")
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the curve.  It can be used to link output results to the
     curve definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@' characters
     are supported."""
    curves: Optional["_models.InflationCurves"] = rest_field()
    invalid_constituents: Optional["_models.InflationConstituentsOutput"] = rest_field(name="invalidConstituents")
    processing_information: Optional[List["_models.ProcessingInformation"]] = rest_field(name="processingInformation")
    """Get processingInformation."""
    underlying_curves: Optional["_models.InflationCurves"] = rest_field(name="underlyingCurves")

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.InflationConstituentsOutput"] = None,
        curve_definition: Optional["_models.InflationCurveDefinitionItem"] = None,
        curve_parameters: Optional["_models.InflationCurveParameters"] = None,
        curve_tag: Optional[str] = None,
        curves: Optional["_models.InflationCurves"] = None,
        invalid_constituents: Optional["_models.InflationConstituentsOutput"] = None,
        processing_information: Optional[List["_models.ProcessingInformation"]] = None,
        underlying_curves: Optional["_models.InflationCurves"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationIndex(_model_base.Model):
    """The list of attributes used to select the inflation index code.

    Attributes
    ----------
    code : str or ~analyticsapi.models.CodeEnum
        Get code. Known values are: "AAUCPI", "ABECPI", "ABRIGPM", "ABRIPC10",
        "ADECPI", "AESCPI", "AFRCPIXT", "AGBRPI", "AILCPI", "AITCPI",
        "AITCPIXT", "AJPCPICOR", "AUSCPI", "AXZHICPXT", "AZACPI",
        "ErrorAnalyse_InvalidCurrencies", "ErrorAnalyse_InvalidDate",
        "ErrorAnalyse_InvalidLegTypeFromCrossType",
        "ErrorAnalyse_InvalidPricingItem", "ErrorAnalyse_NoAnalyzer",
        "ErrorAnalyse_NoCentralBankDate", "ErrorAnalyse_NoSuitableFxCandidate",
        "ErrorAnalyse_NoSuitableVolatilitySource", "ErrorAnalyse_NoSwapType",
        "ErrorAnalyse_SubItemAnalysisError", "ErrorAnalyse_Unspecified",
        "ErrorAnalyse_UnsupportedCcyPricingForPreferredSecurities",
        "ErrorAnalyse_UnsupportedInstrument",
        "ErrorBusinessCalendar_CalendarDayOfMonthInvalidRange",
        "ErrorBusinessCalendar_CalendarNotFound",
        "ErrorBusinessCalendar_DayOfMonthEmpty",
        "ErrorBusinessCalendar_DayOfWeekOrIndexOrMonthEmpty",
        "ErrorBusinessCalendar_DefineBothStartDateAndEndDateInThePast",
        "ErrorBusinessCalendar_EndDateEarlierStartDate",
        "ErrorBusinessCalendar_EndDateMustBeGreaterThanStartDate",
        "ErrorBusinessCalendar_HolidayRuleEmpty",
        "ErrorBusinessCalendar_HolidayRuleFormatNotSupported",
        "ErrorBusinessCalendar_HolidayRulePositionEmpty",
        "ErrorBusinessCalendar_InvalidCalculationDate",
        "ErrorBusinessCalendar_InvalidCalendarOutput",
        "ErrorBusinessCalendar_InvalidDateString",
        "ErrorBusinessCalendar_InvalidEndDate",
        "ErrorBusinessCalendar_InvalidFrequency",
        "ErrorBusinessCalendar_InvalidHolidayOutput",
        "ErrorBusinessCalendar_InvalidPeriod",
        "ErrorBusinessCalendar_InvalidRefMonth",
        "ErrorBusinessCalendar_InvalidStartDate",
        "ErrorBusinessCalendar_NameEmpty",
        "ErrorBusinessCalendar_NegativeCount",
        "ErrorBusinessCalendar_NoEndDateOrCount",
        "ErrorBusinessCalendar_NoResultReturnedByAdfin",
        "ErrorBusinessCalendar_SetOnlyDayOfWeekOrCalendarDayOfMonth",
        "ErrorBusinessCalendar_SetOnlyEndDateOrCount",
        "ErrorBusinessCalendar_SpecifyCalendarDayOfMonth",
        "ErrorBusinessCalendar_SpecifyDayOfWeek",
        "ErrorBusinessCalendar_SpecifyMonthlyFrequency",
        "ErrorBusinessCalendar_SpecifyWeeklyFrequency",
        "ErrorBusinessCalendar_StartDateAfterEndDate",
        "ErrorBusinessCalendar_TooManyCalendars",
        "ErrorBusinessCalendar_TooManyCurrencies", "ErrorCvaInput",
        "ErrorCvaInput_InvalidCSADefinition",
        "ErrorCvaInput_InvalidCreditCurve",
        "ErrorCvaInput_InvalidInstrumentType",
        "ErrorCvaInput_InvalidVolatilityModel",
        "ErrorCvaInput_MissingCSADefinition", "ErrorCvaInput_NoCSADefined",
        "ErrorCvaInput_NoItemDefined", "ErrorCvaPricing_MissingRecoveryRate",
        "ErrorCvaPricing_PriceItError", "ErrorCvaPricing_PriceItFixings",
        "ErrorCvaPricing_PriceItInputError",
        "ErrorFxVolSurfInput_DefineDataPointsForList",
        "ErrorFxVolSurfInput_DefineSurfaceLayoutFilterIsAtmForList",
        "ErrorFxVolSurfInput_EmptyCutoffTime",
        "ErrorFxVolSurfInput_EmptyCutoffTimeZone",
        "ErrorFxVolSurfInput_InvalidCutoffTime",
        "ErrorFxVolSurfInput_InvalidCutoffTimeZone",
        "ErrorFxVolSurfInput_MatrixMode", "ErrorFxVolSurfInput_OutputField",
        "ErrorMarketData_Access_Denied", "ErrorMarketData_Assignment",
        "ErrorMarketData_EmptyCalibrationParameters",
        "ErrorMarketData_EmptyDiscountCurve",
        "ErrorMarketData_EmptyDividendCurve",
        "ErrorMarketData_EmptyForwardCurve",
        "ErrorMarketData_EmptyFxSpotPoint",
        "ErrorMarketData_EmptyFxVolSurface", "ErrorMarketData_EmptyRateCurve",
        "ErrorMarketData_FixingInfo", "ErrorMarketData_InvalidFxCurve",
        "ErrorMarketData_InvalidSwapCurve",
        "ErrorMarketData_NoCurveService_Data",
        "ErrorMarketData_NoDataCloud_Data",
        "ErrorMarketData_NoHistoricalFxRate",
        "ErrorMarketData_NoIdnCurve_ForThisCurrency",
        "ErrorMarketData_NoQuotesFromMarket",
        "ErrorMarketData_NoRealTime_Data", "ErrorMarketData_NoSearch_Data",
        "ErrorMarketData_NoTimeSeries_Data", "ErrorMarketData_NotFound",
        "ErrorMarketData_TooManyMarketDataRequests",
        "ErrorMarketData_Unspecified", "ErrorMarketData_WrongAnalyzedItem",
        "ErrorMarketData_WrongCsvFileFormat", "ErrorMarketData_WrongOverride",
        "ErrorMissingInput_GreeksFailed", "ErrorMissingInput_ImpliedVolFailed",
        "ErrorMissingInput_NoTenor", "ErrorMissingInput_PremiumFailed",
        "ErrorPricing_AccruedComputation", "ErrorPricing_Adfin",
        "ErrorPricing_AssetSwapSpreadComputation",
        "ErrorPricing_BondFutureEndDate", "ErrorPricing_BondProceeds",
        "ErrorPricing_BrentSolver", "ErrorPricing_CalculationOutputEmpty",
        "ErrorPricing_CashFlowsComputation",
        "ErrorPricing_CfcCalculationError",
        "ErrorPricing_ConvSpreadComputation", "ErrorPricing_DatesComputation",
        "ErrorPricing_Dcb_Constant", "ErrorPricing_Divide_By_Zero",
        "ErrorPricing_GreeksComputation", "ErrorPricing_IborRateComputation",
        "ErrorPricing_ImpliedPrepSpeed", "ErrorPricing_ImpliedVolComputation",
        "ErrorPricing_InstrumentNotManaged",
        "ErrorPricing_InvalidInput_InstrumentNotListedYet",
        "ErrorPricing_InvalidInput_InvalidRate",
        "ErrorPricing_InvalidInstrument", "ErrorPricing_NoHistoricalFxRate",
        "ErrorPricing_NoLegs", "ErrorPricing_NoResultReturned",
        "ErrorPricing_NoSourceCurrency", "ErrorPricing_NoTargetCurrency",
        "ErrorPricing_NotionalComputation", "ErrorPricing_NpvComputation",
        "ErrorPricing_OASComputation", "ErrorPricing_OprInvalidAssetType",
        "ErrorPricing_OutPutIsEmpty", "ErrorPricing_ParCapStrikeComputation",
        "ErrorPricing_ParFloorStrikeComputation",
        "ErrorPricing_ParRateComputation", "ErrorPricing_ParSpreadComputation",
        "ErrorPricing_PremiumComputation", "ErrorPricing_PriceIt",
        "ErrorPricing_PriceSideNotAvailable", "ErrorPricing_PricingAnalysis",
        "ErrorPricing_RepoEndDates", "ErrorPricing_RepoPricingEndDate",
        "ErrorPricing_RepoPricingError", "ErrorPricing_RiskMeasures",
        "ErrorPricing_SensitivityComputation",
        "ErrorPricing_SettlementConvention", "ErrorPricing_SolverError",
        "ErrorPricing_StructuredProducts_Pricing",
        "ErrorPricing_SubItem_DataNotFound", "ErrorPricing_TooManyRequests",
        "ErrorPricing_TradeDateInvalidForTradeDateAccrued",
        "ErrorPricing_UnableToInterpolate", "ErrorPricing_UnhandledCurrency",
        "ErrorPricing_Unspecified", "ErrorPricing_UpfrontComputation",
        "ErrorPricing_Valuation", "ErrorPricing_VolSurf",
        "ErrorPricing_ZSpreadComputation", "ErrorPricing_inputError",
        "ErrorRateSurfInput_Currency", "ErrorRateSurfInput_DefinitionDate",
        "ErrorStripletDates_InvalidInputEndDate",
        "ErrorStripletDates_InvalidMonthlyInputDayOfMonth",
        "ErrorStripletDates_InvalidPeriodDefintion",
        "ErrorStripletDates_InvalidRollConventionType",
        "ErrorVolSurfFiltering_DynamicFiltering",
        "ErrorVolSurfFiltering_NoData",
        "ErrorVolSurfFiltering_NotEfficientFilters",
        "ErrorVolSurfFiltering_StaticFiltering",
        "ErrorVolSurfInput_IncorentInputConstituents",
        "ErrorVolSurfInput_IncorrectInputIntrumentCodeFormat",
        "ErrorWrongInput_FrequencyNotSupported", "Error_GenSec_Analysis_Error",
        "Error_HraInsufficientData",
        "Error_ImpliedDistribution_No_Surface_Returned",
        "Error_InvalidInput_AnalysisDirection",
        "Error_InvalidInput_CrossCurrencyEmpty",
        "Error_InvalidInput_CrossCurrencyInvalid",
        "Error_InvalidInput_CurvePricingParameters",
        "Error_InvalidInput_DateAndTenorAndTenorsNull",
        "Error_InvalidInput_DateAndTenorConflict",
        "Error_InvalidInput_DeltaNoSigma",
        "Error_InvalidInput_EmptyCalendarCountPeriod",
        "Error_InvalidInput_EmptyExpiryAxis",
        "Error_InvalidInput_EmptyPricingItem",
        "Error_InvalidInput_EmptySurfaceDefinition",
        "Error_InvalidInput_EmptySurfaceLayout",
        "Error_InvalidInput_EmptySurfaceParameters",
        "Error_InvalidInput_EmptyUniverse", "Error_InvalidInput_EndDate",
        "Error_InvalidInput_EndDateBeforeValuationDate",
        "Error_InvalidInput_ImpliedVolOverrideIncompatibleWithCapsOnCms",
        "Error_InvalidInput_ImpliedVolOverrideIncompatibleWithCollars",
        "Error_InvalidInput_InconsistentParameters",
        "Error_InvalidInput_InstrumentDefintionCantBeOverriden",
        "Error_InvalidInput_InvalidAmortizationSchedule",
        "Error_InvalidInput_InvalidAmount", "Error_InvalidInput_InvalidAxis",
        "Error_InvalidInput_InvalidCalculationInput",
        "Error_InvalidInput_InvalidCalendarCode",
        "Error_InvalidInput_InvalidCalendarDayOfMonth",
        "Error_InvalidInput_InvalidCalendarOrCurrency",
        "Error_InvalidInput_InvalidCommodityForwardCurveDefinition",
        "Error_InvalidInput_InvalidConvexityAdjustmentIntegrationMethod",
        "Error_InvalidInput_InvalidCount",
        "Error_InvalidInput_InvalidCrossCurrencySwapsConstituent",
        "Error_InvalidInput_InvalidCurrencyCode",
        "Error_InvalidInput_InvalidDate",
        "Error_InvalidInput_InvalidDayOfWeek",
        "Error_InvalidInput_InvalidFieldValue",
        "Error_InvalidInput_InvalidFxCrossCodeCrossCurrencySwapsConstituent",
        "Error_InvalidInput_InvalidFxForwardCurveDefinition",
        "Error_InvalidInput_InvalidInstrumentDefinition",
        "Error_InvalidInput_InvalidInterestRateCurveDefinition",
        "Error_InvalidInput_InvalidInterval",
        "Error_InvalidInput_InvalidJsonPayload",
        "Error_InvalidInput_InvalidLagAndLockOutValues",
        "Error_InvalidInput_InvalidLegDefinition",
        "Error_InvalidInput_InvalidMarketDataDate",
        "Error_InvalidInput_InvalidMarketDataParameters",
        "Error_InvalidInput_InvalidMaturityDate",
        "Error_InvalidInput_InvalidParametersForImmpliedVol",
        "Error_InvalidInput_InvalidPricingModelType",
        "Error_InvalidInput_InvalidPricingParameter",
        "Error_InvalidInput_InvalidPricingType",
        "Error_InvalidInput_InvalidReportCurrencyCode",
        "Error_InvalidInput_InvalidShiftModel",
        "Error_InvalidInput_InvalidSurfaceType",
        "Error_InvalidInput_InvalidTenor",
        "Error_InvalidInput_InvalidTenorPriority",
        "Error_InvalidInput_InvalidUnderlyingInstrumentType",
        "Error_InvalidInput_InvalidValuationDate",
        "Error_InvalidInput_MandatoryFieldValue",
        "Error_InvalidInput_MaturityDateExpired",
        "Error_InvalidInput_MaxMaturityFilter",
        "Error_InvalidInput_MaxStalenessDaysFilter",
        "Error_InvalidInput_MinMaturityFilter",
        "Error_InvalidInput_MissingParameter",
        "Error_InvalidInput_MissingUnderlyingInstrument",
        "Error_InvalidInput_MissingUnderlyingInstrumentType",
        "Error_InvalidInput_NoCalculationInput",
        "Error_InvalidInput_NoDefaultFields", "Error_InvalidInput_NoFields",
        "Error_InvalidInput_NoInstrumentType", "Error_InvalidInput_NoRequest",
        "Error_InvalidInput_NoUnderlyingType", "Error_InvalidInput_NoUniverse",
        "Error_InvalidInput_NoUserId", "Error_InvalidInput_RequestIdMismatch",
        "Error_InvalidInput_Ric_Not_Supported",
        "Error_InvalidInput_SameExpiryAxis", "Error_InvalidInput_StartDate",
        "Error_InvalidInput_StartDateAfterEndDate",
        "Error_InvalidInput_StartDateMatchEndDate",
        "Error_InvalidInput_StaticFilter_PastCalDate",
        "Error_InvalidInput_Template_Not_Supported",
        "Error_InvalidInput_TooManyInstruments",
        "Error_InvalidInput_UnbindableJsonPayload",
        "Error_InvalidInput_UnknownField",
        "Error_InvalidInput_UnrecognizedUnderlyingType",
        "Error_InvalidInput_Unspecified",
        "Error_InvalidInput_UnsupportedInstrumentType",
        "Error_InvalidMarketDataInput_CrossCurrencyCurve_Duplicated_Outrights",
        "Error_InvalidMarketDataInput_CrossCurrencyCurve_Duplicated_SwapPoints"
        , "Error_InvalidMarketDataInput_CrossCurrencyCurve_ManyCurvesDefined",
        "Error_InvalidMarketDataInput_CrossCurrencyCurve__InvalidFxCrossCode",
        "Error_InvalidMarketDataInput_DepositCurve_EmptyCurrency",
        "Error_InvalidMarketDataInput_DepositCurve_InvalidCurrency",
        "Error_InvalidMarketDataInput_ExcludedTenorsDefinition",
        "Error_InvalidMarketDataInput_FxCurve_EmptyFxCrossCode",
        "Error_InvalidMarketDataInput_FxCurve_InvalidFxCrossCode",
        "Error_InvalidMarketDataInput_FxCurve_InvalidReferenceCurrency",
        "Error_InvalidMarketDataInput_InterestRateCurve_EmptyCurrency",
        "Error_InvalidMarketDataInput_InterestRateCurve_InsufficientData",
        "Error_InvalidMarketDataInput_InterestRateCurve_InvalidCurrency",
        "Error_InvalidMarketDataInput_IrVolatility_InsufficientData",
        "Error_InvalidMarketDataInput_TenorsDefinition",
        "Error_Invalid_VolatilityType", "Error_LifeCycleEvent_No_Event_Found",
        "Error_No_Underlying_Price", "Error_NotFound", "None",
        "TechnicalError", "TestDataNotRecordedError", "TestDataSavingFailed",
        "Warning_InvalidInput_CubicSplineIsNotRecommended",
        "Warning_InvalidInput_CurvePointWithNegativeOutright",
        "Warning_InvalidInput_DuplicatedTenors",
        "Warning_InvalidInput_EndDateNotBusinessDay",
        "Warning_InvalidInput_FxSpotNotExist",
        "Warning_InvalidInput_FxSpotOnlyUsed",
        "Warning_InvalidInput_IgnoredCrossCurrencySwaps",
        "Warning_InvalidInput_IgnoredUncollateralizedInstruments",
        "Warning_InvalidInput_InvalidConstituent",
        "Warning_InvalidInput_InvalidFxForwardConstituent",
        "Warning_InvalidInput_InvalidStepDates",
        "Warning_InvalidInput_NoBeforeAfterTurn",
        "Warning_InvalidInput_NoEncapsulatedTurn",
        "Warning_InvalidInput_NoOverlapTurn",
        "Warning_InvalidInput_NoPreSpotTurn",
        "Warning_InvalidInput_NoPreValuationStepDate",
        "Warning_InvalidInput_PartialSwapPoints",
        "Warning_InvalidInput_StartDateAlreadyExists",
        "Warning_InvalidInput_StartDateBeforeSpotDate",
        "Warning_InvalidInput_StartDateCannotBeExtrapolated",
        "Warning_InvalidInput_StartDateEmpty",
        "Warning_InvalidInput_StartDateIncludedInStandardTurnPeriods",
        "Warning_InvalidInput_StartDateIsTheSameWithStandardTurnDates",
        "Warning_InvalidInput_StartDateNotBusinessDay",
        "Warning_InvalidInput_StepDateBeforeValuationDate",
        "Warning_InvalidInput_TurnAdjustmentsNotAppliedToBothLegs",
        "Warning_InvalidInput_TurnAdjustmentsNotMatchedConstituents",
        "Warning_InvalidInput_TurnPeriodExceeded", and
        "Warning_InvalidInput_UnprocessedTurn".
    name : str
        Inflation index name.
    periodicity : str or ~analyticsapi.models.PeriodicityEnum
        Get periodicity. Known values are: "Monthly" and "Quarterly".
    """

    code: Optional[Union[str, "_models.CodeEnum"]] = rest_field()
    """Get code. Known values are: \"AAUCPI\", \"ABECPI\", \"ABRIGPM\", \"ABRIPC10\", \"ADECPI\",
     \"AESCPI\", \"AFRCPIXT\", \"AGBRPI\", \"AILCPI\", \"AITCPI\", \"AITCPIXT\", \"AJPCPICOR\",
     \"AUSCPI\", \"AXZHICPXT\", \"AZACPI\", \"ErrorAnalyse_InvalidCurrencies\",
     \"ErrorAnalyse_InvalidDate\", \"ErrorAnalyse_InvalidLegTypeFromCrossType\",
     \"ErrorAnalyse_InvalidPricingItem\", \"ErrorAnalyse_NoAnalyzer\",
     \"ErrorAnalyse_NoCentralBankDate\", \"ErrorAnalyse_NoSuitableFxCandidate\",
     \"ErrorAnalyse_NoSuitableVolatilitySource\", \"ErrorAnalyse_NoSwapType\",
     \"ErrorAnalyse_SubItemAnalysisError\", \"ErrorAnalyse_Unspecified\",
     \"ErrorAnalyse_UnsupportedCcyPricingForPreferredSecurities\",
     \"ErrorAnalyse_UnsupportedInstrument\",
     \"ErrorBusinessCalendar_CalendarDayOfMonthInvalidRange\",
     \"ErrorBusinessCalendar_CalendarNotFound\", \"ErrorBusinessCalendar_DayOfMonthEmpty\",
     \"ErrorBusinessCalendar_DayOfWeekOrIndexOrMonthEmpty\",
     \"ErrorBusinessCalendar_DefineBothStartDateAndEndDateInThePast\",
     \"ErrorBusinessCalendar_EndDateEarlierStartDate\",
     \"ErrorBusinessCalendar_EndDateMustBeGreaterThanStartDate\",
     \"ErrorBusinessCalendar_HolidayRuleEmpty\",
     \"ErrorBusinessCalendar_HolidayRuleFormatNotSupported\",
     \"ErrorBusinessCalendar_HolidayRulePositionEmpty\",
     \"ErrorBusinessCalendar_InvalidCalculationDate\",
     \"ErrorBusinessCalendar_InvalidCalendarOutput\", \"ErrorBusinessCalendar_InvalidDateString\",
     \"ErrorBusinessCalendar_InvalidEndDate\", \"ErrorBusinessCalendar_InvalidFrequency\",
     \"ErrorBusinessCalendar_InvalidHolidayOutput\", \"ErrorBusinessCalendar_InvalidPeriod\",
     \"ErrorBusinessCalendar_InvalidRefMonth\", \"ErrorBusinessCalendar_InvalidStartDate\",
     \"ErrorBusinessCalendar_NameEmpty\", \"ErrorBusinessCalendar_NegativeCount\",
     \"ErrorBusinessCalendar_NoEndDateOrCount\", \"ErrorBusinessCalendar_NoResultReturnedByAdfin\",
     \"ErrorBusinessCalendar_SetOnlyDayOfWeekOrCalendarDayOfMonth\",
     \"ErrorBusinessCalendar_SetOnlyEndDateOrCount\",
     \"ErrorBusinessCalendar_SpecifyCalendarDayOfMonth\",
     \"ErrorBusinessCalendar_SpecifyDayOfWeek\", \"ErrorBusinessCalendar_SpecifyMonthlyFrequency\",
     \"ErrorBusinessCalendar_SpecifyWeeklyFrequency\",
     \"ErrorBusinessCalendar_StartDateAfterEndDate\", \"ErrorBusinessCalendar_TooManyCalendars\",
     \"ErrorBusinessCalendar_TooManyCurrencies\", \"ErrorCvaInput\",
     \"ErrorCvaInput_InvalidCSADefinition\", \"ErrorCvaInput_InvalidCreditCurve\",
     \"ErrorCvaInput_InvalidInstrumentType\", \"ErrorCvaInput_InvalidVolatilityModel\",
     \"ErrorCvaInput_MissingCSADefinition\", \"ErrorCvaInput_NoCSADefined\",
     \"ErrorCvaInput_NoItemDefined\", \"ErrorCvaPricing_MissingRecoveryRate\",
     \"ErrorCvaPricing_PriceItError\", \"ErrorCvaPricing_PriceItFixings\",
     \"ErrorCvaPricing_PriceItInputError\", \"ErrorFxVolSurfInput_DefineDataPointsForList\",
     \"ErrorFxVolSurfInput_DefineSurfaceLayoutFilterIsAtmForList\",
     \"ErrorFxVolSurfInput_EmptyCutoffTime\", \"ErrorFxVolSurfInput_EmptyCutoffTimeZone\",
     \"ErrorFxVolSurfInput_InvalidCutoffTime\", \"ErrorFxVolSurfInput_InvalidCutoffTimeZone\",
     \"ErrorFxVolSurfInput_MatrixMode\", \"ErrorFxVolSurfInput_OutputField\",
     \"ErrorMarketData_Access_Denied\", \"ErrorMarketData_Assignment\",
     \"ErrorMarketData_EmptyCalibrationParameters\", \"ErrorMarketData_EmptyDiscountCurve\",
     \"ErrorMarketData_EmptyDividendCurve\", \"ErrorMarketData_EmptyForwardCurve\",
     \"ErrorMarketData_EmptyFxSpotPoint\", \"ErrorMarketData_EmptyFxVolSurface\",
     \"ErrorMarketData_EmptyRateCurve\", \"ErrorMarketData_FixingInfo\",
     \"ErrorMarketData_InvalidFxCurve\", \"ErrorMarketData_InvalidSwapCurve\",
     \"ErrorMarketData_NoCurveService_Data\", \"ErrorMarketData_NoDataCloud_Data\",
     \"ErrorMarketData_NoHistoricalFxRate\", \"ErrorMarketData_NoIdnCurve_ForThisCurrency\",
     \"ErrorMarketData_NoQuotesFromMarket\", \"ErrorMarketData_NoRealTime_Data\",
     \"ErrorMarketData_NoSearch_Data\", \"ErrorMarketData_NoTimeSeries_Data\",
     \"ErrorMarketData_NotFound\", \"ErrorMarketData_TooManyMarketDataRequests\",
     \"ErrorMarketData_Unspecified\", \"ErrorMarketData_WrongAnalyzedItem\",
     \"ErrorMarketData_WrongCsvFileFormat\", \"ErrorMarketData_WrongOverride\",
     \"ErrorMissingInput_GreeksFailed\", \"ErrorMissingInput_ImpliedVolFailed\",
     \"ErrorMissingInput_NoTenor\", \"ErrorMissingInput_PremiumFailed\",
     \"ErrorPricing_AccruedComputation\", \"ErrorPricing_Adfin\",
     \"ErrorPricing_AssetSwapSpreadComputation\", \"ErrorPricing_BondFutureEndDate\",
     \"ErrorPricing_BondProceeds\", \"ErrorPricing_BrentSolver\",
     \"ErrorPricing_CalculationOutputEmpty\", \"ErrorPricing_CashFlowsComputation\",
     \"ErrorPricing_CfcCalculationError\", \"ErrorPricing_ConvSpreadComputation\",
     \"ErrorPricing_DatesComputation\", \"ErrorPricing_Dcb_Constant\",
     \"ErrorPricing_Divide_By_Zero\", \"ErrorPricing_GreeksComputation\",
     \"ErrorPricing_IborRateComputation\", \"ErrorPricing_ImpliedPrepSpeed\",
     \"ErrorPricing_ImpliedVolComputation\", \"ErrorPricing_InstrumentNotManaged\",
     \"ErrorPricing_InvalidInput_InstrumentNotListedYet\",
     \"ErrorPricing_InvalidInput_InvalidRate\", \"ErrorPricing_InvalidInstrument\",
     \"ErrorPricing_NoHistoricalFxRate\", \"ErrorPricing_NoLegs\",
     \"ErrorPricing_NoResultReturned\", \"ErrorPricing_NoSourceCurrency\",
     \"ErrorPricing_NoTargetCurrency\", \"ErrorPricing_NotionalComputation\",
     \"ErrorPricing_NpvComputation\", \"ErrorPricing_OASComputation\",
     \"ErrorPricing_OprInvalidAssetType\", \"ErrorPricing_OutPutIsEmpty\",
     \"ErrorPricing_ParCapStrikeComputation\", \"ErrorPricing_ParFloorStrikeComputation\",
     \"ErrorPricing_ParRateComputation\", \"ErrorPricing_ParSpreadComputation\",
     \"ErrorPricing_PremiumComputation\", \"ErrorPricing_PriceIt\",
     \"ErrorPricing_PriceSideNotAvailable\", \"ErrorPricing_PricingAnalysis\",
     \"ErrorPricing_RepoEndDates\", \"ErrorPricing_RepoPricingEndDate\",
     \"ErrorPricing_RepoPricingError\", \"ErrorPricing_RiskMeasures\",
     \"ErrorPricing_SensitivityComputation\", \"ErrorPricing_SettlementConvention\",
     \"ErrorPricing_SolverError\", \"ErrorPricing_StructuredProducts_Pricing\",
     \"ErrorPricing_SubItem_DataNotFound\", \"ErrorPricing_TooManyRequests\",
     \"ErrorPricing_TradeDateInvalidForTradeDateAccrued\", \"ErrorPricing_UnableToInterpolate\",
     \"ErrorPricing_UnhandledCurrency\", \"ErrorPricing_Unspecified\",
     \"ErrorPricing_UpfrontComputation\", \"ErrorPricing_Valuation\", \"ErrorPricing_VolSurf\",
     \"ErrorPricing_ZSpreadComputation\", \"ErrorPricing_inputError\",
     \"ErrorRateSurfInput_Currency\", \"ErrorRateSurfInput_DefinitionDate\",
     \"ErrorStripletDates_InvalidInputEndDate\",
     \"ErrorStripletDates_InvalidMonthlyInputDayOfMonth\",
     \"ErrorStripletDates_InvalidPeriodDefintion\",
     \"ErrorStripletDates_InvalidRollConventionType\", \"ErrorVolSurfFiltering_DynamicFiltering\",
     \"ErrorVolSurfFiltering_NoData\", \"ErrorVolSurfFiltering_NotEfficientFilters\",
     \"ErrorVolSurfFiltering_StaticFiltering\", \"ErrorVolSurfInput_IncorentInputConstituents\",
     \"ErrorVolSurfInput_IncorrectInputIntrumentCodeFormat\",
     \"ErrorWrongInput_FrequencyNotSupported\", \"Error_GenSec_Analysis_Error\",
     \"Error_HraInsufficientData\", \"Error_ImpliedDistribution_No_Surface_Returned\",
     \"Error_InvalidInput_AnalysisDirection\", \"Error_InvalidInput_CrossCurrencyEmpty\",
     \"Error_InvalidInput_CrossCurrencyInvalid\", \"Error_InvalidInput_CurvePricingParameters\",
     \"Error_InvalidInput_DateAndTenorAndTenorsNull\", \"Error_InvalidInput_DateAndTenorConflict\",
     \"Error_InvalidInput_DeltaNoSigma\", \"Error_InvalidInput_EmptyCalendarCountPeriod\",
     \"Error_InvalidInput_EmptyExpiryAxis\", \"Error_InvalidInput_EmptyPricingItem\",
     \"Error_InvalidInput_EmptySurfaceDefinition\", \"Error_InvalidInput_EmptySurfaceLayout\",
     \"Error_InvalidInput_EmptySurfaceParameters\", \"Error_InvalidInput_EmptyUniverse\",
     \"Error_InvalidInput_EndDate\", \"Error_InvalidInput_EndDateBeforeValuationDate\",
     \"Error_InvalidInput_ImpliedVolOverrideIncompatibleWithCapsOnCms\",
     \"Error_InvalidInput_ImpliedVolOverrideIncompatibleWithCollars\",
     \"Error_InvalidInput_InconsistentParameters\",
     \"Error_InvalidInput_InstrumentDefintionCantBeOverriden\",
     \"Error_InvalidInput_InvalidAmortizationSchedule\", \"Error_InvalidInput_InvalidAmount\",
     \"Error_InvalidInput_InvalidAxis\", \"Error_InvalidInput_InvalidCalculationInput\",
     \"Error_InvalidInput_InvalidCalendarCode\", \"Error_InvalidInput_InvalidCalendarDayOfMonth\",
     \"Error_InvalidInput_InvalidCalendarOrCurrency\",
     \"Error_InvalidInput_InvalidCommodityForwardCurveDefinition\",
     \"Error_InvalidInput_InvalidConvexityAdjustmentIntegrationMethod\",
     \"Error_InvalidInput_InvalidCount\",
     \"Error_InvalidInput_InvalidCrossCurrencySwapsConstituent\",
     \"Error_InvalidInput_InvalidCurrencyCode\", \"Error_InvalidInput_InvalidDate\",
     \"Error_InvalidInput_InvalidDayOfWeek\", \"Error_InvalidInput_InvalidFieldValue\",
     \"Error_InvalidInput_InvalidFxCrossCodeCrossCurrencySwapsConstituent\",
     \"Error_InvalidInput_InvalidFxForwardCurveDefinition\",
     \"Error_InvalidInput_InvalidInstrumentDefinition\",
     \"Error_InvalidInput_InvalidInterestRateCurveDefinition\",
     \"Error_InvalidInput_InvalidInterval\", \"Error_InvalidInput_InvalidJsonPayload\",
     \"Error_InvalidInput_InvalidLagAndLockOutValues\", \"Error_InvalidInput_InvalidLegDefinition\",
     \"Error_InvalidInput_InvalidMarketDataDate\",
     \"Error_InvalidInput_InvalidMarketDataParameters\", \"Error_InvalidInput_InvalidMaturityDate\",
     \"Error_InvalidInput_InvalidParametersForImmpliedVol\",
     \"Error_InvalidInput_InvalidPricingModelType\", \"Error_InvalidInput_InvalidPricingParameter\",
     \"Error_InvalidInput_InvalidPricingType\", \"Error_InvalidInput_InvalidReportCurrencyCode\",
     \"Error_InvalidInput_InvalidShiftModel\", \"Error_InvalidInput_InvalidSurfaceType\",
     \"Error_InvalidInput_InvalidTenor\", \"Error_InvalidInput_InvalidTenorPriority\",
     \"Error_InvalidInput_InvalidUnderlyingInstrumentType\",
     \"Error_InvalidInput_InvalidValuationDate\", \"Error_InvalidInput_MandatoryFieldValue\",
     \"Error_InvalidInput_MaturityDateExpired\", \"Error_InvalidInput_MaxMaturityFilter\",
     \"Error_InvalidInput_MaxStalenessDaysFilter\", \"Error_InvalidInput_MinMaturityFilter\",
     \"Error_InvalidInput_MissingParameter\", \"Error_InvalidInput_MissingUnderlyingInstrument\",
     \"Error_InvalidInput_MissingUnderlyingInstrumentType\",
     \"Error_InvalidInput_NoCalculationInput\", \"Error_InvalidInput_NoDefaultFields\",
     \"Error_InvalidInput_NoFields\", \"Error_InvalidInput_NoInstrumentType\",
     \"Error_InvalidInput_NoRequest\", \"Error_InvalidInput_NoUnderlyingType\",
     \"Error_InvalidInput_NoUniverse\", \"Error_InvalidInput_NoUserId\",
     \"Error_InvalidInput_RequestIdMismatch\", \"Error_InvalidInput_Ric_Not_Supported\",
     \"Error_InvalidInput_SameExpiryAxis\", \"Error_InvalidInput_StartDate\",
     \"Error_InvalidInput_StartDateAfterEndDate\", \"Error_InvalidInput_StartDateMatchEndDate\",
     \"Error_InvalidInput_StaticFilter_PastCalDate\", \"Error_InvalidInput_Template_Not_Supported\",
     \"Error_InvalidInput_TooManyInstruments\", \"Error_InvalidInput_UnbindableJsonPayload\",
     \"Error_InvalidInput_UnknownField\", \"Error_InvalidInput_UnrecognizedUnderlyingType\",
     \"Error_InvalidInput_Unspecified\", \"Error_InvalidInput_UnsupportedInstrumentType\",
     \"Error_InvalidMarketDataInput_CrossCurrencyCurve_Duplicated_Outrights\",
     \"Error_InvalidMarketDataInput_CrossCurrencyCurve_Duplicated_SwapPoints\",
     \"Error_InvalidMarketDataInput_CrossCurrencyCurve_ManyCurvesDefined\",
     \"Error_InvalidMarketDataInput_CrossCurrencyCurve__InvalidFxCrossCode\",
     \"Error_InvalidMarketDataInput_DepositCurve_EmptyCurrency\",
     \"Error_InvalidMarketDataInput_DepositCurve_InvalidCurrency\",
     \"Error_InvalidMarketDataInput_ExcludedTenorsDefinition\",
     \"Error_InvalidMarketDataInput_FxCurve_EmptyFxCrossCode\",
     \"Error_InvalidMarketDataInput_FxCurve_InvalidFxCrossCode\",
     \"Error_InvalidMarketDataInput_FxCurve_InvalidReferenceCurrency\",
     \"Error_InvalidMarketDataInput_InterestRateCurve_EmptyCurrency\",
     \"Error_InvalidMarketDataInput_InterestRateCurve_InsufficientData\",
     \"Error_InvalidMarketDataInput_InterestRateCurve_InvalidCurrency\",
     \"Error_InvalidMarketDataInput_IrVolatility_InsufficientData\",
     \"Error_InvalidMarketDataInput_TenorsDefinition\", \"Error_Invalid_VolatilityType\",
     \"Error_LifeCycleEvent_No_Event_Found\", \"Error_No_Underlying_Price\", \"Error_NotFound\",
     \"None\", \"TechnicalError\", \"TestDataNotRecordedError\", \"TestDataSavingFailed\",
     \"Warning_InvalidInput_CubicSplineIsNotRecommended\",
     \"Warning_InvalidInput_CurvePointWithNegativeOutright\",
     \"Warning_InvalidInput_DuplicatedTenors\", \"Warning_InvalidInput_EndDateNotBusinessDay\",
     \"Warning_InvalidInput_FxSpotNotExist\", \"Warning_InvalidInput_FxSpotOnlyUsed\",
     \"Warning_InvalidInput_IgnoredCrossCurrencySwaps\",
     \"Warning_InvalidInput_IgnoredUncollateralizedInstruments\",
     \"Warning_InvalidInput_InvalidConstituent\",
     \"Warning_InvalidInput_InvalidFxForwardConstituent\",
     \"Warning_InvalidInput_InvalidStepDates\", \"Warning_InvalidInput_NoBeforeAfterTurn\",
     \"Warning_InvalidInput_NoEncapsulatedTurn\", \"Warning_InvalidInput_NoOverlapTurn\",
     \"Warning_InvalidInput_NoPreSpotTurn\", \"Warning_InvalidInput_NoPreValuationStepDate\",
     \"Warning_InvalidInput_PartialSwapPoints\", \"Warning_InvalidInput_StartDateAlreadyExists\",
     \"Warning_InvalidInput_StartDateBeforeSpotDate\",
     \"Warning_InvalidInput_StartDateCannotBeExtrapolated\",
     \"Warning_InvalidInput_StartDateEmpty\",
     \"Warning_InvalidInput_StartDateIncludedInStandardTurnPeriods\",
     \"Warning_InvalidInput_StartDateIsTheSameWithStandardTurnDates\",
     \"Warning_InvalidInput_StartDateNotBusinessDay\",
     \"Warning_InvalidInput_StepDateBeforeValuationDate\",
     \"Warning_InvalidInput_TurnAdjustmentsNotAppliedToBothLegs\",
     \"Warning_InvalidInput_TurnAdjustmentsNotMatchedConstituents\",
     \"Warning_InvalidInput_TurnPeriodExceeded\", and \"Warning_InvalidInput_UnprocessedTurn\"."""
    name: Optional[str] = rest_field()
    """Inflation index name."""
    periodicity: Optional[Union[str, "_models.PeriodicityEnum"]] = rest_field()
    """Get periodicity. Known values are: \"Monthly\" and \"Quarterly\"."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[Union[str, "_models.CodeEnum"]] = None,
        name: Optional[str] = None,
        periodicity: Optional[Union[str, "_models.PeriodicityEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationIndexDescription(_model_base.Model):
    """InflationIndexDescription.

    Attributes
    ----------
    code : str or ~analyticsapi.models.CodeEnum
        Get code. Known values are: "AAUCPI", "ABECPI", "ABRIGPM", "ABRIPC10",
        "ADECPI", "AESCPI", "AFRCPIXT", "AGBRPI", "AILCPI", "AITCPI",
        "AITCPIXT", "AJPCPICOR", "AUSCPI", "AXZHICPXT", "AZACPI",
        "ErrorAnalyse_InvalidCurrencies", "ErrorAnalyse_InvalidDate",
        "ErrorAnalyse_InvalidLegTypeFromCrossType",
        "ErrorAnalyse_InvalidPricingItem", "ErrorAnalyse_NoAnalyzer",
        "ErrorAnalyse_NoCentralBankDate", "ErrorAnalyse_NoSuitableFxCandidate",
        "ErrorAnalyse_NoSuitableVolatilitySource", "ErrorAnalyse_NoSwapType",
        "ErrorAnalyse_SubItemAnalysisError", "ErrorAnalyse_Unspecified",
        "ErrorAnalyse_UnsupportedCcyPricingForPreferredSecurities",
        "ErrorAnalyse_UnsupportedInstrument",
        "ErrorBusinessCalendar_CalendarDayOfMonthInvalidRange",
        "ErrorBusinessCalendar_CalendarNotFound",
        "ErrorBusinessCalendar_DayOfMonthEmpty",
        "ErrorBusinessCalendar_DayOfWeekOrIndexOrMonthEmpty",
        "ErrorBusinessCalendar_DefineBothStartDateAndEndDateInThePast",
        "ErrorBusinessCalendar_EndDateEarlierStartDate",
        "ErrorBusinessCalendar_EndDateMustBeGreaterThanStartDate",
        "ErrorBusinessCalendar_HolidayRuleEmpty",
        "ErrorBusinessCalendar_HolidayRuleFormatNotSupported",
        "ErrorBusinessCalendar_HolidayRulePositionEmpty",
        "ErrorBusinessCalendar_InvalidCalculationDate",
        "ErrorBusinessCalendar_InvalidCalendarOutput",
        "ErrorBusinessCalendar_InvalidDateString",
        "ErrorBusinessCalendar_InvalidEndDate",
        "ErrorBusinessCalendar_InvalidFrequency",
        "ErrorBusinessCalendar_InvalidHolidayOutput",
        "ErrorBusinessCalendar_InvalidPeriod",
        "ErrorBusinessCalendar_InvalidRefMonth",
        "ErrorBusinessCalendar_InvalidStartDate",
        "ErrorBusinessCalendar_NameEmpty",
        "ErrorBusinessCalendar_NegativeCount",
        "ErrorBusinessCalendar_NoEndDateOrCount",
        "ErrorBusinessCalendar_NoResultReturnedByAdfin",
        "ErrorBusinessCalendar_SetOnlyDayOfWeekOrCalendarDayOfMonth",
        "ErrorBusinessCalendar_SetOnlyEndDateOrCount",
        "ErrorBusinessCalendar_SpecifyCalendarDayOfMonth",
        "ErrorBusinessCalendar_SpecifyDayOfWeek",
        "ErrorBusinessCalendar_SpecifyMonthlyFrequency",
        "ErrorBusinessCalendar_SpecifyWeeklyFrequency",
        "ErrorBusinessCalendar_StartDateAfterEndDate",
        "ErrorBusinessCalendar_TooManyCalendars",
        "ErrorBusinessCalendar_TooManyCurrencies", "ErrorCvaInput",
        "ErrorCvaInput_InvalidCSADefinition",
        "ErrorCvaInput_InvalidCreditCurve",
        "ErrorCvaInput_InvalidInstrumentType",
        "ErrorCvaInput_InvalidVolatilityModel",
        "ErrorCvaInput_MissingCSADefinition", "ErrorCvaInput_NoCSADefined",
        "ErrorCvaInput_NoItemDefined", "ErrorCvaPricing_MissingRecoveryRate",
        "ErrorCvaPricing_PriceItError", "ErrorCvaPricing_PriceItFixings",
        "ErrorCvaPricing_PriceItInputError",
        "ErrorFxVolSurfInput_DefineDataPointsForList",
        "ErrorFxVolSurfInput_DefineSurfaceLayoutFilterIsAtmForList",
        "ErrorFxVolSurfInput_EmptyCutoffTime",
        "ErrorFxVolSurfInput_EmptyCutoffTimeZone",
        "ErrorFxVolSurfInput_InvalidCutoffTime",
        "ErrorFxVolSurfInput_InvalidCutoffTimeZone",
        "ErrorFxVolSurfInput_MatrixMode", "ErrorFxVolSurfInput_OutputField",
        "ErrorMarketData_Access_Denied", "ErrorMarketData_Assignment",
        "ErrorMarketData_EmptyCalibrationParameters",
        "ErrorMarketData_EmptyDiscountCurve",
        "ErrorMarketData_EmptyDividendCurve",
        "ErrorMarketData_EmptyForwardCurve",
        "ErrorMarketData_EmptyFxSpotPoint",
        "ErrorMarketData_EmptyFxVolSurface", "ErrorMarketData_EmptyRateCurve",
        "ErrorMarketData_FixingInfo", "ErrorMarketData_InvalidFxCurve",
        "ErrorMarketData_InvalidSwapCurve",
        "ErrorMarketData_NoCurveService_Data",
        "ErrorMarketData_NoDataCloud_Data",
        "ErrorMarketData_NoHistoricalFxRate",
        "ErrorMarketData_NoIdnCurve_ForThisCurrency",
        "ErrorMarketData_NoQuotesFromMarket",
        "ErrorMarketData_NoRealTime_Data", "ErrorMarketData_NoSearch_Data",
        "ErrorMarketData_NoTimeSeries_Data", "ErrorMarketData_NotFound",
        "ErrorMarketData_TooManyMarketDataRequests",
        "ErrorMarketData_Unspecified", "ErrorMarketData_WrongAnalyzedItem",
        "ErrorMarketData_WrongCsvFileFormat", "ErrorMarketData_WrongOverride",
        "ErrorMissingInput_GreeksFailed", "ErrorMissingInput_ImpliedVolFailed",
        "ErrorMissingInput_NoTenor", "ErrorMissingInput_PremiumFailed",
        "ErrorPricing_AccruedComputation", "ErrorPricing_Adfin",
        "ErrorPricing_AssetSwapSpreadComputation",
        "ErrorPricing_BondFutureEndDate", "ErrorPricing_BondProceeds",
        "ErrorPricing_BrentSolver", "ErrorPricing_CalculationOutputEmpty",
        "ErrorPricing_CashFlowsComputation",
        "ErrorPricing_CfcCalculationError",
        "ErrorPricing_ConvSpreadComputation", "ErrorPricing_DatesComputation",
        "ErrorPricing_Dcb_Constant", "ErrorPricing_Divide_By_Zero",
        "ErrorPricing_GreeksComputation", "ErrorPricing_IborRateComputation",
        "ErrorPricing_ImpliedPrepSpeed", "ErrorPricing_ImpliedVolComputation",
        "ErrorPricing_InstrumentNotManaged",
        "ErrorPricing_InvalidInput_InstrumentNotListedYet",
        "ErrorPricing_InvalidInput_InvalidRate",
        "ErrorPricing_InvalidInstrument", "ErrorPricing_NoHistoricalFxRate",
        "ErrorPricing_NoLegs", "ErrorPricing_NoResultReturned",
        "ErrorPricing_NoSourceCurrency", "ErrorPricing_NoTargetCurrency",
        "ErrorPricing_NotionalComputation", "ErrorPricing_NpvComputation",
        "ErrorPricing_OASComputation", "ErrorPricing_OprInvalidAssetType",
        "ErrorPricing_OutPutIsEmpty", "ErrorPricing_ParCapStrikeComputation",
        "ErrorPricing_ParFloorStrikeComputation",
        "ErrorPricing_ParRateComputation", "ErrorPricing_ParSpreadComputation",
        "ErrorPricing_PremiumComputation", "ErrorPricing_PriceIt",
        "ErrorPricing_PriceSideNotAvailable", "ErrorPricing_PricingAnalysis",
        "ErrorPricing_RepoEndDates", "ErrorPricing_RepoPricingEndDate",
        "ErrorPricing_RepoPricingError", "ErrorPricing_RiskMeasures",
        "ErrorPricing_SensitivityComputation",
        "ErrorPricing_SettlementConvention", "ErrorPricing_SolverError",
        "ErrorPricing_StructuredProducts_Pricing",
        "ErrorPricing_SubItem_DataNotFound", "ErrorPricing_TooManyRequests",
        "ErrorPricing_TradeDateInvalidForTradeDateAccrued",
        "ErrorPricing_UnableToInterpolate", "ErrorPricing_UnhandledCurrency",
        "ErrorPricing_Unspecified", "ErrorPricing_UpfrontComputation",
        "ErrorPricing_Valuation", "ErrorPricing_VolSurf",
        "ErrorPricing_ZSpreadComputation", "ErrorPricing_inputError",
        "ErrorRateSurfInput_Currency", "ErrorRateSurfInput_DefinitionDate",
        "ErrorStripletDates_InvalidInputEndDate",
        "ErrorStripletDates_InvalidMonthlyInputDayOfMonth",
        "ErrorStripletDates_InvalidPeriodDefintion",
        "ErrorStripletDates_InvalidRollConventionType",
        "ErrorVolSurfFiltering_DynamicFiltering",
        "ErrorVolSurfFiltering_NoData",
        "ErrorVolSurfFiltering_NotEfficientFilters",
        "ErrorVolSurfFiltering_StaticFiltering",
        "ErrorVolSurfInput_IncorentInputConstituents",
        "ErrorVolSurfInput_IncorrectInputIntrumentCodeFormat",
        "ErrorWrongInput_FrequencyNotSupported", "Error_GenSec_Analysis_Error",
        "Error_HraInsufficientData",
        "Error_ImpliedDistribution_No_Surface_Returned",
        "Error_InvalidInput_AnalysisDirection",
        "Error_InvalidInput_CrossCurrencyEmpty",
        "Error_InvalidInput_CrossCurrencyInvalid",
        "Error_InvalidInput_CurvePricingParameters",
        "Error_InvalidInput_DateAndTenorAndTenorsNull",
        "Error_InvalidInput_DateAndTenorConflict",
        "Error_InvalidInput_DeltaNoSigma",
        "Error_InvalidInput_EmptyCalendarCountPeriod",
        "Error_InvalidInput_EmptyExpiryAxis",
        "Error_InvalidInput_EmptyPricingItem",
        "Error_InvalidInput_EmptySurfaceDefinition",
        "Error_InvalidInput_EmptySurfaceLayout",
        "Error_InvalidInput_EmptySurfaceParameters",
        "Error_InvalidInput_EmptyUniverse", "Error_InvalidInput_EndDate",
        "Error_InvalidInput_EndDateBeforeValuationDate",
        "Error_InvalidInput_ImpliedVolOverrideIncompatibleWithCapsOnCms",
        "Error_InvalidInput_ImpliedVolOverrideIncompatibleWithCollars",
        "Error_InvalidInput_InconsistentParameters",
        "Error_InvalidInput_InstrumentDefintionCantBeOverriden",
        "Error_InvalidInput_InvalidAmortizationSchedule",
        "Error_InvalidInput_InvalidAmount", "Error_InvalidInput_InvalidAxis",
        "Error_InvalidInput_InvalidCalculationInput",
        "Error_InvalidInput_InvalidCalendarCode",
        "Error_InvalidInput_InvalidCalendarDayOfMonth",
        "Error_InvalidInput_InvalidCalendarOrCurrency",
        "Error_InvalidInput_InvalidCommodityForwardCurveDefinition",
        "Error_InvalidInput_InvalidConvexityAdjustmentIntegrationMethod",
        "Error_InvalidInput_InvalidCount",
        "Error_InvalidInput_InvalidCrossCurrencySwapsConstituent",
        "Error_InvalidInput_InvalidCurrencyCode",
        "Error_InvalidInput_InvalidDate",
        "Error_InvalidInput_InvalidDayOfWeek",
        "Error_InvalidInput_InvalidFieldValue",
        "Error_InvalidInput_InvalidFxCrossCodeCrossCurrencySwapsConstituent",
        "Error_InvalidInput_InvalidFxForwardCurveDefinition",
        "Error_InvalidInput_InvalidInstrumentDefinition",
        "Error_InvalidInput_InvalidInterestRateCurveDefinition",
        "Error_InvalidInput_InvalidInterval",
        "Error_InvalidInput_InvalidJsonPayload",
        "Error_InvalidInput_InvalidLagAndLockOutValues",
        "Error_InvalidInput_InvalidLegDefinition",
        "Error_InvalidInput_InvalidMarketDataDate",
        "Error_InvalidInput_InvalidMarketDataParameters",
        "Error_InvalidInput_InvalidMaturityDate",
        "Error_InvalidInput_InvalidParametersForImmpliedVol",
        "Error_InvalidInput_InvalidPricingModelType",
        "Error_InvalidInput_InvalidPricingParameter",
        "Error_InvalidInput_InvalidPricingType",
        "Error_InvalidInput_InvalidReportCurrencyCode",
        "Error_InvalidInput_InvalidShiftModel",
        "Error_InvalidInput_InvalidSurfaceType",
        "Error_InvalidInput_InvalidTenor",
        "Error_InvalidInput_InvalidTenorPriority",
        "Error_InvalidInput_InvalidUnderlyingInstrumentType",
        "Error_InvalidInput_InvalidValuationDate",
        "Error_InvalidInput_MandatoryFieldValue",
        "Error_InvalidInput_MaturityDateExpired",
        "Error_InvalidInput_MaxMaturityFilter",
        "Error_InvalidInput_MaxStalenessDaysFilter",
        "Error_InvalidInput_MinMaturityFilter",
        "Error_InvalidInput_MissingParameter",
        "Error_InvalidInput_MissingUnderlyingInstrument",
        "Error_InvalidInput_MissingUnderlyingInstrumentType",
        "Error_InvalidInput_NoCalculationInput",
        "Error_InvalidInput_NoDefaultFields", "Error_InvalidInput_NoFields",
        "Error_InvalidInput_NoInstrumentType", "Error_InvalidInput_NoRequest",
        "Error_InvalidInput_NoUnderlyingType", "Error_InvalidInput_NoUniverse",
        "Error_InvalidInput_NoUserId", "Error_InvalidInput_RequestIdMismatch",
        "Error_InvalidInput_Ric_Not_Supported",
        "Error_InvalidInput_SameExpiryAxis", "Error_InvalidInput_StartDate",
        "Error_InvalidInput_StartDateAfterEndDate",
        "Error_InvalidInput_StartDateMatchEndDate",
        "Error_InvalidInput_StaticFilter_PastCalDate",
        "Error_InvalidInput_Template_Not_Supported",
        "Error_InvalidInput_TooManyInstruments",
        "Error_InvalidInput_UnbindableJsonPayload",
        "Error_InvalidInput_UnknownField",
        "Error_InvalidInput_UnrecognizedUnderlyingType",
        "Error_InvalidInput_Unspecified",
        "Error_InvalidInput_UnsupportedInstrumentType",
        "Error_InvalidMarketDataInput_CrossCurrencyCurve_Duplicated_Outrights",
        "Error_InvalidMarketDataInput_CrossCurrencyCurve_Duplicated_SwapPoints"
        , "Error_InvalidMarketDataInput_CrossCurrencyCurve_ManyCurvesDefined",
        "Error_InvalidMarketDataInput_CrossCurrencyCurve__InvalidFxCrossCode",
        "Error_InvalidMarketDataInput_DepositCurve_EmptyCurrency",
        "Error_InvalidMarketDataInput_DepositCurve_InvalidCurrency",
        "Error_InvalidMarketDataInput_ExcludedTenorsDefinition",
        "Error_InvalidMarketDataInput_FxCurve_EmptyFxCrossCode",
        "Error_InvalidMarketDataInput_FxCurve_InvalidFxCrossCode",
        "Error_InvalidMarketDataInput_FxCurve_InvalidReferenceCurrency",
        "Error_InvalidMarketDataInput_InterestRateCurve_EmptyCurrency",
        "Error_InvalidMarketDataInput_InterestRateCurve_InsufficientData",
        "Error_InvalidMarketDataInput_InterestRateCurve_InvalidCurrency",
        "Error_InvalidMarketDataInput_IrVolatility_InsufficientData",
        "Error_InvalidMarketDataInput_TenorsDefinition",
        "Error_Invalid_VolatilityType", "Error_LifeCycleEvent_No_Event_Found",
        "Error_No_Underlying_Price", "Error_NotFound", "None",
        "TechnicalError", "TestDataNotRecordedError", "TestDataSavingFailed",
        "Warning_InvalidInput_CubicSplineIsNotRecommended",
        "Warning_InvalidInput_CurvePointWithNegativeOutright",
        "Warning_InvalidInput_DuplicatedTenors",
        "Warning_InvalidInput_EndDateNotBusinessDay",
        "Warning_InvalidInput_FxSpotNotExist",
        "Warning_InvalidInput_FxSpotOnlyUsed",
        "Warning_InvalidInput_IgnoredCrossCurrencySwaps",
        "Warning_InvalidInput_IgnoredUncollateralizedInstruments",
        "Warning_InvalidInput_InvalidConstituent",
        "Warning_InvalidInput_InvalidFxForwardConstituent",
        "Warning_InvalidInput_InvalidStepDates",
        "Warning_InvalidInput_NoBeforeAfterTurn",
        "Warning_InvalidInput_NoEncapsulatedTurn",
        "Warning_InvalidInput_NoOverlapTurn",
        "Warning_InvalidInput_NoPreSpotTurn",
        "Warning_InvalidInput_NoPreValuationStepDate",
        "Warning_InvalidInput_PartialSwapPoints",
        "Warning_InvalidInput_StartDateAlreadyExists",
        "Warning_InvalidInput_StartDateBeforeSpotDate",
        "Warning_InvalidInput_StartDateCannotBeExtrapolated",
        "Warning_InvalidInput_StartDateEmpty",
        "Warning_InvalidInput_StartDateIncludedInStandardTurnPeriods",
        "Warning_InvalidInput_StartDateIsTheSameWithStandardTurnDates",
        "Warning_InvalidInput_StartDateNotBusinessDay",
        "Warning_InvalidInput_StepDateBeforeValuationDate",
        "Warning_InvalidInput_TurnAdjustmentsNotAppliedToBothLegs",
        "Warning_InvalidInput_TurnAdjustmentsNotMatchedConstituents",
        "Warning_InvalidInput_TurnPeriodExceeded", and
        "Warning_InvalidInput_UnprocessedTurn".
    """

    code: Optional[Union[str, "_models.CodeEnum"]] = rest_field()
    """Get code. Known values are: \"AAUCPI\", \"ABECPI\", \"ABRIGPM\", \"ABRIPC10\", \"ADECPI\",
     \"AESCPI\", \"AFRCPIXT\", \"AGBRPI\", \"AILCPI\", \"AITCPI\", \"AITCPIXT\", \"AJPCPICOR\",
     \"AUSCPI\", \"AXZHICPXT\", \"AZACPI\", \"ErrorAnalyse_InvalidCurrencies\",
     \"ErrorAnalyse_InvalidDate\", \"ErrorAnalyse_InvalidLegTypeFromCrossType\",
     \"ErrorAnalyse_InvalidPricingItem\", \"ErrorAnalyse_NoAnalyzer\",
     \"ErrorAnalyse_NoCentralBankDate\", \"ErrorAnalyse_NoSuitableFxCandidate\",
     \"ErrorAnalyse_NoSuitableVolatilitySource\", \"ErrorAnalyse_NoSwapType\",
     \"ErrorAnalyse_SubItemAnalysisError\", \"ErrorAnalyse_Unspecified\",
     \"ErrorAnalyse_UnsupportedCcyPricingForPreferredSecurities\",
     \"ErrorAnalyse_UnsupportedInstrument\",
     \"ErrorBusinessCalendar_CalendarDayOfMonthInvalidRange\",
     \"ErrorBusinessCalendar_CalendarNotFound\", \"ErrorBusinessCalendar_DayOfMonthEmpty\",
     \"ErrorBusinessCalendar_DayOfWeekOrIndexOrMonthEmpty\",
     \"ErrorBusinessCalendar_DefineBothStartDateAndEndDateInThePast\",
     \"ErrorBusinessCalendar_EndDateEarlierStartDate\",
     \"ErrorBusinessCalendar_EndDateMustBeGreaterThanStartDate\",
     \"ErrorBusinessCalendar_HolidayRuleEmpty\",
     \"ErrorBusinessCalendar_HolidayRuleFormatNotSupported\",
     \"ErrorBusinessCalendar_HolidayRulePositionEmpty\",
     \"ErrorBusinessCalendar_InvalidCalculationDate\",
     \"ErrorBusinessCalendar_InvalidCalendarOutput\", \"ErrorBusinessCalendar_InvalidDateString\",
     \"ErrorBusinessCalendar_InvalidEndDate\", \"ErrorBusinessCalendar_InvalidFrequency\",
     \"ErrorBusinessCalendar_InvalidHolidayOutput\", \"ErrorBusinessCalendar_InvalidPeriod\",
     \"ErrorBusinessCalendar_InvalidRefMonth\", \"ErrorBusinessCalendar_InvalidStartDate\",
     \"ErrorBusinessCalendar_NameEmpty\", \"ErrorBusinessCalendar_NegativeCount\",
     \"ErrorBusinessCalendar_NoEndDateOrCount\", \"ErrorBusinessCalendar_NoResultReturnedByAdfin\",
     \"ErrorBusinessCalendar_SetOnlyDayOfWeekOrCalendarDayOfMonth\",
     \"ErrorBusinessCalendar_SetOnlyEndDateOrCount\",
     \"ErrorBusinessCalendar_SpecifyCalendarDayOfMonth\",
     \"ErrorBusinessCalendar_SpecifyDayOfWeek\", \"ErrorBusinessCalendar_SpecifyMonthlyFrequency\",
     \"ErrorBusinessCalendar_SpecifyWeeklyFrequency\",
     \"ErrorBusinessCalendar_StartDateAfterEndDate\", \"ErrorBusinessCalendar_TooManyCalendars\",
     \"ErrorBusinessCalendar_TooManyCurrencies\", \"ErrorCvaInput\",
     \"ErrorCvaInput_InvalidCSADefinition\", \"ErrorCvaInput_InvalidCreditCurve\",
     \"ErrorCvaInput_InvalidInstrumentType\", \"ErrorCvaInput_InvalidVolatilityModel\",
     \"ErrorCvaInput_MissingCSADefinition\", \"ErrorCvaInput_NoCSADefined\",
     \"ErrorCvaInput_NoItemDefined\", \"ErrorCvaPricing_MissingRecoveryRate\",
     \"ErrorCvaPricing_PriceItError\", \"ErrorCvaPricing_PriceItFixings\",
     \"ErrorCvaPricing_PriceItInputError\", \"ErrorFxVolSurfInput_DefineDataPointsForList\",
     \"ErrorFxVolSurfInput_DefineSurfaceLayoutFilterIsAtmForList\",
     \"ErrorFxVolSurfInput_EmptyCutoffTime\", \"ErrorFxVolSurfInput_EmptyCutoffTimeZone\",
     \"ErrorFxVolSurfInput_InvalidCutoffTime\", \"ErrorFxVolSurfInput_InvalidCutoffTimeZone\",
     \"ErrorFxVolSurfInput_MatrixMode\", \"ErrorFxVolSurfInput_OutputField\",
     \"ErrorMarketData_Access_Denied\", \"ErrorMarketData_Assignment\",
     \"ErrorMarketData_EmptyCalibrationParameters\", \"ErrorMarketData_EmptyDiscountCurve\",
     \"ErrorMarketData_EmptyDividendCurve\", \"ErrorMarketData_EmptyForwardCurve\",
     \"ErrorMarketData_EmptyFxSpotPoint\", \"ErrorMarketData_EmptyFxVolSurface\",
     \"ErrorMarketData_EmptyRateCurve\", \"ErrorMarketData_FixingInfo\",
     \"ErrorMarketData_InvalidFxCurve\", \"ErrorMarketData_InvalidSwapCurve\",
     \"ErrorMarketData_NoCurveService_Data\", \"ErrorMarketData_NoDataCloud_Data\",
     \"ErrorMarketData_NoHistoricalFxRate\", \"ErrorMarketData_NoIdnCurve_ForThisCurrency\",
     \"ErrorMarketData_NoQuotesFromMarket\", \"ErrorMarketData_NoRealTime_Data\",
     \"ErrorMarketData_NoSearch_Data\", \"ErrorMarketData_NoTimeSeries_Data\",
     \"ErrorMarketData_NotFound\", \"ErrorMarketData_TooManyMarketDataRequests\",
     \"ErrorMarketData_Unspecified\", \"ErrorMarketData_WrongAnalyzedItem\",
     \"ErrorMarketData_WrongCsvFileFormat\", \"ErrorMarketData_WrongOverride\",
     \"ErrorMissingInput_GreeksFailed\", \"ErrorMissingInput_ImpliedVolFailed\",
     \"ErrorMissingInput_NoTenor\", \"ErrorMissingInput_PremiumFailed\",
     \"ErrorPricing_AccruedComputation\", \"ErrorPricing_Adfin\",
     \"ErrorPricing_AssetSwapSpreadComputation\", \"ErrorPricing_BondFutureEndDate\",
     \"ErrorPricing_BondProceeds\", \"ErrorPricing_BrentSolver\",
     \"ErrorPricing_CalculationOutputEmpty\", \"ErrorPricing_CashFlowsComputation\",
     \"ErrorPricing_CfcCalculationError\", \"ErrorPricing_ConvSpreadComputation\",
     \"ErrorPricing_DatesComputation\", \"ErrorPricing_Dcb_Constant\",
     \"ErrorPricing_Divide_By_Zero\", \"ErrorPricing_GreeksComputation\",
     \"ErrorPricing_IborRateComputation\", \"ErrorPricing_ImpliedPrepSpeed\",
     \"ErrorPricing_ImpliedVolComputation\", \"ErrorPricing_InstrumentNotManaged\",
     \"ErrorPricing_InvalidInput_InstrumentNotListedYet\",
     \"ErrorPricing_InvalidInput_InvalidRate\", \"ErrorPricing_InvalidInstrument\",
     \"ErrorPricing_NoHistoricalFxRate\", \"ErrorPricing_NoLegs\",
     \"ErrorPricing_NoResultReturned\", \"ErrorPricing_NoSourceCurrency\",
     \"ErrorPricing_NoTargetCurrency\", \"ErrorPricing_NotionalComputation\",
     \"ErrorPricing_NpvComputation\", \"ErrorPricing_OASComputation\",
     \"ErrorPricing_OprInvalidAssetType\", \"ErrorPricing_OutPutIsEmpty\",
     \"ErrorPricing_ParCapStrikeComputation\", \"ErrorPricing_ParFloorStrikeComputation\",
     \"ErrorPricing_ParRateComputation\", \"ErrorPricing_ParSpreadComputation\",
     \"ErrorPricing_PremiumComputation\", \"ErrorPricing_PriceIt\",
     \"ErrorPricing_PriceSideNotAvailable\", \"ErrorPricing_PricingAnalysis\",
     \"ErrorPricing_RepoEndDates\", \"ErrorPricing_RepoPricingEndDate\",
     \"ErrorPricing_RepoPricingError\", \"ErrorPricing_RiskMeasures\",
     \"ErrorPricing_SensitivityComputation\", \"ErrorPricing_SettlementConvention\",
     \"ErrorPricing_SolverError\", \"ErrorPricing_StructuredProducts_Pricing\",
     \"ErrorPricing_SubItem_DataNotFound\", \"ErrorPricing_TooManyRequests\",
     \"ErrorPricing_TradeDateInvalidForTradeDateAccrued\", \"ErrorPricing_UnableToInterpolate\",
     \"ErrorPricing_UnhandledCurrency\", \"ErrorPricing_Unspecified\",
     \"ErrorPricing_UpfrontComputation\", \"ErrorPricing_Valuation\", \"ErrorPricing_VolSurf\",
     \"ErrorPricing_ZSpreadComputation\", \"ErrorPricing_inputError\",
     \"ErrorRateSurfInput_Currency\", \"ErrorRateSurfInput_DefinitionDate\",
     \"ErrorStripletDates_InvalidInputEndDate\",
     \"ErrorStripletDates_InvalidMonthlyInputDayOfMonth\",
     \"ErrorStripletDates_InvalidPeriodDefintion\",
     \"ErrorStripletDates_InvalidRollConventionType\", \"ErrorVolSurfFiltering_DynamicFiltering\",
     \"ErrorVolSurfFiltering_NoData\", \"ErrorVolSurfFiltering_NotEfficientFilters\",
     \"ErrorVolSurfFiltering_StaticFiltering\", \"ErrorVolSurfInput_IncorentInputConstituents\",
     \"ErrorVolSurfInput_IncorrectInputIntrumentCodeFormat\",
     \"ErrorWrongInput_FrequencyNotSupported\", \"Error_GenSec_Analysis_Error\",
     \"Error_HraInsufficientData\", \"Error_ImpliedDistribution_No_Surface_Returned\",
     \"Error_InvalidInput_AnalysisDirection\", \"Error_InvalidInput_CrossCurrencyEmpty\",
     \"Error_InvalidInput_CrossCurrencyInvalid\", \"Error_InvalidInput_CurvePricingParameters\",
     \"Error_InvalidInput_DateAndTenorAndTenorsNull\", \"Error_InvalidInput_DateAndTenorConflict\",
     \"Error_InvalidInput_DeltaNoSigma\", \"Error_InvalidInput_EmptyCalendarCountPeriod\",
     \"Error_InvalidInput_EmptyExpiryAxis\", \"Error_InvalidInput_EmptyPricingItem\",
     \"Error_InvalidInput_EmptySurfaceDefinition\", \"Error_InvalidInput_EmptySurfaceLayout\",
     \"Error_InvalidInput_EmptySurfaceParameters\", \"Error_InvalidInput_EmptyUniverse\",
     \"Error_InvalidInput_EndDate\", \"Error_InvalidInput_EndDateBeforeValuationDate\",
     \"Error_InvalidInput_ImpliedVolOverrideIncompatibleWithCapsOnCms\",
     \"Error_InvalidInput_ImpliedVolOverrideIncompatibleWithCollars\",
     \"Error_InvalidInput_InconsistentParameters\",
     \"Error_InvalidInput_InstrumentDefintionCantBeOverriden\",
     \"Error_InvalidInput_InvalidAmortizationSchedule\", \"Error_InvalidInput_InvalidAmount\",
     \"Error_InvalidInput_InvalidAxis\", \"Error_InvalidInput_InvalidCalculationInput\",
     \"Error_InvalidInput_InvalidCalendarCode\", \"Error_InvalidInput_InvalidCalendarDayOfMonth\",
     \"Error_InvalidInput_InvalidCalendarOrCurrency\",
     \"Error_InvalidInput_InvalidCommodityForwardCurveDefinition\",
     \"Error_InvalidInput_InvalidConvexityAdjustmentIntegrationMethod\",
     \"Error_InvalidInput_InvalidCount\",
     \"Error_InvalidInput_InvalidCrossCurrencySwapsConstituent\",
     \"Error_InvalidInput_InvalidCurrencyCode\", \"Error_InvalidInput_InvalidDate\",
     \"Error_InvalidInput_InvalidDayOfWeek\", \"Error_InvalidInput_InvalidFieldValue\",
     \"Error_InvalidInput_InvalidFxCrossCodeCrossCurrencySwapsConstituent\",
     \"Error_InvalidInput_InvalidFxForwardCurveDefinition\",
     \"Error_InvalidInput_InvalidInstrumentDefinition\",
     \"Error_InvalidInput_InvalidInterestRateCurveDefinition\",
     \"Error_InvalidInput_InvalidInterval\", \"Error_InvalidInput_InvalidJsonPayload\",
     \"Error_InvalidInput_InvalidLagAndLockOutValues\", \"Error_InvalidInput_InvalidLegDefinition\",
     \"Error_InvalidInput_InvalidMarketDataDate\",
     \"Error_InvalidInput_InvalidMarketDataParameters\", \"Error_InvalidInput_InvalidMaturityDate\",
     \"Error_InvalidInput_InvalidParametersForImmpliedVol\",
     \"Error_InvalidInput_InvalidPricingModelType\", \"Error_InvalidInput_InvalidPricingParameter\",
     \"Error_InvalidInput_InvalidPricingType\", \"Error_InvalidInput_InvalidReportCurrencyCode\",
     \"Error_InvalidInput_InvalidShiftModel\", \"Error_InvalidInput_InvalidSurfaceType\",
     \"Error_InvalidInput_InvalidTenor\", \"Error_InvalidInput_InvalidTenorPriority\",
     \"Error_InvalidInput_InvalidUnderlyingInstrumentType\",
     \"Error_InvalidInput_InvalidValuationDate\", \"Error_InvalidInput_MandatoryFieldValue\",
     \"Error_InvalidInput_MaturityDateExpired\", \"Error_InvalidInput_MaxMaturityFilter\",
     \"Error_InvalidInput_MaxStalenessDaysFilter\", \"Error_InvalidInput_MinMaturityFilter\",
     \"Error_InvalidInput_MissingParameter\", \"Error_InvalidInput_MissingUnderlyingInstrument\",
     \"Error_InvalidInput_MissingUnderlyingInstrumentType\",
     \"Error_InvalidInput_NoCalculationInput\", \"Error_InvalidInput_NoDefaultFields\",
     \"Error_InvalidInput_NoFields\", \"Error_InvalidInput_NoInstrumentType\",
     \"Error_InvalidInput_NoRequest\", \"Error_InvalidInput_NoUnderlyingType\",
     \"Error_InvalidInput_NoUniverse\", \"Error_InvalidInput_NoUserId\",
     \"Error_InvalidInput_RequestIdMismatch\", \"Error_InvalidInput_Ric_Not_Supported\",
     \"Error_InvalidInput_SameExpiryAxis\", \"Error_InvalidInput_StartDate\",
     \"Error_InvalidInput_StartDateAfterEndDate\", \"Error_InvalidInput_StartDateMatchEndDate\",
     \"Error_InvalidInput_StaticFilter_PastCalDate\", \"Error_InvalidInput_Template_Not_Supported\",
     \"Error_InvalidInput_TooManyInstruments\", \"Error_InvalidInput_UnbindableJsonPayload\",
     \"Error_InvalidInput_UnknownField\", \"Error_InvalidInput_UnrecognizedUnderlyingType\",
     \"Error_InvalidInput_Unspecified\", \"Error_InvalidInput_UnsupportedInstrumentType\",
     \"Error_InvalidMarketDataInput_CrossCurrencyCurve_Duplicated_Outrights\",
     \"Error_InvalidMarketDataInput_CrossCurrencyCurve_Duplicated_SwapPoints\",
     \"Error_InvalidMarketDataInput_CrossCurrencyCurve_ManyCurvesDefined\",
     \"Error_InvalidMarketDataInput_CrossCurrencyCurve__InvalidFxCrossCode\",
     \"Error_InvalidMarketDataInput_DepositCurve_EmptyCurrency\",
     \"Error_InvalidMarketDataInput_DepositCurve_InvalidCurrency\",
     \"Error_InvalidMarketDataInput_ExcludedTenorsDefinition\",
     \"Error_InvalidMarketDataInput_FxCurve_EmptyFxCrossCode\",
     \"Error_InvalidMarketDataInput_FxCurve_InvalidFxCrossCode\",
     \"Error_InvalidMarketDataInput_FxCurve_InvalidReferenceCurrency\",
     \"Error_InvalidMarketDataInput_InterestRateCurve_EmptyCurrency\",
     \"Error_InvalidMarketDataInput_InterestRateCurve_InsufficientData\",
     \"Error_InvalidMarketDataInput_InterestRateCurve_InvalidCurrency\",
     \"Error_InvalidMarketDataInput_IrVolatility_InsufficientData\",
     \"Error_InvalidMarketDataInput_TenorsDefinition\", \"Error_Invalid_VolatilityType\",
     \"Error_LifeCycleEvent_No_Event_Found\", \"Error_No_Underlying_Price\", \"Error_NotFound\",
     \"None\", \"TechnicalError\", \"TestDataNotRecordedError\", \"TestDataSavingFailed\",
     \"Warning_InvalidInput_CubicSplineIsNotRecommended\",
     \"Warning_InvalidInput_CurvePointWithNegativeOutright\",
     \"Warning_InvalidInput_DuplicatedTenors\", \"Warning_InvalidInput_EndDateNotBusinessDay\",
     \"Warning_InvalidInput_FxSpotNotExist\", \"Warning_InvalidInput_FxSpotOnlyUsed\",
     \"Warning_InvalidInput_IgnoredCrossCurrencySwaps\",
     \"Warning_InvalidInput_IgnoredUncollateralizedInstruments\",
     \"Warning_InvalidInput_InvalidConstituent\",
     \"Warning_InvalidInput_InvalidFxForwardConstituent\",
     \"Warning_InvalidInput_InvalidStepDates\", \"Warning_InvalidInput_NoBeforeAfterTurn\",
     \"Warning_InvalidInput_NoEncapsulatedTurn\", \"Warning_InvalidInput_NoOverlapTurn\",
     \"Warning_InvalidInput_NoPreSpotTurn\", \"Warning_InvalidInput_NoPreValuationStepDate\",
     \"Warning_InvalidInput_PartialSwapPoints\", \"Warning_InvalidInput_StartDateAlreadyExists\",
     \"Warning_InvalidInput_StartDateBeforeSpotDate\",
     \"Warning_InvalidInput_StartDateCannotBeExtrapolated\",
     \"Warning_InvalidInput_StartDateEmpty\",
     \"Warning_InvalidInput_StartDateIncludedInStandardTurnPeriods\",
     \"Warning_InvalidInput_StartDateIsTheSameWithStandardTurnDates\",
     \"Warning_InvalidInput_StartDateNotBusinessDay\",
     \"Warning_InvalidInput_StepDateBeforeValuationDate\",
     \"Warning_InvalidInput_TurnAdjustmentsNotAppliedToBothLegs\",
     \"Warning_InvalidInput_TurnAdjustmentsNotMatchedConstituents\",
     \"Warning_InvalidInput_TurnPeriodExceeded\", and \"Warning_InvalidInput_UnprocessedTurn\"."""

    @overload
    def __init__(
        self,
        code: Optional[Union[str, "_models.CodeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["code"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InflationInstruments(_model_base.Model):
    """InflationInstruments.

    Attributes
    ----------
    inflation_swaps : list[~analyticsapi.models.InflationSwapInstrument]
        The list of attributes for Inflation Swap contracts used as
        constituents to construct the curve.  The default value is None, needs
        to be assigned before using.
    """

    inflation_swaps: Optional[List["_models.InflationSwapInstrument"]] = rest_field(name="inflationSwaps")
    """The list of attributes for Inflation Swap contracts used as constituents to construct the
     curve."""

    @overload
    def __init__(
        self,
        inflation_swaps: Optional[List["_models.InflationSwapInstrument"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["inflation_swaps"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InflationInstrumentsOutput(_model_base.Model):
    """InflationInstrumentsOutput.

    Attributes
    ----------
    inflation_swaps : list[~analyticsapi.models.InflationSwapInstrumentOutput]
        Get inflationSwaps.  The default value is None, needs to be assigned
        before using.
    """

    inflation_swaps: Optional[List["_models.InflationSwapInstrumentOutput"]] = rest_field(name="inflationSwaps")
    """Get inflationSwaps."""

    @overload
    def __init__(
        self,
        inflation_swaps: Optional[List["_models.InflationSwapInstrumentOutput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["inflation_swaps"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InflationInstrumentsSegment(_model_base.Model):
    """InflationInstrumentsSegment.

    Attributes
    ----------
    constituents : ~analyticsapi.models.InflationConstituentsDescription
    curve_parameters : ~analyticsapi.models.InflationCurveParametersDescription
    start_date : ~datetime.date
        Get startDate.
    """

    constituents: Optional["_models.InflationConstituentsDescription"] = rest_field()
    curve_parameters: Optional["_models.InflationCurveParametersDescription"] = rest_field(name="curveParameters")
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """Get startDate."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.InflationConstituentsDescription"] = None,
        curve_parameters: Optional["_models.InflationCurveParametersDescription"] = None,
        start_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationRateCurvePoint(_model_base.Model):
    """InflationRateCurvePoint.

    Attributes
    ----------
    annualized_rate_percent : float
        The computed annualized inflation rate of the curve point. The value is
        expressed in percentages.
    end_date : ~datetime.date
        The date used to define the end date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    rate_percent : float
        The computed inflation rate of the curve point. The value is expressed
        in percentages.
    start_date : ~datetime.date
        The date used to define the start date of the curve point tenor.  The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    tenor : str
        The code indicating the period between startDate and endDate of the
        curve points (e.g., '1M', '6M', '4Y'). It is not returned for backward-
        looking period.
    """

    annualized_rate_percent: Optional[float] = rest_field(name="annualizedRatePercent")
    """The computed annualized inflation rate of the curve point. The value is expressed in
     percentages."""
    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date used to define the end date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    rate_percent: Optional[float] = rest_field(name="ratePercent")
    """The computed inflation rate of the curve point. The value is expressed in percentages."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The date used to define the start date of the curve point tenor.  The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between startDate and endDate of the curve points (e.g., '1M',
     '6M', '4Y'). It is not returned for backward-looking period."""

    @overload
    def __init__(
        self,
        *,
        annualized_rate_percent: Optional[float] = None,
        end_date: Optional[datetime.date] = None,
        rate_percent: Optional[float] = None,
        start_date: Optional[datetime.date] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationSeasonality(_model_base.Model):
    """InflationSeasonality.

    Attributes
    ----------
    apply_seasonality : bool
    seasonalities : list[~analyticsapi.models.InflationSeasonalityItem]
        The list of seasonality factors applied to the calculation of the curve
        points. Please note that both 'factor' and 'month' must be provided to
        override seasonality. The default value is None, needs to be assigned
        before using.
    """

    apply_seasonality: Optional[bool] = rest_field(name="applySeasonality")
    seasonalities: Optional[List["_models.InflationSeasonalityItem"]] = rest_field()
    """The list of seasonality factors applied to the calculation of the curve points. Please note
     that both 'factor' and 'month' must be provided to override seasonality."""

    @overload
    def __init__(
        self,
        *,
        apply_seasonality: Optional[bool] = None,
        seasonalities: Optional[List["_models.InflationSeasonalityItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationSeasonalityCurvePoint(_model_base.Model):
    """InflationSeasonalityCurvePoint.

    Attributes
    ----------
    factor : float
        The seasonality factor applied to a certain curve point.
    is_overridden : bool
    month : str or ~analyticsapi.models.MonthEnum
        Get month. Known values are: "January", "February", "March", "April",
        "May", "June", "July", "August", "September", "October", "November",
        and "December".
    """

    factor: Optional[float] = rest_field()
    """The seasonality factor applied to a certain curve point."""
    is_overridden: Optional[bool] = rest_field(name="isOverridden")
    month: Optional[Union[str, "_models.MonthEnum"]] = rest_field()
    """Get month. Known values are: \"January\", \"February\", \"March\", \"April\", \"May\",
     \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", and \"December\"."""

    @overload
    def __init__(
        self,
        *,
        factor: Optional[float] = None,
        is_overridden: Optional[bool] = None,
        month: Optional[Union[str, "_models.MonthEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationSeasonalityItem(_model_base.Model):
    """Inflation Seasonality.

    Attributes
    ----------
    factor : float
        The seasonality factor applied to a certain curve point.
    month : str or ~analyticsapi.models.MonthEnum
        Get month. Known values are: "January", "February", "March", "April",
        "May", "June", "July", "August", "September", "October", "November",
        and "December".
    """

    factor: Optional[float] = rest_field()
    """The seasonality factor applied to a certain curve point."""
    month: Optional[Union[str, "_models.MonthEnum"]] = rest_field()
    """Get month. Known values are: \"January\", \"February\", \"March\", \"April\", \"May\",
     \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", and \"December\"."""

    @overload
    def __init__(
        self,
        *,
        factor: Optional[float] = None,
        month: Optional[Union[str, "_models.MonthEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationSwapInstrument(_model_base.Model):
    """InflationSwapInstrument.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFormulaFields
    instrument_definition : ~analyticsapi.models.InstrumentDefinition
    """

    fields: Optional["_models.BidAskFormulaFields"] = rest_field()
    instrument_definition: Optional["_models.InstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFormulaFields"] = None,
        instrument_definition: Optional["_models.InstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationSwapInstrumentDefinitionOutput(_model_base.Model):
    """InflationSwapInstrumentDefinitionOutput.

    Attributes
    ----------
    end_date : ~datetime.date
        The date used to define the end date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    instrument_code : str
        The code used to define the instrument.
    start_date : ~datetime.date
        The date used to define the start date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    template : str
        A reference to a style used to define the instrument.
    tenor : str
        The code indicating the instrument tenor (e.g., '6M', '1Y').
    """

    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date used to define the end date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The date used to define the start date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""
    tenor: Optional[str] = rest_field()
    """The code indicating the instrument tenor (e.g., '6M', '1Y')."""

    @overload
    def __init__(
        self,
        *,
        end_date: Optional[datetime.date] = None,
        instrument_code: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        template: Optional[str] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationSwapInstrumentOutput(_model_base.Model):
    """InflationSwapInstrumentOutput.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsFormulaOutput
    instrument_definition : ~analyticsapi.models.InflationSwapInstrumentDefinitionOutput
    status_message : str
        Get statusMessage.
    """

    fields: Optional["_models.BidAskFieldsFormulaOutput"] = rest_field()
    instrument_definition: Optional["_models.InflationSwapInstrumentDefinitionOutput"] = rest_field(
        name="instrumentDefinition"
    )
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsFormulaOutput"] = None,
        instrument_definition: Optional["_models.InflationSwapInstrumentDefinitionOutput"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InflationSwapsInstrumentDescription(_model_base.Model):
    """InflationSwapsInstrumentDescription.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsDescription
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterDescription]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.InstrumentDefinition
    """

    fields: Optional["_models.BidAskFieldsDescription"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.InstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsDescription"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = None,
        instrument_definition: Optional["_models.InstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InnerError(_model_base.Model):
    """An object that contains the detailed information in case of a blocking error in calculation.

    Attributes
    ----------
    key : str
        The specification of the request in which an error occurs. Required.
    reason : str
        The reason why an error occurs. Required.
    name : str
        The name of the property causing the error.
    invalid_name : str
        The name of the invalid property.
    """

    key: str = rest_field()
    """The specification of the request in which an error occurs. Required."""
    reason: str = rest_field()
    """The reason why an error occurs. Required."""
    name: Optional[str] = rest_field()
    """The name of the property causing the error."""
    invalid_name: Optional[str] = rest_field(name="invalidName")
    """The name of the invalid property."""

    @overload
    def __init__(
        self,
        *,
        key: str,
        reason: str,
        name: Optional[str] = None,
        invalid_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InputFlow(_model_base.Model):
    """InputFlow.

    Attributes
    ----------
    amount : float
        The amount paid (negative sign of the amount) or received (positive
        sign of the amount).
    currency : str
        The code of amount currency, expressed in ISO 4217 alphabetical format
        (e.g., 'CHF').
    date : ~datetime.datetime
        The date of the instrument cash flow. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    """

    amount: Optional[float] = rest_field()
    """The amount paid (negative sign of the amount) or received (positive sign of the amount)."""
    currency: Optional[str] = rest_field()
    """The code of amount currency, expressed in ISO 4217 alphabetical format (e.g., 'CHF')."""
    date: Optional[datetime.datetime] = rest_field(format="rfc3339")
    """The date of the instrument cash flow. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., '2021-01-01')."""

    @overload
    def __init__(
        self,
        *,
        amount: Optional[float] = None,
        currency: Optional[str] = None,
        date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstrumentDefinition(_model_base.Model):
    """InstrumentDefinition.

    Attributes
    ----------
    instrument_code : str
        The code used to define the instrument.
    template : str
        A reference to a style used to define the instrument.
    tenor : str
        The code indicating the instrument tenor (e.g., '6M', '1Y').
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""
    tenor: Optional[str] = rest_field()
    """The code indicating the instrument tenor (e.g., '6M', '1Y')."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        template: Optional[str] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstrumentDefinitionOutput(_model_base.Model):
    """InstrumentDefinitionOutput.

    Attributes
    ----------
    end_date : ~datetime.date
        The date used to define the end date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    instrument_code : str
        The code used to define the instrument.
    start_date : ~datetime.date
        The date used to define the start date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    synthetic_instrument_code : str
        The code used to define the formula.
    template : str
        A reference to a style used to define the instrument.
    tenor : str
        The code indicating the instrument tenor (e.g., '6M', '1Y').
    """

    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date used to define the end date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The date used to define the start date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    synthetic_instrument_code: Optional[str] = rest_field(name="syntheticInstrumentCode")
    """The code used to define the formula."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""
    tenor: Optional[str] = rest_field()
    """The code indicating the instrument tenor (e.g., '6M', '1Y')."""

    @overload
    def __init__(
        self,
        *,
        end_date: Optional[datetime.date] = None,
        instrument_code: Optional[str] = None,
        start_date: Optional[datetime.date] = None,
        synthetic_instrument_code: Optional[str] = None,
        template: Optional[str] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstrumentDescription(_model_base.Model):
    """InstrumentDescription.

    Attributes
    ----------
    fields : ~analyticsapi.models.BidAskFieldsDescription
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterDescription]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.InstrumentDefinition
    """

    fields: Optional["_models.BidAskFieldsDescription"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.InstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        fields: Optional["_models.BidAskFieldsDescription"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = None,
        instrument_definition: Optional["_models.InstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstrumentTemplate(_model_base.Model):
    """A model template defining a resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.INSTRUMENT_TEMPLATE
        Property defining the type of the resource.
    id : str
        Unique identifier of the InstrumentTemplate.
    location : ~analyticsapi.models.Location
        Object defining the location of the InstrumentTemplate in the platform.
        Required.
    description : ~analyticsapi.models.Description
        Object defining metadata for the InstrumentTemplate.
    definition : ~analyticsapi.models.InstrumentTemplateDefinition
        Object defining the InstrumentTemplate. Required.
    """

    type: Optional[Literal[ResourceType.INSTRUMENT_TEMPLATE]] = rest_field(
        visibility=["read"], default=ResourceType.INSTRUMENT_TEMPLATE
    )
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the InstrumentTemplate."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining the location of the InstrumentTemplate in the platform. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining metadata for the InstrumentTemplate."""
    definition: "_models.InstrumentTemplateDefinition" = rest_field()
    """Object defining the InstrumentTemplate. Required."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        definition: "_models.InstrumentTemplateDefinition",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstrumentTemplateCollectionLinks(_model_base.Model):
    """InstrumentTemplateCollectionLinks.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstrumentTemplateCollectionResponse(_model_base.Model):
    """A model template describing a paged response.

    Attributes
    ----------
    data : list[~analyticsapi.models.InstrumentTemplateInfo]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.InstrumentTemplateCollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.InstrumentTemplateInfo"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.InstrumentTemplateCollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.InstrumentTemplateInfo"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.InstrumentTemplateCollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstrumentTemplateInfo(_model_base.Model):
    """A model template defining the partial description of the resource returned by the GET list
    service.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.INSTRUMENT_TEMPLATE
        Property defining the type of the resource.
    id : str
        Unique identifier of the InstrumentTemplate.
    location : ~analyticsapi.models.Location
        Object defining metadata for the InstrumentTemplate. Required.
    description : ~analyticsapi.models.Description
        Object defining the InstrumentTemplate.
    """

    type: Optional[Literal[ResourceType.INSTRUMENT_TEMPLATE]] = rest_field(
        visibility=["read"], default=ResourceType.INSTRUMENT_TEMPLATE
    )
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the InstrumentTemplate."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining metadata for the InstrumentTemplate. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining the InstrumentTemplate."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InstrumentTemplateResponse(_model_base.Model):
    """A model template describing a single response.

    Attributes
    ----------
    data : ~analyticsapi.models.InstrumentTemplate
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.InstrumentTemplate" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.InstrumentTemplate",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestCashflow(Cashflow, discriminator="Interest"):
    """Lists the properties for Interest payment type.

    Attributes
    ----------
    date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the payment
        date.
    amount : ~analyticsapi.models.Amount
        An object that defines the amount and currency of a payment. Required.
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that makes the payment. Required. Known
        values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that receives the payment. Required. Known
        values are: "Party1" and "Party2".
    occurrence : str or ~analyticsapi.models.PaymentOccurrenceEnum
        The timeline of the transaction. The possible values are: Historical:
        the cash flow date is earlier than the valuation date, Future: the cash
        flow date follows the valuation date and the cash flow is known,
        Projected: the cash flow date follows the valuation date and the cash
        flow is not set by the contract but estimated. Required. Known values
        are: "Historical", "Future", and "Projected".
    payment_type : str or ~analyticsapi.models.INTEREST
        Required.
    annual_rate : ~analyticsapi.models.Rate
        The annualized forward rate that applies to the cashflow period. This
        rate determines the interest amount calculated for the period between
        the start and end dates. Required.
    discount_factor : float
        The ratio used to calculate amount as the present value of future cash
        flows for the instrument. Required.
    start_date : ~datetime.date
        The date when the interest calculation period begins for this type of
        cashflow. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01'). Required.
    end_date : ~datetime.date
        The date when the interest calculation period ends for this type of
        cashflow. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01'). Required.
    remaining_notional : float
        The remaining notional amount as of cash flow date. Required.
    interest_rate_type : str or ~analyticsapi.models.InterestRateTypeEnum
        The type of rate paid or received depending on instrument type.
        Possible values can be FixedRate, FloatRate, StepRate. See extended
        list in InterestRateTypeEnum. Required. Known values are: "FixedRate",
        "StepRate", "FloatingRate", and "FloatingRateFormula".
    zero_rate : ~analyticsapi.models.Rate
        The interpolated zero-coupon rate that applies at the cashflow payment
        date. This rate represents the yield of a theoretical zero-coupon
        instrument with maturity matching the payment date and serves as a
        discount factor for present value calculations.
    index_fixings : list[~analyticsapi.models.IndexFixing]
        The coupon payment information. Applies to floating rate instruments.
        The default value is None, needs to be assigned before using.
    """

    payment_type: Literal[CashFlowPaymentTypeEnum.INTEREST] = rest_discriminator(name="paymentType")  # type: ignore
    """Required."""
    annual_rate: "_models.Rate" = rest_field(name="annualRate")
    """The annualized forward rate that applies to the cashflow period.
     This rate determines the interest amount calculated for the period between the start and end
     dates. Required."""
    discount_factor: float = rest_field(name="discountFactor")
    """The ratio used to calculate amount as the present value of future cash flows for the
     instrument. Required."""
    start_date: datetime.date = rest_field(name="startDate")
    """The date when the interest calculation period begins for this type of cashflow. The value is
     expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Required."""
    end_date: datetime.date = rest_field(name="endDate")
    """The date when the interest calculation period ends for this type of cashflow. The value is
     expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Required."""
    remaining_notional: float = rest_field(name="remainingNotional")
    """The remaining notional amount as of cash flow date. Required."""
    interest_rate_type: Union[str, "_models.InterestRateTypeEnum"] = rest_field(name="interestRateType")
    """The type of rate paid or received depending on instrument type.
     Possible values can be FixedRate, FloatRate, StepRate. See extended list in
     InterestRateTypeEnum. Required. Known values are: \"FixedRate\", \"StepRate\",
     \"FloatingRate\", and \"FloatingRateFormula\"."""
    zero_rate: Optional["_models.Rate"] = rest_field(name="zeroRate")
    """The interpolated zero-coupon rate that applies at the cashflow payment date.
     This rate represents the yield of a theoretical zero-coupon instrument with maturity matching
     the payment date and serves as a discount factor for present value calculations."""
    index_fixings: Optional[List["_models.IndexFixing"]] = rest_field(name="indexFixings")
    """The coupon payment information. Applies to floating rate instruments."""

    @overload
    def __init__(
        self,
        *,
        amount: "_models.Amount",
        payer: Union[str, "_models.PartyEnum"],
        receiver: Union[str, "_models.PartyEnum"],
        occurrence: Union[str, "_models.PaymentOccurrenceEnum"],
        annual_rate: "_models.Rate",
        discount_factor: float,
        start_date: datetime.date,
        end_date: datetime.date,
        remaining_notional: float,
        interest_rate_type: Union[str, "_models.InterestRateTypeEnum"],
        date: Optional["_models.Date"] = None,
        zero_rate: Optional["_models.Rate"] = None,
        index_fixings: Optional[List["_models.IndexFixing"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, payment_type=CashFlowPaymentTypeEnum.INTEREST, **kwargs)


class InterestRateAssignment(_model_base.Model):
    """InterestRateAssignment.

    Attributes
    ----------
    discount : list[~analyticsapi.models.DiscountMarketDataAssignmentKeyAssignmentItem]
        The default value is None, needs to be assigned before using.
    forward : list[~analyticsapi.models.ForwardMarketDataAssignmentKeyAssignmentItem]
        The default value is None, needs to be assigned before using.
    """

    discount: Optional[List["_models.DiscountMarketDataAssignmentKeyAssignmentItem"]] = rest_field()
    forward: Optional[List["_models.ForwardMarketDataAssignmentKeyAssignmentItem"]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        discount: Optional[List["_models.DiscountMarketDataAssignmentKeyAssignmentItem"]] = None,
        forward: Optional[List["_models.ForwardMarketDataAssignmentKeyAssignmentItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateConstituentsDescription(_model_base.Model):
    """InterestRateConstituentsDescription.

    Attributes
    ----------
    deposits : list[~analyticsapi.models.StubBasisInterestRateCurveInstrumentDescription]
        Get deposits.  The default value is None, needs to be assigned before
        using.
    fras : list[~analyticsapi.models.StubBasisInterestRateCurveInstrumentDescription]
        Get fras.  The default value is None, needs to be assigned before
        using.
    futures : list[~analyticsapi.models.FuturesInstrumentDescription]
        Get futures.  The default value is None, needs to be assigned before
        using.
    interest_rate_swaps : list[~analyticsapi.models.InterestRateCurveInstrumentDescription]
        Get interestRateSwaps.  The default value is None, needs to be assigned
        before using.
    overnight_index_swaps : list[~analyticsapi.models.InterestRateCurveInstrumentDescription]
        Get overnightIndexSwaps.  The default value is None, needs to be
        assigned before using.
    sources : ~analyticsapi.models.InterestRateInstrumentsSources
    tenor_basis_swaps : list[~analyticsapi.models.InterestRateCurveInstrumentDescription]
        Get tenorBasisSwaps.  The default value is None, needs to be assigned
        before using.
    """

    deposits: Optional[List["_models.StubBasisInterestRateCurveInstrumentDescription"]] = rest_field()
    """Get deposits."""
    fras: Optional[List["_models.StubBasisInterestRateCurveInstrumentDescription"]] = rest_field()
    """Get fras."""
    futures: Optional[List["_models.FuturesInstrumentDescription"]] = rest_field()
    """Get futures."""
    interest_rate_swaps: Optional[List["_models.InterestRateCurveInstrumentDescription"]] = rest_field(
        name="interestRateSwaps"
    )
    """Get interestRateSwaps."""
    overnight_index_swaps: Optional[List["_models.InterestRateCurveInstrumentDescription"]] = rest_field(
        name="overnightIndexSwaps"
    )
    """Get overnightIndexSwaps."""
    sources: Optional["_models.InterestRateInstrumentsSources"] = rest_field()
    tenor_basis_swaps: Optional[List["_models.InterestRateCurveInstrumentDescription"]] = rest_field(
        name="tenorBasisSwaps"
    )
    """Get tenorBasisSwaps."""

    @overload
    def __init__(
        self,
        *,
        deposits: Optional[List["_models.StubBasisInterestRateCurveInstrumentDescription"]] = None,
        fras: Optional[List["_models.StubBasisInterestRateCurveInstrumentDescription"]] = None,
        futures: Optional[List["_models.FuturesInstrumentDescription"]] = None,
        interest_rate_swaps: Optional[List["_models.InterestRateCurveInstrumentDescription"]] = None,
        overnight_index_swaps: Optional[List["_models.InterestRateCurveInstrumentDescription"]] = None,
        sources: Optional["_models.InterestRateInstrumentsSources"] = None,
        tenor_basis_swaps: Optional[List["_models.InterestRateCurveInstrumentDescription"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurve(_model_base.Model):
    """A model template defining a resource.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.INTEREST_RATE_CURVE
        Property defining the type of the resource.
    id : str
        Unique identifier of the InterestRateCurve.
    location : ~analyticsapi.models.Location
        Object defining the location of the InterestRateCurve in the platform.
        Required.
    description : ~analyticsapi.models.Description
        Object defining metadata for the InterestRateCurve.
    definition : ~analyticsapi.models.IrCurveDefinition
        Object defining the InterestRateCurve. Required.
    """

    type: Optional[Literal[ResourceType.INTEREST_RATE_CURVE]] = rest_field(
        visibility=["read"], default=ResourceType.INTEREST_RATE_CURVE
    )
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the InterestRateCurve."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining the location of the InterestRateCurve in the platform. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining metadata for the InterestRateCurve."""
    definition: "_models.IrCurveDefinition" = rest_field()
    """Object defining the InterestRateCurve. Required."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        definition: "_models.IrCurveDefinition",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveCalculateArrayResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.IrCurveDataResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.IrCurveDataResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.IrCurveDataResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InterestRateCurveCalculateResponse(_model_base.Model):
    """A model template describing the response returned for an analytics request performed on an
    exsting resource.

    Attributes
    ----------
    data : ~analyticsapi.models.IrCurveDataOnResourceResponseData
        Required.
    """

    data: "_models.IrCurveDataOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.IrCurveDataOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InterestRateCurveCalculationParameters(CurveCalculationParameters):
    """An object that contains parameters used to define how the interest rate curve is constructed
    from the constituents.

    Attributes
    ----------
    valuation_date : ~datetime.date
        The date on which the curve is constructed. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01'). The valuation date
        should not be in the future. Default is Today.
    valuation_time : ~analyticsapi.models.ValuationTime
        an object to define the time on witch the curve is constructed.
    curve_tenors : list[str]
        An array of user-defined tenors for which curve points to be computed.
        The values are expressed in:

        * time period code for tenors (e.g., '1M', '1Y'),
        * ISO 8601 format 'YYYY-MM-DD' for dates (e.g., '2023-01-01').  The default value is None,
        needs to be assigned before using.
    extrapolation_mode : str or ~analyticsapi.models.ExtrapolationMode
        The extrapolation method used in the curve bootstrapping. Known values
        are: "Constant" and "Linear".
    interpolation_mode : str or ~analyticsapi.models.InterestRateCurveInterpolationMode
        The interpolation method used in the curve bootstrapping. Known values
        are: "CubicDiscount", "CubicRate", "CubicSpline",
        "ForwardMonotoneConvex", "Linear", "Log", "Hermite", "AkimaMethod",
        "FritschButlandMethod", "KrugerMethod", "MonotonicCubicNaturalSpline",
        "MonotonicHermiteCubic", and "TensionSpline".
    price_side : str or ~analyticsapi.models.PriceSide
        The quoted price side of the instruments to be used for the curve
        construction. The possible values are: Bid, Ask, Mid. Known values are:
        "Bid", "Ask", and "Mid".
    use_delayed_data_if_denied : bool
        An indicator of whether the delayed data defined in request is used.
    ignore_invalid_instruments : bool
        An indicator of whether invalid instruments are ignored for the curve
        construction.
    interest_calculation_method : str or ~analyticsapi.models.DayCountBasis
        The day count basis method. Known values are: "Dcb_30_360",
        "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
        "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
        "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
        "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA",
        "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", and "Dcb_Actual_365_CanadianConvention".
    compounding_type : str or ~analyticsapi.models.CompoundingType
        The type of the interest rate compounding. Known values are:
        "Continuous", "MoneyMarket", "Compounded", and "Discounted".
    use_convexity_adjustment : bool
        An indicator of whether the convexity adjustment is used for
        calculation.
    convexity_adjustment : ~analyticsapi.models.ConvexityAdjustment
        An object that contains parameters used to control the convexity
        adjustment of the reference index.
    calendar_adjustment : ~analyticsapi.models.BusinessDayAdjustmentDefinition
        An object that defines the business day adjustment convention.
    use_multi_dimensional_solver : bool
        An indicator of whether the multi-dimensional solver for yield curve
        bootstrapping should be used. This solving method is required because
        the bootstrapping method sometimes constructs the curve which does not
        accurately reprice the input instruments used to construct it. The
        multi-dimensional solver is recommended when cubic interpolation
        methods are used in constructing the curve (in other cases, performance
        might be inferior to the regular bootstrapping method).
    """

    extrapolation_mode: Optional[Union[str, "_models.ExtrapolationMode"]] = rest_field(name="extrapolationMode")
    """The extrapolation method used in the curve bootstrapping. Known values are: \"Constant\" and
     \"Linear\"."""
    interpolation_mode: Optional[Union[str, "_models.InterestRateCurveInterpolationMode"]] = rest_field(
        name="interpolationMode"
    )
    """The interpolation method used in the curve bootstrapping. Known values are: \"CubicDiscount\",
     \"CubicRate\", \"CubicSpline\", \"ForwardMonotoneConvex\", \"Linear\", \"Log\", \"Hermite\",
     \"AkimaMethod\", \"FritschButlandMethod\", \"KrugerMethod\", \"MonotonicCubicNaturalSpline\",
     \"MonotonicHermiteCubic\", and \"TensionSpline\"."""
    price_side: Optional[Union[str, "_models.PriceSide"]] = rest_field(name="priceSide")
    """The quoted price side of the instruments to be used for the curve construction. The possible
     values are: Bid, Ask, Mid. Known values are: \"Bid\", \"Ask\", and \"Mid\"."""
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")
    """An indicator of whether the delayed data defined in request is used."""
    ignore_invalid_instruments: Optional[bool] = rest_field(name="ignoreInvalidInstruments")
    """An indicator of whether invalid instruments are ignored for the curve construction."""
    interest_calculation_method: Optional[Union[str, "_models.DayCountBasis"]] = rest_field(
        name="interestCalculationMethod"
    )
    """The day count basis method. Known values are: \"Dcb_30_360\", \"Dcb_30_360_US\",
     \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\", \"Dcb_30_365_German\",
     \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\", \"Dcb_30_Actual_ISDA\",
     \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\", \"Dcb_Actual_365\",
     \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\", \"Dcb_Actual_Actual_AFB\",
     \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\", \"Dcb_ActualLeapDay_365\",
     \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\", and \"Dcb_Actual_365_CanadianConvention\"."""
    compounding_type: Optional[Union[str, "_models.CompoundingType"]] = rest_field(name="compoundingType")
    """The type of the interest rate compounding. Known values are: \"Continuous\", \"MoneyMarket\",
     \"Compounded\", and \"Discounted\"."""
    use_convexity_adjustment: Optional[bool] = rest_field(name="useConvexityAdjustment")
    """An indicator of whether the convexity adjustment is used for calculation."""
    convexity_adjustment: Optional["_models.ConvexityAdjustment"] = rest_field(name="convexityAdjustment")
    """An object that contains parameters used to control the convexity adjustment of the reference
     index."""
    calendar_adjustment: Optional["_models.BusinessDayAdjustmentDefinition"] = rest_field(name="calendarAdjustment")
    """An object that defines the business day adjustment convention."""
    use_multi_dimensional_solver: Optional[bool] = rest_field(name="useMultiDimensionalSolver")
    """An indicator of whether the multi-dimensional solver for yield curve bootstrapping should be
     used.
     This solving method is required because the bootstrapping method sometimes constructs the curve
     which does not accurately reprice the input instruments used to construct it.
     The multi-dimensional solver is recommended when cubic interpolation methods are used in
     constructing the curve (in other cases, performance might be inferior to the regular
     bootstrapping method)."""

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.date] = None,
        valuation_time: Optional["_models.ValuationTime"] = None,
        curve_tenors: Optional[List[str]] = None,
        extrapolation_mode: Optional[Union[str, "_models.ExtrapolationMode"]] = None,
        interpolation_mode: Optional[Union[str, "_models.InterestRateCurveInterpolationMode"]] = None,
        price_side: Optional[Union[str, "_models.PriceSide"]] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
        ignore_invalid_instruments: Optional[bool] = None,
        interest_calculation_method: Optional[Union[str, "_models.DayCountBasis"]] = None,
        compounding_type: Optional[Union[str, "_models.CompoundingType"]] = None,
        use_convexity_adjustment: Optional[bool] = None,
        convexity_adjustment: Optional["_models.ConvexityAdjustment"] = None,
        calendar_adjustment: Optional["_models.BusinessDayAdjustmentDefinition"] = None,
        use_multi_dimensional_solver: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveCollectionLinks(_model_base.Model):
    """InterestRateCurveCollectionLinks.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveCollectionResponse(_model_base.Model):
    """A model template describing a paged response.

    Attributes
    ----------
    data : list[~analyticsapi.models.InterestRateCurveInfo]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.InterestRateCurveCollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.InterestRateCurveInfo"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.InterestRateCurveCollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.InterestRateCurveInfo"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.InterestRateCurveCollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveCreateRequest(_model_base.Model):
    """interest rate curve definition.

    Attributes
    ----------
    curve_definition : ~analyticsapi.models.InterestRateCurveDefinitionDescription
    overrides : list[~analyticsapi.models.OverrideBidAsk]
        Get overrides.  The default value is None, needs to be assigned before
        using.
    segments : list[~analyticsapi.models.InterestRateInstrumentsSegment]
        Get segments.  The default value is None, needs to be assigned before
        using.
    steps : list[~analyticsapi.models.Step]
        Get steps.  The default value is None, needs to be assigned before
        using.
    """

    curve_definition: Optional["_models.InterestRateCurveDefinitionDescription"] = rest_field(name="curveDefinition")
    overrides: Optional[List["_models.OverrideBidAsk"]] = rest_field()
    """Get overrides."""
    segments: Optional[List["_models.InterestRateInstrumentsSegment"]] = rest_field()
    """Get segments."""
    steps: Optional[List["_models.Step"]] = rest_field()
    """Get steps."""

    @overload
    def __init__(
        self,
        *,
        curve_definition: Optional["_models.InterestRateCurveDefinitionDescription"] = None,
        overrides: Optional[List["_models.OverrideBidAsk"]] = None,
        segments: Optional[List["_models.InterestRateInstrumentsSegment"]] = None,
        steps: Optional[List["_models.Step"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveDefinition(_model_base.Model):
    """InterestRateCurveDefinition.

    Attributes
    ----------
    currency : str
        The currency code of the interest rate curve (e.g., &#39;EUR&#39;).
    definition_expiry_date : ~datetime.date
        The date after which curveDefinitions can not be used. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    first_historical_availability_date : ~datetime.date
        The date starting from which the definition of the curve can be used.
        The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01').
    id : str
        The identifier of the interest rate curve.
    index_name : str
        The name of the floating rate index (e.g., &#39;ESTR&#39;).
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        The asset class used to generate the interest rate curve. The possible
        values are:   * Deposit   * Futures   * Swap. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    market_data_location : str
        The identifier of the market place from which constituents come from.
        Currently the following values are supported: &#39;Onshore&#39; and
        &#39;EMEA&#39;. The list of values can be extended by a user when
        creating a curve.
    name : str
        The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC
        Curve&#39;).
    owner : str
        The owner of the interest rate curve definition (e.g., 'Refinitiv').
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the generated interest rate curve is sensitive.
        The possible value is: InterestRate. Known values are: "Credit",
        "CrossCurrency", "Inflation", and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of a curve.
        Curves created by Refinitiv have the &#39;Refinitiv&#39; source.
    """

    currency: Optional[str] = rest_field()
    """The currency code of the interest rate curve (e.g., &#39;EUR&#39;)."""
    definition_expiry_date: Optional[datetime.date] = rest_field(name="definitionExpiryDate")
    """The date after which curveDefinitions can not be used. The value is expressed in ISO 8601
     format: YYYY-MM-DD (e.g., '2021-01-01')."""
    first_historical_availability_date: Optional[datetime.date] = rest_field(name="firstHistoricalAvailabilityDate")
    """The date starting from which the definition of the curve can be used.  The value is expressed
     in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    id: Optional[str] = rest_field()
    """The identifier of the interest rate curve."""
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., &#39;ESTR&#39;)."""
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """The asset class used to generate the interest rate curve. The possible values are:   * Deposit
     * Futures   * Swap. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    market_data_location: Optional[str] = rest_field(name="marketDataLocation")
    """The identifier of the market place from which constituents come from. Currently the following
     values are supported: &#39;Onshore&#39; and &#39;EMEA&#39;. The list of values can be extended
     by a user when creating a curve."""
    name: Optional[str] = rest_field()
    """The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC Curve&#39;)."""
    owner: Optional[str] = rest_field()
    """The owner of the interest rate curve definition (e.g., 'Refinitiv')."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the generated interest rate curve is sensitive. The possible value is:
     InterestRate. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of a curve. Curves created by Refinitiv
     have the &#39;Refinitiv&#39; source."""

    @overload
    def __init__(
        self,
        *,
        currency: Optional[str] = None,
        definition_expiry_date: Optional[datetime.date] = None,
        first_historical_availability_date: Optional[datetime.date] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        index_name: Optional[str] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        market_data_location: Optional[str] = None,
        name: Optional[str] = None,
        owner: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveDefinitionDescription(_model_base.Model):
    """InterestRateCurveDefinitionDescription.

    Attributes
    ----------
    currency : str
        The currency code of the interest rate curve (e.g., &#39;EUR&#39;).
    definition_expiry_date : ~datetime.date
        The date after which curveDefinitions can not be used. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    index_name : str
        The name of the floating rate index (e.g., &#39;ESTR&#39;).
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        The asset class used to generate the interest rate curve. The possible
        values are:   * Deposit   * Futures   * Swap. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    market_data_location : str
        The identifier of the market place from which constituents come from.
        Currently the following values are supported: &#39;Onshore&#39; and
        &#39;EMEA&#39;. The list of values can be extended by a user when
        creating a curve.
    name : str
        The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC
        Curve&#39;).
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the generated interest rate curve is sensitive.
        The possible value is: InterestRate. Known values are: "Credit",
        "CrossCurrency", "Inflation", and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of a curve.
        Curves created by Refinitiv have the &#39;Refinitiv&#39; source.
    """

    currency: Optional[str] = rest_field()
    """The currency code of the interest rate curve (e.g., &#39;EUR&#39;)."""
    definition_expiry_date: Optional[datetime.date] = rest_field(name="definitionExpiryDate")
    """The date after which curveDefinitions can not be used. The value is expressed in ISO 8601
     format: YYYY-MM-DD (e.g., '2021-01-01')."""
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., &#39;ESTR&#39;)."""
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """The asset class used to generate the interest rate curve. The possible values are:   * Deposit
     * Futures   * Swap. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    market_data_location: Optional[str] = rest_field(name="marketDataLocation")
    """The identifier of the market place from which constituents come from. Currently the following
     values are supported: &#39;Onshore&#39; and &#39;EMEA&#39;. The list of values can be extended
     by a user when creating a curve."""
    name: Optional[str] = rest_field()
    """The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC Curve&#39;)."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the generated interest rate curve is sensitive. The possible value is:
     InterestRate. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of a curve. Curves created by Refinitiv
     have the &#39;Refinitiv&#39; source."""

    @overload
    def __init__(
        self,
        *,
        currency: Optional[str] = None,
        definition_expiry_date: Optional[datetime.date] = None,
        index_name: Optional[str] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        market_data_location: Optional[str] = None,
        name: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveDefinitionResponse(_model_base.Model):
    """InterestRateCurveDefinitionResponse.

    Attributes
    ----------
    curve_definition : ~analyticsapi.models.InterestRateCurveDefinition
    curve_info : ~analyticsapi.models.CurveInfo
    overrides : list[~analyticsapi.models.OverrideBidAsk]
        Get overrides.  The default value is None, needs to be assigned before
        using.
    segments : list[~analyticsapi.models.InterestRateInstrumentsSegment]
        Get segments.  The default value is None, needs to be assigned before
        using.
    steps : list[~analyticsapi.models.Step]
        Get steps.  The default value is None, needs to be assigned before
        using.
    """

    curve_definition: Optional["_models.InterestRateCurveDefinition"] = rest_field(name="curveDefinition")
    curve_info: Optional["_models.CurveInfo"] = rest_field(name="curveInfo")
    overrides: Optional[List["_models.OverrideBidAsk"]] = rest_field()
    """Get overrides."""
    segments: Optional[List["_models.InterestRateInstrumentsSegment"]] = rest_field()
    """Get segments."""
    steps: Optional[List["_models.Step"]] = rest_field()
    """Get steps."""

    @overload
    def __init__(
        self,
        *,
        curve_definition: Optional["_models.InterestRateCurveDefinition"] = None,
        curve_info: Optional["_models.CurveInfo"] = None,
        overrides: Optional[List["_models.OverrideBidAsk"]] = None,
        segments: Optional[List["_models.InterestRateInstrumentsSegment"]] = None,
        steps: Optional[List["_models.Step"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveInfo(_model_base.Model):
    """A model template defining the partial description of the resource returned by the GET list
    service.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.INTEREST_RATE_CURVE
        Property defining the type of the resource.
    id : str
        Unique identifier of the InterestRateCurve.
    location : ~analyticsapi.models.Location
        Object defining metadata for the InterestRateCurve. Required.
    description : ~analyticsapi.models.Description
        Object defining the InterestRateCurve.
    """

    type: Optional[Literal[ResourceType.INTEREST_RATE_CURVE]] = rest_field(
        visibility=["read"], default=ResourceType.INTEREST_RATE_CURVE
    )
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the InterestRateCurve."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining metadata for the InterestRateCurve. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining the InterestRateCurve."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveInstrumentDescription(_model_base.Model):
    """InterestRateCurveInstrumentDescription.

    Attributes
    ----------
    basis : list[str]
        Get basis.  The default value is None, needs to be assigned before
        using.
    fields : ~analyticsapi.models.BidAskFieldsDescription
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterDescription]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.SyntheticInstrumentDefinition
    """

    basis: Optional[List[str]] = rest_field()
    """Get basis."""
    fields: Optional["_models.BidAskFieldsDescription"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.SyntheticInstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        basis: Optional[List[str]] = None,
        fields: Optional["_models.BidAskFieldsDescription"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = None,
        instrument_definition: Optional["_models.SyntheticInstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveParameters(_model_base.Model):
    """InterestRateCurveParameters.

    Attributes
    ----------
    calendar_adjustment : str or ~analyticsapi.models.CalendarAdjustmentEnum
        The cash flow adjustment according to a selected calendar. The possible
        values are:   * No   * Weekend: for the cash flow pricing using the
        calendar &#39;Weekend&#39;   * Calendar: for the cash flow pricing
        using the calendar defined by the parameter &#39;calendars&#39;. The
        default value is &#39;Calendar&#39;. Known values are: "Calendar",
        "No", and "Weekend".
    calendars : list[str]
        The list of comma-separated calendar codes used to define non-working
        days and to adjust interest rate curve coupon dates and values (e.g.,
        &#39;EMU_FI&#39;). By default, the calendar code is derived from the
        interest rate curve currency.  The default value is None, needs to be
        assigned before using.
    compounding_type : str or ~analyticsapi.models.CompoundingTypeEnum
        The yield type of the interest rate curve. The possible values are:   *
        Discounted   * Compounded   * Continuous   * MoneyMarket The default
        value is &#39;Compounded&#39;. Known values are: "Compounded",
        "Continuous", "Discounted", and "MoneyMarket".
    constant_forward_rate_parameters : ~analyticsapi.models.ConstantForwardRateParameters
    convexity_adjustment : ~analyticsapi.models.CurvesAndSurfacesConvexityAdjustment
    extrapolation_mode : str or ~analyticsapi.models.ExtrapolationModeEnum
        The extrapolation method used in the zero coupon curve bootstrapping.
        The possible values are:   * None: no extrapolation,   * Constant:
        constant extrapolation,   * Linear: linear extrapolation,   *
        ConstantRate: extrapolation with constant zero-coupon rate *
        ConstantForwardRate: extrapolation with constant forward rate   *
        UltimateForwardRate: extrapolation with ultimate forward rate The
        default value is 'None'. Known values are: "Constant",
        "ConstantForwardRate", "ConstantRate", "Linear", "None", and
        "UltimateForwardRate".
    interest_calculation_method : str or ~analyticsapi.models.CurvesAndSurfacesInterestCalculationMethodEnum
        The day count basis method used to compute the points of the zero
        coupon curve. The possible values are:   * Dcb_30_360     Actual number
        of days in the coupon period calculated on the basis of a year of 360
        days with twelve 30-day months unless: - the last day of the period is
        the 31st day of a month and the first day of the period is a day other
        than the 30th or 31st day of a month, in which case the month that
        includes the last day shall not be considered to be shortened to a
        30-day month,     - the last day of the period is the last day of the
        month of February, in which case the month of February shall not be
        considered to be lengthened to a 30-day month.   * Dcb_30_Actual
        The day count is identical to 30/360 (US) and the year basis is
        identical to Actual/Actual.   * Dcb_Actual_360     The day count is the
        actual number of days of the period. The year basis is 360.   *
        Dcb_Actual_365 The day count is the actual number of days of the
        period. The year basis is 365.   * Dcb_Actual_Actual     The DCB is
        calculated by Actual days / year basis where:     - Actual days are
        defined as the actual days between the starting date (D1.M1.Y1) and end
        date (D2.M2.Y2).     - Year basis is defined as the actual days between
        the start date (D1.M1.Y1) and the next relevant interest payment date
        (D3.M3.Y3) multiplied by the instrument coupon frequency.   *
        Dcb_Actual_Actual_ISDA     Similar to Actual/365, except for a period
        that includes days falling in a leap year. It is calculated by DCB
        &#x3D; number of days in a leap year/366 + number of days in a non-leap
        year/365.     A convention is also known as Actual/365 ISDA.
        *Dcb_30_360_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if
        D1 is 31, change it to 30,     - if D2 is 31 and D1 is 30, change D2 to
        30.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
        Dcb_30_365_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if
        D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31
        then D2&#x3D;30.     Then the date difference is
        (Y2-Y1)x365+(M2-M1)x30+(D2-D1)   * Dcb_30_360_US For two dates
        (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     -
        if D2&#x3D;31 and D1&#x3D;30 or 31 then D2&#x3D;30,     - if D1 is the
        last day of February then D1&#x3D;30,     - if D1 is the last day of
        February and D2 is the last day of February then D2&#x3D;30.     The
        last day of February is February 29 in leap years and February 28 in
        non leap years.     The 30/360 US rule is identical to 30/360 ISDA when
        the EOM (end-of-month) convention does not apply. This indicates
        whether all coupon payment dates fall on the last day of the month. If
        the investment is not EOM, it will always pay on the same day of the
        month (e.g., the 10th).     Then the date difference is
        (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_Actual_Actual_AFB     The DCB
        is calculated by Actual days / year basis where:     Actual days are
        defined as the actual days between the start date (D1.M1.Y1) and end
        date (D2.M2.Y2). Year basis is either 365 if the calculation period
        does not contain 29th Feb, or 366 if the calculation period includes
        29th Feb.   * Dcb_WorkingDays_252     The day count is the actual
        number of business days of the period according to the instrument
        calendars. The year basis is 252. Commonly used in the Brazilian
        market.   * Dcb_Actual_365L     The day count is the actual number of
        days of the period. The year basis is calculated in the following two
        rules:     - if the coupon frequency is annual, then year basis is 366
        if the 29 Feb. is included in the interest period, else 365,     - if
        the coupon frequency is not annual, then year basis is 366 for each
        interest period where ending date falls in a leap year, otherwise it is
        365.   * Dcb_ActualLeapDay_365     The day count ignores 29th February
        when counting days. The year basis is 365 days.   *
        Dcb_ActualLeapDay_360     The day count ignores 29th February when
        counting days. The year basis is 360 days.   * Dcb_Actual_36525     The
        day count is the actual number of days of the period. The year basis is
        365.25.   * Dcb_Actual_365_CanadianConvention Follows the Canadian
        domestic bond market convention. The day count basis is computed as
        follows:     - if the number of days of a period is less than the
        actual number of days in a regular coupon period the Dcb_Actual_365
        convention is used,     - otherwise: DCB &#x3D; 1 -
        DaysRemainingInPeriod x Frequency / 365.   * Dcb_30_360_German     For
        two dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then
        D1&#x3D;30,     - if D2&#x3D;31 then D2&#x3D;30,     - if D1 is the
        last day of February then D1&#x3D;30,     - if D2 is the last day of
        February then D2&#x3D;30.     The last day of February is February 29
        in leap years and February 28 in non leap years.     Then the date
        difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_30_365_German
        Similar to 30/360 (German), except that the year basis is treated as
        365 days.   * Dcb_30_Actual_German     The day count is identical to
        30/360 (German) and the year basis is similar to Actual/Actual. This
        method was formerly used in the Eurobond markets.   * Dcb_30E_360_ISMA
        Actual number of days in the coupon period calculated on the basis of a
        year of 360 days with twelve 30-day months (regardless of the date of
        the first day or last day of the period).   * Dcb_Actual_364     A
        special case of Actual/Actual (ISMA) when a coupon period contains 91
        or 182 days. Actual/364 applies for some short-term instruments.
        Day count basis &#x3D; 364.   * Dcb_30_Actual_ISDA   *
        Dcb_30_365_Brazil   * Dcb_Actual_365P   * Dcb_Constant. Known values
        are: "Dcb_30E_360_ISMA", "Dcb_30_360", "Dcb_30_360_German",
        "Dcb_30_360_ISDA", "Dcb_30_360_US", "Dcb_30_365_Brazil",
        "Dcb_30_365_German", "Dcb_30_365_ISDA", "Dcb_30_Actual",
        "Dcb_30_Actual_German", "Dcb_30_Actual_ISDA", "Dcb_ActualLeapDay_360",
        "Dcb_ActualLeapDay_365", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_36525", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_Actual_365_CanadianConvention",
        "Dcb_Actual_Actual", "Dcb_Actual_Actual_AFB", "Dcb_Actual_Actual_ISDA",
        "Dcb_Constant", and "Dcb_WorkingDays_252".
    interpolation_mode : str or ~analyticsapi.models.InterpolationModeEnum
        The interpolation method used in zero curve bootstrapping. The possible
        values are:   * CubicDiscount: local cubic interpolation of discount
        factors   * CubicRate: local cubic interpolation of rates   *
        CubicSpline: a natural cubic spline   * ForwardMonotoneConvex: forward
        Monotone Convexc interpolation   * Linear: linear interpolation * Log:
        log-linear interpolation   * Hermite: Hermite (Bessel) interpolation
        * AkimaMethod: the Akima method (a smoother variant of local cubic
        interpolation)   * FritschButlandMethod: the Fritsch-Butland method (a
        monotonic cubic variant)   * KrugerMethod: the Kruger method (a
        monotonic cubic variant)   * MonotonicCubicNaturalSpline: a monotonic
        natural cubic spline   * MonotonicHermiteCubic: monotonic Hermite
        (Bessel) cubic interpolation   * TensionSpline: a tension spline. Known
        values are: "AkimaMethod", "CubicDiscount", "CubicRate", "CubicSpline",
        "ForwardMonotoneConvex", "FritschButlandMethod", "Hermite",
        "KrugerMethod", "Linear", "Log", "MonotonicCubicNaturalSpline",
        "MonotonicHermiteCubic", "Step", and "TensionSpline".
    market_data_access_denied_fallback : str or ~analyticsapi.models.MarketDataAccessDeniedFallbackEnum
        If at least one constituent access is denied:   * ReturnError: dont
        price the surface and return an error (Default value)   *
        IgnoreConstituents: price the surface without the error market data   *
        UseDelayedData: use delayed Market Data if possible. Known values are:
        "IgnoreConstituents", "ReturnError", and "UseDelayedData".
    market_data_look_back : ~analyticsapi.models.MarketDataLookBack
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        The quoted price side of the instrument to be used for the zero coupon
        curve construction. The possible values are:   * Bid   * Ask   * Mid
        The default value is &#39;Mid&#39;. Known values are: "Ask", "Bid",
        "Last", and "Mid".
    reference_tenor : str
        The tenor of the index interest rate curve for which curvePoints are
        computed (e.g., '3M').
    steps : list[~analyticsapi.models.Step]
        The list of attributes used to calculate the swap rate surface discount
        curve, when OIS is selected as discount curve. The steps can specify
        overnight index stepped dates or/and rates. Currencies supporting steps
        are the following: USD, AUD, BRL, CAD, COP, CZK, EUR, GBP, JPY, NZD,
        PLN, HUF, SEK, CHF, RUB, INR, DKK.  The default value is None, needs to
        be assigned before using.
    turns : list[~analyticsapi.models.Turn]
        The list of attributes used to include end period when calculating swap
        rate surfaces.  The default value is None, needs to be assigned before
        using.
    use_convexity_adjustment : bool
    use_delayed_data_if_denied : bool
    use_multi_dimensional_solver : bool
    use_stub : bool
    """

    calendar_adjustment: Optional[Union[str, "_models.CalendarAdjustmentEnum"]] = rest_field(name="calendarAdjustment")
    """The cash flow adjustment according to a selected calendar. The possible values are:   * No   *
     Weekend: for the cash flow pricing using the calendar &#39;Weekend&#39;   * Calendar: for the
     cash flow pricing using the calendar defined by the parameter &#39;calendars&#39;. The default
     value is &#39;Calendar&#39;. Known values are: \"Calendar\", \"No\", and \"Weekend\"."""
    calendars: Optional[List[str]] = rest_field()
    """The list of comma-separated calendar codes used to define non-working days and to adjust
     interest rate curve coupon dates and values (e.g., &#39;EMU_FI&#39;). By default, the calendar
     code is derived from the interest rate curve currency."""
    compounding_type: Optional[Union[str, "_models.CompoundingTypeEnum"]] = rest_field(name="compoundingType")
    """The yield type of the interest rate curve. The possible values are:   * Discounted   *
     Compounded   * Continuous   * MoneyMarket The default value is &#39;Compounded&#39;. Known
     values are: \"Compounded\", \"Continuous\", \"Discounted\", and \"MoneyMarket\"."""
    constant_forward_rate_parameters: Optional["_models.ConstantForwardRateParameters"] = rest_field(
        name="constantForwardRateParameters"
    )
    convexity_adjustment: Optional["_models.CurvesAndSurfacesConvexityAdjustment"] = rest_field(
        name="convexityAdjustment"
    )
    extrapolation_mode: Optional[Union[str, "_models.ExtrapolationModeEnum"]] = rest_field(name="extrapolationMode")
    """The extrapolation method used in the zero coupon curve bootstrapping. The possible values are:
     * None: no extrapolation,   * Constant: constant extrapolation,   * Linear: linear
     extrapolation,   * ConstantRate: extrapolation with constant zero-coupon rate   *
     ConstantForwardRate: extrapolation with constant forward rate   * UltimateForwardRate:
     extrapolation with ultimate forward rate The default value is 'None'. Known values are:
     \"Constant\", \"ConstantForwardRate\", \"ConstantRate\", \"Linear\", \"None\", and
     \"UltimateForwardRate\"."""
    interest_calculation_method: Optional[Union[str, "_models.CurvesAndSurfacesInterestCalculationMethodEnum"]] = (
        rest_field(name="interestCalculationMethod")
    )
    """The day count basis method used to compute the points of the zero coupon curve. The possible
     values are:   * Dcb_30_360     Actual number of days in the coupon period calculated on the
     basis of a year of 360 days with twelve 30-day months unless:     - the last day of the period
     is the 31st day of a month and the first day of the period is a day other than the 30th or 31st
     day of a month, in which case the month that includes the last day shall not be considered to
     be shortened to a 30-day month,     - the last day of the period is the last day of the month
     of February, in which case the month of February shall not be considered to be lengthened to a
     30-day month.   * Dcb_30_Actual     The day count is identical to 30/360 (US) and the year
     basis is identical to Actual/Actual.   * Dcb_Actual_360     The day count is the actual number
     of days of the period. The year basis is 360.   * Dcb_Actual_365     The day count is the
     actual number of days of the period. The year basis is 365.   * Dcb_Actual_Actual     The DCB
     is calculated by Actual days / year basis where:     - Actual days are defined as the actual
     days between the starting date (D1.M1.Y1) and end date (D2.M2.Y2).     - Year basis is defined
     as the actual days between the start date (D1.M1.Y1) and the next relevant interest payment
     date (D3.M3.Y3) multiplied by the instrument coupon frequency.   * Dcb_Actual_Actual_ISDA
     Similar to Actual/365, except for a period that includes days falling in a leap year. It is
     calculated by DCB &#x3D; number of days in a leap year/366 + number of days in a non-leap
     year/365.     A convention is also known as Actual/365 ISDA.   *Dcb_30_360_ISDA     For two
     dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1 is 31, change it to 30,     - if D2 is 31 and D1
     is 30, change D2 to 30.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
     Dcb_30_365_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then
     D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31 then D2&#x3D;30.     Then the date
     difference is (Y2-Y1)x365+(M2-M1)x30+(D2-D1)   * Dcb_30_360_US     For two dates (Y1,M1,D1) and
     (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31 then
     D2&#x3D;30,     - if D1 is the last day of February then D1&#x3D;30,     - if D1 is the last
     day of February and D2 is the last day of February then D2&#x3D;30.     The last day of
     February is February 29 in leap years and February 28 in non leap years.     The 30/360 US rule
     is identical to 30/360 ISDA when the EOM (end-of-month) convention does not apply. This
     indicates whether all coupon payment dates fall on the last day of the month. If the investment
     is not EOM, it will always pay on the same day of the month (e.g., the 10th).     Then the date
     difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_Actual_Actual_AFB     The DCB is
     calculated by Actual days / year basis where:     Actual days are defined as the actual days
     between the start date (D1.M1.Y1) and end date (D2.M2.Y2).     Year basis is either 365 if the
     calculation period does not contain 29th Feb, or 366 if the calculation period includes 29th
     Feb.   * Dcb_WorkingDays_252     The day count is the actual number of business days of the
     period according to the instrument calendars. The year basis is 252. Commonly used in the
     Brazilian market.   * Dcb_Actual_365L     The day count is the actual number of days of the
     period. The year basis is calculated in the following two rules:     - if the coupon frequency
     is annual, then year basis is 366 if the 29 Feb. is included in the interest period, else 365,
     - if the coupon frequency is not annual, then year basis is 366 for each interest period where
     ending date falls in a leap year, otherwise it is 365.   * Dcb_ActualLeapDay_365     The day
     count ignores 29th February when counting days. The year basis is 365 days.   *
     Dcb_ActualLeapDay_360     The day count ignores 29th February when counting days. The year
     basis is 360 days.   * Dcb_Actual_36525     The day count is the actual number of days of the
     period. The year basis is 365.25.   * Dcb_Actual_365_CanadianConvention     Follows the
     Canadian domestic bond market convention. The day count basis is computed as follows:     - if
     the number of days of a period is less than the actual number of days in a regular coupon
     period the Dcb_Actual_365 convention is used,     - otherwise: DCB &#x3D; 1 -
     DaysRemainingInPeriod x Frequency / 365.   * Dcb_30_360_German     For two dates (Y1,M1,D1) and
     (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 then D2&#x3D;30,     - if
     D1 is the last day of February then D1&#x3D;30,     - if D2 is the last day of February then
     D2&#x3D;30.     The last day of February is February 29 in leap years and February 28 in non
     leap years.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
     Dcb_30_365_German     Similar to 30/360 (German), except that the year basis is treated as 365
     days.   * Dcb_30_Actual_German     The day count is identical to 30/360 (German) and the year
     basis is similar to Actual/Actual. This method was formerly used in the Eurobond markets.   *
     Dcb_30E_360_ISMA     Actual number of days in the coupon period calculated on the basis of a
     year of 360 days with twelve 30-day months (regardless of the date of the first day or last day
     of the period).   * Dcb_Actual_364     A special case of Actual/Actual (ISMA) when a coupon
     period contains 91 or 182 days. Actual/364 applies for some short-term instruments.     Day
     count basis &#x3D; 364.   * Dcb_30_Actual_ISDA   * Dcb_30_365_Brazil   * Dcb_Actual_365P   *
     Dcb_Constant. Known values are: \"Dcb_30E_360_ISMA\", \"Dcb_30_360\", \"Dcb_30_360_German\",
     \"Dcb_30_360_ISDA\", \"Dcb_30_360_US\", \"Dcb_30_365_Brazil\", \"Dcb_30_365_German\",
     \"Dcb_30_365_ISDA\", \"Dcb_30_Actual\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual_ISDA\",
     \"Dcb_ActualLeapDay_360\", \"Dcb_ActualLeapDay_365\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_36525\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_Actual_365_CanadianConvention\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_AFB\",
     \"Dcb_Actual_Actual_ISDA\", \"Dcb_Constant\", and \"Dcb_WorkingDays_252\"."""
    interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = rest_field(name="interpolationMode")
    """The interpolation method used in zero curve bootstrapping. The possible values are:   *
     CubicDiscount: local cubic interpolation of discount factors   * CubicRate: local cubic
     interpolation of rates   * CubicSpline: a natural cubic spline   * ForwardMonotoneConvex:
     forward Monotone Convexc interpolation   * Linear: linear interpolation   * Log: log-linear
     interpolation   * Hermite: Hermite (Bessel) interpolation   * AkimaMethod: the Akima method (a
     smoother variant of local cubic interpolation)   * FritschButlandMethod: the Fritsch-Butland
     method (a monotonic cubic variant)   * KrugerMethod: the Kruger method (a monotonic cubic
     variant)   * MonotonicCubicNaturalSpline: a monotonic natural cubic spline   *
     MonotonicHermiteCubic: monotonic Hermite (Bessel) cubic interpolation   * TensionSpline: a
     tension spline. Known values are: \"AkimaMethod\", \"CubicDiscount\", \"CubicRate\",
     \"CubicSpline\", \"ForwardMonotoneConvex\", \"FritschButlandMethod\", \"Hermite\",
     \"KrugerMethod\", \"Linear\", \"Log\", \"MonotonicCubicNaturalSpline\",
     \"MonotonicHermiteCubic\", \"Step\", and \"TensionSpline\"."""
    market_data_access_denied_fallback: Optional[Union[str, "_models.MarketDataAccessDeniedFallbackEnum"]] = rest_field(
        name="marketDataAccessDeniedFallback"
    )
    """If at least one constituent access is denied:   * ReturnError: dont price the surface and
     return an error (Default value)   * IgnoreConstituents: price the surface without the error
     market data   * UseDelayedData: use delayed Market Data if possible. Known values are:
     \"IgnoreConstituents\", \"ReturnError\", and \"UseDelayedData\"."""
    market_data_look_back: Optional["_models.MarketDataLookBack"] = rest_field(name="marketDataLookBack")
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """The quoted price side of the instrument to be used for the zero coupon curve construction. The
     possible values are:   * Bid   * Ask   * Mid The default value is &#39;Mid&#39;. Known values
     are: \"Ask\", \"Bid\", \"Last\", and \"Mid\"."""
    reference_tenor: Optional[str] = rest_field(name="referenceTenor")
    """The tenor of the index interest rate curve for which curvePoints are computed (e.g., '3M')."""
    steps: Optional[List["_models.Step"]] = rest_field()
    """The list of attributes used to calculate the swap rate surface discount curve, when OIS is
     selected as discount curve. The steps can specify overnight index stepped dates or/and rates.
     Currencies supporting steps are the following: USD, AUD, BRL, CAD, COP, CZK, EUR, GBP, JPY,
     NZD, PLN, HUF, SEK, CHF, RUB, INR, DKK."""
    turns: Optional[List["_models.Turn"]] = rest_field()
    """The list of attributes used to include end period when calculating swap rate surfaces."""
    use_convexity_adjustment: Optional[bool] = rest_field(name="useConvexityAdjustment")
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")
    use_multi_dimensional_solver: Optional[bool] = rest_field(name="useMultiDimensionalSolver")
    use_stub: Optional[bool] = rest_field(name="useStub")

    @overload
    def __init__(
        self,
        *,
        calendar_adjustment: Optional[Union[str, "_models.CalendarAdjustmentEnum"]] = None,
        calendars: Optional[List[str]] = None,
        compounding_type: Optional[Union[str, "_models.CompoundingTypeEnum"]] = None,
        constant_forward_rate_parameters: Optional["_models.ConstantForwardRateParameters"] = None,
        convexity_adjustment: Optional["_models.CurvesAndSurfacesConvexityAdjustment"] = None,
        extrapolation_mode: Optional[Union[str, "_models.ExtrapolationModeEnum"]] = None,
        interest_calculation_method: Optional[
            Union[str, "_models.CurvesAndSurfacesInterestCalculationMethodEnum"]
        ] = None,
        interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = None,
        market_data_access_denied_fallback: Optional[Union[str, "_models.MarketDataAccessDeniedFallbackEnum"]] = None,
        market_data_look_back: Optional["_models.MarketDataLookBack"] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        reference_tenor: Optional[str] = None,
        steps: Optional[List["_models.Step"]] = None,
        turns: Optional[List["_models.Turn"]] = None,
        use_convexity_adjustment: Optional[bool] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
        use_multi_dimensional_solver: Optional[bool] = None,
        use_stub: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveParametersSegmentDescription(_model_base.Model):  # pylint: disable=name-too-long
    """InterestRateCurveParametersSegmentDescription.

    Attributes
    ----------
    calendar_adjustment : str or ~analyticsapi.models.CalendarAdjustmentEnum
        The cash flow adjustment according to a selected calendar. The possible
        values are:   * No   * Weekend: for the cash flow pricing using the
        calendar &#39;Weekend&#39;   * Calendar: for the cash flow pricing
        using the calendar defined by the parameter &#39;calendars&#39;. The
        default value is &#39;Calendar&#39;. Known values are: "Calendar",
        "No", and "Weekend".
    calendars : list[str]
        The list of comma-separated calendar codes used to define non-working
        days and to adjust interest rate curve coupon dates and values (e.g.,
        &#39;EMU_FI&#39;). By default, the calendar code is derived from the
        interest rate curve currency.  The default value is None, needs to be
        assigned before using.
    compounding_type : str or ~analyticsapi.models.CompoundingTypeEnum
        The yield type of the interest rate curve. The possible values are:   *
        Discounted   * Compounded   * Continuous   * MoneyMarket The default
        value is &#39;Compounded&#39;. Known values are: "Compounded",
        "Continuous", "Discounted", and "MoneyMarket".
    constant_forward_rate_parameters : ~analyticsapi.models.ConstantForwardRateParameters
    extrapolation_mode : str or ~analyticsapi.models.ExtrapolationModeEnum
        The extrapolation method used in the zero coupon curve bootstrapping.
        The possible values are:   * None: no extrapolation,   * Constant:
        constant extrapolation,   * Linear: linear extrapolation,   *
        ConstantRate: extrapolation with constant zero-coupon rate *
        ConstantForwardRate: extrapolation with constant forward rate   *
        UltimateForwardRate: extrapolation with ultimate forward rate The
        default value is 'None'. Known values are: "Constant",
        "ConstantForwardRate", "ConstantRate", "Linear", "None", and
        "UltimateForwardRate".
    interest_calculation_method : str or ~analyticsapi.models.CurvesAndSurfacesInterestCalculationMethodEnum
        The day count basis method used to compute the points of the zero
        coupon curve. The possible values are:   * Dcb_30_360     Actual number
        of days in the coupon period calculated on the basis of a year of 360
        days with twelve 30-day months unless: - the last day of the period is
        the 31st day of a month and the first day of the period is a day other
        than the 30th or 31st day of a month, in which case the month that
        includes the last day shall not be considered to be shortened to a
        30-day month,     - the last day of the period is the last day of the
        month of February, in which case the month of February shall not be
        considered to be lengthened to a 30-day month.   * Dcb_30_Actual
        The day count is identical to 30/360 (US) and the year basis is
        identical to Actual/Actual.   * Dcb_Actual_360     The day count is the
        actual number of days of the period. The year basis is 360.   *
        Dcb_Actual_365 The day count is the actual number of days of the
        period. The year basis is 365.   * Dcb_Actual_Actual     The DCB is
        calculated by Actual days / year basis where:     - Actual days are
        defined as the actual days between the starting date (D1.M1.Y1) and end
        date (D2.M2.Y2).     - Year basis is defined as the actual days between
        the start date (D1.M1.Y1) and the next relevant interest payment date
        (D3.M3.Y3) multiplied by the instrument coupon frequency.   *
        Dcb_Actual_Actual_ISDA     Similar to Actual/365, except for a period
        that includes days falling in a leap year. It is calculated by DCB
        &#x3D; number of days in a leap year/366 + number of days in a non-leap
        year/365.     A convention is also known as Actual/365 ISDA.
        *Dcb_30_360_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if
        D1 is 31, change it to 30,     - if D2 is 31 and D1 is 30, change D2 to
        30.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
        Dcb_30_365_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if
        D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31
        then D2&#x3D;30.     Then the date difference is
        (Y2-Y1)x365+(M2-M1)x30+(D2-D1)   * Dcb_30_360_US For two dates
        (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     -
        if D2&#x3D;31 and D1&#x3D;30 or 31 then D2&#x3D;30,     - if D1 is the
        last day of February then D1&#x3D;30,     - if D1 is the last day of
        February and D2 is the last day of February then D2&#x3D;30.     The
        last day of February is February 29 in leap years and February 28 in
        non leap years.     The 30/360 US rule is identical to 30/360 ISDA when
        the EOM (end-of-month) convention does not apply. This indicates
        whether all coupon payment dates fall on the last day of the month. If
        the investment is not EOM, it will always pay on the same day of the
        month (e.g., the 10th).     Then the date difference is
        (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_Actual_Actual_AFB     The DCB
        is calculated by Actual days / year basis where:     Actual days are
        defined as the actual days between the start date (D1.M1.Y1) and end
        date (D2.M2.Y2). Year basis is either 365 if the calculation period
        does not contain 29th Feb, or 366 if the calculation period includes
        29th Feb.   * Dcb_WorkingDays_252     The day count is the actual
        number of business days of the period according to the instrument
        calendars. The year basis is 252. Commonly used in the Brazilian
        market.   * Dcb_Actual_365L     The day count is the actual number of
        days of the period. The year basis is calculated in the following two
        rules:     - if the coupon frequency is annual, then year basis is 366
        if the 29 Feb. is included in the interest period, else 365,     - if
        the coupon frequency is not annual, then year basis is 366 for each
        interest period where ending date falls in a leap year, otherwise it is
        365.   * Dcb_ActualLeapDay_365     The day count ignores 29th February
        when counting days. The year basis is 365 days.   *
        Dcb_ActualLeapDay_360     The day count ignores 29th February when
        counting days. The year basis is 360 days.   * Dcb_Actual_36525     The
        day count is the actual number of days of the period. The year basis is
        365.25.   * Dcb_Actual_365_CanadianConvention Follows the Canadian
        domestic bond market convention. The day count basis is computed as
        follows:     - if the number of days of a period is less than the
        actual number of days in a regular coupon period the Dcb_Actual_365
        convention is used,     - otherwise: DCB &#x3D; 1 -
        DaysRemainingInPeriod x Frequency / 365.   * Dcb_30_360_German     For
        two dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then
        D1&#x3D;30,     - if D2&#x3D;31 then D2&#x3D;30,     - if D1 is the
        last day of February then D1&#x3D;30,     - if D2 is the last day of
        February then D2&#x3D;30.     The last day of February is February 29
        in leap years and February 28 in non leap years.     Then the date
        difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_30_365_German
        Similar to 30/360 (German), except that the year basis is treated as
        365 days.   * Dcb_30_Actual_German     The day count is identical to
        30/360 (German) and the year basis is similar to Actual/Actual. This
        method was formerly used in the Eurobond markets.   * Dcb_30E_360_ISMA
        Actual number of days in the coupon period calculated on the basis of a
        year of 360 days with twelve 30-day months (regardless of the date of
        the first day or last day of the period).   * Dcb_Actual_364     A
        special case of Actual/Actual (ISMA) when a coupon period contains 91
        or 182 days. Actual/364 applies for some short-term instruments.
        Day count basis &#x3D; 364.   * Dcb_30_Actual_ISDA   *
        Dcb_30_365_Brazil   * Dcb_Actual_365P   * Dcb_Constant. Known values
        are: "Dcb_30E_360_ISMA", "Dcb_30_360", "Dcb_30_360_German",
        "Dcb_30_360_ISDA", "Dcb_30_360_US", "Dcb_30_365_Brazil",
        "Dcb_30_365_German", "Dcb_30_365_ISDA", "Dcb_30_Actual",
        "Dcb_30_Actual_German", "Dcb_30_Actual_ISDA", "Dcb_ActualLeapDay_360",
        "Dcb_ActualLeapDay_365", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_36525", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_Actual_365_CanadianConvention",
        "Dcb_Actual_Actual", "Dcb_Actual_Actual_AFB", "Dcb_Actual_Actual_ISDA",
        "Dcb_Constant", and "Dcb_WorkingDays_252".
    interpolation_mode : str or ~analyticsapi.models.InterpolationModeEnum
        The interpolation method used in zero curve bootstrapping. The possible
        values are:   * CubicDiscount: local cubic interpolation of discount
        factors   * CubicRate: local cubic interpolation of rates   *
        CubicSpline: a natural cubic spline   * ForwardMonotoneConvex: forward
        Monotone Convexc interpolation   * Linear: linear interpolation * Log:
        log-linear interpolation   * Hermite: Hermite (Bessel) interpolation
        * AkimaMethod: the Akima method (a smoother variant of local cubic
        interpolation)   * FritschButlandMethod: the Fritsch-Butland method (a
        monotonic cubic variant)   * KrugerMethod: the Kruger method (a
        monotonic cubic variant)   * MonotonicCubicNaturalSpline: a monotonic
        natural cubic spline   * MonotonicHermiteCubic: monotonic Hermite
        (Bessel) cubic interpolation   * TensionSpline: a tension spline. Known
        values are: "AkimaMethod", "CubicDiscount", "CubicRate", "CubicSpline",
        "ForwardMonotoneConvex", "FritschButlandMethod", "Hermite",
        "KrugerMethod", "Linear", "Log", "MonotonicCubicNaturalSpline",
        "MonotonicHermiteCubic", "Step", and "TensionSpline".
    market_data_access_denied_fallback : str or ~analyticsapi.models.MarketDataAccessDeniedFallbackEnum
        If at least one constituent access is denied:   * ReturnError: dont
        price the surface and return an error (Default value)   *
        IgnoreConstituents: price the surface without the error market data   *
        UseDelayedData: use delayed Market Data if possible. Known values are:
        "IgnoreConstituents", "ReturnError", and "UseDelayedData".
    market_data_look_back : ~analyticsapi.models.MarketDataLookBackDefinition
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        The quoted price side of the instrument to be used for the zero coupon
        curve construction. The possible values are:   * Bid   * Ask   * Mid
        The default value is &#39;Mid&#39;. Known values are: "Ask", "Bid",
        "Last", and "Mid".
    reference_tenor : str
        The tenor of the index interest rate curve for which curvePoints are
        computed (e.g., '3M').
    use_convexity_adjustment : bool
    use_delayed_data_if_denied : bool
    use_multi_dimensional_solver : bool
    use_stub : bool
    """

    calendar_adjustment: Optional[Union[str, "_models.CalendarAdjustmentEnum"]] = rest_field(name="calendarAdjustment")
    """The cash flow adjustment according to a selected calendar. The possible values are:   * No   *
     Weekend: for the cash flow pricing using the calendar &#39;Weekend&#39;   * Calendar: for the
     cash flow pricing using the calendar defined by the parameter &#39;calendars&#39;. The default
     value is &#39;Calendar&#39;. Known values are: \"Calendar\", \"No\", and \"Weekend\"."""
    calendars: Optional[List[str]] = rest_field()
    """The list of comma-separated calendar codes used to define non-working days and to adjust
     interest rate curve coupon dates and values (e.g., &#39;EMU_FI&#39;). By default, the calendar
     code is derived from the interest rate curve currency."""
    compounding_type: Optional[Union[str, "_models.CompoundingTypeEnum"]] = rest_field(name="compoundingType")
    """The yield type of the interest rate curve. The possible values are:   * Discounted   *
     Compounded   * Continuous   * MoneyMarket The default value is &#39;Compounded&#39;. Known
     values are: \"Compounded\", \"Continuous\", \"Discounted\", and \"MoneyMarket\"."""
    constant_forward_rate_parameters: Optional["_models.ConstantForwardRateParameters"] = rest_field(
        name="constantForwardRateParameters"
    )
    extrapolation_mode: Optional[Union[str, "_models.ExtrapolationModeEnum"]] = rest_field(name="extrapolationMode")
    """The extrapolation method used in the zero coupon curve bootstrapping. The possible values are:
     * None: no extrapolation,   * Constant: constant extrapolation,   * Linear: linear
     extrapolation,   * ConstantRate: extrapolation with constant zero-coupon rate   *
     ConstantForwardRate: extrapolation with constant forward rate   * UltimateForwardRate:
     extrapolation with ultimate forward rate The default value is 'None'. Known values are:
     \"Constant\", \"ConstantForwardRate\", \"ConstantRate\", \"Linear\", \"None\", and
     \"UltimateForwardRate\"."""
    interest_calculation_method: Optional[Union[str, "_models.CurvesAndSurfacesInterestCalculationMethodEnum"]] = (
        rest_field(name="interestCalculationMethod")
    )
    """The day count basis method used to compute the points of the zero coupon curve. The possible
     values are:   * Dcb_30_360     Actual number of days in the coupon period calculated on the
     basis of a year of 360 days with twelve 30-day months unless:     - the last day of the period
     is the 31st day of a month and the first day of the period is a day other than the 30th or 31st
     day of a month, in which case the month that includes the last day shall not be considered to
     be shortened to a 30-day month,     - the last day of the period is the last day of the month
     of February, in which case the month of February shall not be considered to be lengthened to a
     30-day month.   * Dcb_30_Actual     The day count is identical to 30/360 (US) and the year
     basis is identical to Actual/Actual.   * Dcb_Actual_360     The day count is the actual number
     of days of the period. The year basis is 360.   * Dcb_Actual_365     The day count is the
     actual number of days of the period. The year basis is 365.   * Dcb_Actual_Actual     The DCB
     is calculated by Actual days / year basis where:     - Actual days are defined as the actual
     days between the starting date (D1.M1.Y1) and end date (D2.M2.Y2).     - Year basis is defined
     as the actual days between the start date (D1.M1.Y1) and the next relevant interest payment
     date (D3.M3.Y3) multiplied by the instrument coupon frequency.   * Dcb_Actual_Actual_ISDA
     Similar to Actual/365, except for a period that includes days falling in a leap year. It is
     calculated by DCB &#x3D; number of days in a leap year/366 + number of days in a non-leap
     year/365.     A convention is also known as Actual/365 ISDA.   *Dcb_30_360_ISDA     For two
     dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1 is 31, change it to 30,     - if D2 is 31 and D1
     is 30, change D2 to 30.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
     Dcb_30_365_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then
     D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31 then D2&#x3D;30.     Then the date
     difference is (Y2-Y1)x365+(M2-M1)x30+(D2-D1)   * Dcb_30_360_US     For two dates (Y1,M1,D1) and
     (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31 then
     D2&#x3D;30,     - if D1 is the last day of February then D1&#x3D;30,     - if D1 is the last
     day of February and D2 is the last day of February then D2&#x3D;30.     The last day of
     February is February 29 in leap years and February 28 in non leap years.     The 30/360 US rule
     is identical to 30/360 ISDA when the EOM (end-of-month) convention does not apply. This
     indicates whether all coupon payment dates fall on the last day of the month. If the investment
     is not EOM, it will always pay on the same day of the month (e.g., the 10th).     Then the date
     difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_Actual_Actual_AFB     The DCB is
     calculated by Actual days / year basis where:     Actual days are defined as the actual days
     between the start date (D1.M1.Y1) and end date (D2.M2.Y2).     Year basis is either 365 if the
     calculation period does not contain 29th Feb, or 366 if the calculation period includes 29th
     Feb.   * Dcb_WorkingDays_252     The day count is the actual number of business days of the
     period according to the instrument calendars. The year basis is 252. Commonly used in the
     Brazilian market.   * Dcb_Actual_365L     The day count is the actual number of days of the
     period. The year basis is calculated in the following two rules:     - if the coupon frequency
     is annual, then year basis is 366 if the 29 Feb. is included in the interest period, else 365,
     - if the coupon frequency is not annual, then year basis is 366 for each interest period where
     ending date falls in a leap year, otherwise it is 365.   * Dcb_ActualLeapDay_365     The day
     count ignores 29th February when counting days. The year basis is 365 days.   *
     Dcb_ActualLeapDay_360     The day count ignores 29th February when counting days. The year
     basis is 360 days.   * Dcb_Actual_36525     The day count is the actual number of days of the
     period. The year basis is 365.25.   * Dcb_Actual_365_CanadianConvention     Follows the
     Canadian domestic bond market convention. The day count basis is computed as follows:     - if
     the number of days of a period is less than the actual number of days in a regular coupon
     period the Dcb_Actual_365 convention is used,     - otherwise: DCB &#x3D; 1 -
     DaysRemainingInPeriod x Frequency / 365.   * Dcb_30_360_German     For two dates (Y1,M1,D1) and
     (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 then D2&#x3D;30,     - if
     D1 is the last day of February then D1&#x3D;30,     - if D2 is the last day of February then
     D2&#x3D;30.     The last day of February is February 29 in leap years and February 28 in non
     leap years.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
     Dcb_30_365_German     Similar to 30/360 (German), except that the year basis is treated as 365
     days.   * Dcb_30_Actual_German     The day count is identical to 30/360 (German) and the year
     basis is similar to Actual/Actual. This method was formerly used in the Eurobond markets.   *
     Dcb_30E_360_ISMA     Actual number of days in the coupon period calculated on the basis of a
     year of 360 days with twelve 30-day months (regardless of the date of the first day or last day
     of the period).   * Dcb_Actual_364     A special case of Actual/Actual (ISMA) when a coupon
     period contains 91 or 182 days. Actual/364 applies for some short-term instruments.     Day
     count basis &#x3D; 364.   * Dcb_30_Actual_ISDA   * Dcb_30_365_Brazil   * Dcb_Actual_365P   *
     Dcb_Constant. Known values are: \"Dcb_30E_360_ISMA\", \"Dcb_30_360\", \"Dcb_30_360_German\",
     \"Dcb_30_360_ISDA\", \"Dcb_30_360_US\", \"Dcb_30_365_Brazil\", \"Dcb_30_365_German\",
     \"Dcb_30_365_ISDA\", \"Dcb_30_Actual\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual_ISDA\",
     \"Dcb_ActualLeapDay_360\", \"Dcb_ActualLeapDay_365\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_36525\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_Actual_365_CanadianConvention\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_AFB\",
     \"Dcb_Actual_Actual_ISDA\", \"Dcb_Constant\", and \"Dcb_WorkingDays_252\"."""
    interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = rest_field(name="interpolationMode")
    """The interpolation method used in zero curve bootstrapping. The possible values are:   *
     CubicDiscount: local cubic interpolation of discount factors   * CubicRate: local cubic
     interpolation of rates   * CubicSpline: a natural cubic spline   * ForwardMonotoneConvex:
     forward Monotone Convexc interpolation   * Linear: linear interpolation   * Log: log-linear
     interpolation   * Hermite: Hermite (Bessel) interpolation   * AkimaMethod: the Akima method (a
     smoother variant of local cubic interpolation)   * FritschButlandMethod: the Fritsch-Butland
     method (a monotonic cubic variant)   * KrugerMethod: the Kruger method (a monotonic cubic
     variant)   * MonotonicCubicNaturalSpline: a monotonic natural cubic spline   *
     MonotonicHermiteCubic: monotonic Hermite (Bessel) cubic interpolation   * TensionSpline: a
     tension spline. Known values are: \"AkimaMethod\", \"CubicDiscount\", \"CubicRate\",
     \"CubicSpline\", \"ForwardMonotoneConvex\", \"FritschButlandMethod\", \"Hermite\",
     \"KrugerMethod\", \"Linear\", \"Log\", \"MonotonicCubicNaturalSpline\",
     \"MonotonicHermiteCubic\", \"Step\", and \"TensionSpline\"."""
    market_data_access_denied_fallback: Optional[Union[str, "_models.MarketDataAccessDeniedFallbackEnum"]] = rest_field(
        name="marketDataAccessDeniedFallback"
    )
    """If at least one constituent access is denied:   * ReturnError: dont price the surface and
     return an error (Default value)   * IgnoreConstituents: price the surface without the error
     market data   * UseDelayedData: use delayed Market Data if possible. Known values are:
     \"IgnoreConstituents\", \"ReturnError\", and \"UseDelayedData\"."""
    market_data_look_back: Optional["_models.MarketDataLookBackDefinition"] = rest_field(name="marketDataLookBack")
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """The quoted price side of the instrument to be used for the zero coupon curve construction. The
     possible values are:   * Bid   * Ask   * Mid The default value is &#39;Mid&#39;. Known values
     are: \"Ask\", \"Bid\", \"Last\", and \"Mid\"."""
    reference_tenor: Optional[str] = rest_field(name="referenceTenor")
    """The tenor of the index interest rate curve for which curvePoints are computed (e.g., '3M')."""
    use_convexity_adjustment: Optional[bool] = rest_field(name="useConvexityAdjustment")
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")
    use_multi_dimensional_solver: Optional[bool] = rest_field(name="useMultiDimensionalSolver")
    use_stub: Optional[bool] = rest_field(name="useStub")

    @overload
    def __init__(
        self,
        *,
        calendar_adjustment: Optional[Union[str, "_models.CalendarAdjustmentEnum"]] = None,
        calendars: Optional[List[str]] = None,
        compounding_type: Optional[Union[str, "_models.CompoundingTypeEnum"]] = None,
        constant_forward_rate_parameters: Optional["_models.ConstantForwardRateParameters"] = None,
        extrapolation_mode: Optional[Union[str, "_models.ExtrapolationModeEnum"]] = None,
        interest_calculation_method: Optional[
            Union[str, "_models.CurvesAndSurfacesInterestCalculationMethodEnum"]
        ] = None,
        interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = None,
        market_data_access_denied_fallback: Optional[Union[str, "_models.MarketDataAccessDeniedFallbackEnum"]] = None,
        market_data_look_back: Optional["_models.MarketDataLookBackDefinition"] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        reference_tenor: Optional[str] = None,
        use_convexity_adjustment: Optional[bool] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
        use_multi_dimensional_solver: Optional[bool] = None,
        use_stub: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateCurveResponse(_model_base.Model):
    """A model template describing a single response.

    Attributes
    ----------
    data : ~analyticsapi.models.InterestRateCurve
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.InterestRateCurve" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.InterestRateCurve",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateInstrument(_model_base.Model):
    """InterestRateInstrument.

    Attributes
    ----------
    basis : list[str]
        The code indicating the rate surface slice for which the instrument is
        used. If no basis defined, the instrument could be used for all slices.
        The default value is None, needs to be assigned before using.
    fields : ~analyticsapi.models.CurvesAndSurfacesBidAskFields
    formula : str
        The formula used to adjust market data values of the instrument's Bid
        and Ask price side. For example, '100-marketPrice'.
    formula_parameters : list[~analyticsapi.models.FormulaParameter]
        The list of formula parameters used to adjust market data values of the
        instrument's Bid and Ask price side.  The default value is None, needs
        to be assigned before using.
    instrument_definition : ~analyticsapi.models.InstrumentDefinition
    """

    basis: Optional[List[str]] = rest_field()
    """The code indicating the rate surface slice for which the instrument is used. If no basis
     defined, the instrument could be used for all slices."""
    fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """The formula used to adjust market data values of the instrument's Bid and Ask price side. For
     example, '100-marketPrice'."""
    formula_parameters: Optional[List["_models.FormulaParameter"]] = rest_field(name="formulaParameters")
    """The list of formula parameters used to adjust market data values of the instrument's Bid and
     Ask price side."""
    instrument_definition: Optional["_models.InstrumentDefinition"] = rest_field(name="instrumentDefinition")

    @overload
    def __init__(
        self,
        *,
        basis: Optional[List[str]] = None,
        fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameter"]] = None,
        instrument_definition: Optional["_models.InstrumentDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateInstrumentOutput(_model_base.Model):
    """InterestRateInstrumentOutput.

    Attributes
    ----------
    basis : list[str]
        Get basis.  The default value is None, needs to be assigned before
        using.
    fields : ~analyticsapi.models.BidAskFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.InstrumentDefinitionOutput
    status_message : str
        Get statusMessage.
    """

    basis: Optional[List[str]] = rest_field()
    """Get basis."""
    fields: Optional["_models.BidAskFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.InstrumentDefinitionOutput"] = rest_field(name="instrumentDefinition")
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""

    @overload
    def __init__(
        self,
        *,
        basis: Optional[List[str]] = None,
        fields: Optional["_models.BidAskFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.InstrumentDefinitionOutput"] = None,
        status_message: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateInstruments(_model_base.Model):
    """InterestRateInstruments.

    Attributes
    ----------
    deposits : list[~analyticsapi.models.StubBasisInterestRateInstrument]
        The list of attributes for Deposit contract used as constituents to
        generate the zero coupon curve.  The default value is None, needs to be
        assigned before using.
    fras : list[~analyticsapi.models.StubBasisInterestRateInstrument]
        The list of attributes for FRA contract used as constituents to
        generate the zero coupon curve.  The default value is None, needs to be
        assigned before using.
    futures : list[~analyticsapi.models.BasisInstrumentFutures]
        The list of attributes for Futures contract used as constituents to
        generate the zero coupon curve.  The default value is None, needs to be
        assigned before using.
    interest_rate_swaps : list[~analyticsapi.models.InterestRateInstrument]
        The list of attributes for Interest Rate Swap contract used as
        constituents to generate the zero coupon curve.  The default value is
        None, needs to be assigned before using.
    overnight_index_swaps : list[~analyticsapi.models.InterestRateInstrument]
        The list of attributes for Overnight Index Swap contract used as
        constituents to generate the zero coupon curve.  The default value is
        None, needs to be assigned before using.
    sources : ~analyticsapi.models.InterestRateInstrumentsSources
    tenor_basis_swaps : list[~analyticsapi.models.InterestRateInstrument]
        The list of attributes for Tenor Basis Swap contract used as
        constituents to generate the zero coupon curve.  The default value is
        None, needs to be assigned before using.
    """

    deposits: Optional[List["_models.StubBasisInterestRateInstrument"]] = rest_field()
    """The list of attributes for Deposit contract used as constituents to generate the zero coupon
     curve."""
    fras: Optional[List["_models.StubBasisInterestRateInstrument"]] = rest_field()
    """The list of attributes for FRA contract used as constituents to generate the zero coupon curve."""
    futures: Optional[List["_models.BasisInstrumentFutures"]] = rest_field()
    """The list of attributes for Futures contract used as constituents to generate the zero coupon
     curve."""
    interest_rate_swaps: Optional[List["_models.InterestRateInstrument"]] = rest_field(name="interestRateSwaps")
    """The list of attributes for Interest Rate Swap contract used as constituents to generate the
     zero coupon curve."""
    overnight_index_swaps: Optional[List["_models.InterestRateInstrument"]] = rest_field(name="overnightIndexSwaps")
    """The list of attributes for Overnight Index Swap contract used as constituents to generate the
     zero coupon curve."""
    sources: Optional["_models.InterestRateInstrumentsSources"] = rest_field()
    tenor_basis_swaps: Optional[List["_models.InterestRateInstrument"]] = rest_field(name="tenorBasisSwaps")
    """The list of attributes for Tenor Basis Swap contract used as constituents to generate the zero
     coupon curve."""

    @overload
    def __init__(
        self,
        *,
        deposits: Optional[List["_models.StubBasisInterestRateInstrument"]] = None,
        fras: Optional[List["_models.StubBasisInterestRateInstrument"]] = None,
        futures: Optional[List["_models.BasisInstrumentFutures"]] = None,
        interest_rate_swaps: Optional[List["_models.InterestRateInstrument"]] = None,
        overnight_index_swaps: Optional[List["_models.InterestRateInstrument"]] = None,
        sources: Optional["_models.InterestRateInstrumentsSources"] = None,
        tenor_basis_swaps: Optional[List["_models.InterestRateInstrument"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateInstrumentsOutput(_model_base.Model):
    """InterestRateInstrumentsOutput.

    Attributes
    ----------
    deposits : list[~analyticsapi.models.StubBasisInterestRateInstrumentOutput]
        Get deposits.  The default value is None, needs to be assigned before
        using.
    fras : list[~analyticsapi.models.StubBasisInterestRateInstrumentOutput]
        Get fras.  The default value is None, needs to be assigned before
        using.
    futures : list[~analyticsapi.models.BasisInstrumentFuturesOutput]
        Get futures.  The default value is None, needs to be assigned before
        using.
    interest_rate_swaps : list[~analyticsapi.models.InterestRateInstrumentOutput]
        Get interestRateSwaps.  The default value is None, needs to be assigned
        before using.
    overnight_index_swaps : list[~analyticsapi.models.InterestRateInstrumentOutput]
        Get overnightIndexSwaps.  The default value is None, needs to be
        assigned before using.
    tenor_basis_swaps : list[~analyticsapi.models.InterestRateInstrumentOutput]
        Get tenorBasisSwaps.  The default value is None, needs to be assigned
        before using.
    """

    deposits: Optional[List["_models.StubBasisInterestRateInstrumentOutput"]] = rest_field()
    """Get deposits."""
    fras: Optional[List["_models.StubBasisInterestRateInstrumentOutput"]] = rest_field()
    """Get fras."""
    futures: Optional[List["_models.BasisInstrumentFuturesOutput"]] = rest_field()
    """Get futures."""
    interest_rate_swaps: Optional[List["_models.InterestRateInstrumentOutput"]] = rest_field(name="interestRateSwaps")
    """Get interestRateSwaps."""
    overnight_index_swaps: Optional[List["_models.InterestRateInstrumentOutput"]] = rest_field(
        name="overnightIndexSwaps"
    )
    """Get overnightIndexSwaps."""
    tenor_basis_swaps: Optional[List["_models.InterestRateInstrumentOutput"]] = rest_field(name="tenorBasisSwaps")
    """Get tenorBasisSwaps."""

    @overload
    def __init__(
        self,
        *,
        deposits: Optional[List["_models.StubBasisInterestRateInstrumentOutput"]] = None,
        fras: Optional[List["_models.StubBasisInterestRateInstrumentOutput"]] = None,
        futures: Optional[List["_models.BasisInstrumentFuturesOutput"]] = None,
        interest_rate_swaps: Optional[List["_models.InterestRateInstrumentOutput"]] = None,
        overnight_index_swaps: Optional[List["_models.InterestRateInstrumentOutput"]] = None,
        tenor_basis_swaps: Optional[List["_models.InterestRateInstrumentOutput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateInstrumentsSegment(_model_base.Model):
    """InterestRateInstrumentsSegment.

    Attributes
    ----------
    available_discounting_tenors : list[str]
        Get availableDiscountingTenors.  The default value is None, needs to be
        assigned before using.
    available_tenors : list[str]
        Get availableTenors.  The default value is None, needs to be assigned
        before using.
    constituents : ~analyticsapi.models.InterestRateConstituentsDescription
    curve_parameters : ~analyticsapi.models.InterestRateCurveParametersSegmentDescription
    start_date : ~datetime.date
        Get startDate.
    """

    available_discounting_tenors: Optional[List[str]] = rest_field(name="availableDiscountingTenors")
    """Get availableDiscountingTenors."""
    available_tenors: Optional[List[str]] = rest_field(name="availableTenors")
    """Get availableTenors."""
    constituents: Optional["_models.InterestRateConstituentsDescription"] = rest_field()
    curve_parameters: Optional["_models.InterestRateCurveParametersSegmentDescription"] = rest_field(
        name="curveParameters"
    )
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """Get startDate."""

    @overload
    def __init__(
        self,
        *,
        available_discounting_tenors: Optional[List[str]] = None,
        available_tenors: Optional[List[str]] = None,
        constituents: Optional["_models.InterestRateConstituentsDescription"] = None,
        curve_parameters: Optional["_models.InterestRateCurveParametersSegmentDescription"] = None,
        start_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateInstrumentsSources(_model_base.Model):
    """InterestRateInstrumentsSources.

    Attributes
    ----------
    deposit : ~analyticsapi.models.DepositInstrumentsSource
    """

    deposit: Optional["_models.DepositInstrumentsSource"] = rest_field()

    @overload
    def __init__(
        self,
        deposit: Optional["_models.DepositInstrumentsSource"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["deposit"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class InterestRateLegDefinition(_model_base.Model):
    """An object that defines a leg of an interest rate instrument.

    Attributes
    ----------
    rate : ~analyticsapi.models.InterestRateDefinition
        An object that defines the interest rate settings. Required.
    interest_periods : ~analyticsapi.models.ScheduleDefinition
        An object that defines the schedule of interest periods. Required.
    payment_offset : ~analyticsapi.models.OffsetDefinition
        An object that defines how the payment dates are derived from the
        interest period dates.
    coupon_day_count : str or ~analyticsapi.models.DayCountBasis
        The day count basis method that defines how the year fraction of the
        coupon period is computed. If not defined, the market convention
        related to the leg currency applies. Known values are: "Dcb_30_360",
        "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
        "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
        "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
        "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA",
        "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", and "Dcb_Actual_365_CanadianConvention".
    accrual_day_count : str or ~analyticsapi.models.DayCountBasis
        The day count basis method that defines how the year fraction of the
        accrual period is computed. If not defined, the market convention
        related to the leg currency applies. Known values are: "Dcb_30_360",
        "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
        "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
        "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
        "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA",
        "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", and "Dcb_Actual_365_CanadianConvention".
    principal : ~analyticsapi.models.PrincipalDefinition
        An object that defines the principal used to calculate interest
        payments. It can also be exchanged between parties. Required.
    settlement : ~analyticsapi.models.PaymentSettlementDefinition
        Settlement parameters for interest payments. If not specified, payments
        are settled in 'principal' currency. Required when 'isNonDeliverable'
        property is activated, to define the settlement currency and related
        details.
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that makes the payment. Required. Known
        values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that receives the payment. Required. Known
        values are: "Party1" and "Party2".
    """

    rate: "_models.InterestRateDefinition" = rest_field()
    """An object that defines the interest rate settings. Required."""
    interest_periods: "_models.ScheduleDefinition" = rest_field(name="interestPeriods")
    """An object that defines the schedule of interest periods. Required."""
    payment_offset: Optional["_models.OffsetDefinition"] = rest_field(name="paymentOffset")
    """An object that defines how the payment dates are derived from the interest period dates."""
    coupon_day_count: Optional[Union[str, "_models.DayCountBasis"]] = rest_field(name="couponDayCount")
    """The day count basis method that defines how the year fraction of the coupon period is computed.
     If not defined, the market convention related to the leg currency applies. Known values are:
     \"Dcb_30_360\", \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\",
     \"Dcb_30_365_ISDA\", \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\",
     \"Dcb_30_Actual\", \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\",
     \"Dcb_Actual_364\", \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\", and
     \"Dcb_Actual_365_CanadianConvention\"."""
    accrual_day_count: Optional[Union[str, "_models.DayCountBasis"]] = rest_field(name="accrualDayCount")
    """The day count basis method that defines how the year fraction of the accrual period is
     computed. If not defined, the market convention related to the leg currency applies. Known
     values are: \"Dcb_30_360\", \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\",
     \"Dcb_30_365_ISDA\", \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\",
     \"Dcb_30_Actual\", \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\",
     \"Dcb_Actual_364\", \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\", and
     \"Dcb_Actual_365_CanadianConvention\"."""
    principal: "_models.PrincipalDefinition" = rest_field()
    """An object that defines the principal used to calculate interest payments. It can also be
     exchanged between parties. Required."""
    settlement: Optional["_models.PaymentSettlementDefinition"] = rest_field()
    """Settlement parameters for interest payments. If not specified, payments are settled in
     'principal' currency. Required when 'isNonDeliverable' property is activated, to define the
     settlement currency and related details."""
    payer: Union[str, "_models.PartyEnum"] = rest_field()
    """The party (Party1 or Party2) that makes the payment. Required. Known values are: \"Party1\" and
     \"Party2\"."""
    receiver: Union[str, "_models.PartyEnum"] = rest_field()
    """The party (Party1 or Party2) that receives the payment. Required. Known values are: \"Party1\"
     and \"Party2\"."""

    @overload
    def __init__(
        self,
        *,
        rate: "_models.InterestRateDefinition",
        interest_periods: "_models.ScheduleDefinition",
        principal: "_models.PrincipalDefinition",
        payer: Union[str, "_models.PartyEnum"],
        receiver: Union[str, "_models.PartyEnum"],
        payment_offset: Optional["_models.OffsetDefinition"] = None,
        coupon_day_count: Optional[Union[str, "_models.DayCountBasis"]] = None,
        accrual_day_count: Optional[Union[str, "_models.DayCountBasis"]] = None,
        settlement: Optional["_models.PaymentSettlementDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateLegTemplateDefinition(InstrumentTemplateDefinition, discriminator="InterestRateLeg"):
    """InterestRateLegTemplateDefinition.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.INTEREST_RATE_LEG
        Required. An interest rate leg.
    template : ~analyticsapi.models.InterestRateLegDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.INTEREST_RATE_LEG] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. An interest rate leg."""
    template: "_models.InterestRateLegDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.InterestRateLegDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.INTEREST_RATE_LEG, **kwargs)


class InterestRateScheduleItem(_model_base.Model):
    """InterestRateScheduleItem.

    Attributes
    ----------
    end_date : ~datetime.datetime
    pay_date : ~datetime.datetime
    start_date : ~datetime.datetime
    """

    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    pay_date: Optional[datetime.datetime] = rest_field(name="payDate", format="rfc3339")
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")

    @overload
    def __init__(
        self,
        *,
        end_date: Optional[datetime.datetime] = None,
        pay_date: Optional[datetime.datetime] = None,
        start_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateSwapConstituent(IrConstituent, discriminator="InterestRateSwap"):
    """An object defining an interest rate swap constituent of an interest rate curve.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    index : str
        This is the reference Index of the curve that the constituent
        contributes to. For instance (e.g. LIBOR 3M). Required.
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
        Required.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.INTEREST_RATE_SWAP
        The type of constituent. InterestRateSwap is the only valid value.
        Required.
    definition : ~analyticsapi.models.InterestRateSwapConstituentDefinition
        An object to define the Interest Rate Swap used as a constituent.
        Required.
    """

    type: Literal[IrConstituentEnum.INTEREST_RATE_SWAP] = rest_discriminator(name="type")  # type: ignore
    """The type of constituent. InterestRateSwap is the only valid value. Required."""
    definition: "_models.InterestRateSwapConstituentDefinition" = rest_field()
    """An object to define the Interest Rate Swap used as a constituent. Required."""

    @overload
    def __init__(
        self,
        *,
        index: str,
        quote: "_models.Quote",
        definition: "_models.InterestRateSwapConstituentDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=IrConstituentEnum.INTEREST_RATE_SWAP, **kwargs)


class InterestRateSwapConstituentDefinition(_model_base.Model):
    """The definition of an interest rate swap instrument used as a constituent of an interest rate
    curve.

    Attributes
    ----------
    tenor : str
        The code indicating the tenor of the instrument used as a constituent
        (e.g., '1M', '1Y'). Required.
    template : str
        A pre-defined template can be used as an input by the user. It is the
        currency code of the constituent. Required.
    """

    tenor: str = rest_field()
    """The code indicating the tenor of the instrument used as a constituent (e.g., '1M', '1Y').
     Required."""
    template: str = rest_field()
    """A pre-defined template can be used as an input by the user. It is the currency code of the
     constituent. Required."""

    @overload
    def __init__(
        self,
        *,
        tenor: str,
        template: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterestRateSwapTemplateDefinition(InstrumentTemplateDefinition, discriminator="VanillaSwap"):
    """InterestRateSwapTemplateDefinition.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.VANILLA_SWAP
        Required. A vanilla interest rate swap contract.
    template : ~analyticsapi.models.IrSwapDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.VANILLA_SWAP] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. A vanilla interest rate swap contract."""
    template: "_models.IrSwapDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.IrSwapDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.VANILLA_SWAP, **kwargs)


class InterpolationTypeAndVector(_model_base.Model):
    """InterpolationTypeAndVector.

    Attributes
    ----------
    interpolation_type : str
        Default value is "LINEAR".
    vector : list[~analyticsapi.models.TermAndValue]
        The default value is None, needs to be assigned before using.
    """

    interpolation_type: Optional[Literal["LINEAR"]] = rest_field(name="interpolationType")
    """Default value is \"LINEAR\"."""
    vector: Optional[List["_models.TermAndValue"]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        interpolation_type: Optional[Literal["LINEAR"]] = None,
        vector: Optional[List["_models.TermAndValue"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class InterpolationWeight(_model_base.Model):
    """InterpolationWeight.

    Attributes
    ----------
    days_list : list[~analyticsapi.models.DayWeight]
        The default value is None, needs to be assigned before using.
    holidays : float
    week_days : float
    week_ends : float
    """

    days_list: Optional[List["_models.DayWeight"]] = rest_field(name="daysList")
    holidays: Optional[float] = rest_field()
    week_days: Optional[float] = rest_field(name="weekDays")
    week_ends: Optional[float] = rest_field(name="weekEnds")

    @overload
    def __init__(
        self,
        *,
        days_list: Optional[List["_models.DayWeight"]] = None,
        holidays: Optional[float] = None,
        week_days: Optional[float] = None,
        week_ends: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IPACapFloorDefinition(_model_base.Model):
    """IPACapFloorDefinition.

    Attributes
    ----------
    adjust_interest_to_payment_date : str or ~analyticsapi.models.AdjustInterestToPaymentDateEnum
        An indication if the coupon dates are adjusted to the payment dates.
        The possible values are: Adjusted, Unadjusted. Optional. The default
        value is 'Unadjusted'. Known values are: "Unadjusted" and "Adjusted".
    amortization_schedule : list[~analyticsapi.models.AmortizationItemDefinition]
        The amortization schedule of the instrument. It contains the following
        information: startDate, endDate, remainingNotional,
        amortizationFrequency, amount, amortizationType. No default value
        applies.  The default value is None, needs to be assigned before using.
    annualized_rebate : bool
        An indicator if the rebate is adjusted according to the frequency of
        the cap. For example, if the frequency of the cap is quarterly (FRQ:4),
        all rebates are divided by four (approximately). The possible values
        are: True: the rebates are adjusted, False: there is no rebate
        adjustment(the rebate value is assumed to be annualized). The default
        value is 'False'.
    barrier_definition : ~analyticsapi.models.BarrierDefinitionElement
    buy_sell : str or ~analyticsapi.models.IPABuySellEnum
        The indicator of the deal side. The possible values are: Buy: buying
        the option, Sell: selling/writing the option. Mandatory. No default
        value applies. Known values are: "Buy" and "Sell".
    cap_digital_payout_percent : float
        A percentage of notionalAmount that is received (paid) by the option
        buyer (seller) if the option expires on or above the cap strike. No
        default value applies.
    cap_strike_percent : float
        The contractual strike rate of the cap. The value is expressed in
        percentages. Note: If instrumentType is set to 'CapFloor', either
        capStrikePercent or capStrikePercentSchedule must be provided. The
        default value equals to AtmStrikePercent.
    cms_template : str
        A reference to a common swap contract that represents the underlying
        swap in case of a Constant Maturity Swap contract (CMS). Example:
        EUR_AB6E. No default value applies.
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.
        2021-01-01T00:00:00Z). Either tenor or endDate must be provided. The
        default value is valuationDate shifted forward by tenor.
    first_regular_payment_date : ~datetime.datetime
        The first regular interest payment date used for the odd first interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z). No default value
        applies.
    floor_digital_payout_percent : float
        A percentage of notionalAmount that is received (paid) by the option
        buyer (seller) if the option expires on or below the floor strike. No
        default value applies.
    floor_strike_percent : float
        The contractual strike rate of the floor. The value is expressed in
        percentages. Note: If instrumentType is set to 'CapFloor', either
        FloorStrikePercent or FloorStrikePercentSchedule must be provided. The
        default value equals to AtmStrikePercent.
    index_fixing_lag : int
        The number of working days between the fixing date of the index and the
        start of the interest accrual period ('InAdvance') or the end of the
        interest accrual period ('InArrears'). The 'InAdvance' or 'InArrears'
        mode is set in the indexResetType parameter. Optional. If
        indexFixingRic or indexName is defined, the associated fixing lag is
        selected. Otherwise, the value is based on the first fixing that
        matches currency and indexTenor.
    index_fixing_ric : str
        The RIC that carries the fixing value if the instrument has a floating
        interest. Optional. No default value applies.
    index_name : str
        The name of the floating rate index (e.g. 'EURIBOR'). Optional. No
        default value applies.
    index_observation_method : str or ~analyticsapi.models.IPAIndexObservationMethodEnum
        (RFR) Method for determining the accrual observation period. The lag is
        defined using the indexFixingLag property. The possible values are:
        Lookback: use the interest period for both rate accrual and interest
        payment. PeriodShift: use the observation period for both rate accrual
        and interest payment. Mixed: use the observation period for rate
        accrual and the interest period for interest payment. Optional. No
        default value applies. Known values are: "Lookback", "PeriodShift", and
        "Mixed".
    index_price_side : str or ~analyticsapi.models.IndexPriceSideEnum
        The quoted price side of the floating rate index that applies to legs
        or the instrument. The possible values are: Bid, Ask, Mid. This
        property applies only if an index is quoted with a 'Bid'/'Ask' price
        side. The default value is 'Mid'. Known values are: "Mid", "Bid",
        "Ask", and "Last".
    index_reset_frequency : str or ~analyticsapi.models.IndexResetFrequencyEnum
        The reset frequency for the floating instrument. Optional. By default,
        the reset frequency associated to  the index defined for the floating
        leg is used. Known values are: "Annual", "SemiAnnual", "Quarterly",
        "Monthly", "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every91Days",
        "Every182Days", "Every364Days", "Every365Days", "Every90Days",
        "Every92Days", "Every93Days", "Every180Days", "Every183Days",
        "Every184Days", "Every4Months", "R2", "R4", "Zero", and "Scheduled".
    index_reset_type : str or ~analyticsapi.models.IndexResetTypeEnum
        The reset type indicating if the floating rate index is reset before
        the coupon period starts or at the end of the coupon period. The
        possible values are:

        * InAdvance: resets the index before the start of the interest period,
        * InArrears: resets the index at the end of the interest period.

        Optional. The default value is 'InAdvance'. For RFR index, the default value is 'InArrears'.
        Known values are: "InAdvance" and "InArrears".
    index_source : str
    index_tenor : str
        The period code indicating the tenor of the underlying floating rate
        index (e.g., '1M', '1Y'). The requested tenor must exist in the
        multicurve environment which is used. The 'InAdvance' or 'InArrears'
        mode is set in the indexResetType parameter. If indexFixingRic or
        indexName is defined, the associate fixing lag is selected. Otherwise,
        the default value is the tenor equivalent to indexResetFrequency or
        interestPaymentFrequency.
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported. Optional. No default value applies.
    interest_calculation_convention : str or ~analyticsapi.models.InterestCalculationConventionEnum
        The convention applied to calculate the interest payments. The possible
        values are:

        * None,
        * MoneyMarket: money market methods calculate all cash flow based on the actual number of days
        in the payment period,
        * BondBasis: bond methods calculate interest payments proportionally to the payment frequency
        and adjust them if the number of days in the payment period is larger or smaller.

        Optional. Default value is 'MoneyMarket'. Known values are: "None", "MoneyMarket", and
        "BondBasis".
    interest_calculation_method : str or ~analyticsapi.models.InterestCalculationMethodEnum
        The day count basis method used to calculate the interest payments. The
        default value is selected based on notionalCcy. Known values are:
        "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
        "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
        "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
        "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA",
        "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", "Dcb_Actual_365_CanadianConvention", and
        "Dcb_Constant".
    interest_payment_frequency : str or ~analyticsapi.models.InterestPaymentFrequencyEnum
        The interest payment frequency. By default, indexTenor is used, if it
        is defined. Otherwise, the default value is indexResetFrequency. Known
        values are: "Annual", "SemiAnnual", "Quarterly", "Monthly",
        "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every91Days",
        "Every182Days", "Every364Days", "Every365Days", "Every90Days",
        "Every92Days", "Every93Days", "Every180Days", "Every183Days",
        "Every184Days", "Every4Months", "R2", "R4", "Zero", and "Scheduled".
    is_backward_looking_index : bool
        An indicator if the underlying fixing rate is backward-looking (Mostly
        Risk-Free-Rate). The possible values are:

        * True: the underlying fixing rate is backward-looking. For backward looking caps/floors the
        rate is accreted up to the end of the caplet period.
        * False: the underlying fixing rate is forward-looking and the rate of each caplet is fixed at
        the start of the caplet period.

        The default value is 'False'.
    last_regular_payment_date : ~datetime.datetime
        The last regular interest payment date used for the odd last interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z). No default value
        applies.
    notional_amount : float
        The notional amount of the instrument. Optional. The default value is
        '1,000,000' in notionalCcy.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g. 'USD'). No default
        value applies.
    payment_business_day_convention : str or ~analyticsapi.models.PaymentBusinessDayConventionEnum
        The method to adjust dates to working days. The possible values are:
        PreviousBusinessDay, NextBusinessDay, Modified following, NoMoving,
        BSWModifiedFollowing. Optional. The default value is
        'ModifiedFollowing'. Known values are: "ModifiedFollowing",
        "NextBusinessDay", "PreviousBusinessDay", "NoMoving",
        "EveryThirdWednesday", and "BbswModifiedFollowing".
    payment_business_days : str
        A list of comma-separated calendar codes to adjust dates (e.g. 'EMU' or
        'USA'). No default value applies.
    payment_roll_convention : str or ~analyticsapi.models.PaymentRollConventionEnum
        The method to adjust payment dates when they fall at the end of the
        month (e.g. 28th of February, 30th, 31st). The possible values are:
        Last, Same, Last28, Same28. Optional. The default value is 'Last'.
        Known values are: "Last", "Same", "Same1", "Last28", and "Same28".
    payments : list[~analyticsapi.models.InputFlow]
        The array of properties which can be used to define instruments
        premium for cash flow analysis.  The default value is None, needs to be
        assigned before using.
    start_date : ~datetime.datetime
        The start date of the instrument. This value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
        Optional. The default value is valuationDate shifted forward by a month
        using market conventions.
    stub_rule : str or ~analyticsapi.models.FinancialContractStubRuleEnum
        The rule that defines whether coupon roll dates are aligned to the
        maturity or issue date. The possible values are: Issue, Maturity,
        ShortFirstProRata, ShortFirstFull, LongFirstFull, ShortLastProRata.
        Optional. The default value is 'Maturity'. Known values are: "Issue",
        "Maturity", "ShortFirstProRata", "ShortFirstFull", "LongFirstFull", and
        "ShortLastProRata".
    tenor : str
        The code indicating the period between StartDate and EndDate of the
        instrument (e.g. '5M'). Either tenor or endDate must be provided. No
        default value applies.
    """

    adjust_interest_to_payment_date: Optional[Union[str, "_models.AdjustInterestToPaymentDateEnum"]] = rest_field(
        name="adjustInterestToPaymentDate"
    )
    """An indication if the coupon dates are adjusted to the payment dates. The possible values are:
     Adjusted,
     Unadjusted.
     Optional. The default value is 'Unadjusted'. Known values are: \"Unadjusted\" and \"Adjusted\"."""
    amortization_schedule: Optional[List["_models.AmortizationItemDefinition"]] = rest_field(
        name="amortizationSchedule"
    )
    """The amortization schedule of the instrument. It contains the following information:
     startDate,
     endDate,
     remainingNotional,
     amortizationFrequency,
     amount,
     amortizationType.
     No default value applies."""
    annualized_rebate: Optional[bool] = rest_field(name="annualizedRebate")
    """An indicator if the rebate is adjusted according to the frequency of the cap. For example, if
     the frequency of the cap is quarterly (FRQ:4), all rebates are divided by four (approximately).
     The possible values are:
     True: the rebates are adjusted,
     False: there is no rebate adjustment(the rebate value is assumed to be annualized).
     The default value is 'False'."""
    barrier_definition: Optional["_models.BarrierDefinitionElement"] = rest_field(name="barrierDefinition")
    buy_sell: Optional[Union[str, "_models.IPABuySellEnum"]] = rest_field(name="buySell")
    """The indicator of the deal side. The possible values are:
     Buy: buying the option,
     Sell: selling/writing the option.
     Mandatory. No default value applies. Known values are: \"Buy\" and \"Sell\"."""
    cap_digital_payout_percent: Optional[float] = rest_field(name="capDigitalPayoutPercent")
    """A percentage of notionalAmount that is received (paid) by the option buyer (seller) if the
     option expires on or above the cap strike.
     No default value applies."""
    cap_strike_percent: Optional[float] = rest_field(name="capStrikePercent")
    """The contractual strike rate of the cap. The value is expressed in percentages.
     Note: If instrumentType is set to 'CapFloor', either capStrikePercent or
     capStrikePercentSchedule must be provided.
     The default value equals to AtmStrikePercent."""
    cms_template: Optional[str] = rest_field(name="cmsTemplate")
    """A reference to a common swap contract that represents the underlying swap in case of a Constant
     Maturity Swap contract (CMS). Example: EUR_AB6E.
     No default value applies."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z). Either tenor or endDate must be
     provided.
     The default value is valuationDate shifted forward by tenor."""
    first_regular_payment_date: Optional[datetime.datetime] = rest_field(
        name="firstRegularPaymentDate", format="rfc3339"
    )
    """The first regular interest payment date used for the odd first interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
     No default value applies."""
    floor_digital_payout_percent: Optional[float] = rest_field(name="floorDigitalPayoutPercent")
    """A percentage of notionalAmount that is received (paid) by the option buyer (seller) if the
     option expires on or below the floor strike.
     No default value applies."""
    floor_strike_percent: Optional[float] = rest_field(name="floorStrikePercent")
    """The contractual strike rate of the floor. The value is expressed in percentages.
     Note: If instrumentType is set to 'CapFloor', either FloorStrikePercent or
     FloorStrikePercentSchedule must be provided.
     The default value equals to AtmStrikePercent."""
    index_fixing_lag: Optional[int] = rest_field(name="indexFixingLag")
    """The number of working days between the fixing date of the index and the start of the interest
     accrual period ('InAdvance') or the end of the interest accrual period ('InArrears').
     The 'InAdvance' or 'InArrears' mode is set in the indexResetType parameter.
     Optional. If indexFixingRic or indexName is defined, the associated fixing lag is selected.
     Otherwise, the value is based on the first fixing that matches currency and indexTenor."""
    index_fixing_ric: Optional[str] = rest_field(name="indexFixingRic")
    """The RIC that carries the fixing value if the instrument has a floating interest.
     Optional. No default value applies."""
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g. 'EURIBOR').
     Optional. No default value applies."""
    index_observation_method: Optional[Union[str, "_models.IPAIndexObservationMethodEnum"]] = rest_field(
        name="indexObservationMethod"
    )
    """(RFR) Method for determining the accrual observation period. The lag is defined using the
     indexFixingLag property. The possible values are:
     Lookback: use the interest period for both rate accrual and interest payment.
     PeriodShift: use the observation period for both rate accrual and interest payment.
     Mixed: use the observation period for rate accrual and the interest period for interest
     payment.
     Optional. No default value applies. Known values are: \"Lookback\", \"PeriodShift\", and
     \"Mixed\"."""
    index_price_side: Optional[Union[str, "_models.IndexPriceSideEnum"]] = rest_field(name="indexPriceSide")
    """The quoted price side of the floating rate index that applies to legs or the instrument.
     The possible values are: Bid, Ask, Mid.
     This property applies only if an index is quoted with a 'Bid'/'Ask' price side.
     The default value is 'Mid'. Known values are: \"Mid\", \"Bid\", \"Ask\", and \"Last\"."""
    index_reset_frequency: Optional[Union[str, "_models.IndexResetFrequencyEnum"]] = rest_field(
        name="indexResetFrequency"
    )
    """The reset frequency for the floating instrument.
     Optional. By default, the reset frequency associated to  the index defined for the floating leg
     is used. Known values are: \"Annual\", \"SemiAnnual\", \"Quarterly\", \"Monthly\",
     \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\", \"Every7Days\", \"Every14Days\",
     \"Every28Days\", \"Every30Days\", \"Every91Days\", \"Every182Days\", \"Every364Days\",
     \"Every365Days\", \"Every90Days\", \"Every92Days\", \"Every93Days\", \"Every180Days\",
     \"Every183Days\", \"Every184Days\", \"Every4Months\", \"R2\", \"R4\", \"Zero\", and
     \"Scheduled\"."""
    index_reset_type: Optional[Union[str, "_models.IndexResetTypeEnum"]] = rest_field(name="indexResetType")
    """The reset type indicating if the floating rate index is reset before the coupon period starts
     or at the end of the coupon period.
     The possible values are:
     
     
     * InAdvance: resets the index before the start of the interest period,
     * InArrears: resets the index at the end of the interest period.
     
     Optional. The default value is 'InAdvance'. For RFR index, the default value is 'InArrears'.
     Known values are: \"InAdvance\" and \"InArrears\"."""
    index_source: Optional[str] = rest_field(name="indexSource")
    index_tenor: Optional[str] = rest_field(name="indexTenor")
    """The period code indicating the tenor of the underlying floating rate index (e.g., '1M', '1Y').
     The requested tenor must exist in the multicurve environment which is used.
     The 'InAdvance' or 'InArrears' mode is set in the indexResetType parameter.
     If indexFixingRic or indexName is defined, the associate fixing lag is selected. Otherwise, the
     default value is the tenor equivalent to indexResetFrequency or interestPaymentFrequency."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters.
     Only alphabetic, numeric and '- _.#=@' characters are supported.
     Optional. No default value applies."""
    interest_calculation_convention: Optional[Union[str, "_models.InterestCalculationConventionEnum"]] = rest_field(
        name="interestCalculationConvention"
    )
    """The convention applied to calculate the interest payments. The possible values are:
     
     
     * None,
     * MoneyMarket: money market methods calculate all cash flow based on the actual number of days
     in the payment period,
     * BondBasis: bond methods calculate interest payments proportionally to the payment frequency
     and adjust them if the number of days in the payment period is larger or smaller.
     
     Optional. Default value is 'MoneyMarket'. Known values are: \"None\", \"MoneyMarket\", and
     \"BondBasis\"."""
    interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = rest_field(
        name="interestCalculationMethod"
    )
    """The day count basis method used to calculate the interest payments.
     The default value is selected based on notionalCcy. Known values are: \"Dcb_30_360\",
     \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\",
     \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\",
     \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\",
     \"Dcb_Actual_365_CanadianConvention\", and \"Dcb_Constant\"."""
    interest_payment_frequency: Optional[Union[str, "_models.InterestPaymentFrequencyEnum"]] = rest_field(
        name="interestPaymentFrequency"
    )
    """The interest payment frequency.
     By default, indexTenor is used, if it is defined. Otherwise, the default value is
     indexResetFrequency. Known values are: \"Annual\", \"SemiAnnual\", \"Quarterly\", \"Monthly\",
     \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\", \"Every7Days\", \"Every14Days\",
     \"Every28Days\", \"Every30Days\", \"Every91Days\", \"Every182Days\", \"Every364Days\",
     \"Every365Days\", \"Every90Days\", \"Every92Days\", \"Every93Days\", \"Every180Days\",
     \"Every183Days\", \"Every184Days\", \"Every4Months\", \"R2\", \"R4\", \"Zero\", and
     \"Scheduled\"."""
    is_backward_looking_index: Optional[bool] = rest_field(name="isBackwardLookingIndex")
    """An indicator if the underlying fixing rate is backward-looking (Mostly Risk-Free-Rate). The
     possible values are:
     
     
     * True: the underlying fixing rate is backward-looking. For backward looking caps/floors the
     rate is accreted up to the end of the caplet period.
     * False: the underlying fixing rate is forward-looking and the rate of each caplet is fixed at
     the start of the caplet period.
     
     The default value is 'False'."""
    last_regular_payment_date: Optional[datetime.datetime] = rest_field(name="lastRegularPaymentDate", format="rfc3339")
    """The last regular interest payment date used for the odd last interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
     No default value applies."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument.
     Optional. The default value is '1,000,000' in notionalCcy."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g. 'USD').
     No default value applies."""
    payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = rest_field(
        name="paymentBusinessDayConvention"
    )
    """The method to adjust dates to working days. The possible values are:
     PreviousBusinessDay,
     NextBusinessDay,
     Modified following,
     NoMoving,
     BSWModifiedFollowing.
     Optional. The default value is 'ModifiedFollowing'. Known values are: \"ModifiedFollowing\",
     \"NextBusinessDay\", \"PreviousBusinessDay\", \"NoMoving\", \"EveryThirdWednesday\", and
     \"BbswModifiedFollowing\"."""
    payment_business_days: Optional[str] = rest_field(name="paymentBusinessDays")
    """A list of comma-separated calendar codes to adjust dates (e.g. 'EMU' or 'USA').
     No default value applies."""
    payment_roll_convention: Optional[Union[str, "_models.PaymentRollConventionEnum"]] = rest_field(
        name="paymentRollConvention"
    )
    """The method to adjust payment dates when they fall at the end of the month (e.g. 28th of
     February, 30th, 31st). The possible values are:
     Last,
     Same,
     Last28,
     Same28.
     Optional. The default value is 'Last'. Known values are: \"Last\", \"Same\", \"Same1\",
     \"Last28\", and \"Same28\"."""
    payments: Optional[List["_models.InputFlow"]] = rest_field()
    """The array of properties which can be used to define instruments premium for cash flow
     analysis."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. This value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
     Optional. The default value is valuationDate shifted forward by a month using market
     conventions."""
    stub_rule: Optional[Union[str, "_models.FinancialContractStubRuleEnum"]] = rest_field(name="stubRule")
    """The rule that defines whether coupon roll dates are aligned to the maturity or issue date. The
     possible values are:
     Issue,
     Maturity,
     ShortFirstProRata,
     ShortFirstFull,
     LongFirstFull,
     ShortLastProRata.
     Optional. The default value is 'Maturity'. Known values are: \"Issue\", \"Maturity\",
     \"ShortFirstProRata\", \"ShortFirstFull\", \"LongFirstFull\", and \"ShortLastProRata\"."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between StartDate and EndDate of the instrument (e.g. '5M').
     Either tenor or endDate must be provided.
     No default value applies."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        adjust_interest_to_payment_date: Optional[Union[str, "_models.AdjustInterestToPaymentDateEnum"]] = None,
        amortization_schedule: Optional[List["_models.AmortizationItemDefinition"]] = None,
        annualized_rebate: Optional[bool] = None,
        barrier_definition: Optional["_models.BarrierDefinitionElement"] = None,
        buy_sell: Optional[Union[str, "_models.IPABuySellEnum"]] = None,
        cap_digital_payout_percent: Optional[float] = None,
        cap_strike_percent: Optional[float] = None,
        cms_template: Optional[str] = None,
        end_date: Optional[datetime.datetime] = None,
        first_regular_payment_date: Optional[datetime.datetime] = None,
        floor_digital_payout_percent: Optional[float] = None,
        floor_strike_percent: Optional[float] = None,
        index_fixing_lag: Optional[int] = None,
        index_fixing_ric: Optional[str] = None,
        index_name: Optional[str] = None,
        index_observation_method: Optional[Union[str, "_models.IPAIndexObservationMethodEnum"]] = None,
        index_price_side: Optional[Union[str, "_models.IndexPriceSideEnum"]] = None,
        index_reset_frequency: Optional[Union[str, "_models.IndexResetFrequencyEnum"]] = None,
        index_reset_type: Optional[Union[str, "_models.IndexResetTypeEnum"]] = None,
        index_source: Optional[str] = None,
        index_tenor: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        interest_calculation_convention: Optional[Union[str, "_models.InterestCalculationConventionEnum"]] = None,
        interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = None,
        interest_payment_frequency: Optional[Union[str, "_models.InterestPaymentFrequencyEnum"]] = None,
        is_backward_looking_index: Optional[bool] = None,
        last_regular_payment_date: Optional[datetime.datetime] = None,
        notional_amount: Optional[float] = None,
        notional_ccy: Optional[str] = None,
        payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = None,
        payment_business_days: Optional[str] = None,
        payment_roll_convention: Optional[Union[str, "_models.PaymentRollConventionEnum"]] = None,
        payments: Optional[List["_models.InputFlow"]] = None,
        start_date: Optional[datetime.datetime] = None,
        stub_rule: Optional[Union[str, "_models.FinancialContractStubRuleEnum"]] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IPACapFloorDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.IPACapFloorDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.IPACapFloorDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.IPACapFloorDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IPAInterestRateCurveResponse(_model_base.Model):
    """IPAInterestRateCurveResponse.

    Attributes
    ----------
    data : ~analyticsapi.models.InterestRateCurveDefinitionResponse
        Required.
    """

    data: "_models.InterestRateCurveDefinitionResponse" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.InterestRateCurveDefinitionResponse",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class IPAModelParameters(_model_base.Model):
    """IPAModelParameters."""


class IrCapVolSurfaceChoice(_model_base.Model):
    """The object to provide either a reference to a interest rate cap volatility surface stored in
    the platform or 3rd party volatilities.

    Attributes
    ----------
    reference : str
        The reference to a volatility surface stored in the platform.
    surface : ~analyticsapi.models.IrVolSurfaceInput
        The volatility surface data.
    """

    reference: Optional[str] = rest_field()
    """The reference to a volatility surface stored in the platform."""
    surface: Optional["_models.IrVolSurfaceInput"] = rest_field()
    """The volatility surface data."""

    @overload
    def __init__(
        self,
        *,
        reference: Optional[str] = None,
        surface: Optional["_models.IrVolSurfaceInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrCurveChoice(_model_base.Model):
    """The object to provide either a reference to a interest rate zero curve stored in the platform
    or a 3rd party curve.

    Attributes
    ----------
    reference : str
        The reference to an interest rate curve stored in the platform.
    curve : ~analyticsapi.models.IrZcCurveInput
        The interest rate curve data.
    """

    reference: Optional[str] = rest_field()
    """The reference to an interest rate curve stored in the platform."""
    curve: Optional["_models.IrZcCurveInput"] = rest_field()
    """The interest rate curve data."""

    @overload
    def __init__(
        self,
        *,
        reference: Optional[str] = None,
        curve: Optional["_models.IrZcCurveInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrCurveDataOnResourceResponseData(_model_base.Model):
    """IrCurveDataOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.InterestRateCurve
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.InterestRateCurveCalculationParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.IrCurveDataResponseWithError
        The result of the calculation request.
    """

    resource: Optional["_models.InterestRateCurve"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.InterestRateCurveCalculationParameters"] = rest_field(
        name="pricingPreferences"
    )
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.IrCurveDataResponseWithError"] = rest_field()
    """The result of the calculation request."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.InterestRateCurve"] = None,
        pricing_preferences: Optional["_models.InterestRateCurveCalculationParameters"] = None,
        analytics: Optional["_models.IrCurveDataResponseWithError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrCurveDataResponseData(_model_base.Model):
    """IrCurveDataResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.IrCurveDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.InterestRateCurveCalculationParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.IrCurveDataResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    """

    definitions: Optional[List["_models.IrCurveDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.InterestRateCurveCalculationParameters"] = rest_field(
        name="pricingPreferences"
    )
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.IrCurveDataResponseWithError"]] = rest_field()
    """The result of the calculation request."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.IrCurveDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.InterestRateCurveCalculationParameters"] = None,
        analytics: Optional[List["_models.IrCurveDataResponseWithError"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrCurveDataResponseWithError(_model_base.Model):
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    constituents : list[~analyticsapi.models.IrConstituent]
        An object that defines the constituents used to construct a curve.  The
        default value is None, needs to be assigned before using.
    zc_curves : list[~analyticsapi.models.IrZcCurveDescription]
        An object that contains constructed zero-coupon curves.  The default
        value is None, needs to be assigned before using.
    underlying_curves : list[~analyticsapi.models.Curve]
        An object that contains the underlying curves used when constructing a
        curve.  The default value is None, needs to be assigned before using.
    invalid_constituents : list[~analyticsapi.models.IrConstituent]
        An object that contains constituents that could not be used when
        constructing a curve.  The default value is None, needs to be assigned
        before using.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    constituents: Optional[List["_models.IrConstituent"]] = rest_field()
    """An object that defines the constituents used to construct a curve."""
    zc_curves: Optional[List["_models.IrZcCurveDescription"]] = rest_field(name="zcCurves")
    """An object that contains constructed zero-coupon curves."""
    underlying_curves: Optional[List["_models.Curve"]] = rest_field(name="underlyingCurves")
    """An object that contains the underlying curves used when constructing a curve."""
    invalid_constituents: Optional[List["_models.IrConstituent"]] = rest_field(name="invalidConstituents")
    """An object that contains constituents that could not be used when constructing a curve."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional[List["_models.IrConstituent"]] = None,
        zc_curves: Optional[List["_models.IrZcCurveDescription"]] = None,
        underlying_curves: Optional[List["_models.Curve"]] = None,
        invalid_constituents: Optional[List["_models.IrConstituent"]] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrCurveDefinition(_model_base.Model):
    """An object that defines the properties used to construct a curve.

    Attributes
    ----------
    index : str
        The name of the main reference index of the curve.
    discounting_curve : str
        A reference to the IR curve that is used to discount the cash flows
        when bootstrapping the curve. This is useful for collateral management
        when a risk-free rate index (e.g., SOFR or ESTR) is used.
    constituents : list[~analyticsapi.models.IrConstituent]
        An object that defines the constituents used to construct a curve.  The
        default value is None, needs to be assigned before using.
    """

    index: Optional[str] = rest_field()
    """The name of the main reference index of the curve."""
    discounting_curve: Optional[str] = rest_field(name="discountingCurve")
    """A reference to the IR curve that is used to discount the cash flows when bootstrapping the
     curve. This is useful for collateral management when a risk-free rate index (e.g., SOFR or
     ESTR) is used."""
    constituents: Optional[List["_models.IrConstituent"]] = rest_field()
    """An object that defines the constituents used to construct a curve."""

    @overload
    def __init__(
        self,
        *,
        index: Optional[str] = None,
        discounting_curve: Optional[str] = None,
        constituents: Optional[List["_models.IrConstituent"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrCurveDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.IrCurveDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.IrCurveDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.IrCurveDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrLegDescriptionFields(_model_base.Model):
    """An object that contains fields related to the instrument's description.

    Attributes
    ----------
    leg_tag : str
        A user-defined string to identify a leg. Required.
    leg_description : str
        The label that describes a leg. Required.
    interest_type : str or ~analyticsapi.models.InterestType
        An indicator whether a leg pays a fixed or floating interest. Required.
        Known values are: "Fixed" and "Float".
    currency : str
        The currency of a leg's notional amount. The value is expressed in ISO
        4217 alphabetical format (e.g., 'USD'). Required.
    start_date : ~datetime.date
        The start date of a leg. The value is expressed in ISO 8601 format:
        YYYY-MM-DD (e.g., 2021-01-01). Required.
    end_date : ~datetime.date
        The end date of a leg. The value is expressed in ISO 8601 format: YYYY-
        MM-DD (e.g., 2021-01-01). Required.
    index : str
        The floating rate index identifier.
    """

    leg_tag: str = rest_field(name="legTag")
    """A user-defined string to identify a leg. Required."""
    leg_description: str = rest_field(name="legDescription")
    """The label that describes a leg. Required."""
    interest_type: Union[str, "_models.InterestType"] = rest_field(name="interestType")
    """An indicator whether a leg pays a fixed or floating interest. Required. Known values are:
     \"Fixed\" and \"Float\"."""
    currency: str = rest_field()
    """The currency of a leg's notional amount. The value is expressed in ISO 4217 alphabetical format
     (e.g., 'USD'). Required."""
    start_date: datetime.date = rest_field(name="startDate")
    """The start date of a leg. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
     2021-01-01). Required."""
    end_date: datetime.date = rest_field(name="endDate")
    """The end date of a leg. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
     2021-01-01). Required."""
    index: Optional[str] = rest_field()
    """The floating rate index identifier."""

    @overload
    def __init__(
        self,
        *,
        leg_tag: str,
        leg_description: str,
        interest_type: Union[str, "_models.InterestType"],
        currency: str,
        start_date: datetime.date,
        end_date: datetime.date,
        index: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrLegResponseFields(_model_base.Model):
    """An object that contains the fields returned in the analytic response for a leg.

    Attributes
    ----------
    description : ~analyticsapi.models.IrLegDescriptionFields
        An object that contains fields related to the instrument's description.
        Required.
    valuation : ~analyticsapi.models.IrValuationFields
        An object that contains fields related to the instrument's valuation.
    risk : ~analyticsapi.models.IrRiskFields
        An object that contains fields related to the instrument's risk
        assessment.
    cashflows : list[~analyticsapi.models.Cashflow]
        The default value is None, needs to be assigned before using.
    """

    description: "_models.IrLegDescriptionFields" = rest_field()
    """An object that contains fields related to the instrument's description. Required."""
    valuation: Optional["_models.IrValuationFields"] = rest_field()
    """An object that contains fields related to the instrument's valuation."""
    risk: Optional["_models.IrRiskFields"] = rest_field()
    """An object that contains fields related to the instrument's risk assessment."""
    cashflows: Optional[List["_models.Cashflow"]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        description: "_models.IrLegDescriptionFields",
        valuation: Optional["_models.IrValuationFields"] = None,
        risk: Optional["_models.IrRiskFields"] = None,
        cashflows: Optional[List["_models.Cashflow"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrLegValuationResponseFields(IrLegResponseFields):
    """An object that contains the fields returned in the valuation response for a leg.

    Attributes
    ----------
    description : ~analyticsapi.models.IrLegDescriptionFields
        An object that contains fields related to the instrument's description.
        Required.
    valuation : ~analyticsapi.models.IrValuationFields
        An object that contains fields related to the instrument's valuation.
    risk : ~analyticsapi.models.IrRiskFields
        An object that contains fields related to the instrument's risk
        assessment.
    cashflows : list[~analyticsapi.models.Cashflow]
        The default value is None, needs to be assigned before using.
    """

    @overload
    def __init__(
        self,
        *,
        description: "_models.IrLegDescriptionFields",
        valuation: Optional["_models.IrValuationFields"] = None,
        risk: Optional["_models.IrRiskFields"] = None,
        cashflows: Optional[List["_models.Cashflow"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrMeasure(_model_base.Model):
    """An object that contains measures used to express the results of the instrument leg valuation.

    Attributes
    ----------
    value : float
        The amount expressed as an absolute value. Required.
    bp : float
        The amount expressed in basis points.
    percent : float
        The amount expressed as a percentage.
    deal_currency : ~analyticsapi.models.Amount
        An object that specifies the amount expressed in the deal currency.
    report_currency : ~analyticsapi.models.Amount
        An object that specifies the amount expressed in the reporting
        currency.
    domestic_currency : ~analyticsapi.models.Amount
        An object that specifies the amount expressed in the domestic currency.
    foreign_currency : ~analyticsapi.models.Amount
        An object that specifies the amount expressed in the foreign currency
        (FX specific).
    leg_currency : ~analyticsapi.models.Amount
        An object that specifies the amount in the leg currency.
    """

    value: float = rest_field()
    """The amount expressed as an absolute value. Required."""
    bp: Optional[float] = rest_field()
    """The amount expressed in basis points."""
    percent: Optional[float] = rest_field()
    """The amount expressed as a percentage."""
    deal_currency: Optional["_models.Amount"] = rest_field(name="dealCurrency")
    """An object that specifies the amount expressed in the deal currency."""
    report_currency: Optional["_models.Amount"] = rest_field(name="reportCurrency")
    """An object that specifies the amount expressed in the reporting currency."""
    domestic_currency: Optional["_models.Amount"] = rest_field(name="domesticCurrency")
    """An object that specifies the amount expressed in the domestic currency."""
    foreign_currency: Optional["_models.Amount"] = rest_field(name="foreignCurrency")
    """An object that specifies the amount expressed in the foreign currency (FX specific)."""
    leg_currency: Optional["_models.Amount"] = rest_field(name="legCurrency")
    """An object that specifies the amount in the leg currency."""

    @overload
    def __init__(
        self,
        *,
        value: float,
        bp: Optional[float] = None,
        percent: Optional[float] = None,
        deal_currency: Optional["_models.Amount"] = None,
        report_currency: Optional["_models.Amount"] = None,
        domestic_currency: Optional["_models.Amount"] = None,
        foreign_currency: Optional["_models.Amount"] = None,
        leg_currency: Optional["_models.Amount"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrPricingParameters(BasePricingParameters):
    """An object that contains parameters used to control interest rate analytics.

    Attributes
    ----------
    valuation_date : ~datetime.date
        The date on which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). The valuation date
        should be less than or equal to the instrument's end date. If not
        provided, today's date will be used as the default valuation date.
    report_currency : str
        The reporting currency. The value is expressed in ISO 4217 alphabetical
        format (e.g., 'GBP'). Default is USD.
    index_convexity : ~analyticsapi.models.ConvexityAdjustment
        An object that contains parameters used to control the convexity
        adjustment of the reference index.
    solving_parameters : ~analyticsapi.models.IrSwapSolvingParameters
        An object that contains parameters used to control solving.
    """

    index_convexity: Optional["_models.ConvexityAdjustment"] = rest_field(name="indexConvexity")
    """An object that contains parameters used to control the convexity adjustment of the reference
     index."""
    solving_parameters: Optional["_models.IrSwapSolvingParameters"] = rest_field(name="solvingParameters")
    """An object that contains parameters used to control solving."""

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.date] = None,
        report_currency: Optional[str] = None,
        index_convexity: Optional["_models.ConvexityAdjustment"] = None,
        solving_parameters: Optional["_models.IrSwapSolvingParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrRiskFields(_model_base.Model):
    """An object that contains fields related to the instrument's risk assessment.

    Attributes
    ----------
    duration : ~analyticsapi.models.IrMeasure
        An object that describes the weighted average maturity in years of all
        cash flows. The final cash flow includes the principal, which has a
        much greater weight than the intermediate cash flows. Required.
    modified_duration : ~analyticsapi.models.IrMeasure
        An object that describes the measure of price sensitivity in percent to
        a 100 basis points change in the instrument's yield, or a 1% parallel
        shift in the underlying zero-coupon curve. For a floating rate
        instrument, it is computed as time to next payment. Required.
    benchmark_hedge_notional : ~analyticsapi.models.Amount
        An object that specifies the notional amount of the benchmark
        instrument that allows to hedge the instrument (available for IRS
        only). The value is expressed in the deal currency. It is computed for
        instrument legs only. Required.
    annuity : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value of
        the fixed rate leg to a 1bp shift in the fixed rate. Required.
    dv01 : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value to a
        1bp parallel shift in the zero-coupon curve. Required.
    pv01 : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value to a
        1bp parallel shift in the yield curve. Required.
    br01 : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value to a
        1bp shift of Currency Basis Swap (CBS) spreads. Required.
    """

    duration: "_models.IrMeasure" = rest_field()
    """An object that describes the weighted average maturity in years of all cash flows. The final
     cash flow includes the principal, which has a much greater weight than the intermediate cash
     flows. Required."""
    modified_duration: "_models.IrMeasure" = rest_field(name="modifiedDuration")
    """An object that describes the measure of price sensitivity in percent to a 100 basis points
     change in the instrument's yield, or a 1% parallel shift in the underlying zero-coupon curve.
     For a floating rate instrument, it is computed as time to next payment. Required."""
    benchmark_hedge_notional: "_models.Amount" = rest_field(name="benchmarkHedgeNotional")
    """An object that specifies the notional amount of the benchmark instrument that allows to hedge
     the instrument (available for IRS only). The value is expressed in the deal currency. It is
     computed for instrument legs only. Required."""
    annuity: "_models.IrMeasure" = rest_field()
    """An object that describes the sensitivity of the net present value of the fixed rate leg to a
     1bp shift in the fixed rate. Required."""
    dv01: "_models.IrMeasure" = rest_field()
    """An object that describes the sensitivity of the net present value to a 1bp parallel shift in
     the zero-coupon curve. Required."""
    pv01: "_models.IrMeasure" = rest_field()
    """An object that describes the sensitivity of the net present value to a 1bp parallel shift in
     the yield curve. Required."""
    br01: "_models.IrMeasure" = rest_field()
    """An object that describes the sensitivity of the net present value to a 1bp shift of Currency
     Basis Swap (CBS) spreads. Required."""

    @overload
    def __init__(
        self,
        *,
        duration: "_models.IrMeasure",
        modified_duration: "_models.IrMeasure",
        benchmark_hedge_notional: "_models.Amount",
        annuity: "_models.IrMeasure",
        dv01: "_models.IrMeasure",
        pv01: "_models.IrMeasure",
        br01: "_models.IrMeasure",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrsInstrumentResponse(_model_base.Model):
    """An object that contains fields related to the interest rate swap definition.

    Attributes
    ----------
    data : ~analyticsapi.models.IrSwapDefinition
        An object that describes the instrument generated by the request.
        Required.
    """

    data: "_models.IrSwapDefinition" = rest_field()
    """An object that describes the instrument generated by the request. Required."""

    @overload
    def __init__(
        self,
        data: "_models.IrSwapDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class IrSwap(_model_base.Model):
    """The resource used to create, save and price an interest rate swap.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.IR_SWAP
        Property defining the type of the resource.
    id : str
        Unique identifier of the IrSwap.
    location : ~analyticsapi.models.Location
        Object defining the location of the IrSwap in the platform. Required.
    description : ~analyticsapi.models.Description
        Object defining metadata for the IrSwap.
    definition : ~analyticsapi.models.IrSwapDefinition
        Object defining the IrSwap. Required.
    """

    type: Optional[Literal[ResourceType.IR_SWAP]] = rest_field(visibility=["read"], default=ResourceType.IR_SWAP)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the IrSwap."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining the location of the IrSwap in the platform. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining metadata for the IrSwap."""
    definition: "_models.IrSwapDefinition" = rest_field()
    """Object defining the IrSwap. Required."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        definition: "_models.IrSwapDefinition",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapAsCollectionItem(_model_base.Model):
    """A model template defining the partial description of the resource returned by the GET list
    service.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.IR_SWAP
        Property defining the type of the resource.
    id : str
        Unique identifier of the IrSwap.
    location : ~analyticsapi.models.Location
        Object defining metadata for the IrSwap. Required.
    description : ~analyticsapi.models.Description
        Object defining the IrSwap.
    """

    type: Optional[Literal[ResourceType.IR_SWAP]] = rest_field(visibility=["read"], default=ResourceType.IR_SWAP)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the IrSwap."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining metadata for the IrSwap. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining the IrSwap."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapCollectionLinks(_model_base.Model):
    """IrSwapCollectionLinks.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapCollectionResponse(_model_base.Model):
    """A model template describing a paged response.

    Attributes
    ----------
    data : list[~analyticsapi.models.IrSwapAsCollectionItem]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.IrSwapCollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.IrSwapAsCollectionItem"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.IrSwapCollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.IrSwapAsCollectionItem"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.IrSwapCollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapDefinition(_model_base.Model):
    """An object that defines an interest rate swap.

    Attributes
    ----------
    first_leg : ~analyticsapi.models.InterestRateLegDefinition
        An object that defines the paid leg of the swap. Required.
    second_leg : ~analyticsapi.models.InterestRateLegDefinition
        An object that defines the received leg of the swap. Required.
    upfront_payment : ~analyticsapi.models.Payment
        An object that defines the upfront payment of the swap.
    """

    first_leg: "_models.InterestRateLegDefinition" = rest_field(name="firstLeg")
    """An object that defines the paid leg of the swap. Required."""
    second_leg: "_models.InterestRateLegDefinition" = rest_field(name="secondLeg")
    """An object that defines the received leg of the swap. Required."""
    upfront_payment: Optional["_models.Payment"] = rest_field(name="upfrontPayment")
    """An object that defines the upfront payment of the swap."""

    @overload
    def __init__(
        self,
        *,
        first_leg: "_models.InterestRateLegDefinition",
        second_leg: "_models.InterestRateLegDefinition",
        upfront_payment: Optional["_models.Payment"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.IrSwapDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.IrSwapDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.IrSwapDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapInstrumentArraySolveResponse(_model_base.Model):
    """The solve response for one or more swaps not stored on the platform.
    Used with the endpoint that solves swaps provided directly in the request body.
    The response includes the solving result, as well as calculated valuation and risk analytics
    for each swap.

    Attributes
    ----------
    data : ~analyticsapi.models.IrSwapInstrumentSolveResponseFieldsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.IrSwapInstrumentSolveResponseFieldsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.IrSwapInstrumentSolveResponseFieldsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class IrSwapInstrumentArrayValuationResponse(_model_base.Model):
    """The valuation response for one or more swaps not stored on the platform.
    Used with the endpoint that values swaps provided directly in the request body.
    The response includes calculated analytics (valuation results, risk metrics, and leg details)
    for each swap.

    Attributes
    ----------
    data : ~analyticsapi.models.IrSwapInstrumentValuationResponseFieldsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.IrSwapInstrumentValuationResponseFieldsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.IrSwapInstrumentValuationResponseFieldsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class IrSwapInstrumentDescriptionFields(_model_base.Model):
    """An object that contains fields related to the swap description.

    Attributes
    ----------
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and the characters  '- _.#=@' are
        supported.
    instrument_description : str
        The label that describes the instrument. Required.
    start_date : ~datetime.date
        The start date of the instrument. This value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., 2021-01-01). Required.
    end_date : ~datetime.date
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DD (e.g., 2021-01-01). Required.
    tenor : str
        The code indicating the period between startDate and endDate of the
        instrument (e.g., '6M', '1Y'). A tenor expresses a period of time using
        a specific syntax. There are two kinds of tenor:

        * Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and
        Years (Y).
          For example "1D" for one day, "2W" for two weeks or "3M1D" for three months and a day.
          When mixing units, units must be written in descending order of size (Y > M > W > D).  So,
        5M3D is valid, but 3D5M is not.
        * Common tenors are expressed as letter codes:
        * ON (Overnight) - A one business day period that starts today.
        * TN (Tomorrow-Next) - A one business day period that starts next business day.
        * SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date
        (today) + days to spot.
        * SN (Spot-Next) - A one business day period that starts at the spot date.
        * SW (Spot-Week) - A one business week period that starts at the spot date. Required.
    """

    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and the characters
     '- _.#=@' are supported."""
    instrument_description: str = rest_field(name="instrumentDescription")
    """The label that describes the instrument. Required."""
    start_date: datetime.date = rest_field(name="startDate")
    """The start date of the instrument. This value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
     2021-01-01). Required."""
    end_date: datetime.date = rest_field(name="endDate")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., 2021-01-01). Required."""
    tenor: str = rest_field()
    """The code indicating the period between startDate and endDate of the instrument (e.g., '6M',
     '1Y').
     A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:
     
     
     * Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and
     Years (Y).
       For example \"1D\" for one day, \"2W\" for two weeks or \"3M1D\" for three months and a day.
       When mixing units, units must be written in descending order of size (Y > M > W > D).  So,
     5M3D is valid, but 3D5M is not.
     * Common tenors are expressed as letter codes:
     * ON (Overnight) - A one business day period that starts today.
     * TN (Tomorrow-Next) - A one business day period that starts next business day.
     * SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date
     (today) + days to spot.
     * SN (Spot-Next) - A one business day period that starts at the spot date.
     * SW (Spot-Week) - A one business week period that starts at the spot date. Required."""

    @overload
    def __init__(
        self,
        *,
        instrument_description: str,
        start_date: datetime.date,
        end_date: datetime.date,
        tenor: str,
        instrument_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapInstrumentRiskFields(IrRiskFields):
    """An object that contains fields related to swap risk assessment.

    Attributes
    ----------
    duration : ~analyticsapi.models.IrMeasure
        An object that describes the weighted average maturity in years of all
        cash flows. The final cash flow includes the principal, which has a
        much greater weight than the intermediate cash flows. Required.
    modified_duration : ~analyticsapi.models.IrMeasure
        An object that describes the measure of price sensitivity in percent to
        a 100 basis points change in the instrument's yield, or a 1% parallel
        shift in the underlying zero-coupon curve. For a floating rate
        instrument, it is computed as time to next payment. Required.
    benchmark_hedge_notional : ~analyticsapi.models.Amount
        An object that specifies the notional amount of the benchmark
        instrument that allows to hedge the instrument (available for IRS
        only). The value is expressed in the deal currency. It is computed for
        instrument legs only. Required.
    annuity : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value of
        the fixed rate leg to a 1bp shift in the fixed rate. Required.
    dv01 : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value to a
        1bp parallel shift in the zero-coupon curve. Required.
    pv01 : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value to a
        1bp parallel shift in the yield curve. Required.
    br01 : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value to a
        1bp shift of Currency Basis Swap (CBS) spreads. Required.
    """

    @overload
    def __init__(
        self,
        *,
        duration: "_models.IrMeasure",
        modified_duration: "_models.IrMeasure",
        benchmark_hedge_notional: "_models.Amount",
        annuity: "_models.IrMeasure",
        dv01: "_models.IrMeasure",
        pv01: "_models.IrMeasure",
        br01: "_models.IrMeasure",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapInstrumentSolveResponse(_model_base.Model):
    """The solve response for a swap that has been saved on the platform.
    Used with the endpoint that requires an instrument ID.
    The response includes the solving result, as well as calculated valuation and risk analytics
    for the swap.

    Attributes
    ----------
    data : ~analyticsapi.models.IrSwapInstrumentSolveResponseFieldsOnResourceResponseData
        Required.
    """

    data: "_models.IrSwapInstrumentSolveResponseFieldsOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.IrSwapInstrumentSolveResponseFieldsOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class IrSwapInstrumentSolveResponseFieldsOnResourceResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """IrSwapInstrumentSolveResponseFieldsOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.IrSwap
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.IrPricingParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.IrSwapInstrumentSolveResponseFieldsResponseWithError
        The result of the calculation request.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    resource: Optional["_models.IrSwap"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.IrPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.IrSwapInstrumentSolveResponseFieldsResponseWithError"] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.IrSwap"] = None,
        pricing_preferences: Optional["_models.IrPricingParameters"] = None,
        analytics: Optional["_models.IrSwapInstrumentSolveResponseFieldsResponseWithError"] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapInstrumentSolveResponseFieldsResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """IrSwapInstrumentSolveResponseFieldsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.IrSwapDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.IrPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.IrSwapInstrumentSolveResponseFieldsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.IrSwapDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.IrPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.IrSwapInstrumentSolveResponseFieldsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.IrSwapDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.IrPricingParameters"] = None,
        analytics: Optional[List["_models.IrSwapInstrumentSolveResponseFieldsResponseWithError"]] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapInstrumentSolveResponseFieldsResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    solving : ~analyticsapi.models.SolvingResult
        An object that contains the swap solving result. Required.
    description : ~analyticsapi.models.IrSwapInstrumentDescriptionFields
        An object that contains fields related to the swap description.
        Required.
    valuation : ~analyticsapi.models.IrSwapInstrumentValuationFields
        An object that contains fields related to the swap valuation.
    risk : ~analyticsapi.models.IrSwapInstrumentRiskFields
        An object that contains fields related to the swap risk assessment.
    first_leg : ~analyticsapi.models.IrLegValuationResponseFields
        An object that contains fields related to the first leg of the swap.
    second_leg : ~analyticsapi.models.IrLegValuationResponseFields
        An object that contains fields related to the second leg of the swap.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    solving: "_models.SolvingResult" = rest_field()
    """An object that contains the swap solving result. Required."""
    description: "_models.IrSwapInstrumentDescriptionFields" = rest_field()
    """An object that contains fields related to the swap description. Required."""
    valuation: Optional["_models.IrSwapInstrumentValuationFields"] = rest_field()
    """An object that contains fields related to the swap valuation."""
    risk: Optional["_models.IrSwapInstrumentRiskFields"] = rest_field()
    """An object that contains fields related to the swap risk assessment."""
    first_leg: Optional["_models.IrLegValuationResponseFields"] = rest_field(name="firstLeg")
    """An object that contains fields related to the first leg of the swap."""
    second_leg: Optional["_models.IrLegValuationResponseFields"] = rest_field(name="secondLeg")
    """An object that contains fields related to the second leg of the swap."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        solving: "_models.SolvingResult",
        description: "_models.IrSwapInstrumentDescriptionFields",
        valuation: Optional["_models.IrSwapInstrumentValuationFields"] = None,
        risk: Optional["_models.IrSwapInstrumentRiskFields"] = None,
        first_leg: Optional["_models.IrLegValuationResponseFields"] = None,
        second_leg: Optional["_models.IrLegValuationResponseFields"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrValuationFields(_model_base.Model):
    """An object that contains fields related to the instrument's valuation.

    Attributes
    ----------
    accrued : ~analyticsapi.models.IrMeasure
        An object that describes accrued interest that is accumulated but not
        paid out. Required.
    market_value : ~analyticsapi.models.IrMeasure
        An object that describes the market value of the instrument. Required.
    clean_market_value : ~analyticsapi.models.IrMeasure
        An object that describes the market value of the instrument less any
        accrued interest. Required.
    """

    accrued: "_models.IrMeasure" = rest_field()
    """An object that describes accrued interest that is accumulated but not paid out. Required."""
    market_value: "_models.IrMeasure" = rest_field(name="marketValue")
    """An object that describes the market value of the instrument. Required."""
    clean_market_value: "_models.IrMeasure" = rest_field(name="cleanMarketValue")
    """An object that describes the market value of the instrument less any accrued interest.
     Required."""

    @overload
    def __init__(
        self,
        *,
        accrued: "_models.IrMeasure",
        market_value: "_models.IrMeasure",
        clean_market_value: "_models.IrMeasure",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapInstrumentValuationFields(IrValuationFields):
    """An object that contains fields related to the swap valuation.

    Attributes
    ----------
    accrued : ~analyticsapi.models.IrMeasure
        An object that describes accrued interest that is accumulated but not
        paid out. Required.
    market_value : ~analyticsapi.models.IrMeasure
        An object that describes the market value of the instrument. Required.
    clean_market_value : ~analyticsapi.models.IrMeasure
        An object that describes the market value of the instrument less any
        accrued interest. Required.
    """

    @overload
    def __init__(
        self,
        *,
        accrued: "_models.IrMeasure",
        market_value: "_models.IrMeasure",
        clean_market_value: "_models.IrMeasure",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapInstrumentValuationResponse(_model_base.Model):
    """The valuation response for a swap that has been saved on the platform.
    Used with the endpoint that requires an instrument ID.
    The response includes calculated analytics (valuation results, risk metrics, and leg details)
    for the swap.

    Attributes
    ----------
    data : ~analyticsapi.models.IrSwapInstrumentValuationResponseFieldsOnResourceResponseData
        Required.
    """

    data: "_models.IrSwapInstrumentValuationResponseFieldsOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.IrSwapInstrumentValuationResponseFieldsOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class IrSwapInstrumentValuationResponseFieldsOnResourceResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """IrSwapInstrumentValuationResponseFieldsOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.IrSwap
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.IrPricingParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.IrSwapInstrumentValuationResponseFieldsResponseWithError
        The result of the calculation request.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    resource: Optional["_models.IrSwap"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.IrPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.IrSwapInstrumentValuationResponseFieldsResponseWithError"] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.IrSwap"] = None,
        pricing_preferences: Optional["_models.IrPricingParameters"] = None,
        analytics: Optional["_models.IrSwapInstrumentValuationResponseFieldsResponseWithError"] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapInstrumentValuationResponseFieldsResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """IrSwapInstrumentValuationResponseFieldsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.IrSwapDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.IrPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.IrSwapInstrumentValuationResponseFieldsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.IrSwapDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.IrPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.IrSwapInstrumentValuationResponseFieldsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.IrSwapDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.IrPricingParameters"] = None,
        analytics: Optional[List["_models.IrSwapInstrumentValuationResponseFieldsResponseWithError"]] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapInstrumentValuationResponseFieldsResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    description : ~analyticsapi.models.IrSwapInstrumentDescriptionFields
        An object that contains fields related to the swap description.
        Required.
    valuation : ~analyticsapi.models.IrSwapInstrumentValuationFields
        An object that contains fields related to the swap valuation.
    risk : ~analyticsapi.models.IrSwapInstrumentRiskFields
        An object that contains fields related to the swap risk assessment.
    first_leg : ~analyticsapi.models.IrLegValuationResponseFields
        An object that contains fields related to the first leg of the swap.
    second_leg : ~analyticsapi.models.IrLegValuationResponseFields
        An object that contains fields related to the second leg of the swap.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    description: "_models.IrSwapInstrumentDescriptionFields" = rest_field()
    """An object that contains fields related to the swap description. Required."""
    valuation: Optional["_models.IrSwapInstrumentValuationFields"] = rest_field()
    """An object that contains fields related to the swap valuation."""
    risk: Optional["_models.IrSwapInstrumentRiskFields"] = rest_field()
    """An object that contains fields related to the swap risk assessment."""
    first_leg: Optional["_models.IrLegValuationResponseFields"] = rest_field(name="firstLeg")
    """An object that contains fields related to the first leg of the swap."""
    second_leg: Optional["_models.IrLegValuationResponseFields"] = rest_field(name="secondLeg")
    """An object that contains fields related to the second leg of the swap."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        description: "_models.IrSwapInstrumentDescriptionFields",
        valuation: Optional["_models.IrSwapInstrumentValuationFields"] = None,
        risk: Optional["_models.IrSwapInstrumentRiskFields"] = None,
        first_leg: Optional["_models.IrLegValuationResponseFields"] = None,
        second_leg: Optional["_models.IrLegValuationResponseFields"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapResponse(_model_base.Model):
    """A model template describing a single response.

    Attributes
    ----------
    data : ~analyticsapi.models.IrSwap
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.IrSwap" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.IrSwap",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapSolvingParameters(_model_base.Model):
    """An object that contains the solving target and variable parameters applied to an interest rate
    swap.
    These parameters provide an approach to obtaining the target value by selecting a variable
    value.
    This allows to consider different scenarios of the behavior of a specific parameter (variable)
    given the set value of another parameter (target).

    Attributes
    ----------
    variable : ~analyticsapi.models.IrSwapSolvingVariable
        An object that contains the properties used to identify the swap
        variable parameter. Required.
    target : ~analyticsapi.models.IrSwapSolvingTarget
        An object that contains the properties applied to the swap target
        parameter. Required.
    """

    variable: "_models.IrSwapSolvingVariable" = rest_field()
    """An object that contains the properties used to identify the swap variable parameter. Required."""
    target: "_models.IrSwapSolvingTarget" = rest_field()
    """An object that contains the properties applied to the swap target parameter. Required."""

    @overload
    def __init__(
        self,
        *,
        variable: "_models.IrSwapSolvingVariable",
        target: "_models.IrSwapSolvingTarget",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapSolvingTarget(_model_base.Model):
    """ "An object that contains the properties that apply to the swap target parameter.
        To obtain the solution for the selected variable parameter please specify the value of the
        target parameter.
        Note: Only one of possible target parameters should be requested for solver computations.

        :ivar leg: A swap leg to which the target property applies. It can be used where several
    options are possible (e.g., the market value of the first leg). Known values are: "FirstLeg"
    and "SecondLeg".
        :vartype leg: str or ~analyticsapi.models.SolvingLegEnum
        :ivar accrued: An object that describes the target as the accrued interest of one of the swap
    legs or the swap instrument globally.
        :vartype accrued: ~analyticsapi.models.IrMeasure
        :ivar market_value: An object that describes the target as the market value of one of the swap
    legs or the swap instrument globally.
        :vartype market_value: ~analyticsapi.models.IrMeasure
        :ivar clean_market_value: An object that describes the target as the clean market value of one
    of the swap legs or the swap instrument globally.
        :vartype clean_market_value: ~analyticsapi.models.IrMeasure
        :ivar duration: An object that describes the target as the duration of one of the swap legs or
    the swap instrument globally.
        :vartype duration: ~analyticsapi.models.IrMeasure
        :ivar modified_duration: An object that describes the target as the modified duration of one of
    the swap legs or the swap instrument globally.
        :vartype modified_duration: ~analyticsapi.models.IrMeasure
        :ivar dv01: An object that describes the target as the dv01 of one of the swap legs or the swap
    instrument globally.
        :vartype dv01: ~analyticsapi.models.IrMeasure
        :ivar pv01: An object that describes the target as the pv01 of one of the swap legs or the swap
    instrument globally.
        :vartype pv01: ~analyticsapi.models.IrMeasure
        :ivar br01: An object that describes the target as the br01 of one of the swap legs or the swap
    instrument globally.
        :vartype br01: ~analyticsapi.models.IrMeasure
        :ivar annuity: An object that describes the target as the annuity of one of the swap legs or
    the swap instrument globally.
        :vartype annuity: ~analyticsapi.models.IrMeasure
        :ivar fixed_rate: An object that describes the target as the fixed rate of the swap.
        :vartype fixed_rate: ~analyticsapi.models.Rate
        :ivar spread: An object that describes the target as the spread over the floating rate of the
    swap.
        :vartype spread: ~analyticsapi.models.Rate
    """

    leg: Optional[Union[str, "_models.SolvingLegEnum"]] = rest_field()
    """A swap leg to which the target property applies. It can be used where several options are
     possible (e.g., the market value of the first leg). Known values are: \"FirstLeg\" and
     \"SecondLeg\"."""
    accrued: Optional["_models.IrMeasure"] = rest_field()
    """An object that describes the target as the accrued interest of one of the swap legs or the swap
     instrument globally."""
    market_value: Optional["_models.IrMeasure"] = rest_field(name="marketValue")
    """An object that describes the target as the market value of one of the swap legs or the swap
     instrument globally."""
    clean_market_value: Optional["_models.IrMeasure"] = rest_field(name="cleanMarketValue")
    """An object that describes the target as the clean market value of one of the swap legs or the
     swap instrument globally."""
    duration: Optional["_models.IrMeasure"] = rest_field()
    """An object that describes the target as the duration of one of the swap legs or the swap
     instrument globally."""
    modified_duration: Optional["_models.IrMeasure"] = rest_field(name="modifiedDuration")
    """An object that describes the target as the modified duration of one of the swap legs or the
     swap instrument globally."""
    dv01: Optional["_models.IrMeasure"] = rest_field()
    """An object that describes the target as the dv01 of one of the swap legs or the swap instrument
     globally."""
    pv01: Optional["_models.IrMeasure"] = rest_field()
    """An object that describes the target as the pv01 of one of the swap legs or the swap instrument
     globally."""
    br01: Optional["_models.IrMeasure"] = rest_field()
    """An object that describes the target as the br01 of one of the swap legs or the swap instrument
     globally."""
    annuity: Optional["_models.IrMeasure"] = rest_field()
    """An object that describes the target as the annuity of one of the swap legs or the swap
     instrument globally."""
    fixed_rate: Optional["_models.Rate"] = rest_field(name="fixedRate")
    """An object that describes the target as the fixed rate of the swap."""
    spread: Optional["_models.Rate"] = rest_field()
    """An object that describes the target as the spread over the floating rate of the swap."""

    @overload
    def __init__(
        self,
        *,
        leg: Optional[Union[str, "_models.SolvingLegEnum"]] = None,
        accrued: Optional["_models.IrMeasure"] = None,
        market_value: Optional["_models.IrMeasure"] = None,
        clean_market_value: Optional["_models.IrMeasure"] = None,
        duration: Optional["_models.IrMeasure"] = None,
        modified_duration: Optional["_models.IrMeasure"] = None,
        dv01: Optional["_models.IrMeasure"] = None,
        pv01: Optional["_models.IrMeasure"] = None,
        br01: Optional["_models.IrMeasure"] = None,
        annuity: Optional["_models.IrMeasure"] = None,
        fixed_rate: Optional["_models.Rate"] = None,
        spread: Optional["_models.Rate"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwapSolvingVariable(_model_base.Model):
    """An object that contains the properties used to identify the swap variable parameter.

    Attributes
    ----------
    leg : str or ~analyticsapi.models.SolvingLegEnum
        A swap leg to which the variable property applies. It can be used where
        several options are possible (e.g., the spread of a tenor basis swap).
        Known values are: "FirstLeg" and "SecondLeg".
    name : str or ~analyticsapi.models.SwapSolvingVariableEnum
        The list of swap variable parameters for which the solution is
        calculated. Known values are: "FixedRate" and "Spread".
    """

    leg: Optional[Union[str, "_models.SolvingLegEnum"]] = rest_field()
    """A swap leg to which the variable property applies. It can be used where several options are
     possible (e.g., the spread of a tenor basis swap). Known values are: \"FirstLeg\" and
     \"SecondLeg\"."""
    name: Optional[Union[str, "_models.SwapSolvingVariableEnum"]] = rest_field()
    """The list of swap variable parameters for which the solution is calculated. Known values are:
     \"FixedRate\" and \"Spread\"."""

    @overload
    def __init__(
        self,
        *,
        leg: Optional[Union[str, "_models.SolvingLegEnum"]] = None,
        name: Optional[Union[str, "_models.SwapSolvingVariableEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrSwaptionVolCubeChoice(_model_base.Model):
    """The object to provide either a reference to a interest rate swaption volatility surface stored
    in the platform or 3rd party volatilities.

    Attributes
    ----------
    reference : str
        The reference to a volatility surface stored in the platform.
    cube : ~analyticsapi.models.IrVolCubeInput
        The volatility cube data.
    """

    reference: Optional[str] = rest_field()
    """The reference to a volatility surface stored in the platform."""
    cube: Optional["_models.IrVolCubeInput"] = rest_field()
    """The volatility cube data."""

    @overload
    def __init__(
        self,
        *,
        reference: Optional[str] = None,
        cube: Optional["_models.IrVolCubeInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrVolCubeInput(_model_base.Model):
    """The object defining the 3rd party interest rate swaption volatility cube.

    Attributes
    ----------
    strike_type : str or ~analyticsapi.models.StrikeTypeEnum
        The property that defines the type of the strikes provided in the
        surface points. Required. Known values are: "Absolute", "BasisPoint",
        "Delta", "Moneyness", "Percent", and "Relative".
    model_type : str or ~analyticsapi.models.VolModelTypeEnum
        The property that defines the type of the model (Normal or LogNormal)
        of the volatilities provided in the surface points. Required. Known
        values are: "Normal" and "LogNormal".
    points : list[~analyticsapi.models.VolCubePoint]
        The list of volatility points. Required.  The default value is None,
        needs to be assigned before using.
    index_reference : str
        The reference to the floating rate index. Required.
    """

    strike_type: Union[str, "_models.StrikeTypeEnum"] = rest_field(name="strikeType")
    """The property that defines the type of the strikes provided in the surface points. Required.
     Known values are: \"Absolute\", \"BasisPoint\", \"Delta\", \"Moneyness\", \"Percent\", and
     \"Relative\"."""
    model_type: Union[str, "_models.VolModelTypeEnum"] = rest_field(name="modelType")
    """The property that defines the type of the model (Normal or LogNormal) of the volatilities
     provided in the surface points. Required. Known values are: \"Normal\" and \"LogNormal\"."""
    points: List["_models.VolCubePoint"] = rest_field()
    """The list of volatility points. Required."""
    index_reference: str = rest_field(name="indexReference")
    """The reference to the floating rate index. Required."""

    @overload
    def __init__(
        self,
        *,
        strike_type: Union[str, "_models.StrikeTypeEnum"],
        model_type: Union[str, "_models.VolModelTypeEnum"],
        points: List["_models.VolCubePoint"],
        index_reference: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrVolSurfaceInput(_model_base.Model):
    """The object defining the 3rd party interest rate cap volatility surface.

    Attributes
    ----------
    strike_type : str or ~analyticsapi.models.StrikeTypeEnum
        The property that defines the type of the strikes provided in the
        surface points. Required. Known values are: "Absolute", "BasisPoint",
        "Delta", "Moneyness", "Percent", and "Relative".
    model_type : str or ~analyticsapi.models.VolModelTypeEnum
        The property that defines the type of the model (Normal or LogNormal)
        of the volatilities provided in the surface points. Required. Known
        values are: "Normal" and "LogNormal".
    points : list[~analyticsapi.models.VolSurfacePoint]
        The list of volatility points. Required.  The default value is None,
        needs to be assigned before using.
    index_reference : str
        The reference to the floating rate index. Required.
    """

    strike_type: Union[str, "_models.StrikeTypeEnum"] = rest_field(name="strikeType")
    """The property that defines the type of the strikes provided in the surface points. Required.
     Known values are: \"Absolute\", \"BasisPoint\", \"Delta\", \"Moneyness\", \"Percent\", and
     \"Relative\"."""
    model_type: Union[str, "_models.VolModelTypeEnum"] = rest_field(name="modelType")
    """The property that defines the type of the model (Normal or LogNormal) of the volatilities
     provided in the surface points. Required. Known values are: \"Normal\" and \"LogNormal\"."""
    points: List["_models.VolSurfacePoint"] = rest_field()
    """The list of volatility points. Required."""
    index_reference: str = rest_field(name="indexReference")
    """The reference to the floating rate index. Required."""

    @overload
    def __init__(
        self,
        *,
        strike_type: Union[str, "_models.StrikeTypeEnum"],
        model_type: Union[str, "_models.VolModelTypeEnum"],
        points: List["_models.VolSurfacePoint"],
        index_reference: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrZcCurve(Curve, discriminator="IrZcCurve"):
    """The model defining the output of a interest rate zc curve calculation.

    Attributes
    ----------
    curve_type : str or ~analyticsapi.models.IR_ZC_CURVE
        The type of the curve. Required.
    index : str
        The reference to the floating rate index.
    points : list[~analyticsapi.models.IrZcCurvePoint]
        The list of output points.  The default value is None, needs to be
        assigned before using.
    """

    curve_type: Literal[CurveTypeEnum.IR_ZC_CURVE] = rest_discriminator(name="curveType")  # type: ignore
    """The type of the curve. Required."""
    index: Optional[str] = rest_field()
    """The reference to the floating rate index."""
    points: Optional[List["_models.IrZcCurvePoint"]] = rest_field()
    """The list of output points."""

    @overload
    def __init__(
        self,
        *,
        index: Optional[str] = None,
        points: Optional[List["_models.IrZcCurvePoint"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, curve_type=CurveTypeEnum.IR_ZC_CURVE, **kwargs)


class IrZcCurveDescription(_model_base.Model):
    """IrZcCurveDescription.

    Attributes
    ----------
    curve_type : str or ~analyticsapi.models.IR_ZC_CURVE
        The type of the curve. Required.
    index : str
        The reference to the floating rate index.
    points : list[~analyticsapi.models.IrZcCurvePoint]
        The list of output points.  The default value is None, needs to be
        assigned before using.
    """

    curve_type: Literal[CurveTypeEnum.IR_ZC_CURVE] = rest_field(name="curveType")
    """The type of the curve. Required."""
    index: Optional[str] = rest_field()
    """The reference to the floating rate index."""
    points: Optional[List["_models.IrZcCurvePoint"]] = rest_field()
    """The list of output points."""

    @overload
    def __init__(
        self,
        *,
        curve_type: Literal[CurveTypeEnum.IR_ZC_CURVE],
        index: Optional[str] = None,
        points: Optional[List["_models.IrZcCurvePoint"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrZcCurveInput(_model_base.Model):
    """The object defining the 3rd party interest rate zero curve.

    Attributes
    ----------
    zc_type : str or ~analyticsapi.models.ZcTypeEnum
        The type of values provided (zero coupon rates or discount factors).
        Required. Known values are: "Rate" and "DiscountFactor".
    zc_unit : str or ~analyticsapi.models.UnitEnum
        The unit of the values provided (absolute, basis point, percentage).
        Required. Known values are: "Absolute", "BasisPoint", and "Percentage".
    points : list[~analyticsapi.models.CurveDataPoint]
        The list of dates and values. Required.  The default value is None,
        needs to be assigned before using.
    index_reference : str
        The reference to the floating rate index. Required.
    """

    zc_type: Union[str, "_models.ZcTypeEnum"] = rest_field(name="zcType")
    """The type of values provided (zero coupon rates or discount factors). Required. Known values
     are: \"Rate\" and \"DiscountFactor\"."""
    zc_unit: Union[str, "_models.UnitEnum"] = rest_field(name="zcUnit")
    """The unit of the values provided (absolute, basis point, percentage). Required. Known values
     are: \"Absolute\", \"BasisPoint\", and \"Percentage\"."""
    points: List["_models.CurveDataPoint"] = rest_field()
    """The list of dates and values. Required."""
    index_reference: str = rest_field(name="indexReference")
    """The reference to the floating rate index. Required."""

    @overload
    def __init__(
        self,
        *,
        zc_type: Union[str, "_models.ZcTypeEnum"],
        zc_unit: Union[str, "_models.UnitEnum"],
        points: List["_models.CurveDataPoint"],
        index_reference: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class IrZcCurvePoint(_model_base.Model):
    """An object that contains the values applied to the interest rate curve point.

    Attributes
    ----------
    start_date : ~datetime.date
        The start date of the curve point tenor. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
    tenor : str
        The code indicating the period between the start date and the end date
        of the curve point (e.g., '1M', 1Y'). Required.
    end_date : ~datetime.date
        The end date of the curve point tenor. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2023-01-01'). Required.
    rate : ~analyticsapi.models.Rate
        The zero coupon rate. Required.
    discount_factor : ~analyticsapi.models.Rate
        The discount factor calculated for a given curve point. Required.
    instruments : list[~analyticsapi.models.CurvePointRelatedInstruments]
        An array of objects that contains instruments used to calculate the
        curve point.  The default value is None, needs to be assigned before
        using.
    """

    start_date: datetime.date = rest_field(name="startDate")
    """The start date of the curve point tenor. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., '2023-01-01'). Required."""
    tenor: str = rest_field()
    """The code indicating the period between the start date and the end date of the curve point
     (e.g., '1M', 1Y'). Required."""
    end_date: datetime.date = rest_field(name="endDate")
    """The end date of the curve point tenor. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., '2023-01-01'). Required."""
    rate: "_models.Rate" = rest_field()
    """The zero coupon rate. Required."""
    discount_factor: "_models.Rate" = rest_field(name="discountFactor")
    """The discount factor calculated for a given curve point. Required."""
    instruments: Optional[List["_models.CurvePointRelatedInstruments"]] = rest_field()
    """An array of objects that contains instruments used to calculate the curve point."""

    @overload
    def __init__(
        self,
        *,
        start_date: datetime.date,
        tenor: str,
        end_date: datetime.date,
        rate: "_models.Rate",
        discount_factor: "_models.Rate",
        instruments: Optional[List["_models.CurvePointRelatedInstruments"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JobCreationRequest(_model_base.Model):
    """JobCreationRequest.

    Attributes
    ----------
    priority : int
        Control priority of job. Requests within jobs of higher priority are
        processed prior to jobs with lower priority.
    hold : bool
        When set to true, suspends the excution of all requests in the job,
        processing resumes only after the job is updated and the value is set
        to false.
    start_after : ~datetime.datetime
    stop_after : ~datetime.datetime
    name : str
        Optional. Unique name associated with a job. There can only be one
        active job with this name. Job name can be used for all future job
        references. If a previously open job exists with the same name, the
        older job is closed before a new job is created.
    asof : ~datetime.date
    order : str
        Is one of the following types: Literal["FAST"], Literal["FIFO"],
        Literal["NONE"]
    chain : str
    desc : str
        User defined description of the job.
    """

    priority: Optional[int] = rest_field()
    """Control priority of job. Requests within jobs of higher priority are processed prior to jobs
     with lower priority."""
    hold: Optional[bool] = rest_field()
    """When set to true, suspends the excution of all requests in the job, processing resumes only
     after the job is updated and the value is set to false."""
    start_after: Optional[datetime.datetime] = rest_field(name="startAfter", format="rfc3339")
    stop_after: Optional[datetime.datetime] = rest_field(name="stopAfter", format="rfc3339")
    name: Optional[str] = rest_field()
    """Optional. Unique name associated with a job. There can only be one active job with this name.
     Job name can be used for all future job references. If a previously open job exists with the
     same name, the older job is closed before a new job is created."""
    asof: Optional[datetime.date] = rest_field()
    order: Optional[Literal["FAST", "FIFO", "NONE"]] = rest_field()
    """Is one of the following types: Literal[\"FAST\"], Literal[\"FIFO\"], Literal[\"NONE\"]"""
    chain: Optional[str] = rest_field()
    desc: Optional[str] = rest_field()
    """User defined description of the job."""

    @overload
    def __init__(
        self,
        *,
        priority: Optional[int] = None,
        hold: Optional[bool] = None,
        start_after: Optional[datetime.datetime] = None,
        stop_after: Optional[datetime.datetime] = None,
        name: Optional[str] = None,
        asof: Optional[datetime.date] = None,
        order: Optional[Literal["FAST", "FIFO", "NONE"]] = None,
        chain: Optional[str] = None,
        desc: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JobResponse(_model_base.Model):
    """JobResponse.

    Attributes
    ----------
    id : str
        Required.
    sequence : int
    as_of : ~datetime.date
    closed : bool
    on_hold : bool
    aborted : bool
    exit_status : str
        Is one of the following types: Literal["DONE"], Literal["ERROR"],
        Literal["NEVER_STARTED"], Literal["ABORTED"], Literal["TIMEOUT"],
        Literal["ABANDONED"]
    actual_hold : bool
    name : str
    chain : str
    description : str
    priority : int
    order : str
        Is one of the following types: Literal["FAST"], Literal["FIFO"],
        Literal["NONE"]
    request_count : int
    pending_count : int
    running_count : int
    ok_count : int
    error_count : int
    aborted_count : int
    skip_count : int
    start_after : ~datetime.datetime
    stop_after : ~datetime.datetime
    created_at : ~datetime.datetime
    updated_at : ~datetime.datetime
    timeline : list[~analyticsapi.models.JobTimelineEntry]
        The default value is None, needs to be assigned before using.
    """

    id: str = rest_field()
    """Required."""
    sequence: Optional[int] = rest_field()
    as_of: Optional[datetime.date] = rest_field(name="asOf")
    closed: Optional[bool] = rest_field()
    on_hold: Optional[bool] = rest_field(name="onHold")
    aborted: Optional[bool] = rest_field()
    exit_status: Optional[Literal["DONE", "ERROR", "NEVER_STARTED", "ABORTED", "TIMEOUT", "ABANDONED"]] = rest_field(
        name="exitStatus"
    )
    """Is one of the following types: Literal[\"DONE\"], Literal[\"ERROR\"],
     Literal[\"NEVER_STARTED\"], Literal[\"ABORTED\"], Literal[\"TIMEOUT\"], Literal[\"ABANDONED\"]"""
    actual_hold: Optional[bool] = rest_field(name="actualHold")
    name: Optional[str] = rest_field()
    chain: Optional[str] = rest_field()
    description: Optional[str] = rest_field()
    priority: Optional[int] = rest_field()
    order: Optional[Literal["FAST", "FIFO", "NONE"]] = rest_field()
    """Is one of the following types: Literal[\"FAST\"], Literal[\"FIFO\"], Literal[\"NONE\"]"""
    request_count: Optional[int] = rest_field(name="requestCount")
    pending_count: Optional[int] = rest_field(name="pendingCount")
    running_count: Optional[int] = rest_field(name="runningCount")
    ok_count: Optional[int] = rest_field(name="okCount")
    error_count: Optional[int] = rest_field(name="errorCount")
    aborted_count: Optional[int] = rest_field(name="abortedCount")
    skip_count: Optional[int] = rest_field(name="skipCount")
    start_after: Optional[datetime.datetime] = rest_field(name="startAfter", format="rfc3339")
    stop_after: Optional[datetime.datetime] = rest_field(name="stopAfter", format="rfc3339")
    created_at: Optional[datetime.datetime] = rest_field(name="createdAt", format="rfc3339")
    updated_at: Optional[datetime.datetime] = rest_field(name="updatedAt", format="rfc3339")
    timeline: Optional[List["_models.JobTimelineEntry"]] = rest_field()

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        sequence: Optional[int] = None,
        as_of: Optional[datetime.date] = None,
        closed: Optional[bool] = None,
        on_hold: Optional[bool] = None,
        aborted: Optional[bool] = None,
        exit_status: Optional[Literal["DONE", "ERROR", "NEVER_STARTED", "ABORTED", "TIMEOUT", "ABANDONED"]] = None,
        actual_hold: Optional[bool] = None,
        name: Optional[str] = None,
        chain: Optional[str] = None,
        description: Optional[str] = None,
        priority: Optional[int] = None,
        order: Optional[Literal["FAST", "FIFO", "NONE"]] = None,
        request_count: Optional[int] = None,
        pending_count: Optional[int] = None,
        running_count: Optional[int] = None,
        ok_count: Optional[int] = None,
        error_count: Optional[int] = None,
        aborted_count: Optional[int] = None,
        skip_count: Optional[int] = None,
        start_after: Optional[datetime.datetime] = None,
        stop_after: Optional[datetime.datetime] = None,
        created_at: Optional[datetime.datetime] = None,
        updated_at: Optional[datetime.datetime] = None,
        timeline: Optional[List["_models.JobTimelineEntry"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JobResubmissionRequest(_model_base.Model):
    """JobResubmissionRequest.

    Attributes
    ----------
    scope : str
        Is one of the following types: Literal["OK"], Literal["ERROR"],
        Literal["ABORTED"], Literal["FAILED"], Literal["ALL"]
    ids : list[str]
        The default value is None, needs to be assigned before using.
    """

    scope: Optional[Literal["OK", "ERROR", "ABORTED", "FAILED", "ALL"]] = rest_field()
    """Is one of the following types: Literal[\"OK\"], Literal[\"ERROR\"], Literal[\"ABORTED\"],
     Literal[\"FAILED\"], Literal[\"ALL\"]"""
    ids: Optional[List[str]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        scope: Optional[Literal["OK", "ERROR", "ABORTED", "FAILED", "ALL"]] = None,
        ids: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JobStatusResponse(_model_base.Model):
    """JobStatusResponse.

    Attributes
    ----------
    id : str
    name : str
    job_status : str
        Is one of the following types: Literal["OPEN"], Literal["EMPTY"],
        Literal["HOLD"], Literal["CLOSED"], Literal["DONE"], Literal["ABORTED"]
    as_of : ~datetime.date
    start_time : ~datetime.datetime
    run_time : str
    pool_id : str
    priority : int
    can_manage : bool
    request_count : int
    pending_count : int
    running_count : int
    ok_count : int
    error_count : int
    aborted_count : int
    skipped_count : int
    """

    id: Optional[str] = rest_field()
    name: Optional[str] = rest_field()
    job_status: Optional[Literal["OPEN", "EMPTY", "HOLD", "CLOSED", "DONE", "ABORTED"]] = rest_field(name="jobStatus")
    """Is one of the following types: Literal[\"OPEN\"], Literal[\"EMPTY\"], Literal[\"HOLD\"],
     Literal[\"CLOSED\"], Literal[\"DONE\"], Literal[\"ABORTED\"]"""
    as_of: Optional[datetime.date] = rest_field(name="asOf")
    start_time: Optional[datetime.datetime] = rest_field(name="startTime", format="rfc3339")
    run_time: Optional[str] = rest_field(name="runTime")
    pool_id: Optional[str] = rest_field(name="poolId")
    priority: Optional[int] = rest_field()
    can_manage: Optional[bool] = rest_field(name="canManage")
    request_count: Optional[int] = rest_field(name="requestCount")
    pending_count: Optional[int] = rest_field(name="pendingCount")
    running_count: Optional[int] = rest_field(name="runningCount")
    ok_count: Optional[int] = rest_field(name="okCount")
    error_count: Optional[int] = rest_field(name="errorCount")
    aborted_count: Optional[int] = rest_field(name="abortedCount")
    skipped_count: Optional[int] = rest_field(name="skippedCount")

    @overload
    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        name: Optional[str] = None,
        job_status: Optional[Literal["OPEN", "EMPTY", "HOLD", "CLOSED", "DONE", "ABORTED"]] = None,
        as_of: Optional[datetime.date] = None,
        start_time: Optional[datetime.datetime] = None,
        run_time: Optional[str] = None,
        pool_id: Optional[str] = None,
        priority: Optional[int] = None,
        can_manage: Optional[bool] = None,
        request_count: Optional[int] = None,
        pending_count: Optional[int] = None,
        running_count: Optional[int] = None,
        ok_count: Optional[int] = None,
        error_count: Optional[int] = None,
        aborted_count: Optional[int] = None,
        skipped_count: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JobTimelineEntry(_model_base.Model):
    """JobTimelineEntry.

    Attributes
    ----------
    ts : ~datetime.datetime
        Required.
    ok_count : int
        Required.
    error_count : int
        Required.
    interval : int
        Required.
    """

    ts: datetime.datetime = rest_field(format="rfc3339")
    """Required."""
    ok_count: int = rest_field(name="okCount")
    """Required."""
    error_count: int = rest_field(name="errorCount")
    """Required."""
    interval: int = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        *,
        ts: datetime.datetime,
        ok_count: int,
        error_count: int,
        interval: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class JsonRef(_model_base.Model):
    """Container for JSON formated references.

    Attributes
    ----------
    d_ref : str
    """

    d_ref: Optional[str] = rest_field(name="$ref")

    @overload
    def __init__(
        self,
        d_ref: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["d_ref"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class JsonScenRef(_model_base.Model):
    """JsonScenRef.

    Attributes
    ----------
    d_ref : str
        This can be a job store reference or system user scenario.

          System scenarios - Shorthand notation for scenarios that have simple shift. Scenarios can be
        defined using the below format

        *
          /sys/scenario/{ShiftType}/{Shift in bps}

          Example 1 - Parallel shift of 50 bps

        *
          /sys/scenario/Par/50

          Example 2 - Forward shift of -150 bps

        *
          /sys/scenario/Fwd/-150

          Valid values for Shift type are Par, Spot, Fwd, ImplFwd (short notation)

          If you would like to make changes to other scenario setup fields like timing etc, use the
        below

        *
          /sys/scenario/Fwd/50?timing=Immediate&reinvestmentRate=Default&swapSpreadConst=true.
    """

    d_ref: Optional[str] = rest_field(name="$ref")
    """This can be a job store reference or system user scenario.
     
       System scenarios - Shorthand notation for scenarios that have simple shift. Scenarios can be
     defined using the below format
     
     
     *
       /sys/scenario/{ShiftType}/{Shift in bps}
     
       Example 1 - Parallel shift of 50 bps
     
     *
       /sys/scenario/Par/50
     
       Example 2 - Forward shift of -150 bps
     
     *
       /sys/scenario/Fwd/-150
     
       Valid values for Shift type are Par, Spot, Fwd, ImplFwd (short notation)
     
       If you would like to make changes to other scenario setup fields like timing etc, use the
     below
     
     *
       /sys/scenario/Fwd/50?timing=Immediate&reinvestmentRate=Default&swapSpreadConst=true."""

    @overload
    def __init__(
        self,
        d_ref: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["d_ref"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class RescheduleDescription(ABC, _model_base.Model):
    """An object to determine a holiday rescheduling.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    LagDaysRescheduleDescription, RelativeRescheduleDescription

    Attributes
    ----------
    reschedule_type : str or ~analyticsapi.models.RescheduleType
        The type of rescheduling for the observation period. Required. Known
        values are: "LagDaysRescheduleDescription" and
        "RelativeRescheduleDescription".
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    reschedule_type: str = rest_discriminator(name="rescheduleType")
    """The type of rescheduling for the observation period. Required. Known values are:
     \"LagDaysRescheduleDescription\" and \"RelativeRescheduleDescription\"."""

    @overload
    def __init__(
        self,
        reschedule_type: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["reschedule_type"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class LagDaysRescheduleDescription(RescheduleDescription, discriminator="LagDaysRescheduleDescription"):
    """An object to determine the rule for rescheduling a holiday using day lags.

    Attributes
    ----------
    reschedule_type : str or ~analyticsapi.models.LAG_DAYS_RESCHEDULE_DESCRIPTION
        The type of rescheduling for the observation period. Only
        LagDaysRescheduleDescription value applies. Required. The rule for
        rescheduling a holiday using day lags. For example, if a holiday falls
        on Sunday, it is rescheduled by the number of days defined by the lag.
    lag_days : int
        The length of the lag in days. The holiday will be rescheduled to a
        date this many days in the future. Value can be negative. Required.
    """

    reschedule_type: Literal[RescheduleType.LAG_DAYS_RESCHEDULE_DESCRIPTION] = rest_discriminator(name="rescheduleType")  # type: ignore # pylint: disable=line-too-long
    """The type of rescheduling for the observation period. Only LagDaysRescheduleDescription value
     applies. Required. The rule for rescheduling a holiday using day lags. For example, if a
     holiday falls on Sunday, it is rescheduled by the number of days defined by the lag."""
    lag_days: int = rest_field(name="lagDays")
    """The length of the lag in days. The holiday will be rescheduled to a date this many days in the
     future. Value can be negative. Required."""

    @overload
    def __init__(
        self,
        lag_days: int,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, reschedule_type=RescheduleType.LAG_DAYS_RESCHEDULE_DESCRIPTION, **kwargs)


class LinkRef(_model_base.Model):
    """An object representing a hyperlink to a related resource, including its URL, optional schema,
    and HTTP method.

    Attributes
    ----------
    href : str
        The URL reference to the related resource. Required.
    href_schema : str
        The URL to the schema definition for the referenced resource.
    http_method : str
        The HTTP method (e.g., GET, POST) to be used when accessing the
        referenced resource.
    """

    href: str = rest_field()
    """The URL reference to the related resource. Required."""
    href_schema: Optional[str] = rest_field(name="hrefSchema")
    """The URL to the schema definition for the referenced resource."""
    http_method: Optional[str] = rest_field(name="httpMethod")
    """The HTTP method (e.g., GET, POST) to be used when accessing the referenced resource."""

    @overload
    def __init__(
        self,
        *,
        href: str,
        href_schema: Optional[str] = None,
        http_method: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Loan(_model_base.Model):
    """The resource used to create, save and analyze a loan instrument.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.LOAN
        Property defining the type of the resource.
    id : str
        Unique identifier of the Loan.
    location : ~analyticsapi.models.Location
        Object defining the location of the Loan in the platform. Required.
    description : ~analyticsapi.models.Description
        Object defining metadata for the Loan.
    definition : ~analyticsapi.models.LoanDefinition
        Object defining the Loan. Required.
    """

    type: Optional[Literal[ResourceType.LOAN]] = rest_field(visibility=["read"], default=ResourceType.LOAN)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the Loan."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining the location of the Loan in the platform. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining metadata for the Loan."""
    definition: "_models.LoanDefinition" = rest_field()
    """Object defining the Loan. Required."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        definition: "_models.LoanDefinition",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanAsCollectionItem(_model_base.Model):
    """A model template defining the partial description of the resource returned by the GET list
    service.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.LOAN
        Property defining the type of the resource.
    id : str
        Unique identifier of the Loan.
    location : ~analyticsapi.models.Location
        Object defining metadata for the Loan. Required.
    description : ~analyticsapi.models.Description
        Object defining the Loan.
    """

    type: Optional[Literal[ResourceType.LOAN]] = rest_field(visibility=["read"], default=ResourceType.LOAN)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the Loan."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining metadata for the Loan. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining the Loan."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanCollectionLinks(_model_base.Model):
    """LoanCollectionLinks.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanCollectionResponse(_model_base.Model):
    """A model template describing a paged response.

    Attributes
    ----------
    data : list[~analyticsapi.models.LoanAsCollectionItem]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.LoanCollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.LoanAsCollectionItem"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.LoanCollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.LoanAsCollectionItem"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.LoanCollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanDefinition(InterestRateLegDefinition):
    """The description of a loan.

    Attributes
    ----------
    rate : ~analyticsapi.models.InterestRateDefinition
        An object that defines the interest rate settings. Required.
    interest_periods : ~analyticsapi.models.ScheduleDefinition
        An object that defines the schedule of interest periods. Required.
    payment_offset : ~analyticsapi.models.OffsetDefinition
        An object that defines how the payment dates are derived from the
        interest period dates.
    coupon_day_count : str or ~analyticsapi.models.DayCountBasis
        The day count basis method that defines how the year fraction of the
        coupon period is computed. If not defined, the market convention
        related to the leg currency applies. Known values are: "Dcb_30_360",
        "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
        "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
        "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
        "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA",
        "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", and "Dcb_Actual_365_CanadianConvention".
    accrual_day_count : str or ~analyticsapi.models.DayCountBasis
        The day count basis method that defines how the year fraction of the
        accrual period is computed. If not defined, the market convention
        related to the leg currency applies. Known values are: "Dcb_30_360",
        "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
        "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
        "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
        "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA",
        "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", and "Dcb_Actual_365_CanadianConvention".
    principal : ~analyticsapi.models.PrincipalDefinition
        An object that defines the principal used to calculate interest
        payments. It can also be exchanged between parties. Required.
    settlement : ~analyticsapi.models.PaymentSettlementDefinition
        Settlement parameters for interest payments. If not specified, payments
        are settled in 'principal' currency. Required when 'isNonDeliverable'
        property is activated, to define the settlement currency and related
        details.
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that makes the payment. Required. Known
        values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that receives the payment. Required. Known
        values are: "Party1" and "Party2".
    """

    @overload
    def __init__(
        self,
        *,
        rate: "_models.InterestRateDefinition",
        interest_periods: "_models.ScheduleDefinition",
        principal: "_models.PrincipalDefinition",
        payer: Union[str, "_models.PartyEnum"],
        receiver: Union[str, "_models.PartyEnum"],
        payment_offset: Optional["_models.OffsetDefinition"] = None,
        coupon_day_count: Optional[Union[str, "_models.DayCountBasis"]] = None,
        accrual_day_count: Optional[Union[str, "_models.DayCountBasis"]] = None,
        settlement: Optional["_models.PaymentSettlementDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.LoanDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.LoanDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.LoanDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanInstrumentArraySolveResponse(_model_base.Model):
    """The solve response of the loans that are defined as part of a request.

    Attributes
    ----------
    data : ~analyticsapi.models.LoanInstrumentSolveResponseFieldsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.LoanInstrumentSolveResponseFieldsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.LoanInstrumentSolveResponseFieldsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class LoanInstrumentArrayValuationResponse(_model_base.Model):
    """The valuation response of the loans that are defined as part of a request.

    Attributes
    ----------
    data : ~analyticsapi.models.LoanInstrumentValuationResponseFieldsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.LoanInstrumentValuationResponseFieldsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.LoanInstrumentValuationResponseFieldsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class LoanInstrumentDescriptionFields(_model_base.Model):
    """An object that contains fields related to the loan description.

    Attributes
    ----------
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and the characters  '- _.#=@' are
        supported.
    instrument_description : str
        The label that describes the instrument. Required.
    start_date : ~datetime.date
        The start date of the instrument. This value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., 2021-01-01). Required.
    end_date : ~datetime.date
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DD (e.g., 2021-01-01). Required.
    tenor : str
        The code indicating the period between startDate and endDate of the
        instrument (e.g., '6M', '1Y'). A tenor expresses a period of time using
        a specific syntax. There are two kinds of tenor:

        * Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and
        Years (Y).
          For example "1D" for one day, "2W" for two weeks or "3M1D" for three months and a day.
          When mixing units, units must be written in descending order of size (Y > M > W > D).  So,
        5M3D is valid, but 3D5M is not.
        * Common tenors are expressed as letter codes:
        * ON (Overnight) - A one business day period that starts today.
        * TN (Tomorrow-Next) - A one business day period that starts next business day.
        * SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date
        (today) + days to spot.
        * SN (Spot-Next) - A one business day period that starts at the spot date.
        * SW (Spot-Week) - A one business week period that starts at the spot date. Required.
    """

    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and the characters
     '- _.#=@' are supported."""
    instrument_description: str = rest_field(name="instrumentDescription")
    """The label that describes the instrument. Required."""
    start_date: datetime.date = rest_field(name="startDate")
    """The start date of the instrument. This value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
     2021-01-01). Required."""
    end_date: datetime.date = rest_field(name="endDate")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., 2021-01-01). Required."""
    tenor: str = rest_field()
    """The code indicating the period between startDate and endDate of the instrument (e.g., '6M',
     '1Y').
     A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:
     
     
     * Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and
     Years (Y).
       For example \"1D\" for one day, \"2W\" for two weeks or \"3M1D\" for three months and a day.
       When mixing units, units must be written in descending order of size (Y > M > W > D).  So,
     5M3D is valid, but 3D5M is not.
     * Common tenors are expressed as letter codes:
     * ON (Overnight) - A one business day period that starts today.
     * TN (Tomorrow-Next) - A one business day period that starts next business day.
     * SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date
     (today) + days to spot.
     * SN (Spot-Next) - A one business day period that starts at the spot date.
     * SW (Spot-Week) - A one business week period that starts at the spot date. Required."""

    @overload
    def __init__(
        self,
        *,
        instrument_description: str,
        start_date: datetime.date,
        end_date: datetime.date,
        tenor: str,
        instrument_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanInstrumentRiskFields(IrRiskFields):
    """An object that contains fields related to loan risk assessment.

    Attributes
    ----------
    duration : ~analyticsapi.models.IrMeasure
        An object that describes the weighted average maturity in years of all
        cash flows. The final cash flow includes the principal, which has a
        much greater weight than the intermediate cash flows. Required.
    modified_duration : ~analyticsapi.models.IrMeasure
        An object that describes the measure of price sensitivity in percent to
        a 100 basis points change in the instrument's yield, or a 1% parallel
        shift in the underlying zero-coupon curve. For a floating rate
        instrument, it is computed as time to next payment. Required.
    benchmark_hedge_notional : ~analyticsapi.models.Amount
        An object that specifies the notional amount of the benchmark
        instrument that allows to hedge the instrument (available for IRS
        only). The value is expressed in the deal currency. It is computed for
        instrument legs only. Required.
    annuity : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value of
        the fixed rate leg to a 1bp shift in the fixed rate. Required.
    dv01 : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value to a
        1bp parallel shift in the zero-coupon curve. Required.
    pv01 : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value to a
        1bp parallel shift in the yield curve. Required.
    br01 : ~analyticsapi.models.IrMeasure
        An object that describes the sensitivity of the net present value to a
        1bp shift of Currency Basis Swap (CBS) spreads. Required.
    """

    @overload
    def __init__(
        self,
        *,
        duration: "_models.IrMeasure",
        modified_duration: "_models.IrMeasure",
        benchmark_hedge_notional: "_models.Amount",
        annuity: "_models.IrMeasure",
        dv01: "_models.IrMeasure",
        pv01: "_models.IrMeasure",
        br01: "_models.IrMeasure",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanInstrumentSolveResponse(_model_base.Model):
    """The solve response of a loan that is already on the platform.

    Attributes
    ----------
    data : ~analyticsapi.models.LoanInstrumentSolveResponseFieldsOnResourceResponseData
        Required.
    """

    data: "_models.LoanInstrumentSolveResponseFieldsOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.LoanInstrumentSolveResponseFieldsOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class LoanInstrumentSolveResponseFieldsOnResourceResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """LoanInstrumentSolveResponseFieldsOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.Loan
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.IrPricingParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.LoanInstrumentSolveResponseFieldsResponseWithError
        The result of the calculation request.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    resource: Optional["_models.Loan"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.IrPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.LoanInstrumentSolveResponseFieldsResponseWithError"] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.Loan"] = None,
        pricing_preferences: Optional["_models.IrPricingParameters"] = None,
        analytics: Optional["_models.LoanInstrumentSolveResponseFieldsResponseWithError"] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanInstrumentSolveResponseFieldsResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """LoanInstrumentSolveResponseFieldsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.LoanDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.IrPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.LoanInstrumentSolveResponseFieldsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.LoanDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.IrPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.LoanInstrumentSolveResponseFieldsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.LoanDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.IrPricingParameters"] = None,
        analytics: Optional[List["_models.LoanInstrumentSolveResponseFieldsResponseWithError"]] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanInstrumentSolveResponseFieldsResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    solving : ~analyticsapi.models.SolvingResult
        An object that contains the loan solving result. Required.
    description : ~analyticsapi.models.LoanInstrumentDescriptionFields
        An object that contains fields related to the loan description.
        Required.
    valuation : ~analyticsapi.models.LoanInstrumentValuationFields
        An object that contains fields related to the loan valuation.
    risk : ~analyticsapi.models.LoanInstrumentRiskFields
        An object that contains fields related to the loan risk assessment.
    cashflows : list[~analyticsapi.models.Cashflow]
        The default value is None, needs to be assigned before using.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    solving: "_models.SolvingResult" = rest_field()
    """An object that contains the loan solving result. Required."""
    description: "_models.LoanInstrumentDescriptionFields" = rest_field()
    """An object that contains fields related to the loan description. Required."""
    valuation: Optional["_models.LoanInstrumentValuationFields"] = rest_field()
    """An object that contains fields related to the loan valuation."""
    risk: Optional["_models.LoanInstrumentRiskFields"] = rest_field()
    """An object that contains fields related to the loan risk assessment."""
    cashflows: Optional[List["_models.Cashflow"]] = rest_field()
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        solving: "_models.SolvingResult",
        description: "_models.LoanInstrumentDescriptionFields",
        valuation: Optional["_models.LoanInstrumentValuationFields"] = None,
        risk: Optional["_models.LoanInstrumentRiskFields"] = None,
        cashflows: Optional[List["_models.Cashflow"]] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanInstrumentValuationFields(IrValuationFields):
    """An object that contains fields related to the loan valuation.

    Attributes
    ----------
    accrued : ~analyticsapi.models.IrMeasure
        An object that describes accrued interest that is accumulated but not
        paid out. Required.
    market_value : ~analyticsapi.models.IrMeasure
        An object that describes the market value of the instrument. Required.
    clean_market_value : ~analyticsapi.models.IrMeasure
        An object that describes the market value of the instrument less any
        accrued interest. Required.
    """

    @overload
    def __init__(
        self,
        *,
        accrued: "_models.IrMeasure",
        market_value: "_models.IrMeasure",
        clean_market_value: "_models.IrMeasure",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanInstrumentValuationResponse(_model_base.Model):
    """The valuation response of a loan that is already on the platform.

    Attributes
    ----------
    data : ~analyticsapi.models.LoanInstrumentValuationResponseFieldsOnResourceResponseData
        Required.
    """

    data: "_models.LoanInstrumentValuationResponseFieldsOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.LoanInstrumentValuationResponseFieldsOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class LoanInstrumentValuationResponseFieldsOnResourceResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """LoanInstrumentValuationResponseFieldsOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.Loan
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.IrPricingParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.LoanInstrumentValuationResponseFieldsResponseWithError
        The result of the calculation request.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    resource: Optional["_models.Loan"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.IrPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.LoanInstrumentValuationResponseFieldsResponseWithError"] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.Loan"] = None,
        pricing_preferences: Optional["_models.IrPricingParameters"] = None,
        analytics: Optional["_models.LoanInstrumentValuationResponseFieldsResponseWithError"] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanInstrumentValuationResponseFieldsResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """LoanInstrumentValuationResponseFieldsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.LoanDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.IrPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.LoanInstrumentValuationResponseFieldsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.LoanDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.IrPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.LoanInstrumentValuationResponseFieldsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.LoanDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.IrPricingParameters"] = None,
        analytics: Optional[List["_models.LoanInstrumentValuationResponseFieldsResponseWithError"]] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanInstrumentValuationResponseFieldsResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    description : ~analyticsapi.models.LoanInstrumentDescriptionFields
        An object that contains fields related to the loan description.
        Required.
    valuation : ~analyticsapi.models.LoanInstrumentValuationFields
        An object that contains fields related to the loan valuation.
    risk : ~analyticsapi.models.LoanInstrumentRiskFields
        An object that contains fields related to the loan risk assessment.
    cashflows : list[~analyticsapi.models.Cashflow]
        The default value is None, needs to be assigned before using.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    description: "_models.LoanInstrumentDescriptionFields" = rest_field()
    """An object that contains fields related to the loan description. Required."""
    valuation: Optional["_models.LoanInstrumentValuationFields"] = rest_field()
    """An object that contains fields related to the loan valuation."""
    risk: Optional["_models.LoanInstrumentRiskFields"] = rest_field()
    """An object that contains fields related to the loan risk assessment."""
    cashflows: Optional[List["_models.Cashflow"]] = rest_field()
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        description: "_models.LoanInstrumentDescriptionFields",
        valuation: Optional["_models.LoanInstrumentValuationFields"] = None,
        risk: Optional["_models.LoanInstrumentRiskFields"] = None,
        cashflows: Optional[List["_models.Cashflow"]] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LoanResponse(_model_base.Model):
    """A model template describing a single response.

    Attributes
    ----------
    data : ~analyticsapi.models.Loan
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.Loan" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.Loan",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Location(_model_base.Model):
    """An object identifying a resource by a combination of its name and the space where it's saved on
    the platform.

    Attributes
    ----------
    space : str
        The space in which the resource is saved.
    name : str
        The name of the resource. Required.
    """

    space: Optional[str] = rest_field()
    """The space in which the resource is saved."""
    name: str = rest_field()
    """The name of the resource. Required."""

    @overload
    def __init__(
        self,
        *,
        name: str,
        space: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LongEndShift(_model_base.Model):
    """LongEndShift.

    Attributes
    ----------
    amount : float
        Amount of shifting, applied to points depending on shift method
        selected. Can be measured in basis points/percents/future price based
        points. Also can be expressed as multiplier for relative shift type.
    ignore_quotation_scale : bool
    shift_type : str or ~analyticsapi.models.ShiftTypeEnum
        The type of shifting. The possible values are:   * Additive: the amount
        of shifting is added to the corresponding curve point,   * Relative:
        the curve point is multiplied by the amount of shifting (e.g., if
        amount = 1, the curve point value will be doubled),   * Scaled: the
        curve point is scaled by the value of the shifting amount (e.g., if
        amount = 1.1, the curve point value will multiplied by this value).
        Known values are: "Additive", "Relative", and "Scaled".
    shift_unit : str or ~analyticsapi.models.ShiftUnitEnum
        The unit that describes the amount of shifting. The possible values
        are:   * Absolute: the amount of shifting is expressed in absolute
        value.   * Bp: the amount of shifting is expressed in basis points,   *
        Percent: the amount of shifting is expressed in percentages,. Known
        values are: "Absolute", "Bp", and "Percent".
    """

    amount: Optional[float] = rest_field()
    """Amount of shifting, applied to points depending on shift method selected. Can be measured in
     basis points/percents/future price based points. Also can be expressed as multiplier for
     relative shift type."""
    ignore_quotation_scale: Optional[bool] = rest_field(name="ignoreQuotationScale")
    shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = rest_field(name="shiftType")
    """The type of shifting. The possible values are:   * Additive: the amount of shifting is added to
     the corresponding curve point,   * Relative: the curve point is multiplied by the amount of
     shifting (e.g., if amount = 1, the curve point value will be doubled),   * Scaled: the curve
     point is scaled by the value of the shifting amount (e.g., if amount = 1.1, the curve point
     value will multiplied by this value). Known values are: \"Additive\", \"Relative\", and
     \"Scaled\"."""
    shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = rest_field(name="shiftUnit")
    """The unit that describes the amount of shifting. The possible values are:   * Absolute: the
     amount of shifting is expressed in absolute value.   * Bp: the amount of shifting is expressed
     in basis points,   * Percent: the amount of shifting is expressed in percentages,. Known values
     are: \"Absolute\", \"Bp\", and \"Percent\"."""

    @overload
    def __init__(
        self,
        *,
        amount: Optional[float] = None,
        ignore_quotation_scale: Optional[bool] = None,
        shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = None,
        shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LookbackSettings(_model_base.Model):
    """LookbackSettings.

    Attributes
    ----------
    basis_lookback_days : int
    curve_lookback_days : int
    volatility_lookback_days : int
    ccoas_lookback_days : int
    mortgage_date_lookback_days : int
    curve_date_shift_lookback_days : int
    curve_date_roll_lookback : bool
    """

    basis_lookback_days: Optional[int] = rest_field(name="basisLookbackDays")
    curve_lookback_days: Optional[int] = rest_field(name="curveLookbackDays")
    volatility_lookback_days: Optional[int] = rest_field(name="volatilityLookbackDays")
    ccoas_lookback_days: Optional[int] = rest_field(name="ccoasLookbackDays")
    mortgage_date_lookback_days: Optional[int] = rest_field(name="mortgageDateLookbackDays")
    curve_date_shift_lookback_days: Optional[int] = rest_field(name="curveDateShiftLookbackDays")
    curve_date_roll_lookback: Optional[bool] = rest_field(name="curveDateRollLookback")

    @overload
    def __init__(
        self,
        *,
        basis_lookback_days: Optional[int] = None,
        curve_lookback_days: Optional[int] = None,
        volatility_lookback_days: Optional[int] = None,
        ccoas_lookback_days: Optional[int] = None,
        mortgage_date_lookback_days: Optional[int] = None,
        curve_date_shift_lookback_days: Optional[int] = None,
        curve_date_roll_lookback: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LookupDetails(_model_base.Model):
    """LookupDetails.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    table : str
        Required.
    show : str
    default : any
    default_value : any
    """

    table: str = rest_field()
    """Required."""
    show: Optional[str] = rest_field()
    default: Optional[Any] = rest_field()
    default_value: Optional[Any] = rest_field(name="defaultValue")

    @overload
    def __init__(
        self,
        *,
        table: str,
        show: Optional[str] = None,
        default: Optional[Any] = None,
        default_value: Optional[Any] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class LossSettings(_model_base.Model):
    """Only used for securities that are modeled with losses.

    Attributes
    ----------
    default_type : str
        Required. Loss determination type. Is one of the following types:
        Literal["SDA"], Literal["CDR"], Literal["MODEL"]
    default_rate : float
        Number that specifies the default rate. Either defaultRate or default
        Vector is required.
    default_vector : ~analyticsapi.models.Vector
    severity_type : str
        Default loss severity type selection. Is either a Literal["PERCENT"]
        type or a Literal["MODEL"] type.
    severity_rate : float
        If severity type is set to percent, this is the severity percentage. If
        set to model, this is loss model speed. Baseline speed is 100. Either
        severityRate or severityVector is required.
    severity_vector : ~analyticsapi.models.Vector
    recovery_lag : int
        Required if severityType = PERCENT. The expected number of months from
        the time of date of an assumed default until the receipt of the assumed
        recovery on defaulted assets.
    delinquency_type : str
        Is one of the following types: Literal["PERCENT"], Literal["PASS"],
        Literal["FAIL"], Literal["MODEL"]
    delinquency_rate : float
        If delinquency type is PERCENT, this is the delinquency percentage. If
        type is MODEL, this is the model speed. Baseline model speed is 100.
        Either delinquencyRate or delinquencyVector is required.
    delinquency_vector : ~analyticsapi.models.Vector
        A month/rate vector that specifies delinquency amount. Either
        delinquencyRate or delinquencyVector is required.
    use_model_loan_modifications : bool
        Optional. Choose whether or not to use loan modifications that are
        assumed/projected by the our proprietary, internal models.
    ignore_insurance : bool
        Optional. Choose whether or not to incorporate mortgage insurance into
        loss projections.
    """

    default_type: Optional[Literal["SDA", "CDR", "MODEL"]] = rest_field(name="defaultType")
    """Required. Loss determination type. Is one of the following types: Literal[\"SDA\"],
     Literal[\"CDR\"], Literal[\"MODEL\"]"""
    default_rate: Optional[float] = rest_field(name="defaultRate")
    """Number that specifies the default rate. Either defaultRate or default Vector is required."""
    default_vector: Optional["_models.Vector"] = rest_field(name="defaultVector")
    severity_type: Optional[Literal["PERCENT", "MODEL"]] = rest_field(name="severityType")
    """Default loss severity type selection. Is either a Literal[\"PERCENT\"] type or a
     Literal[\"MODEL\"] type."""
    severity_rate: Optional[float] = rest_field(name="severityRate")
    """If severity type is set to percent, this is the severity percentage. If set to model, this is
     loss model speed. Baseline speed is 100. Either severityRate or severityVector is required."""
    severity_vector: Optional["_models.Vector"] = rest_field(name="severityVector")
    recovery_lag: Optional[int] = rest_field(name="recoveryLag")
    """Required if severityType = PERCENT. The expected number of months from the time of date of an
     assumed default until the receipt of the assumed recovery on defaulted assets."""
    delinquency_type: Optional[Literal["PERCENT", "PASS", "FAIL", "MODEL"]] = rest_field(name="delinquencyType")
    """Is one of the following types: Literal[\"PERCENT\"], Literal[\"PASS\"], Literal[\"FAIL\"],
     Literal[\"MODEL\"]"""
    delinquency_rate: Optional[float] = rest_field(name="delinquencyRate")
    """If delinquency type is PERCENT, this is the delinquency percentage. If type is MODEL, this is
     the model speed. Baseline model speed is 100. Either delinquencyRate or delinquencyVector is
     required."""
    delinquency_vector: Optional["_models.Vector"] = rest_field(name="delinquencyVector")
    """A month/rate vector that specifies delinquency amount. Either delinquencyRate or
     delinquencyVector is required."""
    use_model_loan_modifications: Optional[bool] = rest_field(name="useModelLoanModifications")
    """Optional. Choose whether or not to use loan modifications that are assumed/projected by the our
     proprietary, internal models."""
    ignore_insurance: Optional[bool] = rest_field(name="ignoreInsurance")
    """Optional. Choose whether or not to incorporate mortgage insurance into loss projections."""

    @overload
    def __init__(
        self,
        *,
        default_type: Optional[Literal["SDA", "CDR", "MODEL"]] = None,
        default_rate: Optional[float] = None,
        default_vector: Optional["_models.Vector"] = None,
        severity_type: Optional[Literal["PERCENT", "MODEL"]] = None,
        severity_rate: Optional[float] = None,
        severity_vector: Optional["_models.Vector"] = None,
        recovery_lag: Optional[int] = None,
        delinquency_type: Optional[Literal["PERCENT", "PASS", "FAIL", "MODEL"]] = None,
        delinquency_rate: Optional[float] = None,
        delinquency_vector: Optional["_models.Vector"] = None,
        use_model_loan_modifications: Optional[bool] = None,
        ignore_insurance: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MappedResponseRefData(_model_base.Model):
    """Bond indicative response data from the server. It returns a generic container of data contaning
    a combined dataset of all available instrument types, with only dedicated data filled out. For
    more information check 'Results' model documentation.

    Attributes
    ----------
    meta : ~analyticsapi.models.RefDataMeta
        Required.
    results : list[~analyticsapi.models.Results]
        Required.  The default value is None, needs to be assigned before
        using.
    """

    meta: "_models.RefDataMeta" = rest_field()
    """Required."""
    results: List["_models.Results"] = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        *,
        meta: "_models.RefDataMeta",
        results: List["_models.Results"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MarketData(_model_base.Model):
    """model describing the data that may be provided to control the market data, curves, surfaces to
    be used in analytic computations.

    Attributes
    ----------
    fx_forward_curves : list[~analyticsapi.models.FxForwardCurveChoice]
        The list of fx forward curves per currency. This is used to generate fx
        forward rates.  The default value is None, needs to be assigned before
        using.
    ir_curves : list[~analyticsapi.models.IrCurveChoice]
        The list of interest rate curves per interest reference index. This is
        used to generate forward interest rates.  The default value is None,
        needs to be assigned before using.
    discount_curves : list[~analyticsapi.models.IrCurveChoice]
        The list of discount curves per currency. This is used to generate
        discount factors.  The default value is None, needs to be assigned
        before using.
    credit_curves : list[~analyticsapi.models.CreditCurveChoice]
        The list of risky curves per reference entity. This is used to generate
        risky interest rate or discount factors.  The default value is None,
        needs to be assigned before using.
    eq_option_vol_surface : list[~analyticsapi.models.EqOptionVolSurfaceChoice]
        The list of volatility surfaces per reference entity. This is used to
        generate equity option volatilities.  The default value is None, needs
        to be assigned before using.
    fx_option_vol_surface : list[~analyticsapi.models.FxOptionVolSurfaceChoice]
        The list of volatility surfaces per currency pair. This is used to
        generate fx option volatilities.  The default value is None, needs to
        be assigned before using.
    cmdty_option_vol_surface : list[~analyticsapi.models.CmdtyOptionVolSurfaceChoice]
        The list of volatility surfaces per commodity contract. This is used to
        generate commodity option volatilities.  The default value is None,
        needs to be assigned before using.
    ir_cap_vol_surface : list[~analyticsapi.models.IrCapVolSurfaceChoice]
        The list of volatility surfaces per interest reference index. This is
        used to generate cap or floor volatilities.  The default value is None,
        needs to be assigned before using.
    ir_swaption_vol_cube : list[~analyticsapi.models.IrSwaptionVolCubeChoice]
        The list of volatility cubes per interest reference index. This is used
        to generate swaption volatilities.  The default value is None, needs to
        be assigned before using.
    """

    fx_forward_curves: Optional[List["_models.FxForwardCurveChoice"]] = rest_field(name="fxForwardCurves")
    """The list of fx forward curves per currency. This is used to generate fx forward rates."""
    ir_curves: Optional[List["_models.IrCurveChoice"]] = rest_field(name="irCurves")
    """The list of interest rate curves per interest reference index. This is used to generate forward
     interest rates."""
    discount_curves: Optional[List["_models.IrCurveChoice"]] = rest_field(name="discountCurves")
    """The list of discount curves per currency. This is used to generate discount factors."""
    credit_curves: Optional[List["_models.CreditCurveChoice"]] = rest_field(name="creditCurves")
    """The list of risky curves per reference entity. This is used to generate risky interest rate or
     discount factors."""
    eq_option_vol_surface: Optional[List["_models.EqOptionVolSurfaceChoice"]] = rest_field(name="eqOptionVolSurface")
    """The list of volatility surfaces per reference entity. This is used to generate equity option
     volatilities."""
    fx_option_vol_surface: Optional[List["_models.FxOptionVolSurfaceChoice"]] = rest_field(name="fxOptionVolSurface")
    """The list of volatility surfaces per currency pair. This is used to generate fx option
     volatilities."""
    cmdty_option_vol_surface: Optional[List["_models.CmdtyOptionVolSurfaceChoice"]] = rest_field(
        name="cmdtyOptionVolSurface"
    )
    """The list of volatility surfaces per commodity contract. This is used to generate commodity
     option volatilities."""
    ir_cap_vol_surface: Optional[List["_models.IrCapVolSurfaceChoice"]] = rest_field(name="irCapVolSurface")
    """The list of volatility surfaces per interest reference index. This is used to generate cap or
     floor volatilities."""
    ir_swaption_vol_cube: Optional[List["_models.IrSwaptionVolCubeChoice"]] = rest_field(name="irSwaptionVolCube")
    """The list of volatility cubes per interest reference index. This is used to generate swaption
     volatilities."""

    @overload
    def __init__(
        self,
        *,
        fx_forward_curves: Optional[List["_models.FxForwardCurveChoice"]] = None,
        ir_curves: Optional[List["_models.IrCurveChoice"]] = None,
        discount_curves: Optional[List["_models.IrCurveChoice"]] = None,
        credit_curves: Optional[List["_models.CreditCurveChoice"]] = None,
        eq_option_vol_surface: Optional[List["_models.EqOptionVolSurfaceChoice"]] = None,
        fx_option_vol_surface: Optional[List["_models.FxOptionVolSurfaceChoice"]] = None,
        cmdty_option_vol_surface: Optional[List["_models.CmdtyOptionVolSurfaceChoice"]] = None,
        ir_cap_vol_surface: Optional[List["_models.IrCapVolSurfaceChoice"]] = None,
        ir_swaption_vol_cube: Optional[List["_models.IrSwaptionVolCubeChoice"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MarketDataAssignments(_model_base.Model):
    """MarketDataAssignments.

    Attributes
    ----------
    interest_rate : ~analyticsapi.models.InterestRateAssignment
    """

    interest_rate: Optional["_models.InterestRateAssignment"] = rest_field(name="interestRate")

    @overload
    def __init__(
        self,
        interest_rate: Optional["_models.InterestRateAssignment"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["interest_rate"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class MarketDataLookBack(_model_base.Model):
    """The list of properties used to define the limited time range when getting historical timeseries
    or intraday timeseries market data used to construct the curve.

    Attributes
    ----------
    unit : str or ~analyticsapi.models.CurvesAndSurfacesUnitEnum
        The unit that describes the limited time range. The possible values
        are:   * Hour: used to subtract hours (applies to intraday or real-time
        request only),   * CalendarDay: used to subtract calendar days,   *
        BusinessCalendarDay: used to subtract business days. Known values are:
        "BusinessCalendarDay", "CalendarDay", and "Hour".
    value : int
        The value of the limited time range.
    """

    unit: Optional[Union[str, "_models.CurvesAndSurfacesUnitEnum"]] = rest_field()
    """The unit that describes the limited time range. The possible values are:   * Hour: used to
     subtract hours (applies to intraday or real-time request only),   * CalendarDay: used to
     subtract calendar days,   * BusinessCalendarDay: used to subtract business days. Known values
     are: \"BusinessCalendarDay\", \"CalendarDay\", and \"Hour\"."""
    value: Optional[int] = rest_field()
    """The value of the limited time range."""

    @overload
    def __init__(
        self,
        *,
        unit: Optional[Union[str, "_models.CurvesAndSurfacesUnitEnum"]] = None,
        value: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MarketDataLookBackDefinition(_model_base.Model):
    """MarketDataLookBackDefinition.

    Attributes
    ----------
    historical_interday : ~analyticsapi.models.MarketDataLookBack
    historical_intraday : ~analyticsapi.models.MarketDataLookBack
    real_time : ~analyticsapi.models.MarketDataLookBack
    """

    historical_interday: Optional["_models.MarketDataLookBack"] = rest_field(name="historicalInterday")
    historical_intraday: Optional["_models.MarketDataLookBack"] = rest_field(name="historicalIntraday")
    real_time: Optional["_models.MarketDataLookBack"] = rest_field(name="realTime")

    @overload
    def __init__(
        self,
        *,
        historical_interday: Optional["_models.MarketDataLookBack"] = None,
        historical_intraday: Optional["_models.MarketDataLookBack"] = None,
        real_time: Optional["_models.MarketDataLookBack"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MarketDataQps(_model_base.Model):
    """MarketDataQps."""


class MarketDataTime(_model_base.Model):
    """MarketDataTime.

    Attributes
    ----------
    local_time : str
        Local time or other words time in offset timezone. The value is
        expressed in ISO 8601 format: [hh]:[mm]:[ss] (e.g., '14:00:00').
    time_zone_offset : str
        Time offsets from UTC. The value is expressed in ISO 8601 format:
        [hh]:[mm] (e.g., '+05:00').
    """

    local_time: Optional[str] = rest_field(name="localTime")
    """Local time or other words time in offset timezone. The value is expressed in ISO 8601 format:
     [hh]:[mm]:[ss] (e.g., '14:00:00')."""
    time_zone_offset: Optional[str] = rest_field(name="timeZoneOffset")
    """Time offsets from UTC. The value is expressed in ISO 8601 format: [hh]:[mm] (e.g., '+05:00')."""

    @overload
    def __init__(
        self,
        *,
        local_time: Optional[str] = None,
        time_zone_offset: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MarketSettingsRequest(_model_base.Model):
    """MarketSettingsRequest.

    Attributes
    ----------
    input : list[~analyticsapi.models.MarketSettingsRequestInfo]
        The default value is None, needs to be assigned before using.
    """

    input: Optional[List["_models.MarketSettingsRequestInfo"]] = rest_field()

    @overload
    def __init__(
        self,
        input: Optional[List["_models.MarketSettingsRequestInfo"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["input"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class MarketSettingsRequestInfo(_model_base.Model):
    """MarketSettingsRequestInfo.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    identifier : str
        Required.
    id_type : str or ~analyticsapi.models.IdTypeEnum
        CUSIP, ISIN, etc.. The IdType must match the identifier given. Known
        values are: "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN",
        "REGSISIN", "SEDOL", "Identifier", "ChinaInterbankCode",
        "ShanghaiExchangeCode", "ShenzhenExchangeCode", and "MXTickerID".
    pricing_date : str
    user_tag : str
    """

    identifier: str = rest_field()
    """Required."""
    id_type: Optional[Union[str, "_models.IdTypeEnum"]] = rest_field(name="idType")
    """CUSIP, ISIN, etc.. The IdType must match the identifier given. Known values are:
     \"SecurityIDEntry\", \"SecurityID\", \"CUSIP\", \"ISIN\", \"REGSISIN\", \"SEDOL\",
     \"Identifier\", \"ChinaInterbankCode\", \"ShanghaiExchangeCode\", \"ShenzhenExchangeCode\", and
     \"MXTickerID\"."""
    pricing_date: Optional[str] = rest_field(name="pricingDate")
    user_tag: Optional[str] = rest_field(name="userTag")

    @overload
    def __init__(
        self,
        *,
        identifier: str,
        id_type: Optional[Union[str, "_models.IdTypeEnum"]] = None,
        pricing_date: Optional[str] = None,
        user_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MarketVolatility(_model_base.Model):
    """An object that describes the volatility parameters.

    Attributes
    ----------
    type : str or ~analyticsapi.models.VolatilityTypeEnum
        The type of the volatility. Known values are: "Default", "Implied",
        "Surface", and "Historical".
    value : ~analyticsapi.models.Rate
        An object that describes the volatility value.
    """

    type: Optional[Union[str, "_models.VolatilityTypeEnum"]] = rest_field(default="None")
    """The type of the volatility. Known values are: \"Default\", \"Implied\", \"Surface\", and
     \"Historical\"."""
    value: Optional["_models.Rate"] = rest_field()
    """An object that describes the volatility value."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.VolatilityTypeEnum"]] = None,
        value: Optional["_models.Rate"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MaturityFilter(_model_base.Model):
    """The parameters needed to define the maturity filter.

    Attributes
    ----------
    max_maturity : str
        Max Maturity to consider in the filtering. (expressed in tenor).
    min_maturity : str
        Min Maturity to consider in the filtering. (expressed in tenor) Default
        value: 7D.
    min_of_median_nb_of_strikes_percent : float
        Remove maturities whose number of strikes is less than
        MinOfMedianNbOfStrikesPercent of the Median number of Strikes.
    """

    max_maturity: Optional[str] = rest_field(name="maxMaturity")
    """Max Maturity to consider in the filtering. (expressed in tenor)."""
    min_maturity: Optional[str] = rest_field(name="minMaturity")
    """Min Maturity to consider in the filtering. (expressed in tenor)
     Default value: 7D."""
    min_of_median_nb_of_strikes_percent: Optional[float] = rest_field(name="minOfMedianNbOfStrikesPercent")
    """Remove maturities whose number of strikes is less than MinOfMedianNbOfStrikesPercent of the
     Median number of Strikes."""

    @overload
    def __init__(
        self,
        *,
        max_maturity: Optional[str] = None,
        min_maturity: Optional[str] = None,
        min_of_median_nb_of_strikes_percent: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MbsSettings(_model_base.Model):
    """Additional settings for mortgage backed securities.

    Attributes
    ----------
    use_roll_info : bool
        Optional, for adjustable rate mortgages (ARMS). If the ARM has roll
        Information, one can choose to assume the ARM has one reset date or use
        the Roll Information. Note, OAS will not calculate if roll information
        is used.
    call_underlying_remics : bool
        Optional, used for re-remic securities. Treats the underlying
        collateral remics as callable.
    """

    use_roll_info: Optional[bool] = rest_field(name="useRollInfo")
    """Optional, for adjustable rate mortgages (ARMS). If the ARM has roll Information, one can choose
     to assume the ARM has one reset date or use the Roll Information. Note, OAS will not calculate
     if roll information is used."""
    call_underlying_remics: Optional[bool] = rest_field(name="callUnderlyingRemics")
    """Optional, used for re-remic securities. Treats the underlying collateral remics as callable."""

    @overload
    def __init__(
        self,
        *,
        use_roll_info: Optional[bool] = None,
        call_underlying_remics: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Measure(_model_base.Model):
    """An object that contains measures used to express the results of the instrument valuation.

    Attributes
    ----------
    value : float
        The amount expressed as an absolute value. Required.
    bp : float
        The amount expressed in basis points.
    percent : float
        The amount expressed as a percentage.
    deal_currency : ~analyticsapi.models.Amount
        An object that specifies the amount expressed in the deal currency.
    report_currency : ~analyticsapi.models.Amount
        An object that specifies the amount expressed in the reporting
        currency.
    domestic_currency : ~analyticsapi.models.Amount
        An object that specifies the amount expressed in the domestic currency.
    foreign_currency : ~analyticsapi.models.Amount
        An object that specifies the amount expressed in the foreign currency
        (FX specific).
    """

    value: float = rest_field()
    """The amount expressed as an absolute value. Required."""
    bp: Optional[float] = rest_field()
    """The amount expressed in basis points."""
    percent: Optional[float] = rest_field()
    """The amount expressed as a percentage."""
    deal_currency: Optional["_models.Amount"] = rest_field(name="dealCurrency")
    """An object that specifies the amount expressed in the deal currency."""
    report_currency: Optional["_models.Amount"] = rest_field(name="reportCurrency")
    """An object that specifies the amount expressed in the reporting currency."""
    domestic_currency: Optional["_models.Amount"] = rest_field(name="domesticCurrency")
    """An object that specifies the amount expressed in the domestic currency."""
    foreign_currency: Optional["_models.Amount"] = rest_field(name="foreignCurrency")
    """An object that specifies the amount expressed in the foreign currency (FX specific)."""

    @overload
    def __init__(
        self,
        *,
        value: float,
        bp: Optional[float] = None,
        percent: Optional[float] = None,
        deal_currency: Optional["_models.Amount"] = None,
        report_currency: Optional["_models.Amount"] = None,
        domestic_currency: Optional["_models.Amount"] = None,
        foreign_currency: Optional["_models.Amount"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MetaData(_model_base.Model):
    """The metadata of the resource.

    Attributes
    ----------
    created_at : ~datetime.datetime
        The date and time when the resource was created.

        The value is expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        2023-01-01T00:00:00Z).
    status : str or ~analyticsapi.models.Status
        The status of the resource. Known values are: "Active" and "Deleted".
    revision : str
        The version of the resource.
    creator : str
        The uuid of the user who created the resource.
    updated_at : ~datetime.datetime
        The date and time when the resource was updated.

        The value is expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        2023-01-01T00:00:00Z).
    deleted_at : ~datetime.datetime
        The date and time when the resource was deleted.

        The value is expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        2023-01-01T00:00:00Z).
    updated_by : str
        The name of the user who updated the resource.
    """

    created_at: Optional[datetime.datetime] = rest_field(name="createdAt", format="rfc3339")
    """The date and time when the resource was created.
     
     The value is expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
     2023-01-01T00:00:00Z)."""
    status: Optional[Union[str, "_models.Status"]] = rest_field()
    """The status of the resource. Known values are: \"Active\" and \"Deleted\"."""
    revision: Optional[str] = rest_field()
    """The version of the resource."""
    creator: Optional[str] = rest_field()
    """The uuid of the user who created the resource."""
    updated_at: Optional[datetime.datetime] = rest_field(name="updatedAt", format="rfc3339")
    """The date and time when the resource was updated.
     
     The value is expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
     2023-01-01T00:00:00Z)."""
    deleted_at: Optional[datetime.datetime] = rest_field(name="deletedAt", format="rfc3339")
    """The date and time when the resource was deleted.
     
     The value is expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
     2023-01-01T00:00:00Z)."""
    updated_by: Optional[str] = rest_field(name="updatedBy")
    """The name of the user who updated the resource."""

    @overload
    def __init__(
        self,
        *,
        created_at: Optional[datetime.datetime] = None,
        status: Optional[Union[str, "_models.Status"]] = None,
        revision: Optional[str] = None,
        creator: Optional[str] = None,
        updated_at: Optional[datetime.datetime] = None,
        deleted_at: Optional[datetime.datetime] = None,
        updated_by: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ModelDefinition(_model_base.Model):
    """ModelDefinition.

    Attributes
    ----------
    asset_class : str or ~analyticsapi.models.FinancialContractAssetClassEnum
        The asset class of the underlying asset. The possible values are:

        * InterestRate,
        * ForeignExchange,
        * Equity. Known values are: "Equity", "ForeignExchange", and "InterestRate".
    calibration_list : list[~analyticsapi.models.Calibration]
        The list of properties used to calibrate the model parameters. It is
        used only for interest rate models. All properties are mandatory if
        calibrationList is requested. Depending on the asset class the
        different sets of parameters should be specified. The default value is
        None, needs to be assigned before using.
    chain_ric : str
        The CDS chain RIC, if applicable.
    foreign_currency : str
        The foreign currency of the underlying asset. It is mainly used in FX
        models in combination with the underlying currency. The value is
        expressed in ISO 4217 alphabetical format (e.g., 'USD').
    model_name : str or ~analyticsapi.models.ModelNameEnum
        The name of the model to be used to price a specific underlying asset.
        The possible values are: ForeignExchange:

        * Deterministic,
        * BlackScholes: stochastic model with constant volatility,
        * BlackScholesVannaVolga: stochastic model extending the Black-Scholes model by incorporating
        hedging costs,
        * Dupire: stochastic model with deterministic non-constant volatility,
        * Heston: stochastic model with stochastic volatility,
        * HestonLocalStochasticVolatility: stochastic model with both stochastic volatility and local
        volatility components,
        * MarketBlackScholes: stochastic model with constant volatility,
        * Andersen: stochastic model with deterministic non-constant volatility extending the Dupire
        model by adding jumps.

        InterestRate:

        * Forward: deterministic model,
        * HullWhite1Factor: stochastic model with one factor,
        * HullWhite2Factor: stochastic model with two factors,
        * LiborMarketModelnFactor: stochastic model with 'n' factors,
        * MarketBlackScholes: stochastic model with constant volatility,
        * Normal: stochastic model with constant volatility,
        * StochasticAlphaBetaRho: stochastic model with stochastic volatility.

        Equity:

        * BlackScholes: stochastic model with constant volatility,
        * Dupire: stochastic model with deterministic non-constant volatility,
        * Heston: stochastic model with stochastic volatility,
        * MarketBlackScholes: stochastic model with constant volatility,
        * Andersen: stochastic model with deterministic non-constant volatility extending the Dupire
        model by adding jumps. Known values are: "BlackScholes", "BlackScholesVannaVolga",
        "Deterministic", "DetIntensity", "Dupire", "Forward", "Gaussian", "Heston", "HullWhite1Factor",
        "HullWhite2Factor", "LiborMarketModelnFactor", "LogNormal", "MarketBlackScholes", "Normal",
        "StochasticAlphaBetaRho", and "Andersen".
    model_parameters : ~analyticsapi.models.IPAModelParameters
    reference_entity_type : str
    underlying_code : str
        The code used to identify the underlying asset which is defined in
        payoffDefinition and to which the model is applied.
    underlying_currency : str
        The currency of underlying asset which is used in payoff definition and
        for which this model will be applied. The value is expressed in ISO
        4217 alphabetical format (e.g., 'EUR'). Mandatory for assetClass =
        'InterestRate'.
    underlying_name : str
        A user-defined string to identify the underlying asset which is used in
        payoffDefinition and to which the model is applied. Limited to 40
        characters.Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    underlying_tag : str
        Tag used to identify the model.
    """

    asset_class: Optional[Union[str, "_models.FinancialContractAssetClassEnum"]] = rest_field(name="assetClass")
    """The asset class of the underlying asset. The possible values are:
     
     
     * InterestRate,
     * ForeignExchange,
     * Equity. Known values are: \"Equity\", \"ForeignExchange\", and \"InterestRate\"."""
    calibration_list: Optional[List["_models.Calibration"]] = rest_field(name="calibrationList")
    """The list of properties used to calibrate the model parameters. It is used only for interest
     rate models. All properties are mandatory if calibrationList is requested. Depending on the
     asset class the different sets of parameters should be specified."""
    chain_ric: Optional[str] = rest_field(name="chainRic")
    """The CDS chain RIC, if applicable."""
    foreign_currency: Optional[str] = rest_field(name="foreignCurrency")
    """The foreign currency of the underlying asset. It is mainly used in FX models in combination
     with the underlying currency. The value is expressed in ISO 4217 alphabetical format (e.g.,
     'USD')."""
    model_name: Optional[Union[str, "_models.ModelNameEnum"]] = rest_field(name="modelName")
    """The name of the model to be used to price a specific underlying asset. The possible values are:
     ForeignExchange:
     
     
     * Deterministic,
     * BlackScholes: stochastic model with constant volatility,
     * BlackScholesVannaVolga: stochastic model extending the Black-Scholes model by incorporating
     hedging costs,
     * Dupire: stochastic model with deterministic non-constant volatility,
     * Heston: stochastic model with stochastic volatility,
     * HestonLocalStochasticVolatility: stochastic model with both stochastic volatility and local
     volatility components,
     * MarketBlackScholes: stochastic model with constant volatility,
     * Andersen: stochastic model with deterministic non-constant volatility extending the Dupire
     model by adding jumps.
     
     InterestRate:
     
     
     * Forward: deterministic model,
     * HullWhite1Factor: stochastic model with one factor,
     * HullWhite2Factor: stochastic model with two factors,
     * LiborMarketModelnFactor: stochastic model with 'n' factors,
     * MarketBlackScholes: stochastic model with constant volatility,
     * Normal: stochastic model with constant volatility,
     * StochasticAlphaBetaRho: stochastic model with stochastic volatility.
     
     Equity:
     
     
     * BlackScholes: stochastic model with constant volatility,
     * Dupire: stochastic model with deterministic non-constant volatility,
     * Heston: stochastic model with stochastic volatility,
     * MarketBlackScholes: stochastic model with constant volatility,
     * Andersen: stochastic model with deterministic non-constant volatility extending the Dupire
     model by adding jumps. Known values are: \"BlackScholes\", \"BlackScholesVannaVolga\",
     \"Deterministic\", \"DetIntensity\", \"Dupire\", \"Forward\", \"Gaussian\", \"Heston\",
     \"HullWhite1Factor\", \"HullWhite2Factor\", \"LiborMarketModelnFactor\", \"LogNormal\",
     \"MarketBlackScholes\", \"Normal\", \"StochasticAlphaBetaRho\", and \"Andersen\"."""
    model_parameters: Optional["_models.IPAModelParameters"] = rest_field(name="modelParameters")
    reference_entity_type: Optional[str] = rest_field(name="referenceEntityType")
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The code used to identify the underlying asset which is defined in payoffDefinition and to
     which the model is applied."""
    underlying_currency: Optional[str] = rest_field(name="underlyingCurrency")
    """The currency of underlying asset which is used in payoff definition and for which this model
     will be applied. The value is expressed in ISO 4217 alphabetical format (e.g., 'EUR').
     Mandatory for assetClass = 'InterestRate'."""
    underlying_name: Optional[str] = rest_field(name="underlyingName")
    """A user-defined string to identify the underlying asset which is used in payoffDefinition and to
     which the model is applied. Limited to 40 characters.Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    underlying_tag: Optional[str] = rest_field(name="underlyingTag")
    """Tag used to identify the model."""

    @overload
    def __init__(
        self,
        *,
        asset_class: Optional[Union[str, "_models.FinancialContractAssetClassEnum"]] = None,
        calibration_list: Optional[List["_models.Calibration"]] = None,
        chain_ric: Optional[str] = None,
        foreign_currency: Optional[str] = None,
        model_name: Optional[Union[str, "_models.ModelNameEnum"]] = None,
        model_parameters: Optional["_models.IPAModelParameters"] = None,
        reference_entity_type: Optional[str] = None,
        underlying_code: Optional[str] = None,
        underlying_currency: Optional[str] = None,
        underlying_name: Optional[str] = None,
        underlying_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ModifyClass(_model_base.Model):
    """ModifyClass.

    Attributes
    ----------
    current_coupon : ~decimal.Decimal
    notional_flag : bool
    modify_interest_flag : bool
    index : str
    leverage : ~decimal.Decimal
    reset_margin : ~decimal.Decimal
    life_cap : ~decimal.Decimal
    life_floor : ~decimal.Decimal
    payment_delay : int
    class_amount : ~decimal.Decimal
    ignore_amount : ~decimal.Decimal
    modify_class_calc_type : str
    payment_day_of_month : int
    """

    current_coupon: Optional[decimal.Decimal] = rest_field(name="currentCoupon")
    notional_flag: Optional[bool] = rest_field(name="notionalFlag")
    modify_interest_flag: Optional[bool] = rest_field(name="modifyInterestFlag")
    index: Optional[str] = rest_field()
    leverage: Optional[decimal.Decimal] = rest_field()
    reset_margin: Optional[decimal.Decimal] = rest_field(name="resetMargin")
    life_cap: Optional[decimal.Decimal] = rest_field(name="lifeCap")
    life_floor: Optional[decimal.Decimal] = rest_field(name="lifeFloor")
    payment_delay: Optional[int] = rest_field(name="paymentDelay")
    class_amount: Optional[decimal.Decimal] = rest_field(name="classAmount")
    ignore_amount: Optional[decimal.Decimal] = rest_field(name="ignoreAmount")
    modify_class_calc_type: Optional[str] = rest_field(name="modifyClassCalcType")
    payment_day_of_month: Optional[int] = rest_field(name="paymentDayOfMonth")

    @overload
    def __init__(
        self,
        *,
        current_coupon: Optional[decimal.Decimal] = None,
        notional_flag: Optional[bool] = None,
        modify_interest_flag: Optional[bool] = None,
        index: Optional[str] = None,
        leverage: Optional[decimal.Decimal] = None,
        reset_margin: Optional[decimal.Decimal] = None,
        life_cap: Optional[decimal.Decimal] = None,
        life_floor: Optional[decimal.Decimal] = None,
        payment_delay: Optional[int] = None,
        class_amount: Optional[decimal.Decimal] = None,
        ignore_amount: Optional[decimal.Decimal] = None,
        modify_class_calc_type: Optional[str] = None,
        payment_day_of_month: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ModifyCollateral(_model_base.Model):
    """ModifyCollateral.

    Attributes
    ----------
    collateral_net_coupon : ~decimal.Decimal
    gross_wac : ~decimal.Decimal
    loan_age : int
    current3_rd_party_origination : ~decimal.Decimal
    spread_at_origination : ~decimal.Decimal
    current_ltv : ~decimal.Decimal
    ltv : ~decimal.Decimal
    post_modification_ltv : ~decimal.Decimal
    credit_score : int
    post_modification_credit_score : ~decimal.Decimal
    percent_refi : ~decimal.Decimal
    percent_prev_loss_mitigation : ~decimal.Decimal
    percent2_to4_unit : ~decimal.Decimal
    percent_inv : ~decimal.Decimal
    percent_harp : ~decimal.Decimal
    percent_harp2 : ~decimal.Decimal
    percent_dti : ~decimal.Decimal
    combined_ltv : ~decimal.Decimal
    percent_reperformer : ~decimal.Decimal
    reperformer_months : int
    clean_pay_months : int
    percent_payment_reduction : ~decimal.Decimal
    forbearance_amount : ~decimal.Decimal
    forbearance_modification : ~decimal.Decimal
    percent_first_time_home_buyer : ~decimal.Decimal
    new_original_loan_size : ~decimal.Decimal
    new_current_loan_size : ~decimal.Decimal
    origination_channel : ~analyticsapi.models.OriginChannel
    percent_fha : ~decimal.Decimal
    percent_va : ~decimal.Decimal
    percent_rh : ~decimal.Decimal
    percent_pih : ~decimal.Decimal
    percent_retail : ~decimal.Decimal
    percent_unspecified : ~decimal.Decimal
    adjusted_spread_at_origination : ~decimal.Decimal
    adjusted_ltv : ~decimal.Decimal
    adjusted_original_loan_size : ~decimal.Decimal
    adjusted_current_loan_size : ~decimal.Decimal
    weighted_avg_loan_size : ~decimal.Decimal
    original_weighted_avg_loan_size : ~decimal.Decimal
    second_lien_frac : ~decimal.Decimal
    occupancy_second_home : ~decimal.Decimal
    permanent_jumbo_frac : ~decimal.Decimal
    units_multi : ~decimal.Decimal
    loan_purpose_cashout : ~decimal.Decimal
    percent_piw_appraisal : ~decimal.Decimal
    percent_piw_onsite_avm : ~decimal.Decimal
    percent_piwgse_refinance : ~decimal.Decimal
    percent_piw_waiver : ~decimal.Decimal
    percent_home_ready_home_possible : ~decimal.Decimal
    percent_state_hfa : ~decimal.Decimal
    percent_hamp_mods : ~decimal.Decimal
    percent_regular_mods : ~decimal.Decimal
    modify_collateral_type : str
    prepay_model_servicer : list[~analyticsapi.models.PrepayModelServicer]
        The default value is None, needs to be assigned before using.
    prepay_model_seller : list[~analyticsapi.models.PrepayModelSeller]
        The default value is None, needs to be assigned before using.
    """

    collateral_net_coupon: Optional[decimal.Decimal] = rest_field(name="collateralNetCoupon")
    gross_wac: Optional[decimal.Decimal] = rest_field(name="grossWAC")
    loan_age: Optional[int] = rest_field(name="loanAge")
    current3_rd_party_origination: Optional[decimal.Decimal] = rest_field(name="current3RdPartyOrigination")
    spread_at_origination: Optional[decimal.Decimal] = rest_field(name="spreadAtOrigination")
    current_ltv: Optional[decimal.Decimal] = rest_field(name="currentLTV")
    ltv: Optional[decimal.Decimal] = rest_field()
    post_modification_ltv: Optional[decimal.Decimal] = rest_field(name="postModificationLTV")
    credit_score: Optional[int] = rest_field(name="creditScore")
    post_modification_credit_score: Optional[decimal.Decimal] = rest_field(name="postModificationCreditScore")
    percent_refi: Optional[decimal.Decimal] = rest_field(name="percentRefi")
    percent_prev_loss_mitigation: Optional[decimal.Decimal] = rest_field(name="percentPrevLossMitigation")
    percent2_to4_unit: Optional[decimal.Decimal] = rest_field(name="percent2To4Unit")
    percent_inv: Optional[decimal.Decimal] = rest_field(name="percentInv")
    percent_harp: Optional[decimal.Decimal] = rest_field(name="percentHARP")
    percent_harp2: Optional[decimal.Decimal] = rest_field(name="percentHARP2")
    percent_dti: Optional[decimal.Decimal] = rest_field(name="percentDTI")
    combined_ltv: Optional[decimal.Decimal] = rest_field(name="combinedLTV")
    percent_reperformer: Optional[decimal.Decimal] = rest_field(name="percentReperformer")
    reperformer_months: Optional[int] = rest_field(name="reperformerMonths")
    clean_pay_months: Optional[int] = rest_field(name="cleanPayMonths")
    percent_payment_reduction: Optional[decimal.Decimal] = rest_field(name="percentPaymentReduction")
    forbearance_amount: Optional[decimal.Decimal] = rest_field(name="forbearanceAmount")
    forbearance_modification: Optional[decimal.Decimal] = rest_field(name="forbearanceModification")
    percent_first_time_home_buyer: Optional[decimal.Decimal] = rest_field(name="percentFirstTimeHomeBuyer")
    new_original_loan_size: Optional[decimal.Decimal] = rest_field(name="newOriginalLoanSize")
    new_current_loan_size: Optional[decimal.Decimal] = rest_field(name="newCurrentLoanSize")
    origination_channel: Optional["_models.OriginChannel"] = rest_field(name="originationChannel")
    percent_fha: Optional[decimal.Decimal] = rest_field(name="percentFHA")
    percent_va: Optional[decimal.Decimal] = rest_field(name="percentVA")
    percent_rh: Optional[decimal.Decimal] = rest_field(name="percentRH")
    percent_pih: Optional[decimal.Decimal] = rest_field(name="percentPIH")
    percent_retail: Optional[decimal.Decimal] = rest_field(name="percentRetail")
    percent_unspecified: Optional[decimal.Decimal] = rest_field(name="percentUnspecified")
    adjusted_spread_at_origination: Optional[decimal.Decimal] = rest_field(name="adjustedSpreadAtOrigination")
    adjusted_ltv: Optional[decimal.Decimal] = rest_field(name="adjustedLTV")
    adjusted_original_loan_size: Optional[decimal.Decimal] = rest_field(name="adjustedOriginalLoanSize")
    adjusted_current_loan_size: Optional[decimal.Decimal] = rest_field(name="adjustedCurrentLoanSize")
    weighted_avg_loan_size: Optional[decimal.Decimal] = rest_field(name="weightedAvgLoanSize")
    original_weighted_avg_loan_size: Optional[decimal.Decimal] = rest_field(name="originalWeightedAvgLoanSize")
    second_lien_frac: Optional[decimal.Decimal] = rest_field(name="secondLienFrac")
    occupancy_second_home: Optional[decimal.Decimal] = rest_field(name="occupancySecondHome")
    permanent_jumbo_frac: Optional[decimal.Decimal] = rest_field(name="permanentJumboFrac")
    units_multi: Optional[decimal.Decimal] = rest_field(name="unitsMulti")
    loan_purpose_cashout: Optional[decimal.Decimal] = rest_field(name="loanPurposeCashout")
    percent_piw_appraisal: Optional[decimal.Decimal] = rest_field(name="percentPIWAppraisal")
    percent_piw_onsite_avm: Optional[decimal.Decimal] = rest_field(name="percentPIWOnsiteAVM")
    percent_piwgse_refinance: Optional[decimal.Decimal] = rest_field(name="percentPIWGSERefinance")
    percent_piw_waiver: Optional[decimal.Decimal] = rest_field(name="percentPIWWaiver")
    percent_home_ready_home_possible: Optional[decimal.Decimal] = rest_field(name="percentHomeReadyHomePossible")
    percent_state_hfa: Optional[decimal.Decimal] = rest_field(name="percentStateHFA")
    percent_hamp_mods: Optional[decimal.Decimal] = rest_field(name="percentHAMPMods")
    percent_regular_mods: Optional[decimal.Decimal] = rest_field(name="percentRegularMods")
    modify_collateral_type: Optional[str] = rest_field(name="modifyCollateralType")
    prepay_model_servicer: Optional[List["_models.PrepayModelServicer"]] = rest_field(name="prepayModelServicer")
    prepay_model_seller: Optional[List["_models.PrepayModelSeller"]] = rest_field(name="prepayModelSeller")

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        collateral_net_coupon: Optional[decimal.Decimal] = None,
        gross_wac: Optional[decimal.Decimal] = None,
        loan_age: Optional[int] = None,
        current3_rd_party_origination: Optional[decimal.Decimal] = None,
        spread_at_origination: Optional[decimal.Decimal] = None,
        current_ltv: Optional[decimal.Decimal] = None,
        ltv: Optional[decimal.Decimal] = None,
        post_modification_ltv: Optional[decimal.Decimal] = None,
        credit_score: Optional[int] = None,
        post_modification_credit_score: Optional[decimal.Decimal] = None,
        percent_refi: Optional[decimal.Decimal] = None,
        percent_prev_loss_mitigation: Optional[decimal.Decimal] = None,
        percent2_to4_unit: Optional[decimal.Decimal] = None,
        percent_inv: Optional[decimal.Decimal] = None,
        percent_harp: Optional[decimal.Decimal] = None,
        percent_harp2: Optional[decimal.Decimal] = None,
        percent_dti: Optional[decimal.Decimal] = None,
        combined_ltv: Optional[decimal.Decimal] = None,
        percent_reperformer: Optional[decimal.Decimal] = None,
        reperformer_months: Optional[int] = None,
        clean_pay_months: Optional[int] = None,
        percent_payment_reduction: Optional[decimal.Decimal] = None,
        forbearance_amount: Optional[decimal.Decimal] = None,
        forbearance_modification: Optional[decimal.Decimal] = None,
        percent_first_time_home_buyer: Optional[decimal.Decimal] = None,
        new_original_loan_size: Optional[decimal.Decimal] = None,
        new_current_loan_size: Optional[decimal.Decimal] = None,
        origination_channel: Optional["_models.OriginChannel"] = None,
        percent_fha: Optional[decimal.Decimal] = None,
        percent_va: Optional[decimal.Decimal] = None,
        percent_rh: Optional[decimal.Decimal] = None,
        percent_pih: Optional[decimal.Decimal] = None,
        percent_retail: Optional[decimal.Decimal] = None,
        percent_unspecified: Optional[decimal.Decimal] = None,
        adjusted_spread_at_origination: Optional[decimal.Decimal] = None,
        adjusted_ltv: Optional[decimal.Decimal] = None,
        adjusted_original_loan_size: Optional[decimal.Decimal] = None,
        adjusted_current_loan_size: Optional[decimal.Decimal] = None,
        weighted_avg_loan_size: Optional[decimal.Decimal] = None,
        original_weighted_avg_loan_size: Optional[decimal.Decimal] = None,
        second_lien_frac: Optional[decimal.Decimal] = None,
        occupancy_second_home: Optional[decimal.Decimal] = None,
        permanent_jumbo_frac: Optional[decimal.Decimal] = None,
        units_multi: Optional[decimal.Decimal] = None,
        loan_purpose_cashout: Optional[decimal.Decimal] = None,
        percent_piw_appraisal: Optional[decimal.Decimal] = None,
        percent_piw_onsite_avm: Optional[decimal.Decimal] = None,
        percent_piwgse_refinance: Optional[decimal.Decimal] = None,
        percent_piw_waiver: Optional[decimal.Decimal] = None,
        percent_home_ready_home_possible: Optional[decimal.Decimal] = None,
        percent_state_hfa: Optional[decimal.Decimal] = None,
        percent_hamp_mods: Optional[decimal.Decimal] = None,
        percent_regular_mods: Optional[decimal.Decimal] = None,
        modify_collateral_type: Optional[str] = None,
        prepay_model_servicer: Optional[List["_models.PrepayModelServicer"]] = None,
        prepay_model_seller: Optional[List["_models.PrepayModelSeller"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MoneynessWeight(_model_base.Model):
    """MoneynessWeight.

    Attributes
    ----------
    max_moneyness : float
    min_moneyness : float
    weight : float
    """

    max_moneyness: Optional[float] = rest_field(name="maxMoneyness")
    min_moneyness: Optional[float] = rest_field(name="minMoneyness")
    weight: Optional[float] = rest_field()

    @overload
    def __init__(
        self,
        *,
        max_moneyness: Optional[float] = None,
        min_moneyness: Optional[float] = None,
        weight: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MonthRatePair(_model_base.Model):
    """MonthRatePair.

    Attributes
    ----------
    month : int
    rate : float
    """

    month: Optional[int] = rest_field()
    rate: Optional[float] = rest_field()

    @overload
    def __init__(
        self,
        *,
        month: Optional[int] = None,
        rate: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class MuniSettings(_model_base.Model):
    """Optional settings for municipal bonds.

    Attributes
    ----------
    paydown_optional : bool
        Optional, if true the bond's sink or paydown schedule is treated as
        optional.
    ignore_call_info : bool
        Optional, if true the bond's call schedule is ignored.
    use_stub_rate : bool
        Optional, if true stub rate is used for municipal bond discounting.
    """

    paydown_optional: Optional[bool] = rest_field(name="paydownOptional")
    """Optional, if true the bond's sink or paydown schedule is treated as optional."""
    ignore_call_info: Optional[bool] = rest_field(name="ignoreCallInfo")
    """Optional, if true the bond's call schedule is ignored."""
    use_stub_rate: Optional[bool] = rest_field(name="useStubRate")
    """Optional, if true stub rate is used for municipal bond discounting."""

    @overload
    def __init__(
        self,
        *,
        paydown_optional: Optional[bool] = None,
        ignore_call_info: Optional[bool] = None,
        use_stub_rate: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class NameTypeValue(_model_base.Model):
    """NameTypeValue.

    Attributes
    ----------
    basket : list[~analyticsapi.models.BasketItem]
        The default value is None, needs to be assigned before using.
    name : str
    type : str
    value : any
    """

    basket: Optional[List["_models.BasketItem"]] = rest_field()
    name: Optional[str] = rest_field()
    type: Optional[str] = rest_field(default="None")
    value: Optional[Any] = rest_field()

    @overload
    def __init__(
        self,
        *,
        basket: Optional[List["_models.BasketItem"]] = None,
        name: Optional[str] = None,
        type: Optional[str] = None,
        value: Optional[Any] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Observance(_model_base.Model):
    """An object to determine a holiday rescheduling if it falls on a rest day.

    Attributes
    ----------
    falls_on : str or ~analyticsapi.models.WeekDay
        The day of the week the holiday falls on. It is used as a reference
        point. Required. Known values are: "Monday", "Tuesday", "Wednesday",
        "Thursday", "Friday", "Saturday", and "Sunday".
    reschedule_description : ~analyticsapi.models.RescheduleDescription
        An object to determine a holiday rescheduling. Required.
    """

    falls_on: Union[str, "_models.WeekDay"] = rest_field(name="fallsOn")
    """The day of the week the holiday falls on. It is used as a reference point. Required. Known
     values are: \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", and
     \"Sunday\"."""
    reschedule_description: "_models.RescheduleDescription" = rest_field(name="rescheduleDescription")
    """An object to determine a holiday rescheduling. Required."""

    @overload
    def __init__(
        self,
        *,
        falls_on: Union[str, "_models.WeekDay"],
        reschedule_description: "_models.RescheduleDescription",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OffsetDefinition(_model_base.Model):
    """An object that defines how the payment dates are derived from the interest period dates.

    Attributes
    ----------
    tenor : str
        The tenor that represents the difference between the actual payment
        date and the interest period reference date. A tenor expresses a period
        of time using a specific syntax. There are two kinds of tenor:

        * Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and
        Years (Y).
          For example "1D" for one day, "2W" for two weeks or "3M1D" for three months and a day.
          When mixing units, units must be written in descending order of size (Y > M > W > D).  So,
        5M3D is valid, but 3D5M is not.
        * Common tenors are expressed as letter codes:
        * ON (Overnight) - A one business day period that starts today.
        * TN (Tomorrow-Next) - A one business day period that starts next business day.
        * SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date
        (today) + days to spot.
        * SN (Spot-Next) - A one business day period that starts at the spot date.
        * SW (Spot-Week) - A one business week period that starts at the spot date. Required.
    business_day_adjustment : ~analyticsapi.models.BusinessDayAdjustmentDefinition
        An object that defines the business day adjustment convention.
        Required.
    reference_date : str or ~analyticsapi.models.CouponReferenceDateEnum
        The reference date for the actual payment date calculation. Required.
        Known values are: "PeriodStartDate" and "PeriodEndDate".
    direction : str or ~analyticsapi.models.DirectionEnum
        The direction of the actual payment date calculation (backward or
        forward). Required. Known values are: "Backward" and "Forward".
    """

    tenor: str = rest_field()
    """The tenor that represents the difference between the actual payment date and the interest
     period reference date.
     A tenor expresses a period of time using a specific syntax. There are two kinds of tenor:
     
     
     * Ad-hoc tenors explicitly state the length of time in Days (D), Weeks (W), Months (M) and
     Years (Y).
       For example \"1D\" for one day, \"2W\" for two weeks or \"3M1D\" for three months and a day.
       When mixing units, units must be written in descending order of size (Y > M > W > D).  So,
     5M3D is valid, but 3D5M is not.
     * Common tenors are expressed as letter codes:
     * ON (Overnight) - A one business day period that starts today.
     * TN (Tomorrow-Next) - A one business day period that starts next business day.
     * SPOT (Spot Date) - A period that ends on the spot date.  Date is calculated as trade date
     (today) + days to spot.
     * SN (Spot-Next) - A one business day period that starts at the spot date.
     * SW (Spot-Week) - A one business week period that starts at the spot date. Required."""
    business_day_adjustment: "_models.BusinessDayAdjustmentDefinition" = rest_field(name="businessDayAdjustment")
    """An object that defines the business day adjustment convention. Required."""
    reference_date: Union[str, "_models.CouponReferenceDateEnum"] = rest_field(name="referenceDate")
    """The reference date for the actual payment date calculation. Required. Known values are:
     \"PeriodStartDate\" and \"PeriodEndDate\"."""
    direction: Union[str, "_models.DirectionEnum"] = rest_field()
    """The direction of the actual payment date calculation (backward or forward). Required. Known
     values are: \"Backward\" and \"Forward\"."""

    @overload
    def __init__(
        self,
        *,
        tenor: str,
        business_day_adjustment: "_models.BusinessDayAdjustmentDefinition",
        reference_date: Union[str, "_models.CouponReferenceDateEnum"],
        direction: Union[str, "_models.DirectionEnum"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Option(_model_base.Model):
    """The resource used to create, save and price options.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.OPTION
        Property defining the type of the resource.
    id : str
        Unique identifier of the Option.
    location : ~analyticsapi.models.Location
        Object defining the location of the Option in the platform. Required.
    description : ~analyticsapi.models.Description
        Object defining metadata for the Option.
    definition : ~analyticsapi.models.OptionDefinition
        Object defining the Option. Required.
    """

    type: Optional[Literal[ResourceType.OPTION]] = rest_field(visibility=["read"], default=ResourceType.OPTION)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the Option."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining the location of the Option in the platform. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining metadata for the Option."""
    definition: "_models.OptionDefinition" = rest_field()
    """Object defining the Option. Required."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        definition: "_models.OptionDefinition",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionArraySolveResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.OptionSolveResponseFieldsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.OptionSolveResponseFieldsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.OptionSolveResponseFieldsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class OptionArrayValuationResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.OptionValuationResponseFieldsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.OptionValuationResponseFieldsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.OptionValuationResponseFieldsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class OptionCollectionLinks(_model_base.Model):
    """OptionCollectionLinks.

    Attributes
    ----------
    self_property : ~analyticsapi.models.LinkRef
        Required.
    first : ~analyticsapi.models.LinkRef
    prev : ~analyticsapi.models.LinkRef
    next : ~analyticsapi.models.LinkRef
    last : ~analyticsapi.models.LinkRef
    """

    self_property: "_models.LinkRef" = rest_field(name="self")
    """Required."""
    first: Optional["_models.LinkRef"] = rest_field()
    prev: Optional["_models.LinkRef"] = rest_field()
    next: Optional["_models.LinkRef"] = rest_field()
    last: Optional["_models.LinkRef"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        self_property: "_models.LinkRef",
        first: Optional["_models.LinkRef"] = None,
        prev: Optional["_models.LinkRef"] = None,
        next: Optional["_models.LinkRef"] = None,
        last: Optional["_models.LinkRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionCollectionResponse(_model_base.Model):
    """A model template describing a paged response.

    Attributes
    ----------
    data : list[~analyticsapi.models.OptionInfo]
        Required.  The default value is None, needs to be assigned before
        using.
    page : int
        The page number of the current page displayed. Minimum value of this
        property is 1. Required.
    item_per_page : int
        Number of items displayed per page. Required.
    total_pages : int
        Total number of pages available for display. Required.
    total_items : int
        Total number of items available for display. Required.
    links : ~analyticsapi.models.OptionCollectionLinks
        Links for available operations and/or resources linked to current
        response.
    """

    data: List["_models.OptionInfo"] = rest_field()
    """Required."""
    page: int = rest_field()
    """The page number of the current page displayed. Minimum value of this property is 1. Required."""
    item_per_page: int = rest_field(name="itemPerPage")
    """Number of items displayed per page. Required."""
    total_pages: int = rest_field(name="totalPages")
    """Total number of pages available for display. Required."""
    total_items: int = rest_field(name="totalItems")
    """Total number of items available for display. Required."""
    links: Optional["_models.OptionCollectionLinks"] = rest_field()
    """Links for available operations and/or resources linked to current response."""

    @overload
    def __init__(
        self,
        *,
        data: List["_models.OptionInfo"],
        page: int,
        item_per_page: int,
        total_pages: int,
        total_items: int,
        links: Optional["_models.OptionCollectionLinks"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionDefinition(_model_base.Model):
    """An object that defines an option instrument.
    It can can be either a vanilla option (that gives the holder the right to buy or sell the
    underlying asset at a predetermined price within a given time frame),
    or an exotic option (such as an Asian, a barrier, a binary and other options).

    Attributes
    ----------
    underlying : ~analyticsapi.models.UnderlyingDefinition
        An object that defines the underlying asset of an option instrument.
        Required.
    exercise : ~analyticsapi.models.ExerciseDefinition
        An object that defines the exercise settings of an option instrument.
        Required.
    settlement : ~analyticsapi.models.SettlementDefinition
        An object that defines the settlement settings of an option instrument.
    option_type : str or ~analyticsapi.models.CallPutEnum
        An indicator of whether an option instrument is a call or a put. Known
        values are: "Call" and "Put".
    notional_amount : ~analyticsapi.models.Amount
        An object that defines the notional amount of an option instrument.
    barrier_up : ~analyticsapi.models.BarrierDefinition
        An object that defines an up barrier option.
    barrier_down : ~analyticsapi.models.BarrierDefinition
        An object that defines a down barrier option.
    binary_up : ~analyticsapi.models.BinaryDefinition
        An object that defines an up binary option.
    binary_down : ~analyticsapi.models.BinaryDefinition
        An object that defines a down binary option.
    asian : ~analyticsapi.models.AsianDefinition
        An object that defines an Asian option.
    """

    underlying: "_models.UnderlyingDefinition" = rest_field()
    """An object that defines the underlying asset of an option instrument. Required."""
    exercise: "_models.ExerciseDefinition" = rest_field()
    """An object that defines the exercise settings of an option instrument. Required."""
    settlement: Optional["_models.SettlementDefinition"] = rest_field()
    """An object that defines the settlement settings of an option instrument."""
    option_type: Optional[Union[str, "_models.CallPutEnum"]] = rest_field(name="optionType")
    """An indicator of whether an option instrument is a call or a put. Known values are: \"Call\" and
     \"Put\"."""
    notional_amount: Optional["_models.Amount"] = rest_field(name="notionalAmount")
    """An object that defines the notional amount of an option instrument."""
    barrier_up: Optional["_models.BarrierDefinition"] = rest_field(name="barrierUp")
    """An object that defines an up barrier option."""
    barrier_down: Optional["_models.BarrierDefinition"] = rest_field(name="barrierDown")
    """An object that defines a down barrier option."""
    binary_up: Optional["_models.BinaryDefinition"] = rest_field(name="binaryUp")
    """An object that defines an up binary option."""
    binary_down: Optional["_models.BinaryDefinition"] = rest_field(name="binaryDown")
    """An object that defines a down binary option."""
    asian: Optional["_models.AsianDefinition"] = rest_field()
    """An object that defines an Asian option."""

    @overload
    def __init__(
        self,
        *,
        underlying: "_models.UnderlyingDefinition",
        exercise: "_models.ExerciseDefinition",
        settlement: Optional["_models.SettlementDefinition"] = None,
        option_type: Optional[Union[str, "_models.CallPutEnum"]] = None,
        notional_amount: Optional["_models.Amount"] = None,
        barrier_up: Optional["_models.BarrierDefinition"] = None,
        barrier_down: Optional["_models.BarrierDefinition"] = None,
        binary_up: Optional["_models.BinaryDefinition"] = None,
        binary_down: Optional["_models.BinaryDefinition"] = None,
        asian: Optional["_models.AsianDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.OptionDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.OptionDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.OptionDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionDescriptionFields(_model_base.Model):
    """An object that contains fields related to the description of an option instrument.

    Attributes
    ----------
    instrument_tag : str
        A string to identify the instrument. It can be used to link output
        results to the instrument definition. Limited to 40 characters. Only
        alphabetic, numeric, and "- _.#=@" characters are supported.
    instrument_code : str
        The code (a RIC) used to define an option instrument.
    underlying_ric : str
        The code (a RIC) used to define the underlying asset.
    instrument_description : str
        The label that describes an option instrument.
    strike : float
        The set price at which the option holder can buy or sell the underlying
        asset. The value is expressed according to the market convention linked
        to the underlying asset.
    excercise_style : str or ~analyticsapi.models.ExerciseStyleEnum
        The style of an option instrument based on its exercise restrictions.
        Note that all exercise styles may not apply to certain types of option
        instruments. Known values are: "European", "American", and "Bermudan".
    option_type : str or ~analyticsapi.models.CallPutEnum
        An indicator of whether an option instrument is a call or a put. Known
        values are: "Call" and "Put".
    expiry_date : ~datetime.date
        The maturity or expiry date of an option instrument. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    """

    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A string to identify the instrument. It can be used to link output results to the instrument
     definition. Limited to 40 characters. Only alphabetic, numeric, and \"- _.#=@\" characters are
     supported."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code (a RIC) used to define an option instrument."""
    underlying_ric: Optional[str] = rest_field(name="underlyingRic")
    """The code (a RIC) used to define the underlying asset."""
    instrument_description: Optional[str] = rest_field(name="instrumentDescription")
    """The label that describes an option instrument."""
    strike: Optional[float] = rest_field()
    """The set price at which the option holder can buy or sell the underlying asset. The value is
     expressed according to the market convention linked to the underlying asset."""
    excercise_style: Optional[Union[str, "_models.ExerciseStyleEnum"]] = rest_field(name="excerciseStyle")
    """The style of an option instrument based on its exercise restrictions. Note that all exercise
     styles may not apply to certain types of option instruments. Known values are: \"European\",
     \"American\", and \"Bermudan\"."""
    option_type: Optional[Union[str, "_models.CallPutEnum"]] = rest_field(name="optionType")
    """An indicator of whether an option instrument is a call or a put. Known values are: \"Call\" and
     \"Put\"."""
    expiry_date: Optional[datetime.date] = rest_field(name="expiryDate")
    """The maturity or expiry date of an option instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2021-01-01')."""

    @overload
    def __init__(
        self,
        *,
        instrument_tag: Optional[str] = None,
        instrument_code: Optional[str] = None,
        underlying_ric: Optional[str] = None,
        instrument_description: Optional[str] = None,
        strike: Optional[float] = None,
        excercise_style: Optional[Union[str, "_models.ExerciseStyleEnum"]] = None,
        option_type: Optional[Union[str, "_models.CallPutEnum"]] = None,
        expiry_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionInfo(_model_base.Model):
    """A model template defining the partial description of the resource returned by the GET list
    service.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    type : str or ~analyticsapi.models.OPTION
        Property defining the type of the resource.
    id : str
        Unique identifier of the Option.
    location : ~analyticsapi.models.Location
        Object defining metadata for the Option. Required.
    description : ~analyticsapi.models.Description
        Object defining the Option.
    """

    type: Optional[Literal[ResourceType.OPTION]] = rest_field(visibility=["read"], default=ResourceType.OPTION)
    """Property defining the type of the resource."""
    id: Optional[str] = rest_field(visibility=["read"])
    """Unique identifier of the Option."""
    location: "_models.Location" = rest_field(visibility=["read", "create"])
    """Object defining metadata for the Option. Required."""
    description: Optional["_models.Description"] = rest_field()
    """Object defining the Option."""

    @overload
    def __init__(
        self,
        *,
        location: "_models.Location",
        description: Optional["_models.Description"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionInstrumentResponse(_model_base.Model):
    """An object that contains fields related to the definition of an option instrument.

    Attributes
    ----------
    data : ~analyticsapi.models.OptionDefinition
        An object that describes the instrument generated by the request.
        Required.
    """

    data: "_models.OptionDefinition" = rest_field()
    """An object that describes the instrument generated by the request. Required."""

    @overload
    def __init__(
        self,
        data: "_models.OptionDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class OptionPricingParameters(BasePricingParameters):
    """An object that describes the pricing parameters applied to an option instrument analytic
    request.

    Attributes
    ----------
    valuation_date : ~datetime.date
        The date on which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). The valuation date
        should be less than or equal to the instrument's end date. If not
        provided, today's date will be used as the default valuation date.
    report_currency : str
        The reporting currency. The value is expressed in ISO 4217 alphabetical
        format (e.g., 'GBP'). Default is USD.
    pricing_model : str
        The identifier of the pricing mode applied to an option instrument
        (GUID or URI). Note that a URI must be at least 2 and at most 102
        characters long, start with an alphanumeric character, and contain only
        alphanumeric characters, slashes and underscores. The supported models
        are LSEG/BlackScholes, LSEG/Binomial, LSEG/Trinomial and LSEG/Whaley.
        LSEG/LocalVolatility is supported only for Equity barrier and digital
        payoffs. LSEG/VannaVolga model is supported only for FX barrier and
        digital payoffs. Default behavior: when no value is provided the
        service will identify the best model based on the option definition.
    model_numerical_method : str or ~analyticsapi.models.NumericalMethodEnum
        The numerical method that involves discretizing the underlying asset
        price and time to maturity to approximate the option's price through
        iterative calculations. Known values are: "BinomialTree",
        "TrinomialTree", "MonteCarlo", "Formula", and "Pde".
    model_parameters : ~analyticsapi.models.ModelParameters
        An object that describes the pricing model parameters applied to
        options.
    underlying_price_side : str or ~analyticsapi.models.PriceSideWithLastEnum
        The quoted price side of the underlying asset. Known values are: "Bid",
        "Ask", "Mid", and "Last".
    option_price_side : str or ~analyticsapi.models.PriceSideWithLastEnum
        The quoted price side of an option instrument. The parameter is not
        supported for FX option. Known values are: "Bid", "Ask", "Mid", and
        "Last".
    underlying_time_stamp : str or ~analyticsapi.models.TimeStampEnum
        The mode used to select the timestamp for the underlying asset. The
        parameter is not supported for FX option. Known values are: "Open",
        "Close", "Settle", and "Default".
    option_time_stamp : str or ~analyticsapi.models.TimeStampEnum
        The mode used to select the timestamp for an option instrument. The
        parameter is not supported for FX option. Known values are: "Open",
        "Close", "Settle", and "Default".
    solving_parameters : ~analyticsapi.models.OptionSolvingParameters
        An object that contains the solving target and variable parameters
        applied to the option instrument that requires a solution. These
        parameters provide an approach to obtaining the target value by
        selecting a variable value. This enables the consideration of different
        scenarios of the behavior of a specific parameter (variable) given the
        set value of another parameter (target). The solving provides a better
        control of computation when pricing a financial contract.
    """

    pricing_model: Optional[str] = rest_field(name="pricingModel")
    """The identifier of the pricing mode applied to an option instrument (GUID or URI).
     Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
     character, and contain only alphanumeric characters, slashes and underscores.
     The supported models are LSEG/BlackScholes, LSEG/Binomial, LSEG/Trinomial and LSEG/Whaley.
     LSEG/LocalVolatility is supported only for Equity barrier and digital payoffs.
     LSEG/VannaVolga model is supported only for FX barrier and digital payoffs.
     Default behavior: when no value is provided the service will identify the best model based on
     the option definition."""
    model_numerical_method: Optional[Union[str, "_models.NumericalMethodEnum"]] = rest_field(
        name="modelNumericalMethod"
    )
    """The numerical method that involves discretizing the underlying asset price and time to maturity
     to approximate the option's price through iterative calculations. Known values are:
     \"BinomialTree\", \"TrinomialTree\", \"MonteCarlo\", \"Formula\", and \"Pde\"."""
    model_parameters: Optional["_models.ModelParameters"] = rest_field(name="modelParameters")
    """An object that describes the pricing model parameters applied to options."""
    underlying_price_side: Optional[Union[str, "_models.PriceSideWithLastEnum"]] = rest_field(
        name="underlyingPriceSide"
    )
    """The quoted price side of the underlying asset. Known values are: \"Bid\", \"Ask\", \"Mid\", and
     \"Last\"."""
    option_price_side: Optional[Union[str, "_models.PriceSideWithLastEnum"]] = rest_field(name="optionPriceSide")
    """The quoted price side of an option instrument. The parameter is not supported for FX option.
     Known values are: \"Bid\", \"Ask\", \"Mid\", and \"Last\"."""
    underlying_time_stamp: Optional[Union[str, "_models.TimeStampEnum"]] = rest_field(name="underlyingTimeStamp")
    """The mode used to select the timestamp for the underlying asset. The parameter is not supported
     for FX option. Known values are: \"Open\", \"Close\", \"Settle\", and \"Default\"."""
    option_time_stamp: Optional[Union[str, "_models.TimeStampEnum"]] = rest_field(name="optionTimeStamp")
    """The mode used to select the timestamp for an option instrument. The parameter is not supported
     for FX option. Known values are: \"Open\", \"Close\", \"Settle\", and \"Default\"."""
    solving_parameters: Optional["_models.OptionSolvingParameters"] = rest_field(name="solvingParameters")
    """An object that contains the solving target and variable parameters applied to the option
     instrument that requires a solution.
     These parameters provide an approach to obtaining the target value by selecting a variable
     value.
     This enables the consideration of different scenarios of the behavior of a specific parameter
     (variable) given the set value of another parameter (target).
     The solving provides a better control of computation when pricing a financial contract."""

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.date] = None,
        report_currency: Optional[str] = None,
        pricing_model: Optional[str] = None,
        model_numerical_method: Optional[Union[str, "_models.NumericalMethodEnum"]] = None,
        model_parameters: Optional["_models.ModelParameters"] = None,
        underlying_price_side: Optional[Union[str, "_models.PriceSideWithLastEnum"]] = None,
        option_price_side: Optional[Union[str, "_models.PriceSideWithLastEnum"]] = None,
        underlying_time_stamp: Optional[Union[str, "_models.TimeStampEnum"]] = None,
        option_time_stamp: Optional[Union[str, "_models.TimeStampEnum"]] = None,
        solving_parameters: Optional["_models.OptionSolvingParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionResponse(_model_base.Model):
    """A model template describing a single response.

    Attributes
    ----------
    data : ~analyticsapi.models.Option
        Required.
    meta : ~analyticsapi.models.MetaData
    """

    data: "_models.Option" = rest_field()
    """Required."""
    meta: Optional["_models.MetaData"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        data: "_models.Option",
        meta: Optional["_models.MetaData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionRiskFields(Greeks):
    """An object that contains fields related to the risk assessment of an option instrument.

    Attributes
    ----------
    delta : ~analyticsapi.models.Measure
        An object used to express the delta of an instrument, which is defined
        as the change in the instrument's price or market value caused by a
        one-unit change in the price of the underlying asset, or by a 1bp
        change in the swap rate for a swaption, or by a 100bp change in the
        outright for FX instruments.
    gamma : ~analyticsapi.models.Measure
        An object used to express the gamma of an instrument, which is defined
        as the change in the instrument's delta or DV01 per a one-unit change
        in the price of the underlying asset, or a 1 unit parallel shift in the
        curve representing the instrument.
    rho : ~analyticsapi.models.Measure
        An object used to express the rho of an instrument, which is defined as
        the change in the instrument's price per a 1% change in the risk-free
        interest rate.
    theta : ~analyticsapi.models.Measure
        An object used to express the theta of an instrument, which is defined
        as the change in the instrument's price or market value caused by a
        one-day decrease in its time to expiration.
    vega : ~analyticsapi.models.Measure
        An object used to express the vega of an instrument, which is defined
        as the change in the instrument's price per a 1bp change in the normal
        volatility (1% in lognormal volatility) of the underlying asset.
    vanna : ~analyticsapi.models.Measure
        An object used to express the vanna of an option instrument, which is
        defined as the change in the option's vega caused by a 1 unit change in
        the price of the underlying asset.
    volga : ~analyticsapi.models.Measure
        An object used to express the volga of an option instrument, which is
        defined as the change in the option's vega per a 1% change in the
        implied volatility of the underlying asset.
    charm : ~analyticsapi.models.Measure
        An object used to express the charm of an option instrument, which is
        defined as the change in the options delta for a one-day decrease in
        the time to expiration.
    hedge_ratio : float
        The number of options you need to buy or sell to hedge one unit of the
        underlying instrument. It is calculated as [(-1) / delta].
    leverage : float
        The amount by which the option's price changes for a 1% change in the
        underlying asset. It is calculated as option's delta multiplied by
        gearing (the measure of the cash amount spent purchasing the option
        contract, compared to the actual value of the underlying position).
    forward_delta : ~analyticsapi.models.Measure
        The change in the option's price caused by a one-unit change in the
        forward price of the underlying asset.
    """

    vanna: Optional["_models.Measure"] = rest_field()
    """An object used to express the vanna of an option instrument, which is defined as the change in
     the option's vega caused by a 1 unit change in the price of the underlying asset."""
    volga: Optional["_models.Measure"] = rest_field()
    """An object used to express the volga of an option instrument, which is defined as the change in
     the option's vega per a 1% change in the implied volatility of the underlying asset."""
    charm: Optional["_models.Measure"] = rest_field()
    """An object used to express the charm of an option instrument, which is defined as the change in
     the options delta for a one-day decrease in the time to expiration."""
    hedge_ratio: Optional[float] = rest_field(name="hedgeRatio")
    """The number of options you need to buy or sell to hedge one unit of the underlying instrument.
     It is calculated as [(-1) / delta]."""
    leverage: Optional[float] = rest_field()
    """The amount by which the option's price changes for a 1% change in the underlying asset. It is
     calculated as option's delta multiplied by gearing (the measure of the cash amount spent
     purchasing the option contract, compared to the actual value of the underlying position)."""
    forward_delta: Optional["_models.Measure"] = rest_field(name="forwardDelta")
    """The change in the option's price caused by a one-unit change in the forward price of the
     underlying asset."""

    @overload
    def __init__(
        self,
        *,
        delta: Optional["_models.Measure"] = None,
        gamma: Optional["_models.Measure"] = None,
        rho: Optional["_models.Measure"] = None,
        theta: Optional["_models.Measure"] = None,
        vega: Optional["_models.Measure"] = None,
        vanna: Optional["_models.Measure"] = None,
        volga: Optional["_models.Measure"] = None,
        charm: Optional["_models.Measure"] = None,
        hedge_ratio: Optional[float] = None,
        leverage: Optional[float] = None,
        forward_delta: Optional["_models.Measure"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionSolveResponse(_model_base.Model):
    """The description of the solve response of the Option.

    Attributes
    ----------
    data : ~analyticsapi.models.OptionSolveResponseFieldsOnResourceResponseData
        Required.
    """

    data: "_models.OptionSolveResponseFieldsOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.OptionSolveResponseFieldsOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class OptionSolveResponseFieldsOnResourceResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """OptionSolveResponseFieldsOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.Option
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.OptionPricingParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.OptionSolveResponseFieldsResponseWithError
        The result of the calculation request.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    resource: Optional["_models.Option"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.OptionPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.OptionSolveResponseFieldsResponseWithError"] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.Option"] = None,
        pricing_preferences: Optional["_models.OptionPricingParameters"] = None,
        analytics: Optional["_models.OptionSolveResponseFieldsResponseWithError"] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionSolveResponseFieldsResponseData(_model_base.Model):
    """OptionSolveResponseFieldsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.OptionDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.OptionPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.OptionSolveResponseFieldsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.OptionDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.OptionPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.OptionSolveResponseFieldsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.OptionDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.OptionPricingParameters"] = None,
        analytics: Optional[List["_models.OptionSolveResponseFieldsResponseWithError"]] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionSolveResponseFieldsResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    description : ~analyticsapi.models.OptionDescriptionFields
        An object that contains fields related to the description of an option
        instument. Required.
    valuation : ~analyticsapi.models.OptionValuationFields
        An object that contains fields related to the valuation of an option
        instrument.
    risk : ~analyticsapi.models.OptionRiskFields
        An object that contains fields related to the risk assessment of an
        option instrument.
    solving : ~analyticsapi.models.SolvingResult
        An object that contains the solving result for an option instrument.
        Required.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    description: "_models.OptionDescriptionFields" = rest_field()
    """An object that contains fields related to the description of an option instument. Required."""
    valuation: Optional["_models.OptionValuationFields"] = rest_field()
    """An object that contains fields related to the valuation of an option instrument."""
    risk: Optional["_models.OptionRiskFields"] = rest_field()
    """An object that contains fields related to the risk assessment of an option instrument."""
    solving: "_models.SolvingResult" = rest_field()
    """An object that contains the solving result for an option instrument. Required."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        description: "_models.OptionDescriptionFields",
        solving: "_models.SolvingResult",
        valuation: Optional["_models.OptionValuationFields"] = None,
        risk: Optional["_models.OptionRiskFields"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionSolvingParameters(_model_base.Model):
    """An object that contains the solving target and variable parameters.

    Attributes
    ----------
    variable : ~analyticsapi.models.OptionSolvingVariable
        An object that contains the properties applied to the variable
        parameter set for an exchange-traded option. The solution is calculated
        for the varaible considering the target parameter. Required.
    target : ~analyticsapi.models.OptionSolvingTarget
        An object that contains the properties applied to the target parameter
        set for an exchange-traded option. Required.
    """

    variable: "_models.OptionSolvingVariable" = rest_field()
    """An object that contains the properties applied to the variable parameter set for an
     exchange-traded option. The solution is calculated for the varaible considering the target
     parameter. Required."""
    target: "_models.OptionSolvingTarget" = rest_field()
    """An object that contains the properties applied to the target parameter set for an
     exchange-traded option. Required."""

    @overload
    def __init__(
        self,
        *,
        variable: "_models.OptionSolvingVariable",
        target: "_models.OptionSolvingTarget",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionSolvingTarget(_model_base.Model):
    """An object that contains the parameter and its value that will be used as the target of the
    solving operation.

    Attributes
    ----------
    market_value : ~analyticsapi.models.Measure
        An object that describes the market value of an an exchange-traded
        option as a target parameter.
    """

    market_value: Optional["_models.Measure"] = rest_field(name="marketValue")
    """An object that describes the market value of an an exchange-traded option as a target
     parameter."""

    @overload
    def __init__(
        self,
        market_value: Optional["_models.Measure"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["market_value"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class OptionSolvingVariable(_model_base.Model):
    """An object that contains the properties that define the varaible part of the solving operation.

    Attributes
    ----------
    name : str or ~analyticsapi.models.OptionSolvingVariableEnum
        The variable parameter selected  for the solving operation. Required.
        Known values are: "Volatility" and "Strike".
    start_point : float
        The initial value of the variable parameter used for solving.
    """

    name: Union[str, "_models.OptionSolvingVariableEnum"] = rest_field()
    """The variable parameter selected  for the solving operation. Required. Known values are:
     \"Volatility\" and \"Strike\"."""
    start_point: Optional[float] = rest_field(name="startPoint")
    """The initial value of the variable parameter used for solving."""

    @overload
    def __init__(
        self,
        *,
        name: Union[str, "_models.OptionSolvingVariableEnum"],
        start_point: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionValuationFields(_model_base.Model):
    """An object that contains fields related to the valuation of an option instrument.

    Attributes
    ----------
    volatility : ~analyticsapi.models.Rate
        An object used to express the implied volatility of an option
        instrument, which is defined as the degree of the underlying asset's
        price variations over a specified time period.
    market_value : ~analyticsapi.models.Measure
        An object used to express the market value of an option instrument.
    total_market_value : ~analyticsapi.models.Measure
        An object used to express the market value (premium) of an option
        instrument computed per transaction. It is calculated as the option's
        market value multiplied by the lot size and multiplied by the number of
        contracts bought or sold.
    intrinsic_value : ~analyticsapi.models.Measure
        An object used to express the intrinsic value of an option instrument,
        which is defined as the difference between the option's strike price
        and the market price of the underlying asset. It is calculated:

        * for a call option as [underlying price  strike],
        * for a put option as [strike  underlying price].

        If it gives a negative result, the intrinsic value is zero.
    time_value : ~analyticsapi.models.Measure
        An object used to express the time value of an option instrument, which
        is defined as the difference between the market value of the option and
        its intrinsic value. When expressed in percentage, it is calculated
        relative to the price of the underlying asset.
    premium_over_cash : ~analyticsapi.models.Measure
        An object used to express the additional premium paid to buy or sell
        the underlying asset via an option instrument, rather than through the
        market. It is calculated:

        * for a call option as [break-even price  underlying price],
        * for a put option as [underlying price  break-even price].

        When expressed in percentage, it is calculated relative to the price of the underlying asset.
    moneyness : ~analyticsapi.models.Rate
        An object used to express the moneyness of an option instrument, which
        is defined as the measure of the degree to which the option is likely
        to have a positive monetary value at expiration. It describes whether
        the option is in- or out of the money and calculated:

        * for a call option as [underlying price / strike],
        * for a put option as [strike / underlying price].
    annualized_yield : ~analyticsapi.models.Rate
        An object used to express the annualized yield of an option instrument,
        which is calculated:

        * for a call option as [(strike  underlying price + market value) / underlying price / years
        to expiry],
        * for a put option as [(underlying price  strike + market value) / underlying price / years to
        expiry].
    forward_premium : ~analyticsapi.models.Rate
        An object used to express the price of an option instrument on the
        delivery date.
    forward_market_value : ~analyticsapi.models.Measure
        An object used to express the market value of an option instrument on
        the delivery date.
    fx_spot : float
        The spot value of the cross-currency pair, which is the price of one
        unit of foreign currency expressed in domestic currency (e.g., EURUSD =
        1.05 means that 1 EUR = 1.05 USD).
    fx_outright : float
        The outright price of the currency pair for the selected price side of
        an option instrument.
    fx_swap : float
        The FX Swap price of the currency pair for the selected price side of
        an option instrument.
    domestic_deposit_rate : ~analyticsapi.models.Rate
        An object used to express the domestic deposit rate on the delivery
        date.
    foreign_deposit_rate : ~analyticsapi.models.Rate
        An object used to express the foreign deposit rate on the delivery
        date.
    """

    volatility: Optional["_models.Rate"] = rest_field()
    """An object used to express the implied volatility of an option instrument, which is defined as
     the degree of the underlying asset's price variations over a specified time period."""
    market_value: Optional["_models.Measure"] = rest_field(name="marketValue")
    """An object used to express the market value of an option instrument."""
    total_market_value: Optional["_models.Measure"] = rest_field(name="totalMarketValue")
    """An object used to express the market value (premium) of an option instrument computed per
     transaction.
     It is calculated as the option's market value multiplied by the lot size and multiplied by the
     number of contracts bought or sold."""
    intrinsic_value: Optional["_models.Measure"] = rest_field(name="intrinsicValue")
    """An object used to express the intrinsic value of an option instrument, which is defined as the
     difference between the option's strike price and the market price of the underlying asset.
     It is calculated:
     
     
     * for a call option as [underlying price  strike],
     * for a put option as [strike  underlying price].
     
     If it gives a negative result, the intrinsic value is zero."""
    time_value: Optional["_models.Measure"] = rest_field(name="timeValue")
    """An object used to express the time value of an option instrument, which is defined as the
     difference between the market value of the option and its intrinsic value.
     When expressed in percentage, it is calculated relative to the price of the underlying asset."""
    premium_over_cash: Optional["_models.Measure"] = rest_field(name="premiumOverCash")
    """An object used to express the additional premium paid to buy or sell the underlying asset via
     an option instrument, rather than through the market.
     It is calculated:
     
     
     * for a call option as [break-even price  underlying price],
     * for a put option as [underlying price  break-even price].
     
     When expressed in percentage, it is calculated relative to the price of the underlying asset."""
    moneyness: Optional["_models.Rate"] = rest_field()
    """An object used to express the moneyness of an option instrument, which is defined as the
     measure of the degree to which the option is likely to have a positive monetary value at
     expiration.
     It describes whether the option is in- or out of the money and calculated:
     
     
     * for a call option as [underlying price / strike],
     * for a put option as [strike / underlying price]."""
    annualized_yield: Optional["_models.Rate"] = rest_field(name="annualizedYield")
    """An object used to express the annualized yield of an option instrument, which is calculated:
     
     
     * for a call option as [(strike  underlying price + market value) / underlying price / years
     to expiry],
     * for a put option as [(underlying price  strike + market value) / underlying price / years to
     expiry]."""
    forward_premium: Optional["_models.Rate"] = rest_field(name="forwardPremium")
    """An object used to express the price of an option instrument on the delivery date."""
    forward_market_value: Optional["_models.Measure"] = rest_field(name="forwardMarketValue")
    """An object used to express the market value of an option instrument on the delivery date."""
    fx_spot: Optional[float] = rest_field(name="fxSpot")
    """The spot value of the cross-currency pair, which is the price of one unit of foreign currency
     expressed in domestic currency (e.g., EURUSD = 1.05 means that 1 EUR = 1.05 USD)."""
    fx_outright: Optional[float] = rest_field(name="fxOutright")
    """The outright price of the currency pair for the selected price side of an option instrument."""
    fx_swap: Optional[float] = rest_field(name="fxSwap")
    """The FX Swap price of the currency pair for the selected price side of an option instrument."""
    domestic_deposit_rate: Optional["_models.Rate"] = rest_field(name="domesticDepositRate")
    """An object used to express the domestic deposit rate on the delivery date."""
    foreign_deposit_rate: Optional["_models.Rate"] = rest_field(name="foreignDepositRate")
    """An object used to express the foreign deposit rate on the delivery date."""

    @overload
    def __init__(
        self,
        *,
        volatility: Optional["_models.Rate"] = None,
        market_value: Optional["_models.Measure"] = None,
        total_market_value: Optional["_models.Measure"] = None,
        intrinsic_value: Optional["_models.Measure"] = None,
        time_value: Optional["_models.Measure"] = None,
        premium_over_cash: Optional["_models.Measure"] = None,
        moneyness: Optional["_models.Rate"] = None,
        annualized_yield: Optional["_models.Rate"] = None,
        forward_premium: Optional["_models.Rate"] = None,
        forward_market_value: Optional["_models.Measure"] = None,
        fx_spot: Optional[float] = None,
        fx_outright: Optional[float] = None,
        fx_swap: Optional[float] = None,
        domestic_deposit_rate: Optional["_models.Rate"] = None,
        foreign_deposit_rate: Optional["_models.Rate"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionValuationResponse(_model_base.Model):
    """The description of the Option valuation response.

    Attributes
    ----------
    data : ~analyticsapi.models.OptionValuationResponseFieldsOnResourceResponseData
        Required.
    """

    data: "_models.OptionValuationResponseFieldsOnResourceResponseData" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        data: "_models.OptionValuationResponseFieldsOnResourceResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class OptionValuationResponseFieldsOnResourceResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """OptionValuationResponseFieldsOnResourceResponseData.

    Attributes
    ----------
    resource : ~analyticsapi.models.Option
        Definition of the resource.
    pricing_preferences : ~analyticsapi.models.OptionPricingParameters
        The parameters that control the computation of the analytics.
    analytics : ~analyticsapi.models.OptionValuationResponseFieldsResponseWithError
        The result of the calculation request.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    resource: Optional["_models.Option"] = rest_field()
    """Definition of the resource."""
    pricing_preferences: Optional["_models.OptionPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional["_models.OptionValuationResponseFieldsResponseWithError"] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        resource: Optional["_models.Option"] = None,
        pricing_preferences: Optional["_models.OptionPricingParameters"] = None,
        analytics: Optional["_models.OptionValuationResponseFieldsResponseWithError"] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionValuationResponseFieldsResponseData(_model_base.Model):  # pylint: disable=name-too-long
    """OptionValuationResponseFieldsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.OptionDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.OptionPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.OptionValuationResponseFieldsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketData
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.OptionDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.OptionPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.OptionValuationResponseFieldsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketData"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.OptionDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.OptionPricingParameters"] = None,
        analytics: Optional[List["_models.OptionValuationResponseFieldsResponseWithError"]] = None,
        market_data: Optional["_models.MarketData"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OptionValuationResponseFieldsResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    description : ~analyticsapi.models.OptionDescriptionFields
        An object that contains fields related to the description of an option
        instument. Required.
    valuation : ~analyticsapi.models.OptionValuationFields
        An object that contains fields related to the valuation of an option
        instrument.
    risk : ~analyticsapi.models.OptionRiskFields
        An object that contains fields related to the risk assessment of an
        option instrument.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    description: "_models.OptionDescriptionFields" = rest_field()
    """An object that contains fields related to the description of an option instument. Required."""
    valuation: Optional["_models.OptionValuationFields"] = rest_field()
    """An object that contains fields related to the valuation of an option instrument."""
    risk: Optional["_models.OptionRiskFields"] = rest_field()
    """An object that contains fields related to the risk assessment of an option instrument."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        description: "_models.OptionDescriptionFields",
        valuation: Optional["_models.OptionValuationFields"] = None,
        risk: Optional["_models.OptionRiskFields"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OriginChannel(_model_base.Model):
    """OriginChannel.

    Attributes
    ----------
    unspecified : ~decimal.Decimal
    broker : ~decimal.Decimal
    correspondence : ~decimal.Decimal
    retail : ~decimal.Decimal
    """

    unspecified: Optional[decimal.Decimal] = rest_field()
    broker: Optional[decimal.Decimal] = rest_field()
    correspondence: Optional[decimal.Decimal] = rest_field()
    retail: Optional[decimal.Decimal] = rest_field()

    @overload
    def __init__(
        self,
        *,
        unspecified: Optional[decimal.Decimal] = None,
        broker: Optional[decimal.Decimal] = None,
        correspondence: Optional[decimal.Decimal] = None,
        retail: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OvernightIndexSwapConstituent(IrConstituent, discriminator="OvernightIndexSwap"):
    """An object defining an overnight index swap constituent of an interest rate curve.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    index : str
        This is the reference Index of the curve that the constituent
        contributes to. For instance (e.g. LIBOR 3M). Required.
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
        Required.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.OVERNIGHT_INDEX_SWAP
        The type of constituent. OvernightIndexSwap is the only valid value.
        Required.
    definition : ~analyticsapi.models.OvernightIndexSwapConstituentDefinition
        An object to define the overnight index swap used as a constituent.
        Required.
    """

    type: Literal[IrConstituentEnum.OVERNIGHT_INDEX_SWAP] = rest_discriminator(name="type")  # type: ignore
    """The type of constituent. OvernightIndexSwap is the only valid value. Required."""
    definition: "_models.OvernightIndexSwapConstituentDefinition" = rest_field()
    """An object to define the overnight index swap used as a constituent. Required."""

    @overload
    def __init__(
        self,
        *,
        index: str,
        quote: "_models.Quote",
        definition: "_models.OvernightIndexSwapConstituentDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=IrConstituentEnum.OVERNIGHT_INDEX_SWAP, **kwargs)


class OvernightIndexSwapConstituentDefinition(_model_base.Model):
    """The definition of an overnight index swap instrument used as a constituent of an interest rate
    curve.

    Attributes
    ----------
    tenor : str
        The code indicating the tenor of the instrument used as a constituent
        (e.g., '1M', '1Y'). Required.
    template : str
        A pre-defined template can be used as an input by the user. It is the
        currency code of the constituent. Required.
    """

    tenor: str = rest_field()
    """The code indicating the tenor of the instrument used as a constituent (e.g., '1M', '1Y').
     Required."""
    template: str = rest_field()
    """A pre-defined template can be used as an input by the user. It is the currency code of the
     constituent. Required."""

    @overload
    def __init__(
        self,
        *,
        tenor: str,
        template: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OverrideBidAsk(_model_base.Model):
    """OverrideBidAsk.

    Attributes
    ----------
    date : ~datetime.date
        Overridden date.
    fields : ~analyticsapi.models.OverrideBidAskFields
    instrument_code : str
        Reuters instrument code (RIC).
    """

    date: Optional[datetime.date] = rest_field()
    """Overridden date."""
    fields: Optional["_models.OverrideBidAskFields"] = rest_field()
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """Reuters instrument code (RIC)."""

    @overload
    def __init__(
        self,
        *,
        date: Optional[datetime.date] = None,
        fields: Optional["_models.OverrideBidAskFields"] = None,
        instrument_code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class OverrideBidAskFields(_model_base.Model):
    """OverrideBidAskFields.

    Attributes
    ----------
    ask : float
        Overridden value.
    bid : float
        Overridden value.
    """

    ask: Optional[float] = rest_field()
    """Overridden value."""
    bid: Optional[float] = rest_field()
    """Overridden value."""

    @overload
    def __init__(
        self,
        *,
        ask: Optional[float] = None,
        bid: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ParallelShift(_model_base.Model):
    """ParallelShift.

    Attributes
    ----------
    amount : float
        Amount of shifting, applied to points depending on shift method
        selected. Can be measured in basis points/percents/future price based
        points. Also can be expressed as multiplier for relative shift type.
    ignore_quotation_scale : bool
    shift_type : str or ~analyticsapi.models.ShiftTypeEnum
        The type of shifting. The possible values are:   * Additive: the amount
        of shifting is added to the corresponding curve point,   * Relative:
        the curve point is multiplied by the amount of shifting (e.g., if
        amount = 1, the curve point value will be doubled),   * Scaled: the
        curve point is scaled by the value of the shifting amount (e.g., if
        amount = 1.1, the curve point value will multiplied by this value).
        Known values are: "Additive", "Relative", and "Scaled".
    shift_unit : str or ~analyticsapi.models.ShiftUnitEnum
        The unit that describes the amount of shifting. The possible values
        are:   * Absolute: the amount of shifting is expressed in absolute
        value.   * Bp: the amount of shifting is expressed in basis points,   *
        Percent: the amount of shifting is expressed in percentages,. Known
        values are: "Absolute", "Bp", and "Percent".
    """

    amount: Optional[float] = rest_field()
    """Amount of shifting, applied to points depending on shift method selected. Can be measured in
     basis points/percents/future price based points. Also can be expressed as multiplier for
     relative shift type."""
    ignore_quotation_scale: Optional[bool] = rest_field(name="ignoreQuotationScale")
    shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = rest_field(name="shiftType")
    """The type of shifting. The possible values are:   * Additive: the amount of shifting is added to
     the corresponding curve point,   * Relative: the curve point is multiplied by the amount of
     shifting (e.g., if amount = 1, the curve point value will be doubled),   * Scaled: the curve
     point is scaled by the value of the shifting amount (e.g., if amount = 1.1, the curve point
     value will multiplied by this value). Known values are: \"Additive\", \"Relative\", and
     \"Scaled\"."""
    shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = rest_field(name="shiftUnit")
    """The unit that describes the amount of shifting. The possible values are:   * Absolute: the
     amount of shifting is expressed in absolute value.   * Bp: the amount of shifting is expressed
     in basis points,   * Percent: the amount of shifting is expressed in percentages,. Known values
     are: \"Absolute\", \"Bp\", and \"Percent\"."""

    @overload
    def __init__(
        self,
        *,
        amount: Optional[float] = None,
        ignore_quotation_scale: Optional[bool] = None,
        shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = None,
        shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ParRateShift(_model_base.Model):
    """Scenario of par rates shift (shift applied to constituents).

    Attributes
    ----------
    cross_currency_instruments : dict[str, ~analyticsapi.models.ShiftCrossCurrencyInstrumentsItem]
        Get crossCurrencyInstruments.
    interest_rate_instruments : dict[str, ~analyticsapi.models.ShiftInterestRateInstrumentsPerBasis]
        Get interestRateInstruments.
    """

    cross_currency_instruments: Optional[Dict[str, "_models.ShiftCrossCurrencyInstrumentsItem"]] = rest_field(
        name="crossCurrencyInstruments"
    )
    """Get crossCurrencyInstruments."""
    interest_rate_instruments: Optional[Dict[str, "_models.ShiftInterestRateInstrumentsPerBasis"]] = rest_field(
        name="interestRateInstruments"
    )
    """Get interestRateInstruments."""

    @overload
    def __init__(
        self,
        *,
        cross_currency_instruments: Optional[Dict[str, "_models.ShiftCrossCurrencyInstrumentsItem"]] = None,
        interest_rate_instruments: Optional[Dict[str, "_models.ShiftInterestRateInstrumentsPerBasis"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Partials(_model_base.Model):
    """Partials.

    Attributes
    ----------
    curve_type : str
        Is one of the following types: Literal["PAR"], Literal["SPOT"],
        Literal["FORWARD"]
    curve_shift : float
        Shock amount, in basis points.
    shock_type : str
        Is either a Literal["SQUARE"] type or a Literal["TRIANGLE"] type.
    use_cumulative_wave_method : bool
        A cumulative shock which starts at the short end and attributes
        sensitivity to the tenors as it moves through the curve, so the entire
        curve is shocked by 25bps.
    partial_duration_years : list[float]
        Specific custom partial points.  The default value is None, needs to be
        assigned before using.
    """

    curve_type: Optional[Literal["PAR", "SPOT", "FORWARD"]] = rest_field(name="curveType")
    """Is one of the following types: Literal[\"PAR\"], Literal[\"SPOT\"], Literal[\"FORWARD\"]"""
    curve_shift: Optional[float] = rest_field(name="curveShift")
    """Shock amount, in basis points."""
    shock_type: Optional[Literal["SQUARE", "TRIANGLE"]] = rest_field(name="shockType")
    """Is either a Literal[\"SQUARE\"] type or a Literal[\"TRIANGLE\"] type."""
    use_cumulative_wave_method: Optional[bool] = rest_field(name="useCumulativeWaveMethod")
    """A cumulative shock which starts at the short end and attributes sensitivity to the tenors as it
     moves through the curve, so the entire curve is shocked by 25bps."""
    partial_duration_years: Optional[List[float]] = rest_field(name="partialDurationYears")
    """Specific custom partial points."""

    @overload
    def __init__(
        self,
        *,
        curve_type: Optional[Literal["PAR", "SPOT", "FORWARD"]] = None,
        curve_shift: Optional[float] = None,
        shock_type: Optional[Literal["SQUARE", "TRIANGLE"]] = None,
        use_cumulative_wave_method: Optional[bool] = None,
        partial_duration_years: Optional[List[float]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Payment(_model_base.Model):
    """An object that defines a payment.

    Attributes
    ----------
    date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the payment
        date.
    amount : ~analyticsapi.models.Amount
        An object that defines the amount and currency of a payment. Required.
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that makes the payment. Required. Known
        values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that receives the payment. Required. Known
        values are: "Party1" and "Party2".
    """

    date: Optional["_models.Date"] = rest_field()
    """An object that contains properties to define and adjust the payment date."""
    amount: "_models.Amount" = rest_field()
    """An object that defines the amount and currency of a payment. Required."""
    payer: Union[str, "_models.PartyEnum"] = rest_field()
    """The party (Party1 or Party2) that makes the payment. Required. Known values are: \"Party1\" and
     \"Party2\"."""
    receiver: Union[str, "_models.PartyEnum"] = rest_field()
    """The party (Party1 or Party2) that receives the payment. Required. Known values are: \"Party1\"
     and \"Party2\"."""

    @overload
    def __init__(
        self,
        *,
        amount: "_models.Amount",
        payer: Union[str, "_models.PartyEnum"],
        receiver: Union[str, "_models.PartyEnum"],
        date: Optional["_models.Date"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PaymentSettlementDefinition(_model_base.Model):
    """An object that describes settlement parameters.

    Attributes
    ----------
    currency : str
        The settlement currency. The value is expressed in ISO 4217
        alphabetical format (e.g., 'GBP'). Required.
    fixing_lag : ~analyticsapi.models.OffsetDefinition
        An object that defines how FX rate is fixed prior to settlement.
    """

    currency: str = rest_field()
    """The settlement currency. The value is expressed in ISO 4217 alphabetical format (e.g., 'GBP').
     Required."""
    fixing_lag: Optional["_models.OffsetDefinition"] = rest_field(name="fixingLag")
    """An object that defines how FX rate is fixed prior to settlement."""

    @overload
    def __init__(
        self,
        *,
        currency: str,
        fixing_lag: Optional["_models.OffsetDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PayoffCashflow(Cashflow, discriminator="Payoff"):
    """Lists the properties for Payoff payment type.

    Attributes
    ----------
    date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the payment
        date.
    amount : ~analyticsapi.models.Amount
        An object that defines the amount and currency of a payment. Required.
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that makes the payment. Required. Known
        values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that receives the payment. Required. Known
        values are: "Party1" and "Party2".
    occurrence : str or ~analyticsapi.models.PaymentOccurrenceEnum
        The timeline of the transaction. The possible values are: Historical:
        the cash flow date is earlier than the valuation date, Future: the cash
        flow date follows the valuation date and the cash flow is known,
        Projected: the cash flow date follows the valuation date and the cash
        flow is not set by the contract but estimated. Required. Known values
        are: "Historical", "Future", and "Projected".
    payment_type : str or ~analyticsapi.models.PAYOFF
        Required.
    index_fixings : list[~analyticsapi.models.IndexFixing]
        The coupon payment information. Applies to floating rate instruments.
        The default value is None, needs to be assigned before using.
    """

    payment_type: Literal[CashFlowPaymentTypeEnum.PAYOFF] = rest_discriminator(name="paymentType")  # type: ignore
    """Required."""
    index_fixings: Optional[List["_models.IndexFixing"]] = rest_field(name="indexFixings")
    """The coupon payment information. Applies to floating rate instruments."""

    @overload
    def __init__(
        self,
        *,
        amount: "_models.Amount",
        payer: Union[str, "_models.PartyEnum"],
        receiver: Union[str, "_models.PartyEnum"],
        occurrence: Union[str, "_models.PaymentOccurrenceEnum"],
        date: Optional["_models.Date"] = None,
        index_fixings: Optional[List["_models.IndexFixing"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, payment_type=CashFlowPaymentTypeEnum.PAYOFF, **kwargs)


class PremiumCashflow(Cashflow, discriminator="Premium"):
    """Lists the properties for Premium payment type.

    Attributes
    ----------
    date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the payment
        date.
    amount : ~analyticsapi.models.Amount
        An object that defines the amount and currency of a payment. Required.
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that makes the payment. Required. Known
        values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that receives the payment. Required. Known
        values are: "Party1" and "Party2".
    occurrence : str or ~analyticsapi.models.PaymentOccurrenceEnum
        The timeline of the transaction. The possible values are: Historical:
        the cash flow date is earlier than the valuation date, Future: the cash
        flow date follows the valuation date and the cash flow is known,
        Projected: the cash flow date follows the valuation date and the cash
        flow is not set by the contract but estimated. Required. Known values
        are: "Historical", "Future", and "Projected".
    payment_type : str or ~analyticsapi.models.PREMIUM
        Required.
    """

    payment_type: Literal[CashFlowPaymentTypeEnum.PREMIUM] = rest_discriminator(name="paymentType")  # type: ignore
    """Required."""

    @overload
    def __init__(
        self,
        *,
        amount: "_models.Amount",
        payer: Union[str, "_models.PartyEnum"],
        receiver: Union[str, "_models.PartyEnum"],
        occurrence: Union[str, "_models.PaymentOccurrenceEnum"],
        date: Optional["_models.Date"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["payment_type"] = args[0]
            args = tuple()
        super().__init__(*args, payment_type=CashFlowPaymentTypeEnum.PREMIUM, **kwargs)


class PremiumLegDefinition(_model_base.Model):
    """PremiumLegDefinition.

    Attributes
    ----------
    accrued_calculation_method : str or ~analyticsapi.models.AccruedCalculationMethodEnum
        The day count basis method used to calculate the accrued interest
        payments (e.g. Dcb_30_360, Dcb_30_Actual). If instrumentCode is
        defined, the value comes from the instrument reference data. In case of
        a user-defined instrument, interestCalculationMethod is used. Known
        values are: "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German",
        "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
        "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual",
        "Dcb_30_Actual_ISDA", "Dcb_30E_360_ISMA", "Dcb_Actual_360",
        "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
        "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB",
        "Dcb_WorkingDays_252", "Dcb_Actual_365L", "Dcb_Actual_365P",
        "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525",
        "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
    accrued_paid_on_default : bool
        An indicator which specifies whether the accrued is paid at the credit
        event date or not.

        * true: the accrued is paid at the credit event date,
        * false: the accrued is not paid at the credit event date.

        Optional. Defaults to true.
    direction : str or ~analyticsapi.models.IPADirectionEnum
        The indication whether the cash flows of the instrument's leg are paid
        or received. Mandatory if instrumentCode or template is not defined. If
        instrumentCode or template is defined, the value comes from the
        instrument reference data. The possible values are:

        * For Swap:
          Paid: the cash flows are paid to the counterparty,
          Received: the cash flows are received from the counterparty.
        * For CDS:
          Paid: the fixed payments are paid by the counterparty (applied to the CDS buyer),
          Received: the fixed payments are received from the counterparty (applied to the CDS seller).
        * For Bond and Loan: Not applicable. Known values are: "Paid" and "Received".
    first_regular_payment_date : ~datetime.datetime
        The first regular interest payment date used for the odd first interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).

        * For Swap: No default value applies.
        * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
        stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
        instrument reference data.
        * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency.
    fixed_rate_percent : float
        The interest rate used to derive future fixed interest payments of the
        instrument. The value is expressed in percentages. Either
        fixedRatePercent or fixedRatePercentSchedule is used. In Swap, applies
        to fixed leg only. If instrumentCode is defined, the value comes from
        the instrument reference data. In case of a user-defined instrument,
        the default value is '0' for Bond, par rate for Swap and '1' for CDS.
        For Loan: Mandatory for a fixed rate loan. No default value applies.
    interest_calculation_method : str or ~analyticsapi.models.InterestCalculationMethodEnum
        The day count basis method used to calculate the interest payments(e.g.
        Dcb_30_360, Dcb_30_Actual).

        * For Swap: The default value is selected based on notionalCcy.
        * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
        comes from the instrument reference data.
        * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
        Otherwise, the default value is 'Dcb_Actual_360'.
        * For Loan: Mandatory. No default value applies. Known values are: "Dcb_30_360",
        "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA",
        "Dcb_30_365_German", "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual",
        "Dcb_30_Actual_ISDA", "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365",
        "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252",
        "Dcb_Actual_365L", "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
    interest_payment_ccy : str
        The currency of the interest payment of the premium leg. The value is
        expressed in ISO 4217 alphabetical format (e.g., 'EUR'). Mandatory if
        instrumenCode is not defined. If instrumentCode is defined, the value
        comes from the instrument reference data.
    interest_payment_frequency : str or ~analyticsapi.models.InterestPaymentFrequencyEnum
        The interest payment frequency.

        * For Swap: Either indexResetFrequency or InterestPaymentFrequency must be provided (e.g.
        Annual, SemiAnnual). The default value is indexResetFrequency.
        * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
        comes from the instrument reference data.
        * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
        Otherwise, the default value is 'Quaterly'.
        * For Loan: Mandatory. No default value applies. Known values are: "Annual", "SemiAnnual",
        "Quarterly", "Monthly", "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every91Days", "Every182Days", "Every364Days",
        "Every365Days", "Every90Days", "Every92Days", "Every93Days", "Every180Days", "Every183Days",
        "Every184Days", "Every4Months", "R2", "R4", "Zero", and "Scheduled".
    last_regular_payment_date : ~datetime.datetime
        The last regular interest payment date used for the odd last interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).

        * For Swap: No default value applies.
        * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
        stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
        instrument reference data.
        * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency.
    notional_amount : float
        The notional amount of the instrument. Optional. The default value is
        '1,000,000'. For CDS: the amounts for the premium and protection legs
        must be equal.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g. 'USD'). If
        instrumentCode is defined, the value comes from the instrument
        reference data.

        * For Swap: Mandatory for SwapLegDefinition if instrumentCode is not defined.
        * For CDS: Mandatory for protectionLeg definition if instrumentCode is not defined. For
        premiumLeg definition, it is derived from pretctionLeg definition.
        * For Bond and Loan: Mandatory if no instrumentCode is defined.
    payment_business_day_convention : str or ~analyticsapi.models.PaymentBusinessDayConventionEnum
        The method to adjust dates to working days. The possible values are:
        PreviousBusinessDay, NextBusinessDay, Modified following, NoMoving,
        BBSWModifiedFollowing. If instrumentCode is defined, the value comes
        from the instrument reference data. In case of a user-defined
        instrument, the default value is 'ModifiedFollowing'. Known values are:
        "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay",
        "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing".
    payment_business_days : str
        A list of comma-separated calendar codes to adjust dates (e.g. 'EMU' or
        'USA').

        * For Swap: The default value is the calendar associated to the market conventions of the
        InterestPaymentCcy for the corresponding leg.
        * For Bond and Loan: The default value is the calendar associated to NotionalCcy.
    stub_rule : str or ~analyticsapi.models.FinancialContractStubRuleEnum
        The rule that defines whether coupon roll dates are aligned to the
        maturity or issue date. The possible values are: Issue, Maturity,
        ShortFirstProRata, ShortFirstFull, LongFirstFull, ShortLastProRata. If
        instrumentCode is defined, the value comes from the instrument
        reference data. In case of a user-defined instrument, the default value
        is 'Maturity'. Known values are: "Issue", "Maturity",
        "ShortFirstProRata", "ShortFirstFull", "LongFirstFull", and
        "ShortLastProRata".
    """

    accrued_calculation_method: Optional[Union[str, "_models.AccruedCalculationMethodEnum"]] = rest_field(
        name="accruedCalculationMethod"
    )
    """The day count basis method used to calculate the accrued interest payments (e.g. Dcb_30_360,
     Dcb_30_Actual).
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, interestCalculationMethod is used. Known values are: \"Dcb_30_360\",
     \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\",
     \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\",
     \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\",
     \"Dcb_Actual_365_CanadianConvention\", and \"Dcb_Constant\"."""
    accrued_paid_on_default: Optional[bool] = rest_field(name="accruedPaidOnDefault")
    """An indicator which specifies whether the accrued is paid at the credit event date or not.
     
     
     * true: the accrued is paid at the credit event date,
     * false: the accrued is not paid at the credit event date.
     
     Optional. Defaults to true."""
    direction: Optional[Union[str, "_models.IPADirectionEnum"]] = rest_field()
    """The indication whether the cash flows of the instrument's leg are paid or received.
     Mandatory if instrumentCode or template is not defined. If instrumentCode or template is
     defined, the value comes from the instrument reference data.
     The possible values are:
     
     
     * For Swap:
       Paid: the cash flows are paid to the counterparty,
       Received: the cash flows are received from the counterparty.
     * For CDS:
       Paid: the fixed payments are paid by the counterparty (applied to the CDS buyer),
       Received: the fixed payments are received from the counterparty (applied to the CDS seller).
     * For Bond and Loan: Not applicable. Known values are: \"Paid\" and \"Received\"."""
    first_regular_payment_date: Optional[datetime.datetime] = rest_field(
        name="firstRegularPaymentDate", format="rfc3339"
    )
    """The first regular interest payment date used for the odd first interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
     
     
     * For Swap: No default value applies.
     * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
     stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
     instrument reference data.
     * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency."""
    fixed_rate_percent: Optional[float] = rest_field(name="fixedRatePercent")
    """The interest rate used to derive future fixed interest payments of the instrument. The value is
     expressed in percentages. Either fixedRatePercent or fixedRatePercentSchedule is used.
     In Swap, applies to fixed leg only.
     If instrumentCode is defined, the value comes from the instrument reference data.
     In case of a user-defined instrument, the default value is '0' for Bond, par rate for Swap and
     '1' for CDS.
     For Loan: Mandatory for a fixed rate loan. No default value applies."""
    interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = rest_field(
        name="interestCalculationMethod"
    )
    """The day count basis method used to calculate the interest payments(e.g. Dcb_30_360,
     Dcb_30_Actual).
     
     
     * For Swap: The default value is selected based on notionalCcy.
     * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
     comes from the instrument reference data.
     * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
     Otherwise, the default value is 'Dcb_Actual_360'.
     * For Loan: Mandatory. No default value applies. Known values are: \"Dcb_30_360\",
     \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\",
     \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\",
     \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\",
     \"Dcb_Actual_365_CanadianConvention\", and \"Dcb_Constant\"."""
    interest_payment_ccy: Optional[str] = rest_field(name="interestPaymentCcy")
    """The currency of the interest payment of the premium leg. The value is expressed in ISO 4217
     alphabetical format (e.g., 'EUR').
     Mandatory if instrumenCode is not defined. If instrumentCode is defined, the value comes from
     the instrument reference data."""
    interest_payment_frequency: Optional[Union[str, "_models.InterestPaymentFrequencyEnum"]] = rest_field(
        name="interestPaymentFrequency"
    )
    """The interest payment frequency.
     
     
     * For Swap: Either indexResetFrequency or InterestPaymentFrequency must be provided (e.g.
     Annual, SemiAnnual). The default value is indexResetFrequency.
     * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
     comes from the instrument reference data.
     * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
     Otherwise, the default value is 'Quaterly'.
     * For Loan: Mandatory. No default value applies. Known values are: \"Annual\", \"SemiAnnual\",
     \"Quarterly\", \"Monthly\", \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\", \"Every7Days\",
     \"Every14Days\", \"Every28Days\", \"Every30Days\", \"Every91Days\", \"Every182Days\",
     \"Every364Days\", \"Every365Days\", \"Every90Days\", \"Every92Days\", \"Every93Days\",
     \"Every180Days\", \"Every183Days\", \"Every184Days\", \"Every4Months\", \"R2\", \"R4\",
     \"Zero\", and \"Scheduled\"."""
    last_regular_payment_date: Optional[datetime.datetime] = rest_field(name="lastRegularPaymentDate", format="rfc3339")
    """The last regular interest payment date used for the odd last interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
     
     
     * For Swap: No default value applies.
     * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
     stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
     instrument reference data.
     * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument.
     Optional. The default value is '1,000,000'.
     For CDS: the amounts for the premium and protection legs must be equal."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g. 'USD').
     If instrumentCode is defined, the value comes from the instrument reference data.
     
     
     * For Swap: Mandatory for SwapLegDefinition if instrumentCode is not defined.
     * For CDS: Mandatory for protectionLeg definition if instrumentCode is not defined. For
     premiumLeg definition, it is derived from pretctionLeg definition.
     * For Bond and Loan: Mandatory if no instrumentCode is defined."""
    payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = rest_field(
        name="paymentBusinessDayConvention"
    )
    """The method to adjust dates to working days. The possible values are:
     PreviousBusinessDay,
     NextBusinessDay,
     Modified following,
     NoMoving,
     BBSWModifiedFollowing.
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, the default value is 'ModifiedFollowing'. Known values are:
     \"ModifiedFollowing\", \"NextBusinessDay\", \"PreviousBusinessDay\", \"NoMoving\",
     \"EveryThirdWednesday\", and \"BbswModifiedFollowing\"."""
    payment_business_days: Optional[str] = rest_field(name="paymentBusinessDays")
    """A list of comma-separated calendar codes to adjust dates (e.g. 'EMU' or 'USA').
     
     
     * For Swap: The default value is the calendar associated to the market conventions of the
     InterestPaymentCcy for the corresponding leg.
     * For Bond and Loan: The default value is the calendar associated to NotionalCcy."""
    stub_rule: Optional[Union[str, "_models.FinancialContractStubRuleEnum"]] = rest_field(name="stubRule")
    """The rule that defines whether coupon roll dates are aligned to the maturity or issue date. The
     possible values are:
     Issue,
     Maturity,
     ShortFirstProRata,
     ShortFirstFull,
     LongFirstFull,
     ShortLastProRata.
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, the default value is 'Maturity'. Known values are: \"Issue\",
     \"Maturity\", \"ShortFirstProRata\", \"ShortFirstFull\", \"LongFirstFull\", and
     \"ShortLastProRata\"."""

    @overload
    def __init__(
        self,
        *,
        accrued_calculation_method: Optional[Union[str, "_models.AccruedCalculationMethodEnum"]] = None,
        accrued_paid_on_default: Optional[bool] = None,
        direction: Optional[Union[str, "_models.IPADirectionEnum"]] = None,
        first_regular_payment_date: Optional[datetime.datetime] = None,
        fixed_rate_percent: Optional[float] = None,
        interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = None,
        interest_payment_ccy: Optional[str] = None,
        interest_payment_frequency: Optional[Union[str, "_models.InterestPaymentFrequencyEnum"]] = None,
        last_regular_payment_date: Optional[datetime.datetime] = None,
        notional_amount: Optional[float] = None,
        notional_ccy: Optional[str] = None,
        payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = None,
        payment_business_days: Optional[str] = None,
        stub_rule: Optional[Union[str, "_models.FinancialContractStubRuleEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrepayDialsInput(_model_base.Model):
    """Prepay Dials Settings.

    Attributes
    ----------
    settings : ~analyticsapi.models.PrepayDialsSettings
    dials : ~analyticsapi.models.DefaultDials
    collateral_dials : dict[str, ~analyticsapi.models.DefaultDials]
        The valid values are - CONV, GNMA, WL, ARM, HELS, MANH, ALTA, GHLC.
    """

    settings: Optional["_models.PrepayDialsSettings"] = rest_field()
    dials: Optional["_models.DefaultDials"] = rest_field()
    collateral_dials: Optional[Dict[str, "_models.DefaultDials"]] = rest_field(name="collateralDials")
    """The valid values are - CONV, GNMA, WL, ARM, HELS, MANH, ALTA, GHLC."""

    @overload
    def __init__(
        self,
        *,
        settings: Optional["_models.PrepayDialsSettings"] = None,
        dials: Optional["_models.DefaultDials"] = None,
        collateral_dials: Optional[Dict[str, "_models.DefaultDials"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrepayDialsSettings(_model_base.Model):
    """PrepayDialsSettings.

    Attributes
    ----------
    ignore_housing_inflation_flag : bool
    cmo_geographic_info_flag : bool
    current_coupon_spread_adjustment : ~decimal.Decimal
    ignore_disclosure_info : bool
    short_term_prepay_adjustment_flag : bool
    fnma_model_for_whole_loans_flag : bool
    fnma_model_for_gnma_loans_flag : bool
    fnma_model_for_alta_loans_flag : bool
    ignore_servicer_flag : bool
    ignore_current_delinquency_flag : bool
    commingled_super_as_fn_flag : bool
    use_lphpa_flag : bool
    ignore_sshpa_flag : bool
    ignore_ss_user_hpa_flag : bool
    ignore_dti_dispersion_flag : bool
    ignore_fico_dispersion_flag : bool
    ignore_wala_dispersion_flag : bool
    ignore_ltv_dispersion_flag : bool
    ignore_wac_dispersion_flag : bool
    ignore_model_hpa_scenario_flag : bool
    ps_spread_model_flag : bool
    harp_cutoff_date : str
    ps_spread_lookback : int
    delinquency_resolution_period : int
    home_price_appreciation : ~analyticsapi.models.InterpolationTypeAndVector
    state_home_price_appreciation : list[~analyticsapi.models.StateHomePriceAppreciation]
        The default value is None, needs to be assigned before using.
    unemployment_projection : ~analyticsapi.models.InterpolationTypeAndVector
    cpr_adjustment : ~analyticsapi.models.InterpolationTypeAndVector
    term_unit : str
        Is either a Literal["MONTH"] type or a Literal["YEAR"] type.
    """

    ignore_housing_inflation_flag: Optional[bool] = rest_field(name="ignoreHousingInflationFlag")
    cmo_geographic_info_flag: Optional[bool] = rest_field(name="cmoGeographicInfoFlag")
    current_coupon_spread_adjustment: Optional[decimal.Decimal] = rest_field(name="currentCouponSpreadAdjustment")
    ignore_disclosure_info: Optional[bool] = rest_field(name="ignoreDisclosureInfo")
    short_term_prepay_adjustment_flag: Optional[bool] = rest_field(name="shortTermPrepayAdjustmentFlag")
    fnma_model_for_whole_loans_flag: Optional[bool] = rest_field(name="fnmaModelForWholeLoansFlag")
    fnma_model_for_gnma_loans_flag: Optional[bool] = rest_field(name="fnmaModelForGNMALoansFlag")
    fnma_model_for_alta_loans_flag: Optional[bool] = rest_field(name="fnmaModelForALTALoansFlag")
    ignore_servicer_flag: Optional[bool] = rest_field(name="ignoreServicerFlag")
    ignore_current_delinquency_flag: Optional[bool] = rest_field(name="ignoreCurrentDelinquencyFlag")
    commingled_super_as_fn_flag: Optional[bool] = rest_field(name="commingledSuperAsFNFlag")
    use_lphpa_flag: Optional[bool] = rest_field(name="useLPHPAFlag")
    ignore_sshpa_flag: Optional[bool] = rest_field(name="ignoreSSHPAFlag")
    ignore_ss_user_hpa_flag: Optional[bool] = rest_field(name="ignoreSSUserHPAFlag")
    ignore_dti_dispersion_flag: Optional[bool] = rest_field(name="ignoreDTIDispersionFlag")
    ignore_fico_dispersion_flag: Optional[bool] = rest_field(name="ignoreFICODispersionFlag")
    ignore_wala_dispersion_flag: Optional[bool] = rest_field(name="ignoreWALADispersionFlag")
    ignore_ltv_dispersion_flag: Optional[bool] = rest_field(name="ignoreLTVDispersionFlag")
    ignore_wac_dispersion_flag: Optional[bool] = rest_field(name="ignoreWACDispersionFlag")
    ignore_model_hpa_scenario_flag: Optional[bool] = rest_field(name="ignoreModelHPAScenarioFlag")
    ps_spread_model_flag: Optional[bool] = rest_field(name="psSpreadModelFlag")
    harp_cutoff_date: Optional[str] = rest_field(name="harpCutoffDate")
    ps_spread_lookback: Optional[int] = rest_field(name="psSpreadLookback")
    delinquency_resolution_period: Optional[int] = rest_field(name="delinquencyResolutionPeriod")
    home_price_appreciation: Optional["_models.InterpolationTypeAndVector"] = rest_field(name="homePriceAppreciation")
    state_home_price_appreciation: Optional[List["_models.StateHomePriceAppreciation"]] = rest_field(
        name="stateHomePriceAppreciation"
    )
    unemployment_projection: Optional["_models.InterpolationTypeAndVector"] = rest_field(name="unemploymentProjection")
    cpr_adjustment: Optional["_models.InterpolationTypeAndVector"] = rest_field(name="cprAdjustment")
    term_unit: Optional[Literal["MONTH", "YEAR"]] = rest_field(name="termUnit")
    """Is either a Literal[\"MONTH\"] type or a Literal[\"YEAR\"] type."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        ignore_housing_inflation_flag: Optional[bool] = None,
        cmo_geographic_info_flag: Optional[bool] = None,
        current_coupon_spread_adjustment: Optional[decimal.Decimal] = None,
        ignore_disclosure_info: Optional[bool] = None,
        short_term_prepay_adjustment_flag: Optional[bool] = None,
        fnma_model_for_whole_loans_flag: Optional[bool] = None,
        fnma_model_for_gnma_loans_flag: Optional[bool] = None,
        fnma_model_for_alta_loans_flag: Optional[bool] = None,
        ignore_servicer_flag: Optional[bool] = None,
        ignore_current_delinquency_flag: Optional[bool] = None,
        commingled_super_as_fn_flag: Optional[bool] = None,
        use_lphpa_flag: Optional[bool] = None,
        ignore_sshpa_flag: Optional[bool] = None,
        ignore_ss_user_hpa_flag: Optional[bool] = None,
        ignore_dti_dispersion_flag: Optional[bool] = None,
        ignore_fico_dispersion_flag: Optional[bool] = None,
        ignore_wala_dispersion_flag: Optional[bool] = None,
        ignore_ltv_dispersion_flag: Optional[bool] = None,
        ignore_wac_dispersion_flag: Optional[bool] = None,
        ignore_model_hpa_scenario_flag: Optional[bool] = None,
        ps_spread_model_flag: Optional[bool] = None,
        harp_cutoff_date: Optional[str] = None,
        ps_spread_lookback: Optional[int] = None,
        delinquency_resolution_period: Optional[int] = None,
        home_price_appreciation: Optional["_models.InterpolationTypeAndVector"] = None,
        state_home_price_appreciation: Optional[List["_models.StateHomePriceAppreciation"]] = None,
        unemployment_projection: Optional["_models.InterpolationTypeAndVector"] = None,
        cpr_adjustment: Optional["_models.InterpolationTypeAndVector"] = None,
        term_unit: Optional[Literal["MONTH", "YEAR"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrepayModelSeller(_model_base.Model):
    """PrepayModelSeller.

    Attributes
    ----------
    seller : str
    percent : ~decimal.Decimal
    """

    seller: Optional[str] = rest_field()
    percent: Optional[decimal.Decimal] = rest_field()

    @overload
    def __init__(
        self,
        *,
        seller: Optional[str] = None,
        percent: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrepayModelServicer(_model_base.Model):
    """PrepayModelServicer.

    Attributes
    ----------
    servicer : str
    percent : ~decimal.Decimal
    """

    servicer: Optional[str] = rest_field()
    percent: Optional[decimal.Decimal] = rest_field()

    @overload
    def __init__(
        self,
        *,
        servicer: Optional[str] = None,
        percent: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PricingScenario(_model_base.Model):
    """PricingScenario.

    Attributes
    ----------
    primary : bool
        Primary pricing speed assumption.
    type : str
        Is either a Literal["CPY"] type or a Literal["CPJ"] type.
    rate : float
        Prepayment speed.
    system_scenario_name : str
        Pre-set pricing scenario.
    custom_scenario : ~analyticsapi.models.CustomScenario
    """

    primary: Optional[bool] = rest_field()
    """Primary pricing speed assumption."""
    type: Optional[Literal["CPY", "CPJ"]] = rest_field(default=None)
    """Is either a Literal[\"CPY\"] type or a Literal[\"CPJ\"] type."""
    rate: Optional[float] = rest_field()
    """Prepayment speed."""
    system_scenario_name: Optional[str] = rest_field(name="systemScenarioName")
    """Pre-set pricing scenario."""
    custom_scenario: Optional["_models.CustomScenario"] = rest_field(name="customScenario")

    @overload
    def __init__(
        self,
        *,
        primary: Optional[bool] = None,
        type: Optional[Literal["CPY", "CPJ"]] = None,
        rate: Optional[float] = None,
        system_scenario_name: Optional[str] = None,
        custom_scenario: Optional["_models.CustomScenario"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PrincipalCashflow(Cashflow, discriminator="Principal"):
    """Lists the properties for Principal payment type.

    Attributes
    ----------
    date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the payment
        date.
    amount : ~analyticsapi.models.Amount
        An object that defines the amount and currency of a payment. Required.
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that makes the payment. Required. Known
        values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that receives the payment. Required. Known
        values are: "Party1" and "Party2".
    occurrence : str or ~analyticsapi.models.PaymentOccurrenceEnum
        The timeline of the transaction. The possible values are: Historical:
        the cash flow date is earlier than the valuation date, Future: the cash
        flow date follows the valuation date and the cash flow is known,
        Projected: the cash flow date follows the valuation date and the cash
        flow is not set by the contract but estimated. Required. Known values
        are: "Historical", "Future", and "Projected".
    payment_type : str or ~analyticsapi.models.PRINCIPAL
        Required.
    annual_rate : ~analyticsapi.models.Rate
        The annualized forward rate that applies to the cashflow period. This
        rate determines the interest amount calculated for the period between
        the start and end dates. Required.
    start_date : ~datetime.date
        The date when the interest calculation period begins for this type of
        cashflow. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01'). Required.
    end_date : ~datetime.date
        The date when the interest calculation period ends for this type of
        cashflow. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01'). Required.
    remaining_notional : float
        The remaining notional amount at the cash flow date. Required.
    """

    payment_type: Literal[CashFlowPaymentTypeEnum.PRINCIPAL] = rest_discriminator(name="paymentType")  # type: ignore
    """Required."""
    annual_rate: "_models.Rate" = rest_field(name="annualRate")
    """The annualized forward rate that applies to the cashflow period.
     This rate determines the interest amount calculated for the period between the start and end
     dates. Required."""
    start_date: datetime.date = rest_field(name="startDate")
    """The date when the interest calculation period begins for this type of cashflow. The value is
     expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Required."""
    end_date: datetime.date = rest_field(name="endDate")
    """The date when the interest calculation period ends for this type of cashflow. The value is
     expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Required."""
    remaining_notional: float = rest_field(name="remainingNotional")
    """The remaining notional amount at the cash flow date. Required."""

    @overload
    def __init__(
        self,
        *,
        amount: "_models.Amount",
        payer: Union[str, "_models.PartyEnum"],
        receiver: Union[str, "_models.PartyEnum"],
        occurrence: Union[str, "_models.PaymentOccurrenceEnum"],
        annual_rate: "_models.Rate",
        start_date: datetime.date,
        end_date: datetime.date,
        remaining_notional: float,
        date: Optional["_models.Date"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, payment_type=CashFlowPaymentTypeEnum.PRINCIPAL, **kwargs)


class PrincipalDefinition(_model_base.Model):
    """An object that defines the principal used to calculate interest payments, which can also be
    exchanged between parties.

    Attributes
    ----------
    currency : str
        The currency of the payments derived from the principal (e.g., interest
        rate payments). Required.
    amount : float
        The principal value of the instrument. It can be zero if it gradually
        increases with the payments defined in the payments parameter.
    payments : list[~analyticsapi.models.DatedValue]
        An array of date-value pairs representing the actual principal amounts
        added (positive value) or substracted from the principal.  The default
        value is None, needs to be assigned before using.
    amortization : ~analyticsapi.models.AmortizationDefinition
        An object that defines the amortization schedule.
    initial_principal_exchange : bool
        An indicator of whether the principal is exchanged between parties on
        the start date.
    final_principal_exchange : bool
        An indicator of whether the principal is exchanged between parties on
        the end date.
    interim_principal_exchange : bool
        An indicator of whether the principal is exchanged between parties
        during the life of the instrtument (e.g., resettable principal).
    repayment_currency : str
        The currency in which the principal is repaid if different from the
        denomination currency. This can be used for dual currency bonds.
    """

    currency: str = rest_field()
    """The currency of the payments derived from the principal (e.g., interest rate payments).
     Required."""
    amount: Optional[float] = rest_field()
    """The principal value of the instrument. It can be zero if it gradually increases with the
     payments defined in the payments parameter."""
    payments: Optional[List["_models.DatedValue"]] = rest_field()
    """An array of date-value pairs representing the actual principal amounts added (positive value)
     or substracted from the principal."""
    amortization: Optional["_models.AmortizationDefinition"] = rest_field()
    """An object that defines the amortization schedule."""
    initial_principal_exchange: Optional[bool] = rest_field(name="initialPrincipalExchange")
    """An indicator of whether the principal is exchanged between parties on the start date."""
    final_principal_exchange: Optional[bool] = rest_field(name="finalPrincipalExchange")
    """An indicator of whether the principal is exchanged between parties on the end date."""
    interim_principal_exchange: Optional[bool] = rest_field(name="interimPrincipalExchange")
    """An indicator of whether the principal is exchanged between parties during the life of the
     instrtument (e.g., resettable principal)."""
    repayment_currency: Optional[str] = rest_field(name="repaymentCurrency")
    """The currency in which the principal is repaid if different from the denomination currency. This
     can be used for dual currency bonds."""

    @overload
    def __init__(
        self,
        *,
        currency: str,
        amount: Optional[float] = None,
        payments: Optional[List["_models.DatedValue"]] = None,
        amortization: Optional["_models.AmortizationDefinition"] = None,
        initial_principal_exchange: Optional[bool] = None,
        final_principal_exchange: Optional[bool] = None,
        interim_principal_exchange: Optional[bool] = None,
        repayment_currency: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ProcessingInformation(_model_base.Model):
    """ProcessingInformation.

    Attributes
    ----------
    category : str or ~analyticsapi.models.CategoryEnum
        Get category. Known values are: "Constituents", "Curve",
        "CurveParameter", "Shifting", and "Turn".
    warning : ~analyticsapi.models.ErrorResponse
    """

    category: Optional[Union[str, "_models.CategoryEnum"]] = rest_field()
    """Get category. Known values are: \"Constituents\", \"Curve\", \"CurveParameter\", \"Shifting\",
     and \"Turn\"."""
    warning: Optional["_models.ErrorResponse"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        category: Optional[Union[str, "_models.CategoryEnum"]] = None,
        warning: Optional["_models.ErrorResponse"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ProtectionLegDefinition(_model_base.Model):
    """ProtectionLegDefinition.

    Attributes
    ----------
    direction : str or ~analyticsapi.models.IPADirectionEnum
        The indication whether the cash flows of the instrument's leg are paid
        or received. Mandatory if instrumentCode or template is not defined. If
        instrumentCode or template is defined, the value comes from the
        instrument reference data. The possible values are:

        * For Swap:
          Paid: the cash flows are paid to the counterparty,
          Received: the cash flows are received from the counterparty.
        * For CDS:
          Paid: the fixed payments are paid by the counterparty (applied to the CDS buyer),
          Received: the fixed payments are received from the counterparty (applied to the CDS seller).
        * For Bond and Loan: Not applicable. Known values are: "Paid" and "Received".
    doc_clause : str or ~analyticsapi.models.DocClauseEnum
        The restructuring clause or credit event for Single Name Cds. The
        possible values are:

        * CumRestruct14,
        * ModifiedRestruct14,
        * ModModRestruct14,
        * ExRestruct14,
        * CumRestruct03,
        * ModifiedRestruct03,
        * ModModRestruct03,
        * ExRestruct03.

        It is ignored for CDS Index.
        Optional. By default the docClause of the Primary CDS RIC is used. Known values are:
        "CumRestruct14", "ModifiedRestruct14", "ModModRestruct14", "ExRestruct14", "CumRestruct03",
        "ModifiedRestruct03", "ModModRestruct03", "ExRestruct03", and "None".
    index_factor : float
        The factor that is applied to the notional if a credit event happens in
        one of the constituents of the Cds Index. It is ignored for Single Name
        CDS. Optional. The default value is 1 (no factor applies).
    index_series : int
        The serie of the Cds Index. It is ignored for Single Name CDS.
        Optional. By default, series of the Benchmark Ric is used.
    notional_amount : float
        The notional amount of the instrument. Optional. The default value is
        '1,000,000'. For CDS: the amounts for the premium and protection legs
        must be equal.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g. 'USD'). If
        instrumentCode is defined, the value comes from the instrument
        reference data.

        * For Swap: Mandatory for SwapLegDefinition if instrumentCode is not defined.
        * For CDS: Mandatory for protectionLeg definition if instrumentCode is not defined. For
        premiumLeg definition, it is derived from pretctionLeg definition.
        * For Bond and Loan: Mandatory if no instrumentCode is defined.
    recovery_rate : float
        Deprecated, please see recoveryRatePercent.
    recovery_rate_percent : float
        The rate of the issuer's debt recovery in case of a credit event. The
        value is expressed in percentages. Optional. By default, the value is
        defined from referenceEntity, seniority, docClause and
        notionalCurrency.
    reference_entity : str
        The identifier of the issuer of the debt that is insured by a CDS. The
        possible values are:

        * for Single Name CDS: RedCode, OrgId, RIC,
        * for CDS Index: RedCode, ShortName, CommonName.

        Mandatory if instrumentCode is not defined. If instrumentCode is defined, the value comes from
        the instrument reference data.
    seniority : str or ~analyticsapi.models.SeniorityEnum
        The order of repayment in the case of a credit event for Single Name
        Cds. The possible values are:

        * Secured: Secured Debt (Corporate/Financial) or Domestic Currency Sovereign Debt (Government),
        * SeniorUnsecured: Senior Unsecured Debt (Corporate/Financial) or Foreign Currency Sovereign
        Debt (Government),
        * Subordinated: Subordinated or Lower Tier 2 Debt (Banks),
        * JuniorSubordinated: Junior Subordinated or Upper Tier 2 Debt (Banks),
        * Preference: Preference Shares or Tier 1 Capital (Banks).

        It is ignored for CDS Index.
        Optional. By default, seniority of the Primary CDS RIC is used. Known values are: "Secured",
        "SeniorUnsecured", "Subordinated", "JuniorSubordinated", "Preference", and "None".
    settlement_convention : str
        The settlement tenor of the instrument (e.g., '1WD'), used to compute
        SettlementDate. Only 'D' (days) and 'WD' (working days) are supported.
        If another period code is used, settlementConvention is set to '0WD'.
        Optional. If instrumentCode is defined, the value comes from the
        instrument reference data. Otherwise, the default value is '3WD'.
    """

    direction: Optional[Union[str, "_models.IPADirectionEnum"]] = rest_field()
    """The indication whether the cash flows of the instrument's leg are paid or received.
     Mandatory if instrumentCode or template is not defined. If instrumentCode or template is
     defined, the value comes from the instrument reference data.
     The possible values are:
     
     
     * For Swap:
       Paid: the cash flows are paid to the counterparty,
       Received: the cash flows are received from the counterparty.
     * For CDS:
       Paid: the fixed payments are paid by the counterparty (applied to the CDS buyer),
       Received: the fixed payments are received from the counterparty (applied to the CDS seller).
     * For Bond and Loan: Not applicable. Known values are: \"Paid\" and \"Received\"."""
    doc_clause: Optional[Union[str, "_models.DocClauseEnum"]] = rest_field(name="docClause")
    """The restructuring clause or credit event for Single Name Cds. The possible values are:
     
     
     * CumRestruct14,
     * ModifiedRestruct14,
     * ModModRestruct14,
     * ExRestruct14,
     * CumRestruct03,
     * ModifiedRestruct03,
     * ModModRestruct03,
     * ExRestruct03.
     
     It is ignored for CDS Index.
     Optional. By default the docClause of the Primary CDS RIC is used. Known values are:
     \"CumRestruct14\", \"ModifiedRestruct14\", \"ModModRestruct14\", \"ExRestruct14\",
     \"CumRestruct03\", \"ModifiedRestruct03\", \"ModModRestruct03\", \"ExRestruct03\", and
     \"None\"."""
    index_factor: Optional[float] = rest_field(name="indexFactor")
    """The factor that is applied to the notional if a credit event happens in one of the constituents
     of the Cds Index. It is ignored for Single Name CDS.
     Optional. The default value is 1 (no factor applies)."""
    index_series: Optional[int] = rest_field(name="indexSeries")
    """The serie of the Cds Index. It is ignored for Single Name CDS.
     Optional. By default, series of the Benchmark Ric is used."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument.
     Optional. The default value is '1,000,000'.
     For CDS: the amounts for the premium and protection legs must be equal."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g. 'USD').
     If instrumentCode is defined, the value comes from the instrument reference data.
     
     
     * For Swap: Mandatory for SwapLegDefinition if instrumentCode is not defined.
     * For CDS: Mandatory for protectionLeg definition if instrumentCode is not defined. For
     premiumLeg definition, it is derived from pretctionLeg definition.
     * For Bond and Loan: Mandatory if no instrumentCode is defined."""
    recovery_rate: Optional[float] = rest_field(name="recoveryRate")
    """Deprecated, please see recoveryRatePercent."""
    recovery_rate_percent: Optional[float] = rest_field(name="recoveryRatePercent")
    """The rate of the issuer's debt recovery in case of a credit event. The value is expressed in
     percentages.
     Optional. By default, the value is defined from referenceEntity, seniority, docClause and
     notionalCurrency."""
    reference_entity: Optional[str] = rest_field(name="referenceEntity")
    """The identifier of the issuer of the debt that is insured by a CDS. The possible values are:
     
     
     * for Single Name CDS: RedCode, OrgId, RIC,
     * for CDS Index: RedCode, ShortName, CommonName.
     
     Mandatory if instrumentCode is not defined. If instrumentCode is defined, the value comes from
     the instrument reference data."""
    seniority: Optional[Union[str, "_models.SeniorityEnum"]] = rest_field()
    """The order of repayment in the case of a credit event for Single Name Cds. The possible values
     are:
     
     
     * Secured: Secured Debt (Corporate/Financial) or Domestic Currency Sovereign Debt (Government),
     * SeniorUnsecured: Senior Unsecured Debt (Corporate/Financial) or Foreign Currency Sovereign
     Debt (Government),
     * Subordinated: Subordinated or Lower Tier 2 Debt (Banks),
     * JuniorSubordinated: Junior Subordinated or Upper Tier 2 Debt (Banks),
     * Preference: Preference Shares or Tier 1 Capital (Banks).
     
     It is ignored for CDS Index.
     Optional. By default, seniority of the Primary CDS RIC is used. Known values are: \"Secured\",
     \"SeniorUnsecured\", \"Subordinated\", \"JuniorSubordinated\", \"Preference\", and \"None\"."""
    settlement_convention: Optional[str] = rest_field(name="settlementConvention")
    """The settlement tenor of the instrument (e.g., '1WD'), used to compute SettlementDate. Only 'D'
     (days) and 'WD' (working days) are supported. If another period code is used,
     settlementConvention is set to '0WD'.
     Optional. If instrumentCode is defined, the value comes from the instrument reference data.
     Otherwise, the default value is '3WD'."""

    @overload
    def __init__(
        self,
        *,
        direction: Optional[Union[str, "_models.IPADirectionEnum"]] = None,
        doc_clause: Optional[Union[str, "_models.DocClauseEnum"]] = None,
        index_factor: Optional[float] = None,
        index_series: Optional[int] = None,
        notional_amount: Optional[float] = None,
        notional_ccy: Optional[str] = None,
        recovery_rate: Optional[float] = None,
        recovery_rate_percent: Optional[float] = None,
        reference_entity: Optional[str] = None,
        seniority: Optional[Union[str, "_models.SeniorityEnum"]] = None,
        settlement_convention: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PyCalcGlobalSettings(_model_base.Model):
    """PyCalcGlobalSettings.

    Attributes
    ----------
    pricing_date : ~datetime.date
        A historical curve and term structure date. Only one date option can be
        used (pricingDate, usePreviousClose, useLiveData).
    use_previous_close : bool
        A date selection that uses the prior closing business days curve and
        volatility surface. Only one date option can be used (pricingDate,
        usePreviousClose, useLiveData).
    use_live_data : bool
        A date selection that will always use live curve data. Only one date
        option can be used (pricingDate, usePreviousClose, useLiveData).
    use_ibor6_m : bool
        Use Euribor 6M Swap curve (EUR securities only).
    retrieve_ppm_projection : bool
        Optional. If true, retrieves monthly prepayment model projections.
    retrieve_oas_path : bool
        Optional. If true, OAS model path data.
    use_stochastic_hpa : bool
        Optional, for CRT and Non-Agency. If true, for OAS computations, for
        each rates path there will be an associated stochastic HPA path. If
        false, HPA will align with the agency approach.
    use_five_point_convexity : bool
        Optional, if true convexity is calculated using 5-points, default is
        3-points.
    retrieve_roll_rate_matrix : bool
        Optional, if true Roll Rate Matrix projections are retrieved (for
        CRT/non-agency Deals).
    use_model_col_haircut : bool
        Optional. Default is off (our recommendation) and delinquency model
        used. If true haircut model-projected principal and interest cash flows
        are used. Cash flows are reduced when servicers stop advancing
        principal and interest on delinquent loans.
    use1000_path : bool
        Optional. Default is 200 paths. If true, CMO OAS is calculated using
        1,000 paths.
    use_core_logic_group_model : bool
        Optional, for Non-Agency. Prepayment and default assumptions are based
        at the group level, rather than the deal level.
    sba_ignore_prepay_penalty : bool
        Optional, for SBA bonds. If true, prepayment penalties are ignored.
    use_ois : bool
    use_non_qm_collateral : bool
        Optional, if true, Non-QM collateral is used for non-agency RMBS model
        calls, otherwise Alt-A collateral is used. This flag only applies to
        prepay type v97. If this flag is set to true, you must also set
        'coreLogicCollateral' to 'USE'.
    core_logic_collateral : str
        Optional, for Non-Agency. Enables model to be run using from CoreLogic
        collateral data. Is one of the following types: Literal["DEFAULT"],
        Literal["USE"], Literal["IGNORE"]
    shock_repo_rates_futures : bool
        Optional, for Futures. Repo rates for shocked when calculating partials
        for futures.
    use_muni_non_call_curve : bool
        Optional, for Muni bonds. Curve is constructed using non-callable
        securities only.
    use_muni_tax_settings : bool
        Optional, for Munis. Take into consideration, de minimus, capital gains
        rate, and ordinary income rate.
    muni_de_minimis_annual_discount : float
        Optional, for Muni bonds. User specified de minimus discount.
    muni_capital_gains_rate : float
        Optional, for Muni bonds. User specified capital gains tax rate.
    muni_ordinary_income_rate : float
        Optional, for Muni bonds. User specified ordinary income tax rate.
    prepay_dials : ~analyticsapi.models.JsonRef
        Optional. Used to refer to a prepay dial that a user has uploaded as
        part of a job.
    swap_curve_floor_rate : float
    use_tba_back_settle : bool
    current_coupon_rates : str
        Is one of the following types: Literal["MOATS"],
        Literal["SpreadToSwap"], Literal["SpreadToTreasury"],
        Literal["SpreadToSwapMeanReversion"], Literal["TreasuryMoats"]
    sensitivity_shocks : ~analyticsapi.models.SensitivityShocks
    lookback_settings : ~analyticsapi.models.LookbackSettings
    clo_dials : ~analyticsapi.models.JsonRef
    clo_dials_ref : str
    custom : dict[str, str]
    """

    pricing_date: Optional[datetime.date] = rest_field(name="pricingDate")
    """A historical curve and term structure date. Only one date option can be used (pricingDate,
     usePreviousClose, useLiveData)."""
    use_previous_close: Optional[bool] = rest_field(name="usePreviousClose")
    """A date selection that uses the prior closing business days curve and volatility surface. Only
     one date option can be used (pricingDate, usePreviousClose, useLiveData)."""
    use_live_data: Optional[bool] = rest_field(name="useLiveData")
    """A date selection that will always use live curve data. Only one date option can be used
     (pricingDate, usePreviousClose, useLiveData)."""
    use_ibor6_m: Optional[bool] = rest_field(name="useIBOR6M")
    """Use Euribor 6M Swap curve (EUR securities only)."""
    retrieve_ppm_projection: Optional[bool] = rest_field(name="retrievePPMProjection")
    """Optional. If true, retrieves monthly prepayment model projections."""
    retrieve_oas_path: Optional[bool] = rest_field(name="retrieveOASPath")
    """Optional. If true, OAS model path data."""
    use_stochastic_hpa: Optional[bool] = rest_field(name="useStochasticHPA")
    """Optional, for CRT and Non-Agency. If true, for OAS computations, for each rates path there will
     be an associated stochastic HPA path. If false, HPA will align with the agency approach."""
    use_five_point_convexity: Optional[bool] = rest_field(name="useFivePointConvexity")
    """Optional, if true convexity is calculated using 5-points, default is 3-points."""
    retrieve_roll_rate_matrix: Optional[bool] = rest_field(name="retrieveRollRateMatrix")
    """Optional, if true Roll Rate Matrix projections are retrieved (for CRT/non-agency Deals)."""
    use_model_col_haircut: Optional[bool] = rest_field(name="useModelColHaircut")
    """Optional. Default is off (our recommendation) and delinquency model used. If true haircut
     model-projected principal and interest cash flows are used. Cash flows are reduced when
     servicers stop advancing principal and interest on delinquent loans."""
    use1000_path: Optional[bool] = rest_field(name="use1000Path")
    """Optional. Default is 200 paths. If true, CMO OAS is calculated using 1,000 paths."""
    use_core_logic_group_model: Optional[bool] = rest_field(name="useCoreLogicGroupModel")
    """Optional, for Non-Agency. Prepayment and default assumptions are based at the group level,
     rather than the deal level."""
    sba_ignore_prepay_penalty: Optional[bool] = rest_field(name="sbaIgnorePrepayPenalty")
    """Optional, for SBA bonds. If true, prepayment penalties are ignored."""
    use_ois: Optional[bool] = rest_field(name="useOIS")
    use_non_qm_collateral: Optional[bool] = rest_field(name="useNonQMCollateral")
    """Optional, if true, Non-QM collateral is used for non-agency RMBS model calls, otherwise Alt-A
     collateral is used. This flag only applies to prepay type v97. If this flag is set to true, you
     must also set 'coreLogicCollateral' to 'USE'."""
    core_logic_collateral: Optional[Literal["DEFAULT", "USE", "IGNORE"]] = rest_field(name="coreLogicCollateral")
    """Optional, for Non-Agency. Enables model to be run using from CoreLogic collateral data. Is one
     of the following types: Literal[\"DEFAULT\"], Literal[\"USE\"], Literal[\"IGNORE\"]"""
    shock_repo_rates_futures: Optional[bool] = rest_field(name="shockRepoRatesFutures")
    """Optional, for Futures. Repo rates for shocked when calculating partials for futures."""
    use_muni_non_call_curve: Optional[bool] = rest_field(name="useMuniNonCallCurve")
    """Optional, for Muni bonds. Curve is constructed using non-callable securities only."""
    use_muni_tax_settings: Optional[bool] = rest_field(name="useMuniTaxSettings")
    """Optional, for Munis. Take into consideration, de minimus, capital gains rate, and ordinary
     income rate."""
    muni_de_minimis_annual_discount: Optional[float] = rest_field(name="muniDeMinimisAnnualDiscount")
    """Optional, for Muni bonds. User specified de minimus discount."""
    muni_capital_gains_rate: Optional[float] = rest_field(name="muniCapitalGainsRate")
    """Optional, for Muni bonds. User specified capital gains tax rate."""
    muni_ordinary_income_rate: Optional[float] = rest_field(name="muniOrdinaryIncomeRate")
    """Optional, for Muni bonds. User specified ordinary income tax rate."""
    prepay_dials: Optional["_models.JsonRef"] = rest_field(name="prepayDials")
    """Optional. Used to refer to a prepay dial that a user has uploaded as part of a job."""
    swap_curve_floor_rate: Optional[float] = rest_field(name="swapCurveFloorRate")
    use_tba_back_settle: Optional[bool] = rest_field(name="useTBABackSettle")
    current_coupon_rates: Optional[
        Literal["MOATS", "SpreadToSwap", "SpreadToTreasury", "SpreadToSwapMeanReversion", "TreasuryMoats"]
    ] = rest_field(name="currentCouponRates")
    """Is one of the following types: Literal[\"MOATS\"], Literal[\"SpreadToSwap\"],
     Literal[\"SpreadToTreasury\"], Literal[\"SpreadToSwapMeanReversion\"],
     Literal[\"TreasuryMoats\"]"""
    sensitivity_shocks: Optional["_models.SensitivityShocks"] = rest_field(name="sensitivityShocks")
    lookback_settings: Optional["_models.LookbackSettings"] = rest_field(name="lookbackSettings")
    clo_dials: Optional["_models.JsonRef"] = rest_field(name="cloDials")
    clo_dials_ref: Optional[str] = rest_field(name="cloDials.$ref")
    custom: Optional[Dict[str, str]] = rest_field()

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        pricing_date: Optional[datetime.date] = None,
        use_previous_close: Optional[bool] = None,
        use_live_data: Optional[bool] = None,
        use_ibor6_m: Optional[bool] = None,
        retrieve_ppm_projection: Optional[bool] = None,
        retrieve_oas_path: Optional[bool] = None,
        use_stochastic_hpa: Optional[bool] = None,
        use_five_point_convexity: Optional[bool] = None,
        retrieve_roll_rate_matrix: Optional[bool] = None,
        use_model_col_haircut: Optional[bool] = None,
        use1000_path: Optional[bool] = None,
        use_core_logic_group_model: Optional[bool] = None,
        sba_ignore_prepay_penalty: Optional[bool] = None,
        use_ois: Optional[bool] = None,
        use_non_qm_collateral: Optional[bool] = None,
        core_logic_collateral: Optional[Literal["DEFAULT", "USE", "IGNORE"]] = None,
        shock_repo_rates_futures: Optional[bool] = None,
        use_muni_non_call_curve: Optional[bool] = None,
        use_muni_tax_settings: Optional[bool] = None,
        muni_de_minimis_annual_discount: Optional[float] = None,
        muni_capital_gains_rate: Optional[float] = None,
        muni_ordinary_income_rate: Optional[float] = None,
        prepay_dials: Optional["_models.JsonRef"] = None,
        swap_curve_floor_rate: Optional[float] = None,
        use_tba_back_settle: Optional[bool] = None,
        current_coupon_rates: Optional[
            Literal["MOATS", "SpreadToSwap", "SpreadToTreasury", "SpreadToSwapMeanReversion", "TreasuryMoats"]
        ] = None,
        sensitivity_shocks: Optional["_models.SensitivityShocks"] = None,
        lookback_settings: Optional["_models.LookbackSettings"] = None,
        clo_dials: Optional["_models.JsonRef"] = None,
        clo_dials_ref: Optional[str] = None,
        custom: Optional[Dict[str, str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PyCalcInput(_model_base.Model):
    """PyCalcInput.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    identifier : str
        Security reference ID. Required.
    id_type : str or ~analyticsapi.models.IdTypeEnum
        Known values are: "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN",
        "REGSISIN", "SEDOL", "Identifier", "ChinaInterbankCode",
        "ShanghaiExchangeCode", "ShenzhenExchangeCode", and "MXTickerID".
    user_tag : str
        User provided tag - this will be returned in the response.
    level : str
        Input price for the security. Input can be a price, yield, spread, OAS,
        etc.. See quick card for for list of options.
    level_value : float
        If level is not provided, provide levelValue - only numbers.
    level_type : str
        levelType can be provided along with levelValue. Example - "y" (for
        yield), "o" (for OAS).
    settlement_type : str
        Is one of the following types: Literal["MARKET"], Literal["INDEX"],
        Literal["CUSTOM"]
    settlement_date : ~datetime.date
        User specified settlement date. If settlementType is CUSTOM, user can
        choose between settlementDate and customSettlement. Recommend using
        settlementDate.
    custom_settlement : str
        Optional. If settlementType is CUSTOM, user can choose between
        settlementDate and customSettlement.
          Example of customSettlement (T + 2), where T is the pricing date. Recommend using
        settlementDate.
    underlying_price : float
    curve : ~analyticsapi.models.CurveTypeAndCurrency
        Required.
    volatility : ~analyticsapi.models.Volatility
    extra_settings : ~analyticsapi.models.ExtraSettings
    hecm_settings : ~analyticsapi.models.HecmSettings
    loss_settings : ~analyticsapi.models.LossSettings
    prepay_settings : ~analyticsapi.models.RestPrepaySettings
    cmbs_settings : ~analyticsapi.models.CmbsSettings
    floater_settings : ~analyticsapi.models.FloaterSettings
    index_linker_settings : ~analyticsapi.models.IndexLinkerSettings
    muni_settings : ~analyticsapi.models.MuniSettings
    mbs_settings : ~analyticsapi.models.MbsSettings
    clo_settings : ~analyticsapi.models.CloSettings
    convertible_pricing : ~analyticsapi.models.ConvertiblePricing
    user_instrument : ~analyticsapi.models.JsonRef
        User Instrument reference.
    modification : ~analyticsapi.models.JsonRef
        Modify Collateral reference.
    current_coupon_spread : ~analyticsapi.models.JsonRef
    props : dict[str, any]
    """

    identifier: str = rest_field()
    """Security reference ID. Required."""
    id_type: Optional[Union[str, "_models.IdTypeEnum"]] = rest_field(name="idType")
    """Known values are: \"SecurityIDEntry\", \"SecurityID\", \"CUSIP\", \"ISIN\", \"REGSISIN\",
     \"SEDOL\", \"Identifier\", \"ChinaInterbankCode\", \"ShanghaiExchangeCode\",
     \"ShenzhenExchangeCode\", and \"MXTickerID\"."""
    user_tag: Optional[str] = rest_field(name="userTag")
    """User provided tag - this will be returned in the response."""
    level: Optional[str] = rest_field()
    """Input price for the security. Input can be a price, yield, spread, OAS, etc.. See quick card
     for for list of options."""
    level_value: Optional[float] = rest_field(name="levelValue")
    """If level is not provided, provide levelValue - only numbers."""
    level_type: Optional[str] = rest_field(name="levelType")
    """levelType can be provided along with levelValue. Example - \"y\" (for yield), \"o\" (for OAS)."""
    settlement_type: Optional[Literal["MARKET", "INDEX", "CUSTOM"]] = rest_field(name="settlementType")
    """Is one of the following types: Literal[\"MARKET\"], Literal[\"INDEX\"], Literal[\"CUSTOM\"]"""
    settlement_date: Optional[datetime.date] = rest_field(name="settlementDate")
    """User specified settlement date. If settlementType is CUSTOM, user can choose between
     settlementDate and customSettlement. Recommend using settlementDate."""
    custom_settlement: Optional[str] = rest_field(name="customSettlement")
    """Optional. If settlementType is CUSTOM, user can choose between settlementDate and
     customSettlement.
       Example of customSettlement (T + 2), where T is the pricing date. Recommend using
     settlementDate."""
    underlying_price: Optional[float] = rest_field(name="underlyingPrice")
    curve: "_models.CurveTypeAndCurrency" = rest_field()
    """Required."""
    volatility: Optional["_models.Volatility"] = rest_field()
    extra_settings: Optional["_models.ExtraSettings"] = rest_field(name="extraSettings")
    hecm_settings: Optional["_models.HecmSettings"] = rest_field(name="hecmSettings")
    loss_settings: Optional["_models.LossSettings"] = rest_field(name="lossSettings")
    prepay_settings: Optional["_models.RestPrepaySettings"] = rest_field(name="prepaySettings")
    cmbs_settings: Optional["_models.CmbsSettings"] = rest_field(name="cmbsSettings")
    floater_settings: Optional["_models.FloaterSettings"] = rest_field(name="floaterSettings")
    index_linker_settings: Optional["_models.IndexLinkerSettings"] = rest_field(name="indexLinkerSettings")
    muni_settings: Optional["_models.MuniSettings"] = rest_field(name="muniSettings")
    mbs_settings: Optional["_models.MbsSettings"] = rest_field(name="mbsSettings")
    clo_settings: Optional["_models.CloSettings"] = rest_field(name="cloSettings")
    convertible_pricing: Optional["_models.ConvertiblePricing"] = rest_field(name="convertiblePricing")
    user_instrument: Optional["_models.JsonRef"] = rest_field(name="userInstrument")
    """User Instrument reference."""
    modification: Optional["_models.JsonRef"] = rest_field()
    """Modify Collateral reference."""
    current_coupon_spread: Optional["_models.JsonRef"] = rest_field(name="currentCouponSpread")
    props: Optional[Dict[str, Any]] = rest_field()

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        identifier: str,
        curve: "_models.CurveTypeAndCurrency",
        id_type: Optional[Union[str, "_models.IdTypeEnum"]] = None,
        user_tag: Optional[str] = None,
        level: Optional[str] = None,
        level_value: Optional[float] = None,
        level_type: Optional[str] = None,
        settlement_type: Optional[Literal["MARKET", "INDEX", "CUSTOM"]] = None,
        settlement_date: Optional[datetime.date] = None,
        custom_settlement: Optional[str] = None,
        underlying_price: Optional[float] = None,
        volatility: Optional["_models.Volatility"] = None,
        extra_settings: Optional["_models.ExtraSettings"] = None,
        hecm_settings: Optional["_models.HecmSettings"] = None,
        loss_settings: Optional["_models.LossSettings"] = None,
        prepay_settings: Optional["_models.RestPrepaySettings"] = None,
        cmbs_settings: Optional["_models.CmbsSettings"] = None,
        floater_settings: Optional["_models.FloaterSettings"] = None,
        index_linker_settings: Optional["_models.IndexLinkerSettings"] = None,
        muni_settings: Optional["_models.MuniSettings"] = None,
        mbs_settings: Optional["_models.MbsSettings"] = None,
        clo_settings: Optional["_models.CloSettings"] = None,
        convertible_pricing: Optional["_models.ConvertiblePricing"] = None,
        user_instrument: Optional["_models.JsonRef"] = None,
        modification: Optional["_models.JsonRef"] = None,
        current_coupon_spread: Optional["_models.JsonRef"] = None,
        props: Optional[Dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class PyCalcRequest(_model_base.Model):
    """PyCalcRequest.

    Attributes
    ----------
    global_settings : ~analyticsapi.models.PyCalcGlobalSettings
    input : list[~analyticsapi.models.PyCalcInput]
        The default value is None, needs to be assigned before using.
    keywords : list[str]
        The default value is None, needs to be assigned before using.
    """

    global_settings: Optional["_models.PyCalcGlobalSettings"] = rest_field(name="globalSettings")
    input: Optional[List["_models.PyCalcInput"]] = rest_field()
    keywords: Optional[List[str]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        global_settings: Optional["_models.PyCalcGlobalSettings"] = None,
        input: Optional[List["_models.PyCalcInput"]] = None,
        keywords: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Quote(_model_base.Model):
    """The object that contains the instrument quote and related attributes.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    start_date : ~datetime.date
        The start date of the instrument. Depending on the tenor the start date
        is defined as follows:

        * for ON and SPOT it is typically equal to the valuation date,
        * for TN it is the valuation date + 1D,
        * for post-spot tenors (1D, 1M, 1Y, etc.) it is the valuation date + spot lag.

        The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01').
    end_date : ~datetime.date
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DD (e.g., '2024-01-01').
    definition : ~analyticsapi.models.QuoteDefinition
        Configuration object that defines how to retrieve the instrument quote
        from market data sources. This includes the instrument identifier,
        market data field mappings, and source information. This field is
        required in input requests when quote values are not being overridden.
        If values are provided directly, this field becomes optional as the
        system will use the overridden values instead of retrieving them from
        market data sources.
    values_property : ~analyticsapi.models.Values
        The actual bid and ask quote values for the instrument. When specified
        in the request, these values override any market data that would
        normally be retrieved using the quote definition. This allows for
        manual quote overrides or custom pricing scenarios. When not specified,
        the system will retrieve current market data based on the quote
        definition configuration. In response objects, this contains the final
        quote values (either retrieved or overridden).
    """

    start_date: Optional[datetime.date] = rest_field(name="startDate", visibility=["read"])
    """The start date of the instrument. Depending on the tenor the start date is defined as follows:
     
     
     * for ON and SPOT it is typically equal to the valuation date,
     * for TN it is the valuation date + 1D,
     * for post-spot tenors (1D, 1M, 1Y, etc.) it is the valuation date + spot lag.
     
     The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2023-01-01')."""
    end_date: Optional[datetime.date] = rest_field(name="endDate", visibility=["read"])
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DD (e.g., '2024-01-01')."""
    definition: Optional["_models.QuoteDefinition"] = rest_field()
    """Configuration object that defines how to retrieve the instrument quote from market data
     sources.
     This includes the instrument identifier, market data field mappings, and source information.
     This field is required in input requests when quote values are not being overridden.
     If values are provided directly, this field becomes optional as the system will use the
     overridden values instead of retrieving them from market data sources."""
    values_property: Optional["_models.Values"] = rest_field(name="values")
    """The actual bid and ask quote values for the instrument.
     When specified in the request, these values override any market data that would normally
     be retrieved using the quote definition. This allows for manual quote overrides or
     custom pricing scenarios. When not specified, the system will retrieve current market
     data based on the quote definition configuration.
     In response objects, this contains the final quote values (either retrieved or overridden)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.QuoteDefinition"] = None,
        values_property: Optional["_models.Values"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class QuoteDefinition(_model_base.Model):
    """An object that defines the attributes for getting the instrument quote.

    Attributes
    ----------
    instrument_code : str
        The code (RIC) of the instrument, used to uniquely identify the
        financial instrument for quote retrieval. Required.
    bid : ~analyticsapi.models.FieldDefinition
        Defines the field identifiers and priority order for retrieving bid
        quote data from real-time and historical market data sources. This
        configuration allows you to specify which specific market data fields
        (FIDs) should be used to obtain the bid price, with fallback priorities
        if primary fields are unavailable. If not specified, default bid field
        mappings will be used.
    ask : ~analyticsapi.models.FieldDefinition
        Defines the field identifiers and priority order for retrieving ask
        quote data from real-time and historical market data sources. This
        configuration allows you to specify which specific market data fields
        (FIDs) should be used to obtain the ask price, with fallback priorities
        if primary fields are unavailable. If not specified, default ask field
        mappings will be used.
    source : str
        The market data contributor or source identifier (e.g., 'ICAP') that
        provides the quote data for this instrument.
    """

    instrument_code: str = rest_field(name="instrumentCode")
    """The code (RIC) of the instrument, used to uniquely identify the financial instrument for quote
     retrieval. Required."""
    bid: Optional["_models.FieldDefinition"] = rest_field()
    """Defines the field identifiers and priority order for retrieving bid quote data from
     real-time and historical market data sources. This configuration allows you to specify
     which specific market data fields (FIDs) should be used to obtain the bid price,
     with fallback priorities if primary fields are unavailable.
     If not specified, default bid field mappings will be used."""
    ask: Optional["_models.FieldDefinition"] = rest_field()
    """Defines the field identifiers and priority order for retrieving ask quote data from
     real-time and historical market data sources. This configuration allows you to specify
     which specific market data fields (FIDs) should be used to obtain the ask price,
     with fallback priorities if primary fields are unavailable.
     If not specified, default ask field mappings will be used."""
    source: Optional[str] = rest_field()
    """The market data contributor or source identifier (e.g., 'ICAP') that provides the quote data
     for this instrument."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: str,
        bid: Optional["_models.FieldDefinition"] = None,
        ask: Optional["_models.FieldDefinition"] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Rate(_model_base.Model):
    """An object that defines the interest rate.

    Attributes
    ----------
    value : float
        The rate value. Required.
    unit : str or ~analyticsapi.models.UnitEnum
        The unit of the rate value. Required. Known values are: "Absolute",
        "BasisPoint", and "Percentage".
    """

    value: float = rest_field()
    """The rate value. Required."""
    unit: Union[str, "_models.UnitEnum"] = rest_field()
    """The unit of the rate value. Required. Known values are: \"Absolute\", \"BasisPoint\", and
     \"Percentage\"."""

    @overload
    def __init__(
        self,
        *,
        value: float,
        unit: Union[str, "_models.UnitEnum"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RefDataMeta(_model_base.Model):
    """RefDataMeta.

    Attributes
    ----------
    request_id : str
        Required.
    status : str
        Required. Is one of the following types: Literal["NEW"],
        Literal["WAITING"], Literal["PENDING"], Literal["RUNNING"],
        Literal["ABORTING"], Literal["DONE"], Literal["ERROR"],
        Literal["SKIPPED"], Literal["ABORTED"]
    time_stamp : ~datetime.datetime
        Required.
    response_type : str
        Required. Is one of the following types: Literal["BOND_INDIC"],
        Literal["BOND_SEARCH"], Literal["CURVE_POINTS"],
        Literal["MARKET_SETTINGS"], Literal["MBS_HISTORY"], Literal["PY_CALC"],
        Literal["COLLATERAL_DETAILS"], Literal["CALC_SETTINGS"],
        Literal["MORTGAGE_MODEL"], Literal["ACTUAL_VS_PROJECTED"],
        Literal["WAL_SENSITIVITY"], Literal["SCENARIO_CALC"],
        Literal["MATRIX_PY"], Literal["HISTORICAL_DATA"], Literal["CASHFLOW"],
        Literal["VOLATILITY"], Literal["TEST"], Literal["SCENARIO_SETUPS"],
        Literal["XMLAPI"], Literal["BULK_ZIP"], Literal["BULK_COMPOSITE"],
        Literal["FORWARD_PRICING"], Literal["CALC_STATUS"],
        Literal["DELIMITED"], Literal["COMPACT"], Literal["BULK"],
        Literal["FX_FWDS"], Literal["USER_CURVE"], Literal["WAIT"],
        Literal["RETURNS_CALC"], Literal["TABLE"], Literal["PREPAY_DIALS"]
    results_status : str
        Required. Is one of the following types: Literal["ALL"],
        Literal["NONE"], Literal["PARTIAL"]
    """

    request_id: str = rest_field(name="requestId")
    """Required."""
    status: Literal["NEW", "WAITING", "PENDING", "RUNNING", "ABORTING", "DONE", "ERROR", "SKIPPED", "ABORTED"] = (
        rest_field()
    )
    """Required. Is one of the following types: Literal[\"NEW\"], Literal[\"WAITING\"],
     Literal[\"PENDING\"], Literal[\"RUNNING\"], Literal[\"ABORTING\"], Literal[\"DONE\"],
     Literal[\"ERROR\"], Literal[\"SKIPPED\"], Literal[\"ABORTED\"]"""
    time_stamp: datetime.datetime = rest_field(name="timeStamp", format="rfc3339")
    """Required."""
    response_type: Literal[
        "BOND_INDIC",
        "BOND_SEARCH",
        "CURVE_POINTS",
        "MARKET_SETTINGS",
        "MBS_HISTORY",
        "PY_CALC",
        "COLLATERAL_DETAILS",
        "CALC_SETTINGS",
        "MORTGAGE_MODEL",
        "ACTUAL_VS_PROJECTED",
        "WAL_SENSITIVITY",
        "SCENARIO_CALC",
        "MATRIX_PY",
        "HISTORICAL_DATA",
        "CASHFLOW",
        "VOLATILITY",
        "TEST",
        "SCENARIO_SETUPS",
        "XMLAPI",
        "BULK_ZIP",
        "BULK_COMPOSITE",
        "FORWARD_PRICING",
        "CALC_STATUS",
        "DELIMITED",
        "COMPACT",
        "BULK",
        "FX_FWDS",
        "USER_CURVE",
        "WAIT",
        "RETURNS_CALC",
        "TABLE",
        "PREPAY_DIALS",
    ] = rest_field(name="responseType")
    """Required. Is one of the following types: Literal[\"BOND_INDIC\"], Literal[\"BOND_SEARCH\"],
     Literal[\"CURVE_POINTS\"], Literal[\"MARKET_SETTINGS\"], Literal[\"MBS_HISTORY\"],
     Literal[\"PY_CALC\"], Literal[\"COLLATERAL_DETAILS\"], Literal[\"CALC_SETTINGS\"],
     Literal[\"MORTGAGE_MODEL\"], Literal[\"ACTUAL_VS_PROJECTED\"], Literal[\"WAL_SENSITIVITY\"],
     Literal[\"SCENARIO_CALC\"], Literal[\"MATRIX_PY\"], Literal[\"HISTORICAL_DATA\"],
     Literal[\"CASHFLOW\"], Literal[\"VOLATILITY\"], Literal[\"TEST\"],
     Literal[\"SCENARIO_SETUPS\"], Literal[\"XMLAPI\"], Literal[\"BULK_ZIP\"],
     Literal[\"BULK_COMPOSITE\"], Literal[\"FORWARD_PRICING\"], Literal[\"CALC_STATUS\"],
     Literal[\"DELIMITED\"], Literal[\"COMPACT\"], Literal[\"BULK\"], Literal[\"FX_FWDS\"],
     Literal[\"USER_CURVE\"], Literal[\"WAIT\"], Literal[\"RETURNS_CALC\"], Literal[\"TABLE\"],
     Literal[\"PREPAY_DIALS\"]"""
    results_status: Literal["ALL", "NONE", "PARTIAL"] = rest_field(name="resultsStatus")
    """Required. Is one of the following types: Literal[\"ALL\"], Literal[\"NONE\"],
     Literal[\"PARTIAL\"]"""

    @overload
    def __init__(
        self,
        *,
        request_id: str,
        status: Literal["NEW", "WAITING", "PENDING", "RUNNING", "ABORTING", "DONE", "ERROR", "SKIPPED", "ABORTED"],
        time_stamp: datetime.datetime,
        response_type: Literal[
            "BOND_INDIC",
            "BOND_SEARCH",
            "CURVE_POINTS",
            "MARKET_SETTINGS",
            "MBS_HISTORY",
            "PY_CALC",
            "COLLATERAL_DETAILS",
            "CALC_SETTINGS",
            "MORTGAGE_MODEL",
            "ACTUAL_VS_PROJECTED",
            "WAL_SENSITIVITY",
            "SCENARIO_CALC",
            "MATRIX_PY",
            "HISTORICAL_DATA",
            "CASHFLOW",
            "VOLATILITY",
            "TEST",
            "SCENARIO_SETUPS",
            "XMLAPI",
            "BULK_ZIP",
            "BULK_COMPOSITE",
            "FORWARD_PRICING",
            "CALC_STATUS",
            "DELIMITED",
            "COMPACT",
            "BULK",
            "FX_FWDS",
            "USER_CURVE",
            "WAIT",
            "RETURNS_CALC",
            "TABLE",
            "PREPAY_DIALS",
        ],
        results_status: Literal["ALL", "NONE", "PARTIAL"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RelativeAdjustableDate(Date, discriminator="RelativeAdjustableDate"):
    """RelativeAdjustableDate.

    Attributes
    ----------
    date_moving_convention : str or ~analyticsapi.models.DateMovingConvention
        The method to adjust dates to working days. The possible values are:
        ModifiedFollowing: dates are adjusted to the next business day
        convention unless it goes into the next month. In such case, the
        previous business day convention is used, NextBusinessDay: dates are
        moved to the following working day, PreviousBusinessDay: dates are
        moved to the preceding working day, NoMoving: dates are not adjusted,
        EveryThirdWednesday: dates are moved to the third Wednesday of the
        month, or to the next working day if the third Wednesday is not a
        working day, BbswModifiedFollowing: dates are adjusted to the next
        business day convention unless it goes into the next month, or crosses
        mid-month (15th). In such case, the previous business day convention is
        used. Default is ModifiedFollowing. Known values are:
        "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay",
        "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing".
    calendars : list[str]
        An array of calendars that should be used for the date adjustment.
        Typically the calendars are derived based on the instruments currency
        or crossCurrency code.  The default value is None, needs to be assigned
        before using.
    date_type : str or ~analyticsapi.models.RELATIVE_ADJUSTABLE_DATE
        The type of the Date input. Possible values are: AdjustableDate,
        RelativeAdjustableDate. Required. The date is defined as adjusteable
        according the BusinessDayAdjustmentDefinition and relative to a
        reference date and a tenor.
    tenor : str
        A tenor (relative date) expressed as a code indicating the period
        between referenceDate(default=startDate) to endDate of the instrument
        (e.g., '6M', '1Y'). Predefined values are: ON (Overnight - A one
        business day period that starts today), TN (Tomorrow-Next - A one
        business day period that starts next business day, SPOT (Spot Date), SN
        (Spot-Next - A one business day period that starts at the spot date of
        a currency pair) or SW (Spot-Week - A one business week period that
        starts at the spot date of a currency pair). Tenors can also be
        specified as a whole number of time units. Possible units are: D
        (Days), W (Weeks), M (Months) or Y (Years). For example, one month is
        written '1M', 3 years is written: '3Y'. Time units can be mixed.  For
        example, 5M3D means '5 months and 3 days'. Note: units must be written
        in descending order of size (Y > M > W > D). Required.
    reference_date : str or ~analyticsapi.models.ReferenceDate
        The date which has been used as a reference date for the provided
        tenor. Possible values are: StartDate, ValuationDate, SpotDate. Default
        is StartDate. Known values are: "SpotDate", "StartDate",
        "ValuationDate", and "EndDate".
    """

    date_type: Literal[DateType.RELATIVE_ADJUSTABLE_DATE] = rest_discriminator(name="dateType")  # type: ignore
    """The type of the Date input. Possible values are: AdjustableDate, RelativeAdjustableDate.
     Required. The date is defined as adjusteable according the BusinessDayAdjustmentDefinition and
     relative to a reference date and a tenor."""
    tenor: str = rest_field()
    """A tenor (relative date) expressed as a code indicating the period between
     referenceDate(default=startDate) to endDate of the instrument (e.g., '6M', '1Y').
     Predefined values are: ON (Overnight - A one business day period that starts today), TN
     (Tomorrow-Next - A one business day period that starts next business day, SPOT (Spot Date), SN
     (Spot-Next - A one business day period that starts at the spot date of a currency pair) or SW
     (Spot-Week - A one business week period that starts at the spot date of a currency pair).
     Tenors can also be specified as a whole number of time units. Possible units are: D (Days), W
     (Weeks), M (Months) or Y (Years). For example, one month is written '1M', 3 years is written:
     '3Y'.
     Time units can be mixed.  For example, 5M3D means '5 months and 3 days'. Note: units must be
     written in descending order of size (Y > M > W > D). Required."""
    reference_date: Optional[Union[str, "_models.ReferenceDate"]] = rest_field(name="referenceDate")
    """The date which has been used as a reference date for the provided tenor. Possible values are:
     StartDate, ValuationDate, SpotDate. Default is StartDate. Known values are: \"SpotDate\",
     \"StartDate\", \"ValuationDate\", and \"EndDate\"."""

    @overload
    def __init__(
        self,
        *,
        tenor: str,
        date_moving_convention: Optional[Union[str, "_models.DateMovingConvention"]] = None,
        calendars: Optional[List[str]] = None,
        reference_date: Optional[Union[str, "_models.ReferenceDate"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, date_type=DateType.RELATIVE_ADJUSTABLE_DATE, **kwargs)


class RelativePositionWhen(When, discriminator="RelativePositionWhen"):
    """An object to determine the rule for a holiday that falls on a certain day of the week in a
    certain month. For example, Summer holiday on last Monday of August.

    Attributes
    ----------
    position_type : str or ~analyticsapi.models.RELATIVE_POSITION_WHEN
        The type of regular annual holiday rule. Only RelativePositionWhen
        value applies. Required. A rule to determine a holiday depending on the
        day of the week in a certain month. For example, Summer holiday on the
        last Monday of August.
    index : str or ~analyticsapi.models.IndexOrder
        The ordinal number of the day of the week in the month. Required. Known
        values are: "First", "Second", "Third", "Fourth", and "Last".
    day_of_week : str or ~analyticsapi.models.WeekDay
        The day of the week. Required. Known values are: "Monday", "Tuesday",
        "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
    month : str or ~analyticsapi.models.Month
        The month of the year. Required. Known values are: "January",
        "February", "March", "April", "May", "June", "July", "August",
        "September", "October", "November", and "December".
    """

    position_type: Literal[PositionType.RELATIVE_POSITION_WHEN] = rest_discriminator(name="positionType")  # type: ignore # pylint: disable=line-too-long
    """The type of regular annual holiday rule. Only RelativePositionWhen value applies. Required. A
     rule to determine a holiday depending on the day of the week in a certain month. For example,
     Summer holiday on the last Monday of August."""
    index: Union[str, "_models.IndexOrder"] = rest_field()
    """The ordinal number of the day of the week in the month. Required. Known values are: \"First\",
     \"Second\", \"Third\", \"Fourth\", and \"Last\"."""
    day_of_week: Union[str, "_models.WeekDay"] = rest_field(name="dayOfWeek")
    """The day of the week. Required. Known values are: \"Monday\", \"Tuesday\", \"Wednesday\",
     \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\"."""
    month: Union[str, "_models.Month"] = rest_field()
    """The month of the year. Required. Known values are: \"January\", \"February\", \"March\",
     \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\",
     and \"December\"."""

    @overload
    def __init__(
        self,
        *,
        index: Union[str, "_models.IndexOrder"],
        day_of_week: Union[str, "_models.WeekDay"],
        month: Union[str, "_models.Month"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, position_type=PositionType.RELATIVE_POSITION_WHEN, **kwargs)


class RelativeRescheduleDescription(RescheduleDescription, discriminator="RelativeRescheduleDescription"):
    """An object to determine the rule for rescheduling a holiday to a specific day.

    Attributes
    ----------
    reschedule_type : str or ~analyticsapi.models.RELATIVE_RESCHEDULE_DESCRIPTION
        The type of rescheduling for the observation period. Only
        RelativeRescheduleRescheduleDescription value applies. Required. The
        rule for rescheduling a holiday to a specific day. For example, if a
        holiday falls on Sunday, it is rescheduled to the first Monday after
        the holiday.
    index : str or ~analyticsapi.models.IndexOrder
        The ordinal number of the day of the week in the month. The value
        'Last' should only be used if the direction is set to 'Before'.
        Required. Known values are: "First", "Second", "Third", "Fourth", and
        "Last".
    day_of_week : str or ~analyticsapi.models.WeekDay
        The day of the week. Required. Known values are: "Monday", "Tuesday",
        "Wednesday", "Thursday", "Friday", "Saturday", and "Sunday".
    direction : str or ~analyticsapi.models.Direction
        An indicator of whether the observation period falls before or after
        the reference point. Required. Known values are: "Before" and "After".
    """

    reschedule_type: Literal[RescheduleType.RELATIVE_RESCHEDULE_DESCRIPTION] = rest_discriminator(name="rescheduleType")  # type: ignore # pylint: disable=line-too-long
    """The type of rescheduling for the observation period. Only
     RelativeRescheduleRescheduleDescription value applies. Required. The rule for rescheduling a
     holiday to a specific day. For example, if a holiday falls on Sunday, it is rescheduled to the
     first Monday after the holiday."""
    index: Union[str, "_models.IndexOrder"] = rest_field()
    """The ordinal number of the day of the week in the month. The value 'Last' should only be used if
     the direction is set to 'Before'. Required. Known values are: \"First\", \"Second\", \"Third\",
     \"Fourth\", and \"Last\"."""
    day_of_week: Union[str, "_models.WeekDay"] = rest_field(name="dayOfWeek")
    """The day of the week. Required. Known values are: \"Monday\", \"Tuesday\", \"Wednesday\",
     \"Thursday\", \"Friday\", \"Saturday\", and \"Sunday\"."""
    direction: Union[str, "_models.Direction"] = rest_field()
    """An indicator of whether the observation period falls before or after the reference point.
     Required. Known values are: \"Before\" and \"After\"."""

    @overload
    def __init__(
        self,
        *,
        index: Union[str, "_models.IndexOrder"],
        day_of_week: Union[str, "_models.WeekDay"],
        direction: Union[str, "_models.Direction"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, reschedule_type=RescheduleType.RELATIVE_RESCHEDULE_DESCRIPTION, **kwargs)


class RelativeToRulePositionWhen(When, discriminator="RelativeToRulePositionWhen"):
    """An object to define a rule by reference to another rule. This defines the holiday period by
    reference to another holiday rule. Easter is most commonly used as a reference point.

    Attributes
    ----------
    position_type : str or ~analyticsapi.models.RELATIVE_TO_RULE_POSITION_WHEN
        The type of regular annual holiday rule. Only
        RelativeToRulePositionWhen value applies. Required. A rule that
        references another rule. For example, Easter is most commonly used as a
        reference point.
    key : str
        A user-defined key to create a reference to another rule (e.g. Easter)
        by name. Required.
    reschedule_description : ~analyticsapi.models.RescheduleDescription
        An object to determine holiday rescheduling. Required.
    """

    position_type: Literal[PositionType.RELATIVE_TO_RULE_POSITION_WHEN] = rest_discriminator(name="positionType")  # type: ignore # pylint: disable=line-too-long
    """The type of regular annual holiday rule. Only RelativeToRulePositionWhen value applies.
     Required. A rule that references another rule. For example, Easter is most commonly used as a
     reference point."""
    key: str = rest_field()
    """A user-defined key to create a reference to another rule (e.g. Easter) by name. Required."""
    reschedule_description: "_models.RescheduleDescription" = rest_field(name="rescheduleDescription")
    """An object to determine holiday rescheduling. Required."""

    @overload
    def __init__(
        self,
        *,
        key: str,
        reschedule_description: "_models.RescheduleDescription",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, position_type=PositionType.RELATIVE_TO_RULE_POSITION_WHEN, **kwargs)


class RepoAnalyticsResponseData(_model_base.Model):
    """RepoAnalyticsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.RepoDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.RepoPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.RepoAnalyticsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketDataQps
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.RepoDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.RepoPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.RepoAnalyticsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketDataQps"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.RepoDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.RepoPricingParameters"] = None,
        analytics: Optional[List["_models.RepoAnalyticsResponseWithError"]] = None,
        market_data: Optional["_models.MarketDataQps"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoAnalyticsResponseWithError(_model_base.Model):
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    tabular_data : ~analyticsapi.models.FinancialContractResponse
        Standard Financial Contract Analytics in tabular format.
    cashflows : ~analyticsapi.models.RepoCashflows
        Response categorized under Cashflows.
    description : ~analyticsapi.models.RepoDescription
        Response categorized under Description.
    pricing_analysis : ~analyticsapi.models.RepoPricingAnalysis
        Response categorized under Pricing analysis.
    valuation : ~analyticsapi.models.RepoValuation
        Response categorized under Valuation.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    tabular_data: Optional["_models.FinancialContractResponse"] = rest_field(name="tabularData")
    """Standard Financial Contract Analytics in tabular format."""
    cashflows: Optional["_models.RepoCashflows"] = rest_field()
    """Response categorized under Cashflows."""
    description: Optional["_models.RepoDescription"] = rest_field()
    """Response categorized under Description."""
    pricing_analysis: Optional["_models.RepoPricingAnalysis"] = rest_field(name="pricingAnalysis")
    """Response categorized under Pricing analysis."""
    valuation: Optional["_models.RepoValuation"] = rest_field()
    """Response categorized under Valuation."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        tabular_data: Optional["_models.FinancialContractResponse"] = None,
        cashflows: Optional["_models.RepoCashflows"] = None,
        description: Optional["_models.RepoDescription"] = None,
        pricing_analysis: Optional["_models.RepoPricingAnalysis"] = None,
        valuation: Optional["_models.RepoValuation"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoCalculationResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.RepoAnalyticsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.RepoAnalyticsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.RepoAnalyticsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class RepoCashflows(_model_base.Model):
    """Cashflows Object.

    Attributes
    ----------
    coupon_amount_in_deal_ccy : float
        The total coupon amount paid at the end date of the Repo deal, without
        reinvestment. The value is equal to  0  if  IsCouponExchanged  ='
        False  '. The value is expressed in the deal currency.
    cash_flows : list[any]
        The information on the contract's cash flows during its lifetime. It
        consists of the following properties:

        * instrumentType: the instrument type for which cash flows are computed,
        * payments: the array of properties which define all instruments cash flows (paid and received)
        during its lifetime.

        For more details, please refer here.  The default value is None, needs to be assigned before
        using.
    """

    coupon_amount_in_deal_ccy: Optional[float] = rest_field(name="couponAmountInDealCcy")
    """The total coupon amount paid at the end date of the Repo deal, without reinvestment. The value
     is equal to  0  if  IsCouponExchanged  ='  False  '. The value is expressed in the deal
     currency."""
    cash_flows: Optional[List[Any]] = rest_field(name="cashFlows")
    """The information on the contract's cash flows during its lifetime. It consists of the following
     properties:
     
     
     * instrumentType: the instrument type for which cash flows are computed,
     * payments: the array of properties which define all instruments cash flows (paid and received)
     during its lifetime.
     
     For more details, please refer here."""

    @overload
    def __init__(
        self,
        *,
        coupon_amount_in_deal_ccy: Optional[float] = None,
        cash_flows: Optional[List[Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoDefinition(_model_base.Model):
    """Definition of the Repo contract.

    Attributes
    ----------
    buy_sell : str or ~analyticsapi.models.IPABuySellEnum
        The indicator of the deal side. The possible values are:

        * Buy: buying the repo,
        * Sell: selling the repo.

        Optional. The default value is 'Buy'. Known values are: "Buy" and "Sell".
    day_count_basis : str or ~analyticsapi.models.DayCountBasisEnum
        The day count basis convention used in computations. Optional,
        "Dcb_Actual_360" by default. Known values are: "Dcb_30_360",
        "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
        "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
        "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
        "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA",
        "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", "Dcb_Actual_365_CanadianConvention", and
        "Dcb_Constant".
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It must precede the end date of the underlying
        asset. Either 'endDate' or 'tenor' field must be requested. By default,
        it is computed from 'startDate' and 'tenor'.
    instrument_tag : str
        User defined string to identify the instrument.It can be used to link
        output results to the instrument definition. Only alphabetic, numeric
        and '- _.#=@' characters are supported. Optional.
    is_coupon_exchanged : bool
        An indicator whether intermediate coupons for the underlying asset are
        exchanged between the Repo seller and Repo buyer:

        * True: the intermediate coupons are exchanged. It is typical for sell-buyback Repo
        transactions,
        * False: the intermediate coupons are not exchanged. In this case, the Repo instrument is like
        a standard loan with no intermediate coupons; the bond is only used as a warranty in case the
        money borrower defaults..

        Optional. The default value is 'True'.
    repo_rate_frequency : str or ~analyticsapi.models.RepoRateFrequencyEnum
        The rate type frequency used to compute repo interest amount. The
        possible values are:

        * Yearly : yearly,
        * Monthly : monthly,
        * SemiAnnual: semi-annual
        * Quaterly : quaterly.

        Optional.Default value is "Yearly". Known values are: "Annual", "SemiAnnual", "Quarterly", and
        "Monthly".
    repo_rate_percent : float
        The Repo rate. The value is expressed in percentages. If not defined,
        the default value is computed by interpolating/extrapolating a Repo
        Curve. Optional.
    repo_rate_type : str or ~analyticsapi.models.RepoRateTypeEnum
        The rate type used to compute repo interest amount. The possible values
        are:

        * MoneyMarket: interest amount is computed by multiplying repo rate on the purchase price,
        * Discount: interest amount is computed by multiplying repo rate on the repurchase price.

        Optional.Default value is "MoneyMarket". Known values are: "MoneyMarket", "Actual",
        "Continuous", "Discount", "Compounded", "SimpleJapanese", and "CompoundedJapanese".
    start_date : ~datetime.datetime
        The start date of the instrument. The value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
        Optional. The default value equals to 'valuationDate'.
    tenor : str
        The code indicating the period between StartDate and EndDate of the
        instrument (e.g., '6M', '1Y'). Either 'endDate' or 'tenor' field must
        be requested.
    underlying_instruments : list[~analyticsapi.models.RepoUnderlyingContract]
        Definition of the underlying assets. Only Bond Contracts are supported
        for now, and only one Bond can be used. Mandatory.  The default value
        is None, needs to be assigned before using.
    """

    buy_sell: Optional[Union[str, "_models.IPABuySellEnum"]] = rest_field(name="buySell")
    """The indicator of the deal side. The possible values are:
     
     
     * Buy: buying the repo,
     * Sell: selling the repo.
     
     Optional. The default value is 'Buy'. Known values are: \"Buy\" and \"Sell\"."""
    day_count_basis: Optional[Union[str, "_models.DayCountBasisEnum"]] = rest_field(name="dayCountBasis")
    """The day count basis convention used in computations.
     Optional, \"Dcb_Actual_360\" by default. Known values are: \"Dcb_30_360\", \"Dcb_30_360_US\",
     \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\", \"Dcb_30_365_German\",
     \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\", \"Dcb_30_Actual_ISDA\",
     \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\", \"Dcb_Actual_365\",
     \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\", \"Dcb_Actual_Actual_AFB\",
     \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\", \"Dcb_ActualLeapDay_365\",
     \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\", \"Dcb_Actual_365_CanadianConvention\", and
     \"Dcb_Constant\"."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     It must precede the end date of the underlying asset.
     Either 'endDate' or 'tenor' field must be requested.
     By default, it is computed from 'startDate' and 'tenor'."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """User defined string to identify the instrument.It can be used to link output results to the
     instrument definition.
     Only alphabetic, numeric and '- _.#=@' characters are supported.
     Optional."""
    is_coupon_exchanged: Optional[bool] = rest_field(name="isCouponExchanged")
    """An indicator whether intermediate coupons for the underlying asset are exchanged between the
     Repo seller and Repo buyer:
     
     
     * True: the intermediate coupons are exchanged. It is typical for sell-buyback Repo
     transactions,
     * False: the intermediate coupons are not exchanged. In this case, the Repo instrument is like
     a standard loan with no intermediate coupons; the bond is only used as a warranty in case the
     money borrower defaults..
     
     Optional. The default value is 'True'."""
    repo_rate_frequency: Optional[Union[str, "_models.RepoRateFrequencyEnum"]] = rest_field(name="repoRateFrequency")
    """The rate type frequency used to compute repo interest amount. The possible values are:
     
     
     * Yearly : yearly,
     * Monthly : monthly,
     * SemiAnnual: semi-annual
     * Quaterly : quaterly.
     
     Optional.Default value is \"Yearly\". Known values are: \"Annual\", \"SemiAnnual\",
     \"Quarterly\", and \"Monthly\"."""
    repo_rate_percent: Optional[float] = rest_field(name="repoRatePercent")
    """The Repo rate. The value is expressed in percentages. If not defined, the default value is
     computed by interpolating/extrapolating a Repo Curve.
     Optional."""
    repo_rate_type: Optional[Union[str, "_models.RepoRateTypeEnum"]] = rest_field(name="repoRateType")
    """The rate type used to compute repo interest amount. The possible values are:
     
     
     * MoneyMarket: interest amount is computed by multiplying repo rate on the purchase price,
     * Discount: interest amount is computed by multiplying repo rate on the repurchase price.
     
     Optional.Default value is \"MoneyMarket\". Known values are: \"MoneyMarket\", \"Actual\",
     \"Continuous\", \"Discount\", \"Compounded\", \"SimpleJapanese\", and \"CompoundedJapanese\"."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     Optional. The default value equals to 'valuationDate'."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between StartDate and EndDate of the instrument (e.g., '6M',
     '1Y').
     Either 'endDate' or 'tenor' field must be requested."""
    underlying_instruments: Optional[List["_models.RepoUnderlyingContract"]] = rest_field(name="underlyingInstruments")
    """Definition of the underlying assets. Only Bond Contracts are supported for now, and only one
     Bond can be used.
     Mandatory."""

    @overload
    def __init__(
        self,
        *,
        buy_sell: Optional[Union[str, "_models.IPABuySellEnum"]] = None,
        day_count_basis: Optional[Union[str, "_models.DayCountBasisEnum"]] = None,
        end_date: Optional[datetime.datetime] = None,
        instrument_tag: Optional[str] = None,
        is_coupon_exchanged: Optional[bool] = None,
        repo_rate_frequency: Optional[Union[str, "_models.RepoRateFrequencyEnum"]] = None,
        repo_rate_percent: Optional[float] = None,
        repo_rate_type: Optional[Union[str, "_models.RepoRateTypeEnum"]] = None,
        start_date: Optional[datetime.datetime] = None,
        tenor: Optional[str] = None,
        underlying_instruments: Optional[List["_models.RepoUnderlyingContract"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.RepoDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.RepoDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.RepoDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoDescription(_model_base.Model):
    """Description Object.

    Attributes
    ----------
    instrument_type : str
        The type of instrument defined in the request. The possible values are
        listed  here  .
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    instrument_description : str
        The label that describes the instrument.
    deal_ccy : str
        The currency code which depending on the instrument represents:

        * for FX instruments: the deal (base) currency,
        * for Swap: the currency of the paid leg,
        * for other instruments: the currency of the instrument's notional amount.

        The value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
    report_ccy : str
        The currency code set for the fields ending with '  xxxInReportCcy  '.
        The value is expressed in ISO 4217 alphabetical format (e.g., '  USD
        ').
    start_date : ~datetime.datetime
        The start date of the instrument. The value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ').
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    initial_margin_percent : float
        The initial market value of collateral expressed as a percentage of the
        purchase price of the underlying asset.
    nominal_pledge_quantity : float
        Notional amount of the underlying asset pledged under Repo. The value
        is adjusted for haircut.
    number_of_coupons : int
        The number of coupons paid over the Repo period. Applies only to sell-
        buyback Repo transactions (  isCouponExchange  ='  True  ').
    day_count_basis : str
        The day count basis convention used in computations. The possible
        values are listed  here  .
    repo_curve_id : str
        The ID of the Repo curve used to compute the Repo rate.
    discount_curve_id : str
        The identifier of the zero-coupon curve used to discount the
        instrument's future payments.
    settlement_convention : str
        The settlement tenor of the instrument (e.g., '  1WD  ') used to
        compute  ValuationDate  .
    repo_rate_percent : float
        The Repo rate. The value is expressed in percentages.
    error_code : str
        The code of  ErrorMessage  .
    error_message : str
        The error message in case of a blocking error in calculation.
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    instrument_type: Optional[str] = rest_field(name="instrumentType")
    """The type of instrument defined in the request. The possible values are listed  here  ."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    instrument_description: Optional[str] = rest_field(name="instrumentDescription")
    """The label that describes the instrument."""
    deal_ccy: Optional[str] = rest_field(name="dealCcy")
    """The currency code which depending on the instrument represents:
     
     
     * for FX instruments: the deal (base) currency,
     * for Swap: the currency of the paid leg,
     * for other instruments: the currency of the instrument's notional amount.
     
     The value is expressed in ISO 4217 alphabetical format (e.g., 'USD')."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with '  xxxInReportCcy  '. The value is expressed
     in ISO 4217 alphabetical format (e.g., '  USD  ')."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    initial_margin_percent: Optional[float] = rest_field(name="initialMarginPercent")
    """The initial market value of collateral expressed as a percentage of the purchase price of the
     underlying asset."""
    nominal_pledge_quantity: Optional[float] = rest_field(name="nominalPledgeQuantity")
    """Notional amount of the underlying asset pledged under Repo. The value is adjusted for haircut."""
    number_of_coupons: Optional[int] = rest_field(name="numberOfCoupons")
    """The number of coupons paid over the Repo period. Applies only to sell-buyback Repo transactions
     (  isCouponExchange  ='  True  ')."""
    day_count_basis: Optional[str] = rest_field(name="dayCountBasis")
    """The day count basis convention used in computations. The possible values are listed  here  ."""
    repo_curve_id: Optional[str] = rest_field(name="repoCurveId")
    """The ID of the Repo curve used to compute the Repo rate."""
    discount_curve_id: Optional[str] = rest_field(name="discountCurveId")
    """The identifier of the zero-coupon curve used to discount the instrument's future payments."""
    settlement_convention: Optional[str] = rest_field(name="settlementConvention")
    """The settlement tenor of the instrument (e.g., '  1WD  ') used to compute  ValuationDate  ."""
    repo_rate_percent: Optional[float] = rest_field(name="repoRatePercent")
    """The Repo rate. The value is expressed in percentages."""
    error_code: Optional[str] = rest_field(name="errorCode")
    """The code of  ErrorMessage  ."""
    error_message: Optional[str] = rest_field(name="errorMessage")
    """The error message in case of a blocking error in calculation."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        instrument_type: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        instrument_description: Optional[str] = None,
        deal_ccy: Optional[str] = None,
        report_ccy: Optional[str] = None,
        start_date: Optional[datetime.datetime] = None,
        end_date: Optional[datetime.datetime] = None,
        initial_margin_percent: Optional[float] = None,
        nominal_pledge_quantity: Optional[float] = None,
        number_of_coupons: Optional[int] = None,
        day_count_basis: Optional[str] = None,
        repo_curve_id: Optional[str] = None,
        discount_curve_id: Optional[str] = None,
        settlement_convention: Optional[str] = None,
        repo_rate_percent: Optional[float] = None,
        error_code: Optional[str] = None,
        error_message: Optional[str] = None,
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoParameters(_model_base.Model):
    """RepoParameters.

    Attributes
    ----------
    coupon_paid_at_horizon : bool
        Flag that defines whether coupons paid at horizon.  This has no impact
        on pricing.
    haircut_rate_percent : float
        The discount applied to the value of an underlying asset for purposes
        of calculating a Repo collateral. It is used for computing the initial
        margin of the transaction. The value is expressed in percentages.
        Either 'haircutRatePercent' or 'initialMarginPercent' can be
        overridden. Optional. The default value comes from
        'initialMarginPercent'. If 'initialMarginPercent' is not set, the
        default value is '0'.
    initial_margin_percent : float
        The initial market value of collateral expressed as a percentage of the
        purchase price of the underlying asset. Either 'haircutRatePercent' or
        'initialMarginPercent' can be overriden. Optional. The default value
        comes from 'haircutRatePercent'. If 'haircutRatePercent' is not set,
        the default value is '100'.
    purchase_price : float
        The cash value paid by the buyer of underlying assets to the seller on
        the purchase date. Optional.
    repurchase_price : float
        The amount paid by the Repo buyer to the seller to repurchase the
        underlying asset. Optional.
    """

    coupon_paid_at_horizon: Optional[bool] = rest_field(name="couponPaidAtHorizon")
    """Flag that defines whether coupons paid at horizon.  This has no impact on pricing."""
    haircut_rate_percent: Optional[float] = rest_field(name="haircutRatePercent")
    """The discount applied to the value of an underlying asset for purposes of calculating a Repo
     collateral. It is used for computing the initial margin of the transaction. The value is
     expressed in percentages.
     Either 'haircutRatePercent' or 'initialMarginPercent' can be overridden.
     Optional. The default value comes from 'initialMarginPercent'. If 'initialMarginPercent' is not
     set, the default value is '0'."""
    initial_margin_percent: Optional[float] = rest_field(name="initialMarginPercent")
    """The initial market value of collateral expressed as a percentage of the purchase price of the
     underlying asset.
     Either 'haircutRatePercent' or 'initialMarginPercent' can be overriden.
     Optional. The default value comes from 'haircutRatePercent'. If 'haircutRatePercent' is not
     set, the default value is '100'."""
    purchase_price: Optional[float] = rest_field(name="purchasePrice")
    """The cash value paid by the buyer of underlying assets to the seller on the purchase date.
     Optional."""
    repurchase_price: Optional[float] = rest_field(name="repurchasePrice")
    """The amount paid by the Repo buyer to the seller to repurchase the underlying asset.
     Optional."""

    @overload
    def __init__(
        self,
        *,
        coupon_paid_at_horizon: Optional[bool] = None,
        haircut_rate_percent: Optional[float] = None,
        initial_margin_percent: Optional[float] = None,
        purchase_price: Optional[float] = None,
        repurchase_price: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoPricingAnalysis(_model_base.Model):
    """Pricing analysis Object.

    Attributes
    ----------
    haircut_rate_percent : float
        The discount applied to the value of an underlying asset for purposes
        of calculating a Repo collateral. The value is computed as [(
        InitialMarginPercent  - 100  ) /  InitialMarginPercent  ] and expressed
        in percentages.
    fx_spot : float
        The spot value of the cross-currency pair, which is the instrument
        currency against the reporting currency. It is used to convert amount
        to the reporting currency.
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    purchase_price : float
        The cash value paid by the buyer of underlying assets to the seller on
        the purchase date. The value is computed as [
        UnderlyingAtStartObject.MarketValueInDealCcy  / (  InitialMarginPercent
        /  100  )].
    repurchase_price : float
        The amount paid by the Repo buyer to the seller to repurchase the
        underlying asset.  - If  IsCouponExchanged  ='  True  ', [
        RepurchasePrice  =  PurchasePrice +  RepoInterestAmountInDealCcy  -
        CouponAmountInDealCcy  -  ReinvestmentIncomeInDealCcy  ].  - If
        IsCouponExchanged  ='  False  ', [  RepurchasePrice  =  PurchasePrice
        + RepoInterestAmountInDealCcy  ].
    underlying_at_start_object : any
        The pricing information for the underlying asset at the start date. For
        a detailed breakdown, please refer here.
    underlying_at_end_object : any
        The pricing information for the underlying asset at the end date. For a
        detailed breakdown, please refer here.
    """

    haircut_rate_percent: Optional[float] = rest_field(name="haircutRatePercent")
    """The discount applied to the value of an underlying asset for purposes of calculating a Repo
     collateral. The value is computed as [(  InitialMarginPercent  -  100  ) /
     InitialMarginPercent  ] and expressed in percentages."""
    fx_spot: Optional[float] = rest_field(name="fxSpot")
    """The spot value of the cross-currency pair, which is the instrument currency against the
     reporting currency. It is used to convert amount to the reporting currency."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    purchase_price: Optional[float] = rest_field(name="purchasePrice")
    """The cash value paid by the buyer of underlying assets to the seller on the purchase date. The
     value is computed as [  UnderlyingAtStartObject.MarketValueInDealCcy  / (  InitialMarginPercent
     /  100  )]."""
    repurchase_price: Optional[float] = rest_field(name="repurchasePrice")
    """The amount paid by the Repo buyer to the seller to repurchase the underlying asset.  - If
     IsCouponExchanged  ='  True  ', [  RepurchasePrice  =  PurchasePrice  +
     RepoInterestAmountInDealCcy  -  CouponAmountInDealCcy  -  ReinvestmentIncomeInDealCcy  ].  - If
     IsCouponExchanged  ='  False  ', [  RepurchasePrice  =  PurchasePrice  +
     RepoInterestAmountInDealCcy  ]."""
    underlying_at_start_object: Optional[Any] = rest_field(name="underlyingAtStartObject")
    """The pricing information for the underlying asset at the start date.
     For a detailed breakdown, please refer here."""
    underlying_at_end_object: Optional[Any] = rest_field(name="underlyingAtEndObject")
    """The pricing information for the underlying asset at the end date.
     For a detailed breakdown, please refer here."""

    @overload
    def __init__(
        self,
        *,
        haircut_rate_percent: Optional[float] = None,
        fx_spot: Optional[float] = None,
        market_data_date: Optional[datetime.datetime] = None,
        valuation_date: Optional[datetime.datetime] = None,
        purchase_price: Optional[float] = None,
        repurchase_price: Optional[float] = None,
        underlying_at_start_object: Optional[Any] = None,
        underlying_at_end_object: Optional[Any] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoPricingParameters(_model_base.Model):
    """Repo input parameters for pricing purpose.

    Attributes
    ----------
    coupon_reinvestment_rate_percent : float
        The rate used to reinvest the underlying asset's coupon income. The
        value is expressed in percentages. Optional. Default value is 0.
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).
        Optional. By default, marketDataDate is valuationDate or today.
    repo_curve_type : str or ~analyticsapi.models.RepoCurveTypeEnum
        The curve type used to compute the Repo rate. The possible values are:

        * RepoCurve: the rate is computed by interpolating a repo curve.
        * DepositCurve: the rate is computed by interpolating a deposit curve.
        * LiborFixing: the rate is computed by interpolating LIBOR rates. If a currency has been moved
        to Risk Free Rate (RFR) alternative curve, RFR curve will be returned instead of Libor curve
        for that currency.

        If no curve can be found, the rate is computed using a deposit curve. The default value is
        'RepoCurve'. Known values are: "RepoCurve", "DepositCurve", and "LiborFixing".
    report_ccy : str
        The currency code set for the fields ending with 'xxxInReportCcy'. The
        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
        Optional. No default value applies.
    settlement_convention : str
        The settlement tenor of the instrument (e.g., '1WD') used to compute
        'ValuationDate'. By default, the rule is that [StartDate =
        ValuationDate = MarketDataDate + SettlementConvention]. Only two
        parameters out of 'settlementConvention', 'marketDataDate' and
        'valuationDate' can be overridden at a time. Optional. By default the
        settlement convention is equal to the settlement convention of the
        underlying asset. If it is not defined, the default value is '0WD'.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    """

    coupon_reinvestment_rate_percent: Optional[float] = rest_field(name="couponReinvestmentRatePercent")
    """The rate used to reinvest the underlying asset's coupon income. The value is expressed in
     percentages.
     Optional. Default value is 0."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It should be less or equal to
     valuationDate).
     Optional. By default, marketDataDate is valuationDate or today."""
    repo_curve_type: Optional[Union[str, "_models.RepoCurveTypeEnum"]] = rest_field(name="repoCurveType")
    """The curve type used to compute the Repo rate. The possible values are:
     
     
     * RepoCurve: the rate is computed by interpolating a repo curve.
     * DepositCurve: the rate is computed by interpolating a deposit curve.
     * LiborFixing: the rate is computed by interpolating LIBOR rates. If a currency has been moved
     to Risk Free Rate (RFR) alternative curve, RFR curve will be returned instead of Libor curve
     for that currency.
     
     If no curve can be found, the rate is computed using a deposit curve. The default value is
     'RepoCurve'. Known values are: \"RepoCurve\", \"DepositCurve\", and \"LiborFixing\"."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with 'xxxInReportCcy'. The value is expressed in
     ISO 4217 alphabetical format (e.g., 'USD').
     Optional. No default value applies."""
    settlement_convention: Optional[str] = rest_field(name="settlementConvention")
    """The settlement tenor of the instrument (e.g., '1WD') used to compute 'ValuationDate'. By
     default, the rule is that [StartDate = ValuationDate = MarketDataDate + SettlementConvention].
     Only two parameters out of 'settlementConvention', 'marketDataDate' and 'valuationDate' can be
     overridden at a time.
     Optional. By default the settlement convention is equal to the settlement convention of the
     underlying asset. If it is not defined, the default value is '0WD'."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""

    @overload
    def __init__(
        self,
        *,
        coupon_reinvestment_rate_percent: Optional[float] = None,
        market_data_date: Optional[datetime.datetime] = None,
        repo_curve_type: Optional[Union[str, "_models.RepoCurveTypeEnum"]] = None,
        report_ccy: Optional[str] = None,
        settlement_convention: Optional[str] = None,
        valuation_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoUnderlyingContract(_model_base.Model):
    """RepoUnderlyingContract.

    Attributes
    ----------
    instrument_definition : ~analyticsapi.models.BondDefinition
    instrument_type : str
        The type of instrument defined in the request.
    market_data_assignment : ~analyticsapi.models.MarketDataAssignments
    pricing_parameters : ~analyticsapi.models.RepoUnderlyingPricingParameters
    """

    instrument_definition: Optional["_models.BondDefinition"] = rest_field(name="instrumentDefinition")
    instrument_type: Optional[str] = rest_field(name="instrumentType")
    """The type of instrument defined in the request."""
    market_data_assignment: Optional["_models.MarketDataAssignments"] = rest_field(name="marketDataAssignment")
    pricing_parameters: Optional["_models.RepoUnderlyingPricingParameters"] = rest_field(name="pricingParameters")

    @overload
    def __init__(
        self,
        *,
        instrument_definition: Optional["_models.BondDefinition"] = None,
        instrument_type: Optional[str] = None,
        market_data_assignment: Optional["_models.MarketDataAssignments"] = None,
        pricing_parameters: Optional["_models.RepoUnderlyingPricingParameters"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoUnderlyingPricingParameters(_model_base.Model):
    """RepoUnderlyingPricingParameters.

    Attributes
    ----------
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).
        Optional. By default, marketDataDate is valuationDate or today.
    pricing_parameters_at_end : ~analyticsapi.models.BondPricingParameters
    pricing_parameters_at_start : ~analyticsapi.models.BondPricingParameters
    repo_parameters : ~analyticsapi.models.RepoParameters
    report_ccy : str
        The currency code set for the fields ending with 'xxxInReportCcy'. The
        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
        Optional. No default value applies.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    """

    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It should be less or equal to
     valuationDate).
     Optional. By default, marketDataDate is valuationDate or today."""
    pricing_parameters_at_end: Optional["_models.BondPricingParameters"] = rest_field(name="pricingParametersAtEnd")
    pricing_parameters_at_start: Optional["_models.BondPricingParameters"] = rest_field(name="pricingParametersAtStart")
    repo_parameters: Optional["_models.RepoParameters"] = rest_field(name="repoParameters")
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with 'xxxInReportCcy'. The value is expressed in
     ISO 4217 alphabetical format (e.g., 'USD').
     Optional. No default value applies."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""

    @overload
    def __init__(
        self,
        *,
        market_data_date: Optional[datetime.datetime] = None,
        pricing_parameters_at_end: Optional["_models.BondPricingParameters"] = None,
        pricing_parameters_at_start: Optional["_models.BondPricingParameters"] = None,
        repo_parameters: Optional["_models.RepoParameters"] = None,
        report_ccy: Optional[str] = None,
        valuation_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RepoValuation(_model_base.Model):
    """Valuation Object.

    Attributes
    ----------
    repo_interest_amount_in_deal_ccy : float
        The interest amount of the Repo deal. The value is computed as [
        PurchasePrice  * (  EndDate  -  StartDate  ) /  YearBasis  *
        RepoRatePercent  ] and expressed in the deal currency.
    reinvestment_income_in_deal_ccy : float
        The income earned from reinvesting the coupon in case it is detached
        from the security during the Repo life. By default, reinvestment is
        assumed to be done using the Repo rate. The value is equal to  0  if
        IsCouponExchanged  ='  False'  .
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency.
    market_value_in_report_ccy : float
        The market value of the instrument. The value is expressed in the
        reporting currency.
    """

    repo_interest_amount_in_deal_ccy: Optional[float] = rest_field(name="repoInterestAmountInDealCcy")
    """The interest amount of the Repo deal. The value is computed as [  PurchasePrice  * (  EndDate
     -  StartDate  ) /  YearBasis  *  RepoRatePercent  ] and expressed in the deal currency."""
    reinvestment_income_in_deal_ccy: Optional[float] = rest_field(name="reinvestmentIncomeInDealCcy")
    """The income earned from reinvesting the coupon in case it is detached from the security during
     the Repo life. By default, reinvestment is assumed to be done using the Repo rate. The value is
     equal to  0  if  IsCouponExchanged  ='  False'  ."""
    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value of the instrument. The value is expressed in the reporting currency."""

    @overload
    def __init__(
        self,
        *,
        repo_interest_amount_in_deal_ccy: Optional[float] = None,
        reinvestment_income_in_deal_ccy: Optional[float] = None,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RequestId(_model_base.Model):
    """RequestId.

    Attributes
    ----------
    request_id : str
        Required.
    """

    request_id: str = rest_field(name="requestId")
    """Required."""

    @overload
    def __init__(
        self,
        request_id: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["request_id"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class ResetDatesDefinition(_model_base.Model):
    """An object that defines the reset of index fixing dates.

    Attributes
    ----------
    offset : ~analyticsapi.models.OffsetDefinition
        An object that defines how the fixing dates of each period are derived
        from the interest period dates. Required.
    frequency : str or ~analyticsapi.models.FrequencyEnum
        The frequency of index reset. Known values are: "Annual", "SemiAnnual",
        "Quarterly", "Monthly", "BiMonthly", "Everyday", "EveryWorkingDay",
        "Every7Days", "Every14Days", "Every28Days", "Every30Days",
        "Every90Days", "Every91Days", "Every92Days", "Every93Days",
        "Every4Months", "Every180Days", "Every182Days", "Every183Days",
        "Every184Days", "Every364Days", "Every365Days", "R2", "R4", "Zero", and
        "Scheduled".
    """

    offset: "_models.OffsetDefinition" = rest_field()
    """An object that defines how the fixing dates of each period are derived from the interest period
     dates. Required."""
    frequency: Optional[Union[str, "_models.FrequencyEnum"]] = rest_field()
    """The frequency of index reset. Known values are: \"Annual\", \"SemiAnnual\", \"Quarterly\",
     \"Monthly\", \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\", \"Every7Days\", \"Every14Days\",
     \"Every28Days\", \"Every30Days\", \"Every90Days\", \"Every91Days\", \"Every92Days\",
     \"Every93Days\", \"Every4Months\", \"Every180Days\", \"Every182Days\", \"Every183Days\",
     \"Every184Days\", \"Every364Days\", \"Every365Days\", \"R2\", \"R4\", \"Zero\", and
     \"Scheduled\"."""

    @overload
    def __init__(
        self,
        *,
        offset: "_models.OffsetDefinition",
        frequency: Optional[Union[str, "_models.FrequencyEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RestDays(_model_base.Model):
    """An object to determine rest days for the calendar.

    Attributes
    ----------
    rest_days : list[str or ~analyticsapi.models.WeekDay]
        Days of the week that are set as rest days. An array of WeekDay
        objects. Default is [WeekDay.Saturday, WeekDay.Sunday]. Required.  The
        default value is None, needs to be assigned before using.
    validity_period : ~analyticsapi.models.ValidityPeriod
        An object to determine the validity period. If not specified, the
        validity period is assumed to be perpetual.
    """

    rest_days: List[Union[str, "_models.WeekDay"]] = rest_field(name="restDays")
    """Days of the week that are set as rest days. An array of WeekDay objects. Default is
     [WeekDay.Saturday, WeekDay.Sunday]. Required."""
    validity_period: Optional["_models.ValidityPeriod"] = rest_field(name="validityPeriod")
    """An object to determine the validity period. If not specified, the validity period is assumed to
     be perpetual."""

    @overload
    def __init__(
        self,
        *,
        rest_days: List[Union[str, "_models.WeekDay"]],
        validity_period: Optional["_models.ValidityPeriod"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RestPrepaySettings(_model_base.Model):
    """Optional. Used for securities that allow principal prepayment.

    Attributes
    ----------
    type : str
        Required. Is one of the following types: Literal["Model"],
        Literal["CurrentModel"], Literal["NewModel"], Literal["OldModel"],
        Literal["PreExpModel"], Literal["OldExpModel"], Literal["ExpModel"],
        Literal["CPR"], Literal["MHP"], Literal["HEP"], Literal["ABS"],
        Literal["CPB"], Literal["HPC"], Literal["CPJ"], Literal["CPY"],
        Literal["VPR"], Literal["PPV"], Literal["PSJ"], Literal["PSA"]
    rate : float
        Prepayment speed. Either rate or vector is required.
    vector : ~analyticsapi.models.Vector
    model_to_balloon : bool
        Selected model dictates prepayments until the balloon date, then
        security prepays in full.
    """

    type: Optional[
        Literal[
            "Model",
            "CurrentModel",
            "NewModel",
            "OldModel",
            "PreExpModel",
            "OldExpModel",
            "ExpModel",
            "CPR",
            "MHP",
            "HEP",
            "ABS",
            "CPB",
            "HPC",
            "CPJ",
            "CPY",
            "VPR",
            "PPV",
            "PSJ",
            "PSA",
        ]
    ] = rest_field(default=None)
    """Required. Is one of the following types: Literal[\"Model\"], Literal[\"CurrentModel\"],
     Literal[\"NewModel\"], Literal[\"OldModel\"], Literal[\"PreExpModel\"],
     Literal[\"OldExpModel\"], Literal[\"ExpModel\"], Literal[\"CPR\"], Literal[\"MHP\"],
     Literal[\"HEP\"], Literal[\"ABS\"], Literal[\"CPB\"], Literal[\"HPC\"], Literal[\"CPJ\"],
     Literal[\"CPY\"], Literal[\"VPR\"], Literal[\"PPV\"], Literal[\"PSJ\"], Literal[\"PSA\"]"""
    rate: Optional[float] = rest_field()
    """Prepayment speed. Either rate or vector is required."""
    vector: Optional["_models.Vector"] = rest_field()
    model_to_balloon: Optional[bool] = rest_field(name="modelToBalloon")
    """Selected model dictates prepayments until the balloon date, then security prepays in full."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[
            Literal[
                "Model",
                "CurrentModel",
                "NewModel",
                "OldModel",
                "PreExpModel",
                "OldExpModel",
                "ExpModel",
                "CPR",
                "MHP",
                "HEP",
                "ABS",
                "CPB",
                "HPC",
                "CPJ",
                "CPY",
                "VPR",
                "PPV",
                "PSJ",
                "PSA",
            ]
        ] = None,
        rate: Optional[float] = None,
        vector: Optional["_models.Vector"] = None,
        model_to_balloon: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ResultResponseBulkResultItem(_model_base.Model):
    """ResultResponseBulkResultItem.

    Attributes
    ----------
    meta : ~analyticsapi.models.BulkMeta
    data : ~analyticsapi.models.BulkResultItem
    results : list[~analyticsapi.models.BulkResultItem]
        The default value is None, needs to be assigned before using.
    errors : list[~analyticsapi.models.ApimError]
        The default value is None, needs to be assigned before using.
    summary : ~analyticsapi.models.Summary
    """

    meta: Optional["_models.BulkMeta"] = rest_field()
    data: Optional["_models.BulkResultItem"] = rest_field()
    results: Optional[List["_models.BulkResultItem"]] = rest_field()
    errors: Optional[List["_models.ApimError"]] = rest_field()
    summary: Optional["_models.Summary"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        meta: Optional["_models.BulkMeta"] = None,
        data: Optional["_models.BulkResultItem"] = None,
        results: Optional[List["_models.BulkResultItem"]] = None,
        errors: Optional[List["_models.ApimError"]] = None,
        summary: Optional["_models.Summary"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Results(_model_base.Model):
    """Internal instrument data structure. It's created in dictionary format, replicating the API's
    JSON structure response. In-depth documentation will be provided in future versions of SDK.

    """


class ReturnAttributionCurveTypeAndCurrency(_model_base.Model):
    """ReturnAttributionCurveTypeAndCurrency.

    Attributes
    ----------
    curve_type : str
    currency : str
    """

    curve_type: Optional[str] = rest_field(name="curveType")
    currency: Optional[str] = rest_field()

    @overload
    def __init__(
        self,
        *,
        curve_type: Optional[str] = None,
        currency: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReturnAttributionGlobalSettings(_model_base.Model):
    """ReturnAttributionGlobalSettings.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    begin : ~analyticsapi.models.ScenarioSettlement
        Required.
    end : ~analyticsapi.models.ScenarioSettlement
        Required.
    curve : ~analyticsapi.models.ReturnAttributionCurveTypeAndCurrency
        Required.
    volatility : ~analyticsapi.models.Volatility
        Required.
    """

    begin: "_models.ScenarioSettlement" = rest_field()
    """Required."""
    end: "_models.ScenarioSettlement" = rest_field()
    """Required."""
    curve: "_models.ReturnAttributionCurveTypeAndCurrency" = rest_field()
    """Required."""
    volatility: "_models.Volatility" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        *,
        begin: "_models.ScenarioSettlement",
        end: "_models.ScenarioSettlement",
        curve: "_models.ReturnAttributionCurveTypeAndCurrency",
        volatility: "_models.Volatility",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReturnAttributionInput(_model_base.Model):
    """ReturnAttributionInput.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    identifier : str
        Required.
    id_type : str or ~analyticsapi.models.IdTypeEnum
        Known values are: "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN",
        "REGSISIN", "SEDOL", "Identifier", "ChinaInterbankCode",
        "ShanghaiExchangeCode", "ShenzhenExchangeCode", and "MXTickerID".
    tag : str
    begin_level : str
        Required.
    end_level : str
        Required.
    prepay_settings : ~analyticsapi.models.RestPrepaySettings
    """

    identifier: str = rest_field()
    """Required."""
    id_type: Optional[Union[str, "_models.IdTypeEnum"]] = rest_field(name="idType")
    """Known values are: \"SecurityIDEntry\", \"SecurityID\", \"CUSIP\", \"ISIN\", \"REGSISIN\",
     \"SEDOL\", \"Identifier\", \"ChinaInterbankCode\", \"ShanghaiExchangeCode\",
     \"ShenzhenExchangeCode\", and \"MXTickerID\"."""
    tag: Optional[str] = rest_field()
    begin_level: str = rest_field(name="beginLevel")
    """Required."""
    end_level: str = rest_field(name="endLevel")
    """Required."""
    prepay_settings: Optional["_models.RestPrepaySettings"] = rest_field(name="prepaySettings")

    @overload
    def __init__(
        self,
        *,
        identifier: str,
        begin_level: str,
        end_level: str,
        id_type: Optional[Union[str, "_models.IdTypeEnum"]] = None,
        tag: Optional[str] = None,
        prepay_settings: Optional["_models.RestPrepaySettings"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ReturnAttributionRequest(_model_base.Model):
    """ReturnAttributionRequest.

    Attributes
    ----------
    global_settings : ~analyticsapi.models.ReturnAttributionGlobalSettings
    input : list[~analyticsapi.models.ReturnAttributionInput]
        The default value is None, needs to be assigned before using.
    """

    global_settings: Optional["_models.ReturnAttributionGlobalSettings"] = rest_field(name="globalSettings")
    input: Optional[List["_models.ReturnAttributionInput"]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        global_settings: Optional["_models.ReturnAttributionGlobalSettings"] = None,
        input: Optional[List["_models.ReturnAttributionInput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class RoundingDefinition(_model_base.Model):
    """An object that defines how rounding is applied.

    Attributes
    ----------
    decimal_places : int
        The decimal place the rounding applies to. Required.
    direction : str or ~analyticsapi.models.RoundingModeEnum
        The direction of the rounding. Known values are: "Ceiling", "Down",
        "Floor", "Near", and "Up".
    scale : int
        The scaling factor applied before the rounding operation.
    """

    decimal_places: int = rest_field(name="decimalPlaces")
    """The decimal place the rounding applies to. Required."""
    direction: Optional[Union[str, "_models.RoundingModeEnum"]] = rest_field()
    """The direction of the rounding. Known values are: \"Ceiling\", \"Down\", \"Floor\", \"Near\",
     and \"Up\"."""
    scale: Optional[int] = rest_field()
    """The scaling factor applied before the rounding operation."""

    @overload
    def __init__(
        self,
        *,
        decimal_places: int,
        direction: Optional[Union[str, "_models.RoundingModeEnum"]] = None,
        scale: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScalarAndVector(_model_base.Model):
    """ScalarAndVector.

    Attributes
    ----------
    value : ~decimal.Decimal
    vector : list[~analyticsapi.models.TermAndValue]
        The default value is None, needs to be assigned before using.
    """

    value: Optional[decimal.Decimal] = rest_field()
    vector: Optional[List["_models.TermAndValue"]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        value: Optional[decimal.Decimal] = None,
        vector: Optional[List["_models.TermAndValue"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScalarAndVectorWithCollateral(_model_base.Model):
    """ScalarAndVectorWithCollateral.

    Attributes
    ----------
    value : ~decimal.Decimal
    vector : list[~analyticsapi.models.TermAndValue]
        The default value is None, needs to be assigned before using.
    """

    value: Optional[decimal.Decimal] = rest_field()
    vector: Optional[List["_models.TermAndValue"]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        value: Optional[decimal.Decimal] = None,
        vector: Optional[List["_models.TermAndValue"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScenAbsoluteCurvePoint(_model_base.Model):
    """ScenAbsoluteCurvePoint.

    Attributes
    ----------
    term : ~decimal.Decimal
    rate : ~decimal.Decimal
    spot_rate : ~decimal.Decimal
    forward_rate : ~decimal.Decimal
    discount_factor : ~decimal.Decimal
    """

    term: Optional[decimal.Decimal] = rest_field()
    rate: Optional[decimal.Decimal] = rest_field()
    spot_rate: Optional[decimal.Decimal] = rest_field(name="spotRate")
    forward_rate: Optional[decimal.Decimal] = rest_field(name="forwardRate")
    discount_factor: Optional[decimal.Decimal] = rest_field(name="discountFactor")

    @overload
    def __init__(
        self,
        *,
        term: Optional[decimal.Decimal] = None,
        rate: Optional[decimal.Decimal] = None,
        spot_rate: Optional[decimal.Decimal] = None,
        forward_rate: Optional[decimal.Decimal] = None,
        discount_factor: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Scenario(_model_base.Model):
    """Scenario.

    Attributes
    ----------
    scenario_id : str
        Identification code of the scenario.
    scenario_title : str
        Name of the scenario.
    timing : str
        Is one of the following types: Literal["Immediate"],
        Literal["Gradual"], Literal["AtHorizon"]
    reinvestment_rate : str
        Annualized rate at which scenario cash flows are reinvested. Default
        reinvestment rate is the 3-month rate on the OTR Treasury curve.
    definition : ~analyticsapi.models.ScenarioDefinition
    volatility : ~analyticsapi.models.ScenarioVolatility
    current_coupon_spread_change : float
    """

    scenario_id: Optional[str] = rest_field(name="scenarioID")
    """Identification code of the scenario."""
    scenario_title: Optional[str] = rest_field(name="scenarioTitle")
    """Name of the scenario."""
    timing: Optional[Literal["Immediate", "Gradual", "AtHorizon"]] = rest_field()
    """Is one of the following types: Literal[\"Immediate\"], Literal[\"Gradual\"],
     Literal[\"AtHorizon\"]"""
    reinvestment_rate: Optional[str] = rest_field(name="reinvestmentRate")
    """Annualized rate at which scenario cash flows are reinvested. Default reinvestment rate is the
     3-month rate on the OTR Treasury curve."""
    definition: Optional["_models.ScenarioDefinition"] = rest_field()
    volatility: Optional["_models.ScenarioVolatility"] = rest_field()
    current_coupon_spread_change: Optional[float] = rest_field(name="currentCouponSpreadChange")

    @overload
    def __init__(
        self,
        *,
        scenario_id: Optional[str] = None,
        scenario_title: Optional[str] = None,
        timing: Optional[Literal["Immediate", "Gradual", "AtHorizon"]] = None,
        reinvestment_rate: Optional[str] = None,
        definition: Optional["_models.ScenarioDefinition"] = None,
        volatility: Optional["_models.ScenarioVolatility"] = None,
        current_coupon_spread_change: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScenarioCalcFloaterSettings(_model_base.Model):
    """ScenarioCalcFloaterSettings.

    Attributes
    ----------
    use_forward_index : bool
        Optional, if true floating coupon follows the index's forward path.
        Otherwise floating coupon is static.
    use_immediate_forward_shift : bool
        Optional. Spread over Forward Index. If used, do not use
        forwardIndexVector.
    """

    use_forward_index: Optional[bool] = rest_field(name="useForwardIndex")
    """Optional, if true floating coupon follows the index's forward path. Otherwise floating coupon
     is static."""
    use_immediate_forward_shift: Optional[bool] = rest_field(name="useImmediateForwardShift")
    """Optional. Spread over Forward Index. If used, do not use forwardIndexVector."""

    @overload
    def __init__(
        self,
        *,
        use_forward_index: Optional[bool] = None,
        use_immediate_forward_shift: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScenarioCalcGlobalSettings(_model_base.Model):
    """ScenarioCalcGlobalSettings.

    Attributes
    ----------
    pricing_date : ~datetime.date
        A historical curve and term structure date. Only one date option can be
        used (pricingDate, usePreviousClose, useLiveData).
    use_previous_close : bool
        A date selection that uses the prior closing business days curve and
        volatility surface. Only one date option can be used (pricingDate,
        usePreviousClose, useLiveData).
    use_live_data : bool
        A date selection that will always use live curve data. Only one date
        option can be used (pricingDate, usePreviousClose, useLiveData).
    calc_horizon_effective_measures : bool
        Optional, if true, effective measures at the horizon date are
        calculated (e.g. effective duration, effective convexity, effective
        dv01, etc.).
    calc_horizon_option_measures : bool
        Optional, if true, option greeks at the horizon date are calculated.
    calc_scenario_cash_flow : bool
    calc_option_model_cash_flow : bool
        Optional, if true, returns the scenario cash flows.
    calc_prepay_sensitivity : bool
        Optional, if true, triggers the calculation of current coupon OAS
        spread duration, turnover duration, prepay duration, primary-secondary
        spread duration, refi duration, and refi-elbow duration.
    current_coupon_rates : str
        Is one of the following types: Literal["MOATS"],
        Literal["SpreadToSwap"], Literal["SpreadToTreasury"],
        Literal["SpreadToSwapMeanReversion"], Literal["TreasuryMoats"]
    horizon_months : int
        The number of months in the scenario. Horizon months and/or horizon
        days are required.
    horizon_days : int
        The number of days in the scenario. Horizon months and/or horizon days
        are required.
    retrieve_ppm_projection : bool
    use_stochastic_hpa : bool
        Optional, for CRT and Non-Agency. If true, for OAS computations, for
        each rates path there will be an associated stochastic HPA path. If
        false, HPA will align with the agency approach.
    use_five_point_convexity : bool
        Optional, if true, convexity is calculated using 5-points, default is
        3-points.
    use_core_logic_group_model : bool
        Optional, for Non-Agency MBS. If true, prepayment and default
        assumptions are based at the group level, rather than the deal level.
    use_muni_non_call_curve : bool
        Optional, for Muni bonds. If true, pricing curve is constructed using
        non-callable securities only.
    use_muni_tax_settings : bool
        Optional, for Muni bonds. If true, analytics include certain tax
        considerations - de minimus rule, capital gains rate, and ordinary
        income rate.
    use_ois : bool
    prepay_dials : ~analyticsapi.models.JsonRef
    swap_curve_floor_rate : ~decimal.Decimal
    use_tba_back_settle : bool
    use_non_qm_collateral : bool
        Optional, if true, Non-QM collateral is used for non-agency RMBS model
        calls, otherwise Alt-A collateral is used. This flag only applies to
        prepay type v97. If this flag is set to true, you must also set
        'coreLogicCollateral' to 'USE'.
    core_logic_collateral : str
        Optional, for Non-Agency. Enables model to be run using from CoreLogic
        collateral data. Is one of the following types: Literal["DEFAULT"],
        Literal["USE"], Literal["IGNORE"]
    """

    pricing_date: Optional[datetime.date] = rest_field(name="pricingDate")
    """A historical curve and term structure date. Only one date option can be used (pricingDate,
     usePreviousClose, useLiveData)."""
    use_previous_close: Optional[bool] = rest_field(name="usePreviousClose")
    """A date selection that uses the prior closing business days curve and volatility surface. Only
     one date option can be used (pricingDate, usePreviousClose, useLiveData)."""
    use_live_data: Optional[bool] = rest_field(name="useLiveData")
    """A date selection that will always use live curve data. Only one date option can be used
     (pricingDate, usePreviousClose, useLiveData)."""
    calc_horizon_effective_measures: Optional[bool] = rest_field(name="calcHorizonEffectiveMeasures")
    """Optional, if true, effective measures at the horizon date are calculated (e.g. effective
     duration, effective convexity, effective dv01, etc.)."""
    calc_horizon_option_measures: Optional[bool] = rest_field(name="calcHorizonOptionMeasures")
    """Optional, if true, option greeks at the horizon date are calculated."""
    calc_scenario_cash_flow: Optional[bool] = rest_field(name="calcScenarioCashFlow")
    calc_option_model_cash_flow: Optional[bool] = rest_field(name="calcOptionModelCashFlow")
    """Optional, if true, returns the scenario cash flows."""
    calc_prepay_sensitivity: Optional[bool] = rest_field(name="calcPrepaySensitivity")
    """Optional, if true, triggers the calculation of current coupon OAS spread duration, turnover
     duration, prepay duration, primary-secondary spread duration, refi duration, and refi-elbow
     duration."""
    current_coupon_rates: Optional[
        Literal["MOATS", "SpreadToSwap", "SpreadToTreasury", "SpreadToSwapMeanReversion", "TreasuryMoats"]
    ] = rest_field(name="currentCouponRates")
    """Is one of the following types: Literal[\"MOATS\"], Literal[\"SpreadToSwap\"],
     Literal[\"SpreadToTreasury\"], Literal[\"SpreadToSwapMeanReversion\"],
     Literal[\"TreasuryMoats\"]"""
    horizon_months: Optional[int] = rest_field(name="horizonMonths")
    """The number of months in the scenario. Horizon months and/or horizon days are required."""
    horizon_days: Optional[int] = rest_field(name="horizonDays")
    """The number of days in the scenario. Horizon months and/or horizon days are required."""
    retrieve_ppm_projection: Optional[bool] = rest_field(name="retrievePPMProjection")
    use_stochastic_hpa: Optional[bool] = rest_field(name="useStochasticHPA")
    """Optional, for CRT and Non-Agency. If true, for OAS computations, for each rates path there will
     be an associated stochastic HPA path. If false, HPA will align with the agency approach."""
    use_five_point_convexity: Optional[bool] = rest_field(name="useFivePointConvexity")
    """Optional, if true, convexity is calculated using 5-points, default is 3-points."""
    use_core_logic_group_model: Optional[bool] = rest_field(name="useCoreLogicGroupModel")
    """Optional, for Non-Agency MBS. If true, prepayment and default assumptions are based at the
     group level, rather than the deal level."""
    use_muni_non_call_curve: Optional[bool] = rest_field(name="useMuniNonCallCurve")
    """Optional, for Muni bonds. If true, pricing curve is constructed using non-callable securities
     only."""
    use_muni_tax_settings: Optional[bool] = rest_field(name="useMuniTaxSettings")
    """Optional, for Muni bonds. If true, analytics include certain tax considerations - de minimus
     rule, capital gains rate, and ordinary income rate."""
    use_ois: Optional[bool] = rest_field(name="useOIS")
    prepay_dials: Optional["_models.JsonRef"] = rest_field(name="prepayDials")
    swap_curve_floor_rate: Optional[decimal.Decimal] = rest_field(name="swapCurveFloorRate")
    use_tba_back_settle: Optional[bool] = rest_field(name="useTBABackSettle")
    use_non_qm_collateral: Optional[bool] = rest_field(name="useNonQMCollateral")
    """Optional, if true, Non-QM collateral is used for non-agency RMBS model calls, otherwise Alt-A
     collateral is used. This flag only applies to prepay type v97. If this flag is set to true, you
     must also set 'coreLogicCollateral' to 'USE'."""
    core_logic_collateral: Optional[Literal["DEFAULT", "USE", "IGNORE"]] = rest_field(name="coreLogicCollateral")
    """Optional, for Non-Agency. Enables model to be run using from CoreLogic collateral data. Is one
     of the following types: Literal[\"DEFAULT\"], Literal[\"USE\"], Literal[\"IGNORE\"]"""

    @overload
    def __init__(
        self,
        *,
        pricing_date: Optional[datetime.date] = None,
        use_previous_close: Optional[bool] = None,
        use_live_data: Optional[bool] = None,
        calc_horizon_effective_measures: Optional[bool] = None,
        calc_horizon_option_measures: Optional[bool] = None,
        calc_scenario_cash_flow: Optional[bool] = None,
        calc_option_model_cash_flow: Optional[bool] = None,
        calc_prepay_sensitivity: Optional[bool] = None,
        current_coupon_rates: Optional[
            Literal["MOATS", "SpreadToSwap", "SpreadToTreasury", "SpreadToSwapMeanReversion", "TreasuryMoats"]
        ] = None,
        horizon_months: Optional[int] = None,
        horizon_days: Optional[int] = None,
        retrieve_ppm_projection: Optional[bool] = None,
        use_stochastic_hpa: Optional[bool] = None,
        use_five_point_convexity: Optional[bool] = None,
        use_core_logic_group_model: Optional[bool] = None,
        use_muni_non_call_curve: Optional[bool] = None,
        use_muni_tax_settings: Optional[bool] = None,
        use_ois: Optional[bool] = None,
        prepay_dials: Optional["_models.JsonRef"] = None,
        swap_curve_floor_rate: Optional[decimal.Decimal] = None,
        use_tba_back_settle: Optional[bool] = None,
        use_non_qm_collateral: Optional[bool] = None,
        core_logic_collateral: Optional[Literal["DEFAULT", "USE", "IGNORE"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScenarioCalcInput(_model_base.Model):
    """ScenarioCalcInput.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    identifier : str
        Security reference ID. Required.
    id_type : str or ~analyticsapi.models.IdTypeEnum
        Known values are: "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN",
        "REGSISIN", "SEDOL", "Identifier", "ChinaInterbankCode",
        "ShanghaiExchangeCode", "ShenzhenExchangeCode", and "MXTickerID".
    user_tag : str
        User provided tag - this will be returned in the response.
    curve : ~analyticsapi.models.CurveTypeAndCurrency
        Required.
    volatility : ~analyticsapi.models.Volatility
    settlement_info : ~analyticsapi.models.SettlementInfo
        Required.
    horizon_info : list[~analyticsapi.models.HorizonInfo]
        Required.  The default value is None, needs to be assigned before
        using.
    assume_call : bool
        Applicable for CMBS with a clean up call. If true, remaining balance is
        called once clean up call threshold is reached.
    horizon_py_method : str
        Required. Is one of the following types: Literal["OAS Change"],
        Literal["Spread Change"], Literal["Price Change"], Literal["DM
        Change"], Literal["Libor Sprd Change"], Literal["TED Spread Change"],
        Literal["Stripped Spread Change"], Literal["Static Spread Change"],
        Literal["OAS"], Literal["Spread"], Literal["Yield"], Literal["Stripped
        Yield"], Literal["Price"], Literal["Discount Margin"], Literal["Sprd To
        Libor"], Literal["Stripped Spread"], Literal["Static Spread"],
        Literal["Annualized ROR"], Literal["Volatility"], Literal["Volatility
        Change"], Literal["Real Yield Beta"], Literal["Real Yield Change"],
        Literal["Real Spread"], Literal["Real Spread Change"],
        Literal["Inflation"], Literal["TED Spread"], Literal["Yield Curve
        Margin"], Literal["Yield Curve Margin Change"], Literal["Forward
        Yield"], Literal["Forward Yield Change"], Literal["MX Spread"],
        Literal["MX Spread Change"], Literal["Daily BPVol Change"],
        Literal["Rich Cheap"], Literal["OAS Pct Change"], Literal["Tax Adjusted
        OAS Change"]
    floater_settings : ~analyticsapi.models.ScenarioCalcFloaterSettings
    hecm_settings : ~analyticsapi.models.HecmSettings
    extra_settings : ~analyticsapi.models.ScenCalcExtraSettings
    user_instrument : ~analyticsapi.models.JsonRef
    modification : ~analyticsapi.models.JsonRef
    current_coupon_spread : ~analyticsapi.models.JsonRef
    props : dict[str, any]
    """

    identifier: str = rest_field()
    """Security reference ID. Required."""
    id_type: Optional[Union[str, "_models.IdTypeEnum"]] = rest_field(name="idType")
    """Known values are: \"SecurityIDEntry\", \"SecurityID\", \"CUSIP\", \"ISIN\", \"REGSISIN\",
     \"SEDOL\", \"Identifier\", \"ChinaInterbankCode\", \"ShanghaiExchangeCode\",
     \"ShenzhenExchangeCode\", and \"MXTickerID\"."""
    user_tag: Optional[str] = rest_field(name="userTag")
    """User provided tag - this will be returned in the response."""
    curve: "_models.CurveTypeAndCurrency" = rest_field()
    """Required."""
    volatility: Optional["_models.Volatility"] = rest_field()
    settlement_info: "_models.SettlementInfo" = rest_field(name="settlementInfo")
    """Required."""
    horizon_info: List["_models.HorizonInfo"] = rest_field(name="horizonInfo")
    """Required."""
    assume_call: Optional[bool] = rest_field(name="assumeCall")
    """Applicable for CMBS with a clean up call. If true, remaining balance is called once clean up
     call threshold is reached."""
    horizon_py_method: Literal[
        "OAS Change",
        "Spread Change",
        "Price Change",
        "DM Change",
        "Libor Sprd Change",
        "TED Spread Change",
        "Stripped Spread Change",
        "Static Spread Change",
        "OAS",
        "Spread",
        "Yield",
        "Stripped Yield",
        "Price",
        "Discount Margin",
        "Sprd To Libor",
        "Stripped Spread",
        "Static Spread",
        "Annualized ROR",
        "Volatility",
        "Volatility Change",
        "Real Yield Beta",
        "Real Yield Change",
        "Real Spread",
        "Real Spread Change",
        "Inflation",
        "TED Spread",
        "Yield Curve Margin",
        "Yield Curve Margin Change",
        "Forward Yield",
        "Forward Yield Change",
        "MX Spread",
        "MX Spread Change",
        "Daily BPVol Change",
        "Rich Cheap",
        "OAS Pct Change",
        "Tax Adjusted OAS Change",
    ] = rest_field(name="horizonPYMethod")
    """Required. Is one of the following types: Literal[\"OAS Change\"], Literal[\"Spread Change\"],
     Literal[\"Price Change\"], Literal[\"DM Change\"], Literal[\"Libor Sprd Change\"],
     Literal[\"TED Spread Change\"], Literal[\"Stripped Spread Change\"], Literal[\"Static Spread
     Change\"], Literal[\"OAS\"], Literal[\"Spread\"], Literal[\"Yield\"], Literal[\"Stripped
     Yield\"], Literal[\"Price\"], Literal[\"Discount Margin\"], Literal[\"Sprd To Libor\"],
     Literal[\"Stripped Spread\"], Literal[\"Static Spread\"], Literal[\"Annualized ROR\"],
     Literal[\"Volatility\"], Literal[\"Volatility Change\"], Literal[\"Real Yield Beta\"],
     Literal[\"Real Yield Change\"], Literal[\"Real Spread\"], Literal[\"Real Spread Change\"],
     Literal[\"Inflation\"], Literal[\"TED Spread\"], Literal[\"Yield Curve Margin\"],
     Literal[\"Yield Curve Margin Change\"], Literal[\"Forward Yield\"], Literal[\"Forward Yield
     Change\"], Literal[\"MX Spread\"], Literal[\"MX Spread Change\"], Literal[\"Daily BPVol
     Change\"], Literal[\"Rich Cheap\"], Literal[\"OAS Pct Change\"], Literal[\"Tax Adjusted OAS
     Change\"]"""
    floater_settings: Optional["_models.ScenarioCalcFloaterSettings"] = rest_field(name="floaterSettings")
    hecm_settings: Optional["_models.HecmSettings"] = rest_field(name="hecmSettings")
    extra_settings: Optional["_models.ScenCalcExtraSettings"] = rest_field(name="extraSettings")
    user_instrument: Optional["_models.JsonRef"] = rest_field(name="userInstrument")
    modification: Optional["_models.JsonRef"] = rest_field()
    current_coupon_spread: Optional["_models.JsonRef"] = rest_field(name="currentCouponSpread")
    props: Optional[Dict[str, Any]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        identifier: str,
        curve: "_models.CurveTypeAndCurrency",
        settlement_info: "_models.SettlementInfo",
        horizon_info: List["_models.HorizonInfo"],
        horizon_py_method: Literal[
            "OAS Change",
            "Spread Change",
            "Price Change",
            "DM Change",
            "Libor Sprd Change",
            "TED Spread Change",
            "Stripped Spread Change",
            "Static Spread Change",
            "OAS",
            "Spread",
            "Yield",
            "Stripped Yield",
            "Price",
            "Discount Margin",
            "Sprd To Libor",
            "Stripped Spread",
            "Static Spread",
            "Annualized ROR",
            "Volatility",
            "Volatility Change",
            "Real Yield Beta",
            "Real Yield Change",
            "Real Spread",
            "Real Spread Change",
            "Inflation",
            "TED Spread",
            "Yield Curve Margin",
            "Yield Curve Margin Change",
            "Forward Yield",
            "Forward Yield Change",
            "MX Spread",
            "MX Spread Change",
            "Daily BPVol Change",
            "Rich Cheap",
            "OAS Pct Change",
            "Tax Adjusted OAS Change",
        ],
        id_type: Optional[Union[str, "_models.IdTypeEnum"]] = None,
        user_tag: Optional[str] = None,
        volatility: Optional["_models.Volatility"] = None,
        assume_call: Optional[bool] = None,
        floater_settings: Optional["_models.ScenarioCalcFloaterSettings"] = None,
        hecm_settings: Optional["_models.HecmSettings"] = None,
        extra_settings: Optional["_models.ScenCalcExtraSettings"] = None,
        user_instrument: Optional["_models.JsonRef"] = None,
        modification: Optional["_models.JsonRef"] = None,
        current_coupon_spread: Optional["_models.JsonRef"] = None,
        props: Optional[Dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScenarioCalcRequest(_model_base.Model):
    """ScenarioCalcRequest.

    Attributes
    ----------
    global_settings : ~analyticsapi.models.ScenarioCalcGlobalSettings
    keywords : list[str]
        The default value is None, needs to be assigned before using.
    scenarios : list[~analyticsapi.models.Scenario]
        The default value is None, needs to be assigned before using.
    input : list[~analyticsapi.models.ScenarioCalcInput]
        The default value is None, needs to be assigned before using.
    """

    global_settings: Optional["_models.ScenarioCalcGlobalSettings"] = rest_field(name="globalSettings")
    keywords: Optional[List[str]] = rest_field()
    scenarios: Optional[List["_models.Scenario"]] = rest_field()
    input: Optional[List["_models.ScenarioCalcInput"]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        global_settings: Optional["_models.ScenarioCalcGlobalSettings"] = None,
        keywords: Optional[List[str]] = None,
        scenarios: Optional[List["_models.Scenario"]] = None,
        input: Optional[List["_models.ScenarioCalcInput"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScenarioDefinition(_model_base.Model):
    """ScenarioDefinition.

    Attributes
    ----------
    system_scenario : ~analyticsapi.models.SystemScenario
        User can either use a systemScenario or create a userScenario.
    user_scenario : ~analyticsapi.models.UserScenario
    """

    system_scenario: Optional["_models.SystemScenario"] = rest_field(name="systemScenario")
    """User can either use a systemScenario or create a userScenario."""
    user_scenario: Optional["_models.UserScenario"] = rest_field(name="userScenario")

    @overload
    def __init__(
        self,
        *,
        system_scenario: Optional["_models.SystemScenario"] = None,
        user_scenario: Optional["_models.UserScenario"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScenarioSettlement(_model_base.Model):
    """ScenarioSettlement.

    Attributes
    ----------
    holding_date : ~datetime.date
    settlement_type : str
    settlement_date : ~datetime.date
        Optional. If settlementType is CUSTOM, user needs to input
        settlementDate.
    """

    holding_date: Optional[datetime.date] = rest_field(name="holdingDate")
    settlement_type: Optional[str] = rest_field(name="settlementType")
    settlement_date: Optional[datetime.date] = rest_field(name="settlementDate")
    """Optional. If settlementType is CUSTOM, user needs to input settlementDate."""

    @overload
    def __init__(
        self,
        *,
        holding_date: Optional[datetime.date] = None,
        settlement_type: Optional[str] = None,
        settlement_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScenarioVolatility(_model_base.Model):
    """ScenarioVolatility.

    Attributes
    ----------
    term_unit : str
        Is either a Literal["MONTH"] type or a Literal["YEAR"] type.
    value_type : str
        Is either a Literal["ABS"] type or a Literal["REL"] type.
    parallel_shift : ~decimal.Decimal
        Shock amount to be applied to the entire volatility surface.
    swaption_volatility : ~analyticsapi.models.SwaptionVolatility
    cap_volatility : ~analyticsapi.models.CapVolatility
    """

    term_unit: Optional[Literal["MONTH", "YEAR"]] = rest_field(name="termUnit")
    """Is either a Literal[\"MONTH\"] type or a Literal[\"YEAR\"] type."""
    value_type: Optional[Literal["ABS", "REL"]] = rest_field(name="valueType")
    """Is either a Literal[\"ABS\"] type or a Literal[\"REL\"] type."""
    parallel_shift: Optional[decimal.Decimal] = rest_field(name="parallelShift")
    """Shock amount to be applied to the entire volatility surface."""
    swaption_volatility: Optional["_models.SwaptionVolatility"] = rest_field(name="swaptionVolatility")
    cap_volatility: Optional["_models.CapVolatility"] = rest_field(name="capVolatility")

    @overload
    def __init__(
        self,
        *,
        term_unit: Optional[Literal["MONTH", "YEAR"]] = None,
        value_type: Optional[Literal["ABS", "REL"]] = None,
        parallel_shift: Optional[decimal.Decimal] = None,
        swaption_volatility: Optional["_models.SwaptionVolatility"] = None,
        cap_volatility: Optional["_models.CapVolatility"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScenCalcExtraSettings(_model_base.Model):
    """Optional additional pricing settings.

    Attributes
    ----------
    include_partials : bool
        Partial durations are calculated.
    partials : ~analyticsapi.models.ScenPartials
        Optional, and only to be used if includePartials = true.
    """

    include_partials: Optional[bool] = rest_field(name="includePartials")
    """Partial durations are calculated."""
    partials: Optional["_models.ScenPartials"] = rest_field()
    """Optional, and only to be used if includePartials = true."""

    @overload
    def __init__(
        self,
        *,
        include_partials: Optional[bool] = None,
        partials: Optional["_models.ScenPartials"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScenPartials(_model_base.Model):
    """ScenPartials.

    Attributes
    ----------
    curve_type : str
        Is one of the following types: Literal["PAR"], Literal["SPOT"],
        Literal["FORWARD"]
    curve_shift : float
        Shock amount, in basis points.
    shock_type : str
        Is either a Literal["SQUARE"] type or a Literal["TRIANGLE"] type.
    cumulative_wave_method : bool
        A cumulative shock which starts at the short end and attributes
        sensitivity to the tenors as it moves through the curve, so the entire
        curve is shocked by 25bps.
    partial_duration_years : list[float]
        Specific custom partial points.  The default value is None, needs to be
        assigned before using.
    """

    curve_type: Optional[Literal["PAR", "SPOT", "FORWARD"]] = rest_field(name="curveType")
    """Is one of the following types: Literal[\"PAR\"], Literal[\"SPOT\"], Literal[\"FORWARD\"]"""
    curve_shift: Optional[float] = rest_field(name="curveShift")
    """Shock amount, in basis points."""
    shock_type: Optional[Literal["SQUARE", "TRIANGLE"]] = rest_field(name="shockType")
    """Is either a Literal[\"SQUARE\"] type or a Literal[\"TRIANGLE\"] type."""
    cumulative_wave_method: Optional[bool] = rest_field(name="cumulativeWaveMethod")
    """A cumulative shock which starts at the short end and attributes sensitivity to the tenors as it
     moves through the curve, so the entire curve is shocked by 25bps."""
    partial_duration_years: Optional[List[float]] = rest_field(name="partialDurationYears")
    """Specific custom partial points."""

    @overload
    def __init__(
        self,
        *,
        curve_type: Optional[Literal["PAR", "SPOT", "FORWARD"]] = None,
        curve_shift: Optional[float] = None,
        shock_type: Optional[Literal["SQUARE", "TRIANGLE"]] = None,
        cumulative_wave_method: Optional[bool] = None,
        partial_duration_years: Optional[List[float]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScheduleDefinition(_model_base.Model):
    """An object that defines a date schedule.
    This common model is used in financial instruments where a structured sequence of dates is
    required for financial calculations or contract terms,
    for example, to specify interest periods, amortization dates, or the sequence of dates in the
    fixing period of an Asian option.

    Attributes
    ----------
    start_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the start date
        of the schedule. If not defined, the schedule is spot-starting, and the
        default start date is determined based on market conventions.
    end_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the end date of
        the schedule. Required.
    first_regular_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the first
        regular date of the schedule.
    last_regular_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the last
        regular date of the schedule.
    stub_rule : str or ~analyticsapi.models.StubRuleEnum
        The rule that specifies whether the first or last period on the
        schedule is unregular. Known values are: "LongFirst", "LongLast",
        "ShortFirst", and "ShortLast".
    frequency : str or ~analyticsapi.models.FrequencyEnum
        The frequency of the dates generated in the regular period. Known
        values are: "Annual", "SemiAnnual", "Quarterly", "Monthly",
        "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every90Days",
        "Every91Days", "Every92Days", "Every93Days", "Every4Months",
        "Every180Days", "Every182Days", "Every183Days", "Every184Days",
        "Every364Days", "Every365Days", "R2", "R4", "Zero", and "Scheduled".
    business_day_adjustment : ~analyticsapi.models.BusinessDayAdjustmentDefinition
        An object that defines the business day adjustment convention.
    roll_convention : str or ~analyticsapi.models.EndOfMonthConvention
        The method to adjust a date when it falls at the end of the month.
        Known values are: "Last", "Same", "Last28", "Same28", and "Same1".
    """

    start_date: Optional["_models.Date"] = rest_field(name="startDate")
    """An object that contains properties to define and adjust the start date of the schedule. If not
     defined, the schedule is spot-starting, and the default start date is determined based on
     market conventions."""
    end_date: "_models.Date" = rest_field(name="endDate")
    """An object that contains properties to define and adjust the end date of the schedule. Required."""
    first_regular_date: Optional["_models.Date"] = rest_field(name="firstRegularDate")
    """An object that contains properties to define and adjust the first regular date of the schedule."""
    last_regular_date: Optional["_models.Date"] = rest_field(name="lastRegularDate")
    """An object that contains properties to define and adjust the last regular date of the schedule."""
    stub_rule: Optional[Union[str, "_models.StubRuleEnum"]] = rest_field(name="stubRule")
    """The rule that specifies whether the first or last period on the schedule is unregular. Known
     values are: \"LongFirst\", \"LongLast\", \"ShortFirst\", and \"ShortLast\"."""
    frequency: Optional[Union[str, "_models.FrequencyEnum"]] = rest_field()
    """The frequency of the dates generated in the regular period. Known values are: \"Annual\",
     \"SemiAnnual\", \"Quarterly\", \"Monthly\", \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\",
     \"Every7Days\", \"Every14Days\", \"Every28Days\", \"Every30Days\", \"Every90Days\",
     \"Every91Days\", \"Every92Days\", \"Every93Days\", \"Every4Months\", \"Every180Days\",
     \"Every182Days\", \"Every183Days\", \"Every184Days\", \"Every364Days\", \"Every365Days\",
     \"R2\", \"R4\", \"Zero\", and \"Scheduled\"."""
    business_day_adjustment: Optional["_models.BusinessDayAdjustmentDefinition"] = rest_field(
        name="businessDayAdjustment"
    )
    """An object that defines the business day adjustment convention."""
    roll_convention: Optional[Union[str, "_models.EndOfMonthConvention"]] = rest_field(name="rollConvention")
    """The method to adjust a date when it falls at the end of the month. Known values are: \"Last\",
     \"Same\", \"Last28\", \"Same28\", and \"Same1\"."""

    @overload
    def __init__(
        self,
        *,
        end_date: "_models.Date",
        start_date: Optional["_models.Date"] = None,
        first_regular_date: Optional["_models.Date"] = None,
        last_regular_date: Optional["_models.Date"] = None,
        stub_rule: Optional[Union[str, "_models.StubRuleEnum"]] = None,
        frequency: Optional[Union[str, "_models.FrequencyEnum"]] = None,
        business_day_adjustment: Optional["_models.BusinessDayAdjustmentDefinition"] = None,
        roll_convention: Optional[Union[str, "_models.EndOfMonthConvention"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ScheduleItem(_model_base.Model):
    """ScheduleItem.

    Attributes
    ----------
    date : ~datetime.date
    value : ~decimal.Decimal
    """

    date: Optional[datetime.date] = rest_field()
    value: Optional[decimal.Decimal] = rest_field()

    @overload
    def __init__(
        self,
        *,
        date: Optional[datetime.date] = None,
        value: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Seasonality(_model_base.Model):
    """Seasonality.

    Attributes
    ----------
    apply_seasonality : bool
    seasonality_curve : list[~analyticsapi.models.SeasonalityCurvePoint]
        List containing the points of the Seasonality Curve.  The default value
        is None, needs to be assigned before using.
    seasonality_date : ~datetime.date
        Seasonality data will be returned using a seasonality Date, if it is
        specified in the request.
    seasonality_name : str
        Defines the seasonality curve that will we applied to the calculation.
    """

    apply_seasonality: Optional[bool] = rest_field(name="applySeasonality")
    seasonality_curve: Optional[List["_models.SeasonalityCurvePoint"]] = rest_field(name="seasonalityCurve")
    """List containing the points of the Seasonality Curve."""
    seasonality_date: Optional[datetime.date] = rest_field(name="seasonalityDate")
    """Seasonality data will be returned using a seasonality Date, if it is specified in the request."""
    seasonality_name: Optional[str] = rest_field(name="seasonalityName")
    """Defines the seasonality curve that will we applied to the calculation."""

    @overload
    def __init__(
        self,
        *,
        apply_seasonality: Optional[bool] = None,
        seasonality_curve: Optional[List["_models.SeasonalityCurvePoint"]] = None,
        seasonality_date: Optional[datetime.date] = None,
        seasonality_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SeasonalityCurvePoint(_model_base.Model):
    """SeasonalityCurvePoint.

    Attributes
    ----------
    period : int
        Can either be the index of month of the year, the index of week, etc.
    seasonality_factor : float
        seasonality factor.
    """

    period: Optional[int] = rest_field()
    """Can either be the index of month of the year, the index of week, etc."""
    seasonality_factor: Optional[float] = rest_field(name="seasonalityFactor")
    """seasonality factor."""

    @overload
    def __init__(
        self,
        *,
        period: Optional[int] = None,
        seasonality_factor: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SeasonalityDescription(_model_base.Model):
    """SeasonalityDescription.

    Attributes
    ----------
    apply_seasonality : bool
    seasonality_date : ~datetime.date
        Seasonality data will be returned using a seasonality Date, if it is
        specified in the request.
    seasonality_name : str
        Defines the seasonality curve that will we applied to the calculation.
    """

    apply_seasonality: Optional[bool] = rest_field(name="applySeasonality")
    seasonality_date: Optional[datetime.date] = rest_field(name="seasonalityDate")
    """Seasonality data will be returned using a seasonality Date, if it is specified in the request."""
    seasonality_name: Optional[str] = rest_field(name="seasonalityName")
    """Defines the seasonality curve that will we applied to the calculation."""

    @overload
    def __init__(
        self,
        *,
        apply_seasonality: Optional[bool] = None,
        seasonality_date: Optional[datetime.date] = None,
        seasonality_name: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SensitivityShocks(_model_base.Model):
    """SensitivityShocks.

    Attributes
    ----------
    effective_duration : float
    spread : float
    prepay : float
    current_coupon_spreads : float
    prepay_model_elbow : float
    prepay_model_refi : float
    hpa : float
    """

    effective_duration: Optional[float] = rest_field(name="effectiveDuration")
    spread: Optional[float] = rest_field()
    prepay: Optional[float] = rest_field()
    current_coupon_spreads: Optional[float] = rest_field(name="currentCouponSpreads")
    prepay_model_elbow: Optional[float] = rest_field(name="prepayModelElbow")
    prepay_model_refi: Optional[float] = rest_field(name="prepayModelRefi")
    hpa: Optional[float] = rest_field()

    @overload
    def __init__(
        self,
        *,
        effective_duration: Optional[float] = None,
        spread: Optional[float] = None,
        prepay: Optional[float] = None,
        current_coupon_spreads: Optional[float] = None,
        prepay_model_elbow: Optional[float] = None,
        prepay_model_refi: Optional[float] = None,
        hpa: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceError(_model_base.Model):
    """An object that contains the information in case of a blocking error in calculation.

    Attributes
    ----------
    id : str
        The identifier of the error. Required.
    code : str
        The code of the error. Required.
    message : str
        The message in case of a blocking error in calculation. Required.
    status : str
        The status of the error.
    errors : list[~analyticsapi.models.InnerError]
        An array of objects that contains the detailed information in case of a
        blocking error in calculation.  The default value is None, needs to be
        assigned before using.
    """

    id: str = rest_field()
    """The identifier of the error. Required."""
    code: str = rest_field()
    """The code of the error. Required."""
    message: str = rest_field()
    """The message in case of a blocking error in calculation. Required."""
    status: Optional[str] = rest_field()
    """The status of the error."""
    errors: Optional[List["_models.InnerError"]] = rest_field()
    """An array of objects that contains the detailed information in case of a blocking error in
     calculation."""

    @overload
    def __init__(
        self,
        *,
        id: str,  # pylint: disable=redefined-builtin
        code: str,
        message: str,
        status: Optional[str] = None,
        errors: Optional[List["_models.InnerError"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ServiceErrorResponse(_model_base.Model):
    """The error information returned in response.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    error : ~analyticsapi.models.ServiceError
        An object that contains the information in case of a blocking error in
        calculation. Required.
    """

    error: "_models.ServiceError" = rest_field()
    """An object that contains the information in case of a blocking error in calculation. Required."""

    @overload
    def __init__(
        self,
        error: "_models.ServiceError",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["error"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class SettlementCashflow(Cashflow, discriminator="Settlement"):
    """Lists the properties for Settlement payment type.

    Attributes
    ----------
    date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the payment
        date.
    amount : ~analyticsapi.models.Amount
        An object that defines the amount and currency of a payment. Required.
    payer : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that makes the payment. Required. Known
        values are: "Party1" and "Party2".
    receiver : str or ~analyticsapi.models.PartyEnum
        The party (Party1 or Party2) that receives the payment. Required. Known
        values are: "Party1" and "Party2".
    occurrence : str or ~analyticsapi.models.PaymentOccurrenceEnum
        The timeline of the transaction. The possible values are: Historical:
        the cash flow date is earlier than the valuation date, Future: the cash
        flow date follows the valuation date and the cash flow is known,
        Projected: the cash flow date follows the valuation date and the cash
        flow is not set by the contract but estimated. Required. Known values
        are: "Historical", "Future", and "Projected".
    payment_type : str or ~analyticsapi.models.SETTLEMENT
        Required.
    """

    payment_type: Literal[CashFlowPaymentTypeEnum.SETTLEMENT] = rest_discriminator(name="paymentType")  # type: ignore
    """Required."""

    @overload
    def __init__(
        self,
        *,
        amount: "_models.Amount",
        payer: Union[str, "_models.PartyEnum"],
        receiver: Union[str, "_models.PartyEnum"],
        occurrence: Union[str, "_models.PaymentOccurrenceEnum"],
        date: Optional["_models.Date"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["payment_type"] = args[0]
            args = tuple()
        super().__init__(*args, payment_type=CashFlowPaymentTypeEnum.SETTLEMENT, **kwargs)


class SettlementDefinition(_model_base.Model):
    """An object that defines the settlement settings.

    Attributes
    ----------
    type : str or ~analyticsapi.models.SettlementType
        The settlement type that indicates whether the payment is made by
        exchanging a cash amount or a physical asset. Known values are: "Cash"
        and "Physical".
    currency : str
        The currency in which the payment is settled. The value is expressed in
        ISO 4217 alphabetical format (e.g., 'USD').
    delivery_date : ~analyticsapi.models.Date
        An object that defines the delivery date.
    """

    type: Optional[Union[str, "_models.SettlementType"]] = rest_field(default="None")
    """The settlement type that indicates whether the payment is made by exchanging a cash amount or a
     physical asset. Known values are: \"Cash\" and \"Physical\"."""
    currency: Optional[str] = rest_field()
    """The currency in which the payment is settled. The value is expressed in ISO 4217 alphabetical
     format (e.g., 'USD')."""
    delivery_date: Optional["_models.Date"] = rest_field(name="deliveryDate")
    """An object that defines the delivery date."""

    @overload
    def __init__(
        self,
        *,
        type: Optional[Union[str, "_models.SettlementType"]] = None,
        currency: Optional[str] = None,
        delivery_date: Optional["_models.Date"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SettlementInfo(_model_base.Model):
    """SettlementInfo.

    Attributes
    ----------
    level : str
        Settlement input price for the security. Input can be a price, yield,
        spread, OAS, etc. See quick card for a list of options.
    settlement_type : str
        Is one of the following types: Literal["MARKET"], Literal["INDEX"],
        Literal["CUSTOM"]
    settlement_date : ~datetime.date
        Optional. If settlementType is CUSTOM, user can choose between
        settlementDate and customSettlement. Recommend using settlementDate.
    custom_settlement : str
        Optional. If settlementType is CUSTOM, user can choose between
        settlementDate and customSettlement. Example of customSettlement (T +
        2), where T is the pricing date. Recommend using settlementDate.
    prepay : ~analyticsapi.models.RestPrepaySettings
    loss_settings : ~analyticsapi.models.LossSettings
    cmbs_scenario : ~analyticsapi.models.PricingScenario
    """

    level: Optional[str] = rest_field()
    """Settlement input price for the security. Input can be a price, yield, spread, OAS, etc. See
     quick card for a list of options."""
    settlement_type: Optional[Literal["MARKET", "INDEX", "CUSTOM"]] = rest_field(name="settlementType")
    """Is one of the following types: Literal[\"MARKET\"], Literal[\"INDEX\"], Literal[\"CUSTOM\"]"""
    settlement_date: Optional[datetime.date] = rest_field(name="settlementDate")
    """Optional. If settlementType is CUSTOM, user can choose between settlementDate and
     customSettlement. Recommend using settlementDate."""
    custom_settlement: Optional[str] = rest_field(name="customSettlement")
    """Optional. If settlementType is CUSTOM, user can choose between settlementDate and
     customSettlement. Example of customSettlement (T + 2), where T is the pricing date. Recommend
     using settlementDate."""
    prepay: Optional["_models.RestPrepaySettings"] = rest_field()
    loss_settings: Optional["_models.LossSettings"] = rest_field(name="lossSettings")
    cmbs_scenario: Optional["_models.PricingScenario"] = rest_field(name="cmbsScenario")

    @overload
    def __init__(
        self,
        *,
        level: Optional[str] = None,
        settlement_type: Optional[Literal["MARKET", "INDEX", "CUSTOM"]] = None,
        settlement_date: Optional[datetime.date] = None,
        custom_settlement: Optional[str] = None,
        prepay: Optional["_models.RestPrepaySettings"] = None,
        loss_settings: Optional["_models.LossSettings"] = None,
        cmbs_scenario: Optional["_models.PricingScenario"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ShiftCrossCurrencyInstrumentsItem(_model_base.Model):
    """ShiftCrossCurrencyInstrumentsItem.

    Attributes
    ----------
    all : ~analyticsapi.models.ShiftDefinition
    cross_currency_swap : ~analyticsapi.models.ShiftDefinition
    fx_forward : ~analyticsapi.models.ShiftDefinition
    fx_spot : ~analyticsapi.models.ShiftDefinition
    """

    all: Optional["_models.ShiftDefinition"] = rest_field()
    cross_currency_swap: Optional["_models.ShiftDefinition"] = rest_field(name="crossCurrencySwap")
    fx_forward: Optional["_models.ShiftDefinition"] = rest_field(name="fxForward")
    fx_spot: Optional["_models.ShiftDefinition"] = rest_field(name="fxSpot")

    @overload
    def __init__(
        self,
        *,
        all: Optional["_models.ShiftDefinition"] = None,
        cross_currency_swap: Optional["_models.ShiftDefinition"] = None,
        fx_forward: Optional["_models.ShiftDefinition"] = None,
        fx_spot: Optional["_models.ShiftDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ShiftDefinition(_model_base.Model):
    """ShiftDefinition.

    Attributes
    ----------
    butterfly_shift : ~analyticsapi.models.ButterflyShift
    combined_shifts : list[~analyticsapi.models.CombinedShift]
        The definition of attributes for combined shifts scenario. Each element
        of the combined shifts scenario describes separate shift scenario
        applied to curve points. If one scenario follows the other, they are
        added to each other.  The default value is None, needs to be assigned
        before using.
    flattening_shift : ~analyticsapi.models.FlatteningShift
    long_end_shift : ~analyticsapi.models.LongEndShift
    parallel_shift : ~analyticsapi.models.ParallelShift
    short_end_shift : ~analyticsapi.models.ShortEndShift
    time_bucket_shifts : list[~analyticsapi.models.TimeBucketShift]
        The definition of attributes for time bucket shift scenario. Each
        element of timeBucketShifts describes the separate parallel shift. This
        shift applies from startTenor to endTenor.  The default value is None,
        needs to be assigned before using.
    twist_shift : ~analyticsapi.models.TwistShift
    """

    butterfly_shift: Optional["_models.ButterflyShift"] = rest_field(name="butterflyShift")
    combined_shifts: Optional[List["_models.CombinedShift"]] = rest_field(name="combinedShifts")
    """The definition of attributes for combined shifts scenario. Each element of the combined shifts
     scenario describes separate shift scenario applied to curve points. If one scenario follows the
     other, they are added to each other."""
    flattening_shift: Optional["_models.FlatteningShift"] = rest_field(name="flatteningShift")
    long_end_shift: Optional["_models.LongEndShift"] = rest_field(name="longEndShift")
    parallel_shift: Optional["_models.ParallelShift"] = rest_field(name="parallelShift")
    short_end_shift: Optional["_models.ShortEndShift"] = rest_field(name="shortEndShift")
    time_bucket_shifts: Optional[List["_models.TimeBucketShift"]] = rest_field(name="timeBucketShifts")
    """The definition of attributes for time bucket shift scenario. Each element of timeBucketShifts
     describes the separate parallel shift. This shift applies from startTenor to endTenor."""
    twist_shift: Optional["_models.TwistShift"] = rest_field(name="twistShift")

    @overload
    def __init__(
        self,
        *,
        butterfly_shift: Optional["_models.ButterflyShift"] = None,
        combined_shifts: Optional[List["_models.CombinedShift"]] = None,
        flattening_shift: Optional["_models.FlatteningShift"] = None,
        long_end_shift: Optional["_models.LongEndShift"] = None,
        parallel_shift: Optional["_models.ParallelShift"] = None,
        short_end_shift: Optional["_models.ShortEndShift"] = None,
        time_bucket_shifts: Optional[List["_models.TimeBucketShift"]] = None,
        twist_shift: Optional["_models.TwistShift"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ShiftDefinitionFutures(_model_base.Model):
    """Shift parameters for future instruments.

    Attributes
    ----------
    butterfly_shift : ~analyticsapi.models.ButterflyShift
    combined_shifts : list[~analyticsapi.models.CombinedShift]
        The definition of attributes for combined shifts scenario. Each element
        of the combined shifts scenario describes separate shift scenario
        applied to curve points. If one scenario follows the other, they are
        added to each other.  The default value is None, needs to be assigned
        before using.
    flattening_shift : ~analyticsapi.models.FlatteningShift
    long_end_shift : ~analyticsapi.models.LongEndShift
    parallel_shift : ~analyticsapi.models.ParallelShift
    shift_parameter : ~analyticsapi.models.ShiftFuturesParameter
    short_end_shift : ~analyticsapi.models.ShortEndShift
    time_bucket_shifts : list[~analyticsapi.models.TimeBucketShift]
        The definition of attributes for time bucket shift scenario. Each
        element of timeBucketShifts describes the separate parallel shift. This
        shift applies from startTenor to endTenor.  The default value is None,
        needs to be assigned before using.
    twist_shift : ~analyticsapi.models.TwistShift
    """

    butterfly_shift: Optional["_models.ButterflyShift"] = rest_field(name="butterflyShift")
    combined_shifts: Optional[List["_models.CombinedShift"]] = rest_field(name="combinedShifts")
    """The definition of attributes for combined shifts scenario. Each element of the combined shifts
     scenario describes separate shift scenario applied to curve points. If one scenario follows the
     other, they are added to each other."""
    flattening_shift: Optional["_models.FlatteningShift"] = rest_field(name="flatteningShift")
    long_end_shift: Optional["_models.LongEndShift"] = rest_field(name="longEndShift")
    parallel_shift: Optional["_models.ParallelShift"] = rest_field(name="parallelShift")
    shift_parameter: Optional["_models.ShiftFuturesParameter"] = rest_field(name="shiftParameter")
    short_end_shift: Optional["_models.ShortEndShift"] = rest_field(name="shortEndShift")
    time_bucket_shifts: Optional[List["_models.TimeBucketShift"]] = rest_field(name="timeBucketShifts")
    """The definition of attributes for time bucket shift scenario. Each element of timeBucketShifts
     describes the separate parallel shift. This shift applies from startTenor to endTenor."""
    twist_shift: Optional["_models.TwistShift"] = rest_field(name="twistShift")

    @overload
    def __init__(
        self,
        *,
        butterfly_shift: Optional["_models.ButterflyShift"] = None,
        combined_shifts: Optional[List["_models.CombinedShift"]] = None,
        flattening_shift: Optional["_models.FlatteningShift"] = None,
        long_end_shift: Optional["_models.LongEndShift"] = None,
        parallel_shift: Optional["_models.ParallelShift"] = None,
        shift_parameter: Optional["_models.ShiftFuturesParameter"] = None,
        short_end_shift: Optional["_models.ShortEndShift"] = None,
        time_bucket_shifts: Optional[List["_models.TimeBucketShift"]] = None,
        twist_shift: Optional["_models.TwistShift"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ShiftedUnderlyingCurves(_model_base.Model):
    """ShiftedUnderlyingCurves.

    Attributes
    ----------
    shift_tag : str
        A user-defined string to identify the shift scenario. It can be used to
        link output results to the curve shift scenario. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    underlying_curves : ~analyticsapi.models.UnderlyingCurves
    """

    shift_tag: Optional[str] = rest_field(name="shiftTag")
    """A user-defined string to identify the shift scenario. It can be used to link output results to
     the curve shift scenario. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    underlying_curves: Optional["_models.UnderlyingCurves"] = rest_field(name="underlyingCurves")

    @overload
    def __init__(
        self,
        *,
        shift_tag: Optional[str] = None,
        underlying_curves: Optional["_models.UnderlyingCurves"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ShiftFuturesParameter(_model_base.Model):
    """ShiftFuturesParameter.

    Attributes
    ----------
    future_shift_method : str or ~analyticsapi.models.FutureShiftMethodEnum
        The type of shift method for futures (shift by price or by rate). This
        parameter impacts on the unit of amount in shift scenarios. Price and
        rate can be converted by the next formula: Rate = (100 - Price) / 100.
        The possible values are:   * ShiftRate: the shift amount is expressed
        as a rate,   * ShiftPrice: the shift amount is expressed as a price.
        Known values are: "ShiftPrice" and "ShiftRate".
    """

    future_shift_method: Optional[Union[str, "_models.FutureShiftMethodEnum"]] = rest_field(name="futureShiftMethod")
    """The type of shift method for futures (shift by price or by rate). This parameter impacts on the
     unit of amount in shift scenarios. Price and rate can be converted by the next formula: Rate =
     (100 - Price) / 100. The possible values are:   * ShiftRate: the shift amount is expressed as a
     rate,   * ShiftPrice: the shift amount is expressed as a price. Known values are:
     \"ShiftPrice\" and \"ShiftRate\"."""

    @overload
    def __init__(
        self,
        future_shift_method: Optional[Union[str, "_models.FutureShiftMethodEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["future_shift_method"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class ShiftInterestRateInstrumentsItem(_model_base.Model):
    """ShiftInterestRateInstrumentsItem.

    Attributes
    ----------
    all : ~analyticsapi.models.ShiftDefinition
    deposit : ~analyticsapi.models.ShiftDefinition
    fra : ~analyticsapi.models.ShiftDefinition
    futures : ~analyticsapi.models.ShiftDefinitionFutures
    interest_rate_swap : ~analyticsapi.models.ShiftDefinition
    overnight_index_swap : ~analyticsapi.models.ShiftDefinition
    tenor_basis_swap : ~analyticsapi.models.ShiftDefinition
    """

    all: Optional["_models.ShiftDefinition"] = rest_field()
    deposit: Optional["_models.ShiftDefinition"] = rest_field()
    fra: Optional["_models.ShiftDefinition"] = rest_field()
    futures: Optional["_models.ShiftDefinitionFutures"] = rest_field()
    interest_rate_swap: Optional["_models.ShiftDefinition"] = rest_field(name="interestRateSwap")
    overnight_index_swap: Optional["_models.ShiftDefinition"] = rest_field(name="overnightIndexSwap")
    tenor_basis_swap: Optional["_models.ShiftDefinition"] = rest_field(name="tenorBasisSwap")

    @overload
    def __init__(
        self,
        *,
        all: Optional["_models.ShiftDefinition"] = None,
        deposit: Optional["_models.ShiftDefinition"] = None,
        fra: Optional["_models.ShiftDefinition"] = None,
        futures: Optional["_models.ShiftDefinitionFutures"] = None,
        interest_rate_swap: Optional["_models.ShiftDefinition"] = None,
        overnight_index_swap: Optional["_models.ShiftDefinition"] = None,
        tenor_basis_swap: Optional["_models.ShiftDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ShiftInterestRateInstrumentsPerBasis(_model_base.Model):
    """ShiftInterestRateInstrumentsPerBasis.

    Attributes
    ----------
    shift_interest_rate_instruments_per_basis : ~analyticsapi.models.ShiftInterestRateInstrumentsItem
    """

    shift_interest_rate_instruments_per_basis: Optional["_models.ShiftInterestRateInstrumentsItem"] = rest_field(
        name="shiftInterestRateInstrumentsPerBasis"
    )

    @overload
    def __init__(
        self,
        shift_interest_rate_instruments_per_basis: Optional["_models.ShiftInterestRateInstrumentsItem"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["shift_interest_rate_instruments_per_basis"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class ShiftScenario(_model_base.Model):
    """Contract for all shift scenarios.

    Attributes
    ----------
    par_rate_shift : ~analyticsapi.models.ParRateShift
    shift_tag : str
        User defined string to identify the shift scenario tag. It can be used
        to link output curve to the shift scenario. Only alphabetic, numeric
        and '- _.#=@' characters are supported. Optional.
    zc_curve_shift : dict[str, ~analyticsapi.models.ShiftDefinition]
        Get zcCurveShift.
    """

    par_rate_shift: Optional["_models.ParRateShift"] = rest_field(name="parRateShift")
    shift_tag: Optional[str] = rest_field(name="shiftTag")
    """User defined string to identify the shift scenario tag. It can be used to link output curve to
     the shift scenario. Only alphabetic, numeric and '- _.#=@' characters are supported. Optional."""
    zc_curve_shift: Optional[Dict[str, "_models.ShiftDefinition"]] = rest_field(name="zcCurveShift")
    """Get zcCurveShift."""

    @overload
    def __init__(
        self,
        *,
        par_rate_shift: Optional["_models.ParRateShift"] = None,
        shift_tag: Optional[str] = None,
        zc_curve_shift: Optional[Dict[str, "_models.ShiftDefinition"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ShortEndShift(_model_base.Model):
    """ShortEndShift.

    Attributes
    ----------
    amount : float
        Amount of shifting, applied to points depending on shift method
        selected. Can be measured in basis points/percents/future price based
        points. Also can be expressed as multiplier for relative shift type.
    ignore_quotation_scale : bool
    shift_type : str or ~analyticsapi.models.ShiftTypeEnum
        The type of shifting. The possible values are:   * Additive: the amount
        of shifting is added to the corresponding curve point,   * Relative:
        the curve point is multiplied by the amount of shifting (e.g., if
        amount = 1, the curve point value will be doubled),   * Scaled: the
        curve point is scaled by the value of the shifting amount (e.g., if
        amount = 1.1, the curve point value will multiplied by this value).
        Known values are: "Additive", "Relative", and "Scaled".
    shift_unit : str or ~analyticsapi.models.ShiftUnitEnum
        The unit that describes the amount of shifting. The possible values
        are:   * Absolute: the amount of shifting is expressed in absolute
        value.   * Bp: the amount of shifting is expressed in basis points,   *
        Percent: the amount of shifting is expressed in percentages,. Known
        values are: "Absolute", "Bp", and "Percent".
    """

    amount: Optional[float] = rest_field()
    """Amount of shifting, applied to points depending on shift method selected. Can be measured in
     basis points/percents/future price based points. Also can be expressed as multiplier for
     relative shift type."""
    ignore_quotation_scale: Optional[bool] = rest_field(name="ignoreQuotationScale")
    shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = rest_field(name="shiftType")
    """The type of shifting. The possible values are:   * Additive: the amount of shifting is added to
     the corresponding curve point,   * Relative: the curve point is multiplied by the amount of
     shifting (e.g., if amount = 1, the curve point value will be doubled),   * Scaled: the curve
     point is scaled by the value of the shifting amount (e.g., if amount = 1.1, the curve point
     value will multiplied by this value). Known values are: \"Additive\", \"Relative\", and
     \"Scaled\"."""
    shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = rest_field(name="shiftUnit")
    """The unit that describes the amount of shifting. The possible values are:   * Absolute: the
     amount of shifting is expressed in absolute value.   * Bp: the amount of shifting is expressed
     in basis points,   * Percent: the amount of shifting is expressed in percentages,. Known values
     are: \"Absolute\", \"Bp\", and \"Percent\"."""

    @overload
    def __init__(
        self,
        *,
        amount: Optional[float] = None,
        ignore_quotation_scale: Optional[bool] = None,
        shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = None,
        shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SingleBarrierOtcOptionOverride(_model_base.Model):
    """An object that contains the properties of a single barrier OTC option that can be overridden.

    Attributes
    ----------
    strike : float
        The set price at which the option holder can buy or sell the underlying
        asset. The value is expressed according to the market convention linked
        to the underlying asset.
    end_date : ~analyticsapi.models.Date
        An object that defines the maturity or expiry date of an option
        instrument.
    underlying_code : str
        The code (a RIC) used to define the underlying asset.
    option_type : str or ~analyticsapi.models.CallPutEnum
        An indicator of whether an option instrument is a call or a put. Known
        values are: "Call" and "Put".
    notional_amount : float
        The notional amount of an option instrument.
    level : float
        The price used as a barrier level.
    rebate_amount : ~analyticsapi.models.Amount
        The rebate provided to investors when a barrier option is not able to
        be exercised and becomes worthless.
    """

    strike: Optional[float] = rest_field()
    """The set price at which the option holder can buy or sell the underlying asset. The value is
     expressed according to the market convention linked to the underlying asset."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """An object that defines the maturity or expiry date of an option instrument."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The code (a RIC) used to define the underlying asset."""
    option_type: Optional[Union[str, "_models.CallPutEnum"]] = rest_field(name="optionType")
    """An indicator of whether an option instrument is a call or a put. Known values are: \"Call\" and
     \"Put\"."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of an option instrument."""
    level: Optional[float] = rest_field()
    """The price used as a barrier level."""
    rebate_amount: Optional["_models.Amount"] = rest_field(name="rebateAmount")
    """The rebate provided to investors when a barrier option is not able to be exercised and becomes
     worthless."""

    @overload
    def __init__(
        self,
        *,
        strike: Optional[float] = None,
        end_date: Optional["_models.Date"] = None,
        underlying_code: Optional[str] = None,
        option_type: Optional[Union[str, "_models.CallPutEnum"]] = None,
        notional_amount: Optional[float] = None,
        level: Optional[float] = None,
        rebate_amount: Optional["_models.Amount"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SingleBarrierOtcOptionTemplate(InstrumentTemplateDefinition, discriminator="SingleBarrierOtcOption"):
    """SingleBarrierOtcOptionTemplate.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.SINGLE_BARRIER_OTC_OPTION
        Required. Single Barrier OTC Option contract.
    template : ~analyticsapi.models.OptionDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.SINGLE_BARRIER_OTC_OPTION] = rest_discriminator(name="instrumentType")  # type: ignore
    """Required. Single Barrier OTC Option contract."""
    template: "_models.OptionDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.OptionDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.SINGLE_BARRIER_OTC_OPTION, **kwargs)


class SingleBinaryOtcOptionOverride(_model_base.Model):
    """An object that contains the properties of a single binary OTC option that can be overridden.

    Attributes
    ----------
    strike : float
        The set price at which the option holder can buy or sell the underlying
        asset. The value is expressed according to the market convention linked
        to the underlying asset.
    end_date : ~analyticsapi.models.Date
        An object that defines the maturity or expiry date of an option
        instrument.
    underlying_code : str
        The code (a RIC) used to define the underlying asset.
    option_type : str or ~analyticsapi.models.CallPutEnum
        An indicator of whether an option instrument is a call or a put. Known
        values are: "Call" and "Put".
    notional_amount : float
        The notional amount of an option instrument.
    level : float
        The price used as a binary option level.
    payout_amount : ~analyticsapi.models.Amount
        The payout amount of a binary option.
    payment_type : str or ~analyticsapi.models.PaymentTypeEnum
        The type of a binary option based on when it is paid out. Known values
        are: "Immediate" and "Deferred".
    """

    strike: Optional[float] = rest_field()
    """The set price at which the option holder can buy or sell the underlying asset. The value is
     expressed according to the market convention linked to the underlying asset."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """An object that defines the maturity or expiry date of an option instrument."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The code (a RIC) used to define the underlying asset."""
    option_type: Optional[Union[str, "_models.CallPutEnum"]] = rest_field(name="optionType")
    """An indicator of whether an option instrument is a call or a put. Known values are: \"Call\" and
     \"Put\"."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of an option instrument."""
    level: Optional[float] = rest_field()
    """The price used as a binary option level."""
    payout_amount: Optional["_models.Amount"] = rest_field(name="payoutAmount")
    """The payout amount of a binary option."""
    payment_type: Optional[Union[str, "_models.PaymentTypeEnum"]] = rest_field(name="paymentType")
    """The type of a binary option based on when it is paid out. Known values are: \"Immediate\" and
     \"Deferred\"."""

    @overload
    def __init__(
        self,
        *,
        strike: Optional[float] = None,
        end_date: Optional["_models.Date"] = None,
        underlying_code: Optional[str] = None,
        option_type: Optional[Union[str, "_models.CallPutEnum"]] = None,
        notional_amount: Optional[float] = None,
        level: Optional[float] = None,
        payout_amount: Optional["_models.Amount"] = None,
        payment_type: Optional[Union[str, "_models.PaymentTypeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SingleBinaryOtcOptionTemplate(InstrumentTemplateDefinition, discriminator="SingleBinaryOtcOption"):
    """SingleBinaryOtcOptionTemplate.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.SINGLE_BINARY_OTC_OPTION
        Required. Single Binary OTC Option contract.
    template : ~analyticsapi.models.OptionDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.SINGLE_BINARY_OTC_OPTION] = rest_discriminator(name="instrumentType")  # type: ignore
    """Required. Single Binary OTC Option contract."""
    template: "_models.OptionDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.OptionDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.SINGLE_BINARY_OTC_OPTION, **kwargs)


class SolvingMethod(_model_base.Model):
    """An object that contains properties used to apply the solving method.

    Attributes
    ----------
    name : str or ~analyticsapi.models.SolvingMethodEnum
        The method used to select the variable parameter value. Required. Known
        values are: "BiSection", "Brent", "Secant", and "NewtonRaphson".
    lower_bound : float
        The lower bound of the range of possible values of the variable
        parameter. Not applicable to the 'Secant' method. Required.
    upper_bound : float
        The upper bound of the range of possible values of the variable
        parameter. Not applicable to the 'Secant' method. Required.
    guess : float
        An initial value for the variable parameter used in computation. It is
        applicable to 'Secant' method only.
    """

    name: Union[str, "_models.SolvingMethodEnum"] = rest_field()
    """The method used to select the variable parameter value. Required. Known values are:
     \"BiSection\", \"Brent\", \"Secant\", and \"NewtonRaphson\"."""
    lower_bound: float = rest_field(name="lowerBound")
    """The lower bound of the range of possible values of the variable parameter. Not applicable to
     the 'Secant' method. Required."""
    upper_bound: float = rest_field(name="upperBound")
    """The upper bound of the range of possible values of the variable parameter. Not applicable to
     the 'Secant' method. Required."""
    guess: Optional[float] = rest_field()
    """An initial value for the variable parameter used in computation. It is applicable to 'Secant'
     method only."""

    @overload
    def __init__(
        self,
        *,
        name: Union[str, "_models.SolvingMethodEnum"],
        lower_bound: float,
        upper_bound: float,
        guess: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SolvingResult(_model_base.Model):
    """An object that contains the swap solving result.

    Attributes
    ----------
    result : float
        The solution result for the variable value that gives the set target
        value. Required.
    method : ~analyticsapi.models.SolvingMethod
        An object that contains properties used to apply the solving method.
        Required.
    """

    result: float = rest_field()
    """The solution result for the variable value that gives the set target value. Required."""
    method: "_models.SolvingMethod" = rest_field()
    """An object that contains properties used to apply the solving method. Required."""

    @overload
    def __init__(
        self,
        *,
        result: float,
        method: "_models.SolvingMethod",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Spot(_model_base.Model):
    """An object that describes the spot price of an instrument.

    Attributes
    ----------
    value : float
        The spot price.
    """

    value: Optional[float] = rest_field()
    """The spot price."""

    @overload
    def __init__(
        self,
        value: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["value"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class SqlSettings(_model_base.Model):
    """SqlSettings.

    Attributes
    ----------
    table_name : str
    insert_tran_limit : int
    insert_row_limit : int
    primary_key : list[str]
        The default value is None, needs to be assigned before using.
    create_table : bool
    drop_table : bool
    multi_value_insert_enabled : bool
    default_id : bool
    pk_list_as_string : str
    """

    table_name: Optional[str] = rest_field(name="tableName")
    insert_tran_limit: Optional[int] = rest_field(name="insertTranLimit")
    insert_row_limit: Optional[int] = rest_field(name="insertRowLimit")
    primary_key: Optional[List[str]] = rest_field(name="primaryKey")
    create_table: Optional[bool] = rest_field(name="createTable")
    drop_table: Optional[bool] = rest_field(name="dropTable")
    multi_value_insert_enabled: Optional[bool] = rest_field(name="multiValueInsertEnabled")
    default_id: Optional[bool] = rest_field(name="defaultId")
    pk_list_as_string: Optional[str] = rest_field(name="pkListAsString")

    @overload
    def __init__(
        self,
        *,
        table_name: Optional[str] = None,
        insert_tran_limit: Optional[int] = None,
        insert_row_limit: Optional[int] = None,
        primary_key: Optional[List[str]] = None,
        create_table: Optional[bool] = None,
        drop_table: Optional[bool] = None,
        multi_value_insert_enabled: Optional[bool] = None,
        default_id: Optional[bool] = None,
        pk_list_as_string: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StateHomePriceAppreciation(_model_base.Model):
    """StateHomePriceAppreciation.

    Attributes
    ----------
    hpa_state : str
        Is one of the following types: Literal["AL"], Literal["AK"],
        Literal["AZ"], Literal["AR"], Literal["CA"], Literal["CO"],
        Literal["CT"], Literal["DE"], Literal["FL"], Literal["GA"],
        Literal["HI"], Literal["ID"], Literal["IL"], Literal["IN"],
        Literal["IA"], Literal["KS"], Literal["KY"], Literal["LA"],
        Literal["ME"], Literal["MD"], Literal["MA"], Literal["MI"],
        Literal["MN"], Literal["MS"], Literal["MO"], Literal["MT"],
        Literal["NE"], Literal["NV"], Literal["NH"], Literal["NJ"],
        Literal["NM"], Literal["NY"], Literal["NC"], Literal["ND"],
        Literal["OH"], Literal["OK"], Literal["OR"], Literal["PA"],
        Literal["RI"], Literal["SC"], Literal["SD"], Literal["TN"],
        Literal["TX"], Literal["UT"], Literal["VT"], Literal["VA"],
        Literal["WA"], Literal["WV"], Literal["WI"], Literal["WY"]
    home_price_appreciation : ~analyticsapi.models.InterpolationTypeAndVector
    """

    hpa_state: Optional[
        Literal[
            "AL",
            "AK",
            "AZ",
            "AR",
            "CA",
            "CO",
            "CT",
            "DE",
            "FL",
            "GA",
            "HI",
            "ID",
            "IL",
            "IN",
            "IA",
            "KS",
            "KY",
            "LA",
            "ME",
            "MD",
            "MA",
            "MI",
            "MN",
            "MS",
            "MO",
            "MT",
            "NE",
            "NV",
            "NH",
            "NJ",
            "NM",
            "NY",
            "NC",
            "ND",
            "OH",
            "OK",
            "OR",
            "PA",
            "RI",
            "SC",
            "SD",
            "TN",
            "TX",
            "UT",
            "VT",
            "VA",
            "WA",
            "WV",
            "WI",
            "WY",
        ]
    ] = rest_field(name="hpaState")
    """Is one of the following types: Literal[\"AL\"], Literal[\"AK\"], Literal[\"AZ\"],
     Literal[\"AR\"], Literal[\"CA\"], Literal[\"CO\"], Literal[\"CT\"], Literal[\"DE\"],
     Literal[\"FL\"], Literal[\"GA\"], Literal[\"HI\"], Literal[\"ID\"], Literal[\"IL\"],
     Literal[\"IN\"], Literal[\"IA\"], Literal[\"KS\"], Literal[\"KY\"], Literal[\"LA\"],
     Literal[\"ME\"], Literal[\"MD\"], Literal[\"MA\"], Literal[\"MI\"], Literal[\"MN\"],
     Literal[\"MS\"], Literal[\"MO\"], Literal[\"MT\"], Literal[\"NE\"], Literal[\"NV\"],
     Literal[\"NH\"], Literal[\"NJ\"], Literal[\"NM\"], Literal[\"NY\"], Literal[\"NC\"],
     Literal[\"ND\"], Literal[\"OH\"], Literal[\"OK\"], Literal[\"OR\"], Literal[\"PA\"],
     Literal[\"RI\"], Literal[\"SC\"], Literal[\"SD\"], Literal[\"TN\"], Literal[\"TX\"],
     Literal[\"UT\"], Literal[\"VT\"], Literal[\"VA\"], Literal[\"WA\"], Literal[\"WV\"],
     Literal[\"WI\"], Literal[\"WY\"]"""
    home_price_appreciation: Optional["_models.InterpolationTypeAndVector"] = rest_field(name="homePriceAppreciation")

    @overload
    def __init__(
        self,
        *,
        hpa_state: Optional[
            Literal[
                "AL",
                "AK",
                "AZ",
                "AR",
                "CA",
                "CO",
                "CT",
                "DE",
                "FL",
                "GA",
                "HI",
                "ID",
                "IL",
                "IN",
                "IA",
                "KS",
                "KY",
                "LA",
                "ME",
                "MD",
                "MA",
                "MI",
                "MN",
                "MS",
                "MO",
                "MT",
                "NE",
                "NV",
                "NH",
                "NJ",
                "NM",
                "NY",
                "NC",
                "ND",
                "OH",
                "OK",
                "OR",
                "PA",
                "RI",
                "SC",
                "SD",
                "TN",
                "TX",
                "UT",
                "VT",
                "VA",
                "WA",
                "WV",
                "WI",
                "WY",
            ]
        ] = None,
        home_price_appreciation: Optional["_models.InterpolationTypeAndVector"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Step(_model_base.Model):
    """Step.

    Attributes
    ----------
    effective_date : ~datetime.date
        The effective date of the rate step. The value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., '2021-01-01').
    meeting_date : ~datetime.date
        The meeting date of the rate step (optional, can be set only for EUR).
        The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01').
    """

    effective_date: Optional[datetime.date] = rest_field(name="effectiveDate")
    """The effective date of the rate step. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., '2021-01-01')."""
    meeting_date: Optional[datetime.date] = rest_field(name="meetingDate")
    """The meeting date of the rate step (optional, can be set only for EUR). The value is expressed
     in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""

    @overload
    def __init__(
        self,
        *,
        effective_date: Optional[datetime.date] = None,
        meeting_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StepCurvePoint(_model_base.Model):
    """StepCurvePoint.

    Attributes
    ----------
    constant_forward_rate_percent : float
        The constant forward rate percent of the zero coupon curve computed for
        the given curve point.
    end_date : ~datetime.date
        The date used to define the end date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    is_custom_step : bool
    start_date : ~datetime.date
        The date used to define the start date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    tenor : str
        The code indicating the period between startDate and endDate of the
        zero coupon curve (e.g., '1M', '6M', '4Y').
    """

    constant_forward_rate_percent: Optional[float] = rest_field(name="constantForwardRatePercent")
    """The constant forward rate percent of the zero coupon curve computed for the given curve point."""
    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date used to define the end date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    is_custom_step: Optional[bool] = rest_field(name="isCustomStep")
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The date used to define the start date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between startDate and endDate of the zero coupon curve (e.g.,
     '1M', '6M', '4Y')."""

    @overload
    def __init__(
        self,
        *,
        constant_forward_rate_percent: Optional[float] = None,
        end_date: Optional[datetime.date] = None,
        is_custom_step: Optional[bool] = None,
        start_date: Optional[datetime.date] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StepRateDefinition(InterestRateDefinition, discriminator="StepRate"):
    """An object that defines a stepped rate.

    Attributes
    ----------
    interest_rate_type : str or ~analyticsapi.models.STEP_RATE
        The type of interest rate that is defined as a stepped rate. Required.
        A variable (step) interest rate schedule.
    schedule : list[~analyticsapi.models.DatedRate]
        An array of objects that represens the sequence of fixed rates.
        Required.  The default value is None, needs to be assigned before
        using.
    """

    interest_rate_type: Literal[InterestRateTypeEnum.STEP_RATE] = rest_discriminator(name="interestRateType")  # type: ignore # pylint: disable=line-too-long
    """The type of interest rate that is defined as a stepped rate. Required. A variable (step)
     interest rate schedule."""
    schedule: List["_models.DatedRate"] = rest_field()
    """An array of objects that represens the sequence of fixed rates. Required."""

    @overload
    def __init__(
        self,
        schedule: List["_models.DatedRate"],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, interest_rate_type=InterestRateTypeEnum.STEP_RATE, **kwargs)


class StirFutureConstituent(IrConstituent, discriminator="StirFuture"):
    """StirFutureConstituent.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    index : str
        This is the reference Index of the curve that the constituent
        contributes to. For instance (e.g. LIBOR 3M). Required.
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
        Required.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.STIR_FUTURE
        Required.
    definition : ~analyticsapi.models.StirFutureConstituentDefinition
        Required.
    """

    type: Literal[IrConstituentEnum.STIR_FUTURE] = rest_discriminator(name="type")  # type: ignore
    """Required."""
    definition: "_models.StirFutureConstituentDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        *,
        index: str,
        quote: "_models.Quote",
        definition: "_models.StirFutureConstituentDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=IrConstituentEnum.STIR_FUTURE, **kwargs)


class StirFutureConstituentDefinition(_model_base.Model):
    """The definition of a short-term interest rate futures instrument used as a constituent of an
    interest rate curve.

    Attributes
    ----------
    quotation_mode : str or ~analyticsapi.models.FuturesQuotationMode
        An object defining how the future contract is quoted by the exchange.
        Known values are: "ZeroCoupon" and "ParYield".
    continuous_code : str
        A code representing the position of the contract in the future series.
        The position is expressed as a number of periods (M1, M2, Q1, Q2..)
        from the current contract, M1 (resp. Q1) representing the current
        monthly (resp. quarterly) contract. Required.
    template : str
        A pre-defined template can be used as an input by the user.
    """

    quotation_mode: Optional[Union[str, "_models.FuturesQuotationMode"]] = rest_field(name="quotationMode")
    """An object defining how the future contract is quoted by the exchange. Known values are:
     \"ZeroCoupon\" and \"ParYield\"."""
    continuous_code: str = rest_field(name="continuousCode")
    """A code representing the position of the contract in the future series. The position is
     expressed as a number of periods (M1, M2, Q1, Q2..) from the current contract, M1 (resp. Q1)
     representing the current monthly (resp. quarterly) contract. Required."""
    template: Optional[str] = rest_field()
    """A pre-defined template can be used as an input by the user."""

    @overload
    def __init__(
        self,
        *,
        continuous_code: str,
        quotation_mode: Optional[Union[str, "_models.FuturesQuotationMode"]] = None,
        template: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StirFutureDefinition(SingleInterestRatePaymentDefinition):
    """StirFutureDefinition.

    Attributes
    ----------
    notional : ~analyticsapi.models.Amount
        An object that defines the notional amount of the instrument. Required.
    rate : ~analyticsapi.models.InterestRateDefinition
        An object that defines the rate. Required.
    start_date : ~analyticsapi.models.Date
        An object that defines the start date of the interest payment period.
        Required.
    end_date : ~analyticsapi.models.Date
        An object that defines the end date of the interest payment period.
        Required.
    payment_offset : ~analyticsapi.models.OffsetDefinition
        An object that defines how the payment dates are derived from the
        interest period dates.
    settlement_type : str or ~analyticsapi.models.SettlementType
        An indicator that specifies how the payment is settled (e.g.,
        'Physical', 'Cash'). Known values are: "Cash" and "Physical".
    last_trading_date : ~analyticsapi.models.Date
        Required.
    underlying_spot_date : ~analyticsapi.models.Date
        Required.
    """

    last_trading_date: "_models.Date" = rest_field(name="lastTradingDate")
    """Required."""
    underlying_spot_date: "_models.Date" = rest_field(name="underlyingSpotDate")
    """Required."""

    @overload
    def __init__(
        self,
        *,
        notional: "_models.Amount",
        rate: "_models.InterestRateDefinition",
        start_date: "_models.Date",
        end_date: "_models.Date",
        last_trading_date: "_models.Date",
        underlying_spot_date: "_models.Date",
        payment_offset: Optional["_models.OffsetDefinition"] = None,
        settlement_type: Optional[Union[str, "_models.SettlementType"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StirFutureTemplateDefinition(InstrumentTemplateDefinition, discriminator="MoneyMarketFuture"):
    """StirFutureTemplateDefinition.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.MONEY_MARKET_FUTURE
        Required. A future contract on short term interest rate.
    template : ~analyticsapi.models.StirFutureDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.MONEY_MARKET_FUTURE] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. A future contract on short term interest rate."""
    template: "_models.StirFutureDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.StirFutureDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.MONEY_MARKET_FUTURE, **kwargs)


class StrikeFilter(_model_base.Model):
    """The parameters needed to define the strike filter.

    Attributes
    ----------
    max_of_median_implied_vol : float
        Remove strikes whose implied vol is more than
        MaxOfMedianImpliedVolPercent x Median implied Vol.
    min_of_median_implied_vol : float
        Remove strikes whose implied vol is less than
        MinOfMedianImpliedVolPercent x Median implied Vol.
    """

    max_of_median_implied_vol: Optional[float] = rest_field(name="maxOfMedianImpliedVol")
    """Remove strikes whose implied vol is more than MaxOfMedianImpliedVolPercent x Median implied
     Vol."""
    min_of_median_implied_vol: Optional[float] = rest_field(name="minOfMedianImpliedVol")
    """Remove strikes whose implied vol is less than MinOfMedianImpliedVolPercent x Median implied
     Vol."""

    @overload
    def __init__(
        self,
        *,
        max_of_median_implied_vol: Optional[float] = None,
        min_of_median_implied_vol: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StrikeFilterRange(_model_base.Model):
    """The parameters needed to define the strike filter.

    Attributes
    ----------
    max_of_median_implied_vol_percent : float
        Remove strikes whose implied vol is more than
        MaxOfMedianImpliedVolPercent x Median implied Vol.
    min_of_median_implied_vol_percent : float
        Remove strikes whose implied vol is less than
        MinOfMedianImpliedVolPercent x Median implied Vol.
    """

    max_of_median_implied_vol_percent: Optional[float] = rest_field(name="maxOfMedianImpliedVolPercent")
    """Remove strikes whose implied vol is more than MaxOfMedianImpliedVolPercent x Median implied
     Vol."""
    min_of_median_implied_vol_percent: Optional[float] = rest_field(name="minOfMedianImpliedVolPercent")
    """Remove strikes whose implied vol is less than MinOfMedianImpliedVolPercent x Median implied
     Vol."""

    @overload
    def __init__(
        self,
        *,
        max_of_median_implied_vol_percent: Optional[float] = None,
        min_of_median_implied_vol_percent: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StructuredProductsAnalyticsResponseData(_model_base.Model):
    """StructuredProductsAnalyticsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.StructuredProductsDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.StructuredProductsPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.StructuredProductsAnalyticsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketDataQps
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.StructuredProductsDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.StructuredProductsPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.StructuredProductsAnalyticsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketDataQps"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.StructuredProductsDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.StructuredProductsPricingParameters"] = None,
        analytics: Optional[List["_models.StructuredProductsAnalyticsResponseWithError"]] = None,
        market_data: Optional["_models.MarketDataQps"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StructuredProductsAnalyticsResponseWithError(_model_base.Model):  # pylint: disable=name-too-long
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    tabular_data : ~analyticsapi.models.FinancialContractResponse
        Standard Financial Contract Analytics in tabular format.
    cashflows : ~analyticsapi.models.StructuredProductsCashflows
        Response categorized under Cashflows.
    description : ~analyticsapi.models.StructuredProductsDescription
        Response categorized under Description.
    greeks : ~analyticsapi.models.StructuredProductsGreeks
        Response categorized under Greeks.
    pricing_analysis : ~analyticsapi.models.StructuredProductsPricingAnalysis
        Response categorized under Pricing analysis.
    valuation : ~analyticsapi.models.StructuredProductsValuation
        Response categorized under Valuation.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    tabular_data: Optional["_models.FinancialContractResponse"] = rest_field(name="tabularData")
    """Standard Financial Contract Analytics in tabular format."""
    cashflows: Optional["_models.StructuredProductsCashflows"] = rest_field()
    """Response categorized under Cashflows."""
    description: Optional["_models.StructuredProductsDescription"] = rest_field()
    """Response categorized under Description."""
    greeks: Optional["_models.StructuredProductsGreeks"] = rest_field()
    """Response categorized under Greeks."""
    pricing_analysis: Optional["_models.StructuredProductsPricingAnalysis"] = rest_field(name="pricingAnalysis")
    """Response categorized under Pricing analysis."""
    valuation: Optional["_models.StructuredProductsValuation"] = rest_field()
    """Response categorized under Valuation."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        tabular_data: Optional["_models.FinancialContractResponse"] = None,
        cashflows: Optional["_models.StructuredProductsCashflows"] = None,
        description: Optional["_models.StructuredProductsDescription"] = None,
        greeks: Optional["_models.StructuredProductsGreeks"] = None,
        pricing_analysis: Optional["_models.StructuredProductsPricingAnalysis"] = None,
        valuation: Optional["_models.StructuredProductsValuation"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StructuredProductsCalculationResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.StructuredProductsAnalyticsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.StructuredProductsAnalyticsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.StructuredProductsAnalyticsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class StructuredProductsCashflows(_model_base.Model):
    """Cashflows Object.

    Attributes
    ----------
    cash_flows : list[any]
        The information on the contract's cash flows during its lifetime. It
        consists of the following properties:

        * legTag: the leg information,
        * instrumentType: the instrument type for which cash flows are computed,
        * payments: the array of properties which define all instruments cash flows (paid and received)
        during its lifetime.

        For more details, please refer here.  The default value is None, needs to be assigned before
        using.
    """

    cash_flows: Optional[List[Any]] = rest_field(name="cashFlows")
    """The information on the contract's cash flows during its lifetime. It consists of the following
     properties:
     
     
     * legTag: the leg information,
     * instrumentType: the instrument type for which cash flows are computed,
     * payments: the array of properties which define all instruments cash flows (paid and received)
     during its lifetime.
     
     For more details, please refer here."""

    @overload
    def __init__(
        self,
        cash_flows: Optional[List[Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["cash_flows"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class StructuredProductsDefinition(_model_base.Model):
    """StructuredProductsDefinition.

    Attributes
    ----------
    deal_ccy : str
    inputs : list[~analyticsapi.models.NameTypeValue]
        The default value is None, needs to be assigned before using.
    instrument_tag : str
    payoff_description : list[list[str]]
        The default value is None, needs to be assigned before using.
    """

    deal_ccy: Optional[str] = rest_field(name="dealCcy")
    inputs: Optional[List["_models.NameTypeValue"]] = rest_field()
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    payoff_description: Optional[List[List[str]]] = rest_field(name="payoffDescription")

    @overload
    def __init__(
        self,
        *,
        deal_ccy: Optional[str] = None,
        inputs: Optional[List["_models.NameTypeValue"]] = None,
        instrument_tag: Optional[str] = None,
        payoff_description: Optional[List[List[str]]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StructuredProductsDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.StructuredProductsDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.StructuredProductsDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.StructuredProductsDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StructuredProductsDescription(_model_base.Model):
    """Description Object.

    Attributes
    ----------
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    deal_ccy : str
        The currency code which depending on the instrument represents:

        * for FX instruments: the deal (base) currency,
        * for Swap: the currency of the paid leg,
        * for other instruments: the currency of the instrument's notional amount.

        The value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
    report_ccy : str
        The currency code set for the fields ending with '  xxxInReportCcy  '.
        The value is expressed in ISO 4217 alphabetical format (e.g., '  USD
        ').
    discount_curve_id : str
        The identifier of the zero-coupon curve used to discount the
        instrument's future payments.
    discount_curve_name : str
        The name of the zero-coupon curve used to discount the instrument's
        cash flows. Specifying data for this curve can be set using the market
        data section. By default, the discount curve is found from the
        instrument's currency and frequency.
    inputs : list[any]
        The list of input properties that define variables and their associated
        values to be used in payoffDescription. For a detailed breakdown,
        please refer here.  The default value is None, needs to be assigned
        before using.
    payoff_description : list[list[str]]
        The list of string arrays that describes the instrument payoff.  The
        default value is None, needs to be assigned before using.
    output_list : any
        The total present value of future cash flow payments coming from each
        payoff input parameter defined in  payoffDescription  .
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    error_message : str
        The error message in case of a blocking error in calculation.
    error_code : str
        The code of  ErrorMessage.
    """

    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    deal_ccy: Optional[str] = rest_field(name="dealCcy")
    """The currency code which depending on the instrument represents:
     
     
     * for FX instruments: the deal (base) currency,
     * for Swap: the currency of the paid leg,
     * for other instruments: the currency of the instrument's notional amount.
     
     The value is expressed in ISO 4217 alphabetical format (e.g., 'USD')."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with '  xxxInReportCcy  '. The value is expressed
     in ISO 4217 alphabetical format (e.g., '  USD  ')."""
    discount_curve_id: Optional[str] = rest_field(name="discountCurveId")
    """The identifier of the zero-coupon curve used to discount the instrument's future payments."""
    discount_curve_name: Optional[str] = rest_field(name="discountCurveName")
    """The name of the zero-coupon curve used to discount the instrument's cash flows. Specifying data
     for this curve can be set using the market data section. By default, the discount curve is
     found from the instrument's currency and frequency."""
    inputs: Optional[List[Any]] = rest_field()
    """The list of input properties that define variables and their associated values to be used in
     payoffDescription.
     For a detailed breakdown, please refer here."""
    payoff_description: Optional[List[List[str]]] = rest_field(name="payoffDescription")
    """The list of string arrays that describes the instrument payoff."""
    output_list: Optional[Any] = rest_field(name="outputList")
    """The total present value of future cash flow payments coming from each payoff input parameter
     defined in  payoffDescription  ."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""
    error_message: Optional[str] = rest_field(name="errorMessage")
    """The error message in case of a blocking error in calculation."""
    error_code: Optional[str] = rest_field(name="errorCode")
    """The code of  ErrorMessage."""

    @overload
    def __init__(
        self,
        *,
        instrument_tag: Optional[str] = None,
        deal_ccy: Optional[str] = None,
        report_ccy: Optional[str] = None,
        discount_curve_id: Optional[str] = None,
        discount_curve_name: Optional[str] = None,
        inputs: Optional[List[Any]] = None,
        payoff_description: Optional[List[List[str]]] = None,
        output_list: Optional[Any] = None,
        processing_information: Optional[str] = None,
        error_message: Optional[str] = None,
        error_code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StructuredProductsGreeks(_model_base.Model):
    """Greeks Object.

    Attributes
    ----------
    delta_amount_in_deal_ccy : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in the deal currency.
    delta_amount_in_report_ccy : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in the reporting currency.
    gamma_amount_in_deal_ccy : float
        The change in the option's delta or DV01 per a one-unit change in the
        price of the underlying asset, or 1 unit parallel shift in the curve
        representing the instrument. The value is expressed in the deal
        currency.
    gamma_amount_in_report_ccy : float
        The change in the option's delta or DV01 per a one-unit change in the
        price of the underlying asset, or 1 unit parallel shift in the curve
        representing the instrument. The value is expressed in the reporting
        currency.
    vega_amount_in_deal_ccy : float
        The change in the instrument's price per 1% change in the implied
        volatility of the underlying asset. The value is expressed in the deal
        currency.
    vega_amount_in_report_ccy : float
        The change in the instrument's price per 1% change in the implied
        volatility of the underlying asset. The value is expressed in the
        reporting currency.
    theta_amount_in_deal_ccy : float
        The change in the instrument's price or market value caused by a one-
        day decrease in its time to expiration. The value is expressed in the
        deal currency.
    theta_amount_in_report_ccy : float
        The change in the instrument's price or market value caused by a one-
        day decrease in its time to expiration. The value is expressed in the
        reporting currency.
    """

    delta_amount_in_deal_ccy: Optional[float] = rest_field(name="deltaAmountInDealCcy")
    """The change in the instrument's price or market value caused by a one-unit change in the price
     of the underlying asset, or by 1bp change in the swap rate for a swaption, or by 100bp change
     in the outright for FX instruments. The value is expressed in the deal currency."""
    delta_amount_in_report_ccy: Optional[float] = rest_field(name="deltaAmountInReportCcy")
    """The change in the instrument's price or market value caused by a one-unit change in the price
     of the underlying asset, or by 1bp change in the swap rate for a swaption, or by 100bp change
     in the outright for FX instruments. The value is expressed in the reporting currency."""
    gamma_amount_in_deal_ccy: Optional[float] = rest_field(name="gammaAmountInDealCcy")
    """The change in the option's delta or DV01 per a one-unit change in the price of the underlying
     asset, or 1 unit parallel shift in the curve representing the instrument. The value is
     expressed in the deal currency."""
    gamma_amount_in_report_ccy: Optional[float] = rest_field(name="gammaAmountInReportCcy")
    """The change in the option's delta or DV01 per a one-unit change in the price of the underlying
     asset, or 1 unit parallel shift in the curve representing the instrument. The value is
     expressed in the reporting currency."""
    vega_amount_in_deal_ccy: Optional[float] = rest_field(name="vegaAmountInDealCcy")
    """The change in the instrument's price per 1% change in the implied volatility of the underlying
     asset. The value is expressed in the deal currency."""
    vega_amount_in_report_ccy: Optional[float] = rest_field(name="vegaAmountInReportCcy")
    """The change in the instrument's price per 1% change in the implied volatility of the underlying
     asset. The value is expressed in the reporting currency."""
    theta_amount_in_deal_ccy: Optional[float] = rest_field(name="thetaAmountInDealCcy")
    """The change in the instrument's price or market value caused by a one-day decrease in its time
     to expiration. The value is expressed in the deal currency."""
    theta_amount_in_report_ccy: Optional[float] = rest_field(name="thetaAmountInReportCcy")
    """The change in the instrument's price or market value caused by a one-day decrease in its time
     to expiration. The value is expressed in the reporting currency."""

    @overload
    def __init__(
        self,
        *,
        delta_amount_in_deal_ccy: Optional[float] = None,
        delta_amount_in_report_ccy: Optional[float] = None,
        gamma_amount_in_deal_ccy: Optional[float] = None,
        gamma_amount_in_report_ccy: Optional[float] = None,
        vega_amount_in_deal_ccy: Optional[float] = None,
        vega_amount_in_report_ccy: Optional[float] = None,
        theta_amount_in_deal_ccy: Optional[float] = None,
        theta_amount_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StructuredProductsPricingAnalysis(_model_base.Model):
    """Pricing analysis Object.

    Attributes
    ----------
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    """

    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""

    @overload
    def __init__(
        self,
        *,
        valuation_date: Optional[datetime.datetime] = None,
        market_data_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StructuredProductsPricingParameters(_model_base.Model):
    """.. raw:: html

       <inheritdoc cref="T:TR.Qps.Calculators.BL.Common.Model.PricingParameters" />.

    Attributes
    ----------
    force_decreasing_discount_factor : bool
        An indicator of whether the computation of decreasing discount factors
        should be forced during bootstrapping. The possible values are:

        * true: the computation should be forced,
        * false: the computation should not be forced.

        Optional. The default value is 'false'.
    include_cash_flows_at_valuation_date : bool
        An indicator of whether cash-flows payed at the pricing date are taken
        into account. The possible values are:

        * true: cash-flows are taken into account,
        * false: cash-flows are not taken into account.

        Optional. The default value is 'true'.
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).
        Optional. By default, marketDataDate is valuationDate or today.
    models : list[~analyticsapi.models.ModelDefinition]
        The list of models which can be used to price the defined contract.
        Mandatory. No default value applies.  The default value is None, needs
        to be assigned before using.
    numerical_method : ~analyticsapi.models.GenericNumericalMethod
    report_ccy : str
        The currency code set for the fields ending with 'xxxInReportCcy'. The
        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
        Optional. No default value applies.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    """

    force_decreasing_discount_factor: Optional[bool] = rest_field(name="forceDecreasingDiscountFactor")
    """An indicator of whether the computation of decreasing discount factors should be forced during
     bootstrapping. The possible values are:
     
     
     * true: the computation should be forced,
     * false: the computation should not be forced.
     
     Optional. The default value is 'false'."""
    include_cash_flows_at_valuation_date: Optional[bool] = rest_field(name="includeCashFlowsAtValuationDate")
    """An indicator of whether cash-flows payed at the pricing date are taken into account. The
     possible values are:
     
     
     * true: cash-flows are taken into account,
     * false: cash-flows are not taken into account.
     
     Optional. The default value is 'true'."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It should be less or equal to
     valuationDate).
     Optional. By default, marketDataDate is valuationDate or today."""
    models: Optional[List["_models.ModelDefinition"]] = rest_field()
    """The list of models which can be used to price the defined contract.
     Mandatory. No default value applies."""
    numerical_method: Optional["_models.GenericNumericalMethod"] = rest_field(name="numericalMethod")
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with 'xxxInReportCcy'. The value is expressed in
     ISO 4217 alphabetical format (e.g., 'USD').
     Optional. No default value applies."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""

    @overload
    def __init__(
        self,
        *,
        force_decreasing_discount_factor: Optional[bool] = None,
        include_cash_flows_at_valuation_date: Optional[bool] = None,
        market_data_date: Optional[datetime.datetime] = None,
        models: Optional[List["_models.ModelDefinition"]] = None,
        numerical_method: Optional["_models.GenericNumericalMethod"] = None,
        report_ccy: Optional[str] = None,
        valuation_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StructuredProductsValuation(_model_base.Model):
    """Valuation Object.

    Attributes
    ----------
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency.
    market_value_in_report_ccy : float
        The market value of the instrument. The value is expressed in the
        reporting currency.
    """

    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value of the instrument. The value is expressed in the reporting currency."""

    @overload
    def __init__(
        self,
        *,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StructureNote(_model_base.Model):
    """StructureNote.

    Attributes
    ----------
    pricing : str
        Additional settings for Structured Notes. Is either a
        Literal["DISCOUNTING"] type or a Literal["ASSETSWAP"] type.
    callable_zero_pricing : str
        Is one of the following types: Literal["NETPROCEED"],
        Literal["ACCRETING"], Literal["DYNAMIC"]
    """

    pricing: Optional[Literal["DISCOUNTING", "ASSETSWAP"]] = rest_field()
    """Additional settings for Structured Notes. Is either a Literal[\"DISCOUNTING\"] type or a
     Literal[\"ASSETSWAP\"] type."""
    callable_zero_pricing: Optional[Literal["NETPROCEED", "ACCRETING", "DYNAMIC"]] = rest_field(
        name="callableZeroPricing"
    )
    """Is one of the following types: Literal[\"NETPROCEED\"], Literal[\"ACCRETING\"],
     Literal[\"DYNAMIC\"]"""

    @overload
    def __init__(
        self,
        *,
        pricing: Optional[Literal["DISCOUNTING", "ASSETSWAP"]] = None,
        callable_zero_pricing: Optional[Literal["NETPROCEED", "ACCRETING", "DYNAMIC"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StubBasisInterestRateCurveInstrumentDescription(_model_base.Model):  # pylint: disable=name-too-long
    """StubBasisInterestRateCurveInstrumentDescription.

    Attributes
    ----------
    basis : list[str]
        Get basis.  The default value is None, needs to be assigned before
        using.
    fields : ~analyticsapi.models.BidAskFieldsDescription
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterDescription]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.SyntheticInstrumentDefinition
    stub_basis : list[str]
        The basis tenors to which the stub applies.  The default value is None,
        needs to be assigned before using.
    """

    basis: Optional[List[str]] = rest_field()
    """Get basis."""
    fields: Optional["_models.BidAskFieldsDescription"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.SyntheticInstrumentDefinition"] = rest_field(name="instrumentDefinition")
    stub_basis: Optional[List[str]] = rest_field(name="stubBasis")
    """The basis tenors to which the stub applies."""

    @overload
    def __init__(
        self,
        *,
        basis: Optional[List[str]] = None,
        fields: Optional["_models.BidAskFieldsDescription"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterDescription"]] = None,
        instrument_definition: Optional["_models.SyntheticInstrumentDefinition"] = None,
        stub_basis: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StubBasisInterestRateInstrument(_model_base.Model):
    """StubBasisInterestRateInstrument.

    Attributes
    ----------
    basis : list[str]
        The code indicating the rate surface slice for which the instrument is
        used. If no basis defined, the instrument could be used for all slices.
        The default value is None, needs to be assigned before using.
    fields : ~analyticsapi.models.CurvesAndSurfacesBidAskFields
    formula : str
        The formula used to adjust market data values of the instrument's Bid
        and Ask price side. For example, '100-marketPrice'.
    formula_parameters : list[~analyticsapi.models.FormulaParameter]
        The list of formula parameters used to adjust market data values of the
        instrument's Bid and Ask price side.  The default value is None, needs
        to be assigned before using.
    instrument_definition : ~analyticsapi.models.InstrumentDefinition
    stub_basis : list[str]
        The basis tenors to which the stub applies.  The default value is None,
        needs to be assigned before using.
    """

    basis: Optional[List[str]] = rest_field()
    """The code indicating the rate surface slice for which the instrument is used. If no basis
     defined, the instrument could be used for all slices."""
    fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = rest_field()
    formula: Optional[str] = rest_field()
    """The formula used to adjust market data values of the instrument's Bid and Ask price side. For
     example, '100-marketPrice'."""
    formula_parameters: Optional[List["_models.FormulaParameter"]] = rest_field(name="formulaParameters")
    """The list of formula parameters used to adjust market data values of the instrument's Bid and
     Ask price side."""
    instrument_definition: Optional["_models.InstrumentDefinition"] = rest_field(name="instrumentDefinition")
    stub_basis: Optional[List[str]] = rest_field(name="stubBasis")
    """The basis tenors to which the stub applies."""

    @overload
    def __init__(
        self,
        *,
        basis: Optional[List[str]] = None,
        fields: Optional["_models.CurvesAndSurfacesBidAskFields"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameter"]] = None,
        instrument_definition: Optional["_models.InstrumentDefinition"] = None,
        stub_basis: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StubBasisInterestRateInstrumentOutput(_model_base.Model):
    """StubBasisInterestRateInstrumentOutput.

    Attributes
    ----------
    basis : list[str]
        Get basis.  The default value is None, needs to be assigned before
        using.
    fields : ~analyticsapi.models.BidAskFieldsOutput
    formula : str
        Get formula.
    formula_parameters : list[~analyticsapi.models.FormulaParameterOutput]
        Get formulaParameters.  The default value is None, needs to be assigned
        before using.
    instrument_definition : ~analyticsapi.models.InstrumentDefinitionOutput
    status_message : str
        Get statusMessage.
    stub_basis : list[str]
        The basis tenors to which the stub applies.  The default value is None,
        needs to be assigned before using.
    """

    basis: Optional[List[str]] = rest_field()
    """Get basis."""
    fields: Optional["_models.BidAskFieldsOutput"] = rest_field()
    formula: Optional[str] = rest_field()
    """Get formula."""
    formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = rest_field(name="formulaParameters")
    """Get formulaParameters."""
    instrument_definition: Optional["_models.InstrumentDefinitionOutput"] = rest_field(name="instrumentDefinition")
    status_message: Optional[str] = rest_field(name="statusMessage")
    """Get statusMessage."""
    stub_basis: Optional[List[str]] = rest_field(name="stubBasis")
    """The basis tenors to which the stub applies."""

    @overload
    def __init__(
        self,
        *,
        basis: Optional[List[str]] = None,
        fields: Optional["_models.BidAskFieldsOutput"] = None,
        formula: Optional[str] = None,
        formula_parameters: Optional[List["_models.FormulaParameterOutput"]] = None,
        instrument_definition: Optional["_models.InstrumentDefinitionOutput"] = None,
        status_message: Optional[str] = None,
        stub_basis: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StubIndexReferences(_model_base.Model):
    """An object that defines how the reference rate of a stub period is calculated.

    Attributes
    ----------
    first : str
        The identifier of the first floating rate index definition used to
        determine the reference rate of the stub period (GUID or URI). Note
        that a URI must be at least 2 and at most 102 characters long, start
        with an alphanumeric character, and contain only alphanumeric
        characters, slashes and underscores.
    second : str
        The identifier of the second floating rate index definition used to
        determine the reference rate of the stub period (GUID or URI). Note
        that a URI must be at least 2 and at most 102 characters long, start
        with an alphanumeric character, and contain only alphanumeric
        characters, slashes and underscores.
    reference_rate : ~analyticsapi.models.Rate
        An object that defines the reference rate value.
    """

    first: Optional[str] = rest_field()
    """The identifier of the first floating rate index definition used to determine the reference rate
     of the stub period (GUID or URI).
     Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
     character, and contain only alphanumeric characters, slashes and underscores."""
    second: Optional[str] = rest_field()
    """The identifier of the second floating rate index definition used to determine the reference
     rate of the stub period (GUID or URI).
     Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
     character, and contain only alphanumeric characters, slashes and underscores."""
    reference_rate: Optional["_models.Rate"] = rest_field(name="referenceRate")
    """An object that defines the reference rate value."""

    @overload
    def __init__(
        self,
        *,
        first: Optional[str] = None,
        second: Optional[str] = None,
        reference_rate: Optional["_models.Rate"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class StubRateCalculationParameters(_model_base.Model):
    """Parameters to customize stub rate calculation for floating legs
    Case #1 : Linearly interpolate between two forward rates calculated with zero-coupon curves
    related two given tenors
    Case #2 : Override the stub fixing value.

    Attributes
    ----------
    first_tenor : str
        First tenor used for linear interpolation.
    fixing_in_percent : float
        Fixing value in percent.
    second_tenor : str
        Second tenor used for linear interpolation.
    """

    first_tenor: Optional[str] = rest_field(name="firstTenor")
    """First tenor used for linear interpolation."""
    fixing_in_percent: Optional[float] = rest_field(name="fixingInPercent")
    """Fixing value in percent."""
    second_tenor: Optional[str] = rest_field(name="secondTenor")
    """Second tenor used for linear interpolation."""

    @overload
    def __init__(
        self,
        *,
        first_tenor: Optional[str] = None,
        fixing_in_percent: Optional[float] = None,
        second_tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Summary(_model_base.Model):
    """Summary.

    Attributes
    ----------
    total : int
    excluded : int
    accepted : int
    rejected : int
    """

    total: Optional[int] = rest_field()
    excluded: Optional[int] = rest_field()
    accepted: Optional[int] = rest_field()
    rejected: Optional[int] = rest_field()

    @overload
    def __init__(
        self,
        *,
        total: Optional[int] = None,
        excluded: Optional[int] = None,
        accepted: Optional[int] = None,
        rejected: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SurfaceFilters(_model_base.Model):
    """The parameters needed for filtering the vol.

    Attributes
    ----------
    atm_tolerance_interval_percent : float
        Filter on the ATM tolerance interval percent.
    ensure_prices_monotonicity : bool
        Filter on the monotonicity of price options.
    include_min_tick_prices : bool
        Take into account the minimum tick prices to build the surface.
    maturity_filter_range : ~analyticsapi.models.MaturityFilter
    max_of_median_bid_ask_spread : float
        Spread mutltiplier to filter the options with the same expiry.
    max_staleness_days : int
        Max Staleness past days to use for building the surface.
    strike_range : ~analyticsapi.models.StrikeFilterRange
    strike_range_percent : ~analyticsapi.models.StrikeFilter
    use_only_calls : bool
        SElect only teh calls to build the surface.
    use_only_puts : bool
        Select only the puts to build the surface.
    use_weekly_options : bool
        Filter on the weekly options.
    """

    atm_tolerance_interval_percent: Optional[float] = rest_field(name="atmToleranceIntervalPercent")
    """Filter on the ATM tolerance interval percent."""
    ensure_prices_monotonicity: Optional[bool] = rest_field(name="ensurePricesMonotonicity")
    """Filter on the monotonicity of price options."""
    include_min_tick_prices: Optional[bool] = rest_field(name="includeMinTickPrices")
    """Take into account the minimum tick prices to build the surface."""
    maturity_filter_range: Optional["_models.MaturityFilter"] = rest_field(name="maturityFilterRange")
    max_of_median_bid_ask_spread: Optional[float] = rest_field(name="maxOfMedianBidAskSpread")
    """Spread mutltiplier to filter the options with the same expiry."""
    max_staleness_days: Optional[int] = rest_field(name="maxStalenessDays")
    """Max Staleness past days to use for building the surface."""
    strike_range: Optional["_models.StrikeFilterRange"] = rest_field(name="strikeRange")
    strike_range_percent: Optional["_models.StrikeFilter"] = rest_field(name="strikeRangePercent")
    use_only_calls: Optional[bool] = rest_field(name="useOnlyCalls")
    """SElect only teh calls to build the surface."""
    use_only_puts: Optional[bool] = rest_field(name="useOnlyPuts")
    """Select only the puts to build the surface."""
    use_weekly_options: Optional[bool] = rest_field(name="useWeeklyOptions")
    """Filter on the weekly options."""

    @overload
    def __init__(
        self,
        *,
        atm_tolerance_interval_percent: Optional[float] = None,
        ensure_prices_monotonicity: Optional[bool] = None,
        include_min_tick_prices: Optional[bool] = None,
        maturity_filter_range: Optional["_models.MaturityFilter"] = None,
        max_of_median_bid_ask_spread: Optional[float] = None,
        max_staleness_days: Optional[int] = None,
        strike_range: Optional["_models.StrikeFilterRange"] = None,
        strike_range_percent: Optional["_models.StrikeFilter"] = None,
        use_only_calls: Optional[bool] = None,
        use_only_puts: Optional[bool] = None,
        use_weekly_options: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SurfaceOutput(_model_base.Model):
    """SurfaceOutput.

    Attributes
    ----------
    data_points : list[~analyticsapi.models.VolatilitySurfacePoint]
        Specifies the list of specific data points to be returned.  The default
        value is None, needs to be assigned before using.
    format : str or ~analyticsapi.models.FormatEnum
        Specifies whether the calculated volatilities are returned as a list or
        a matrix. Known values are: "List", "Matrix", and "NDimensionalArray".
    x_point_count : int
        Specifies the number of values that will be generated along the x-axis.
        These values will distributed depending on the available input data and
        the type of volatility.
    x_values : list[str]
        Specifies a list of discrete values for the x-axis.  The default value
        is None, needs to be assigned before using.
    y_point_count : int
        Specifies the number of values that will be generated along the y-axis.
        These values will distributed depending on the available input data and
        the type of volatility.
    y_values : list[str]
        Specifies a list of discrete values for the y-axis.  The default value
        is None, needs to be assigned before using.
    z_point_count : int
        Specifies the number of values that will be generated along the z-axis.
        These values will distributed depending on the available input data and
        the type of volatility.
    z_values : list[str]
        Specifies a list of discrete values for the z-axis.  The default value
        is None, needs to be assigned before using.
    """

    data_points: Optional[List["_models.VolatilitySurfacePoint"]] = rest_field(name="dataPoints")
    """Specifies the list of specific data points to be returned."""
    format: Optional[Union[str, "_models.FormatEnum"]] = rest_field()
    """Specifies whether the calculated volatilities are returned as a list or a matrix. Known values
     are: \"List\", \"Matrix\", and \"NDimensionalArray\"."""
    x_point_count: Optional[int] = rest_field(name="xPointCount")
    """Specifies the number of values that will be generated along the x-axis.
     These values will distributed depending on the available input data and the type of volatility."""
    x_values: Optional[List[str]] = rest_field(name="xValues")
    """Specifies a list of discrete values for the x-axis."""
    y_point_count: Optional[int] = rest_field(name="yPointCount")
    """Specifies the number of values that will be generated along the y-axis.
     These values will distributed depending on the available input data and the type of volatility."""
    y_values: Optional[List[str]] = rest_field(name="yValues")
    """Specifies a list of discrete values for the y-axis."""
    z_point_count: Optional[int] = rest_field(name="zPointCount")
    """Specifies the number of values that will be generated along the z-axis.
     These values will distributed depending on the available input data and the type of volatility."""
    z_values: Optional[List[str]] = rest_field(name="zValues")
    """Specifies a list of discrete values for the z-axis."""

    @overload
    def __init__(
        self,
        *,
        data_points: Optional[List["_models.VolatilitySurfacePoint"]] = None,
        format: Optional[Union[str, "_models.FormatEnum"]] = None,
        x_point_count: Optional[int] = None,
        x_values: Optional[List[str]] = None,
        y_point_count: Optional[int] = None,
        y_values: Optional[List[str]] = None,
        z_point_count: Optional[int] = None,
        z_values: Optional[List[str]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwapDefinition(_model_base.Model):
    """This class represent the input of the Interest Rate and Cross Currency Swap contracts.

    Attributes
    ----------
    cancellable_definition : ~analyticsapi.models.CancellableDefinition
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument's leg. The value is
        expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.
        2021-01-01T00:00:00Z). If instrumentCode is not defined, either tenor
        or endDate must be provided. The default value is valuationDate shifted
        forward by tenor.
    instrument_code : str
        The code used to define the instrument. Mandatory, if no user-defined
        instrument data is provided. No default value applies.
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported. No default value applies.
    is_non_deliverable : bool
        An indicator whether the instrument is non-deliverable: True, False.
        The default value is 'False'.
    legs : list[~analyticsapi.models.SwapLegDefinition]
        The input array which defines the instruments legs using the
        SwapLegDefinition list. It is used if no template or instrumentCode
        have been defined. If instrumentCode or template is defined, the value
        comes from the instrument reference data. The default value is None,
        needs to be assigned before using.
    settlement_ccy : str
        The code of the currency, in which the deal is settled. It can be used
        to define the discounting curve for non-deliverable swaps. The value is
        expressed in ISO 4217 alphabetical format (e.g., 'USD'). By default,
        DealCcy is used.
    start_date : ~datetime.datetime
        The start date of the instrument. The value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z). The
        default value is valuationDate shifted forward by a month using market
        conventions.
    start_tenor : str
        The code indicating the period from a spot date to startDate of the
        instrument (e.g. '1M'). No default value applies.
    template : str
        A reference to a style used to define the instrument (e.g. 'USD_AM3L').
        If instrumentCode is not defined, either template or swap leg
        definition must be provided. No default value applies.
    tenor : str
        The code indicating the period between StartDate and EndDate of the
        instrument (e.g. '6M', '1Y'). If instrumentCode is not defined, either
        tenor or endDate must be provided. No default value applies.
    trade_date : ~datetime.datetime
        The date when the instrument is traded. The value is expressed in ISO
        8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
        The default value is valuationDate.
    """

    cancellable_definition: Optional["_models.CancellableDefinition"] = rest_field(name="cancellableDefinition")
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument's leg. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z). If instrumentCode is not defined,
     either tenor or endDate must be provided.
     The default value is valuationDate shifted forward by tenor."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument.
     Mandatory, if no user-defined instrument data is provided.
     No default value applies."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument
     definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@' characters are
     supported.
     No default value applies."""
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    """An indicator whether the instrument is non-deliverable:
     True,
     False.
     The default value is 'False'."""
    legs: Optional[List["_models.SwapLegDefinition"]] = rest_field()
    """The input array which defines the instruments legs using the SwapLegDefinition list. It is
     used if no template or
     instrumentCode have been defined.
     If instrumentCode or template is defined, the value comes from the instrument reference data."""
    settlement_ccy: Optional[str] = rest_field(name="settlementCcy")
    """The code of the currency, in which the deal is settled. It can be used to define the
     discounting curve for non-deliverable swaps.
     The value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
     By default, DealCcy is used."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.
     2021-01-01T00:00:00Z).
     The default value is valuationDate shifted forward by a month using market conventions."""
    start_tenor: Optional[str] = rest_field(name="startTenor")
    """The code indicating the period from a spot date to startDate of the instrument (e.g. '1M').
     No default value applies."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument (e.g. 'USD_AM3L').
     If instrumentCode is not defined, either template or swap leg definition must be provided.
     No default value applies."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between StartDate and EndDate of the instrument (e.g. '6M',
     '1Y').
     If instrumentCode is not defined, either tenor or endDate must be provided.
     No default value applies."""
    trade_date: Optional[datetime.datetime] = rest_field(name="tradeDate", format="rfc3339")
    """The date when the instrument is traded. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.
     2021-01-01T00:00:00Z).
     The default value is valuationDate."""

    @overload
    def __init__(
        self,
        *,
        cancellable_definition: Optional["_models.CancellableDefinition"] = None,
        end_date: Optional[datetime.datetime] = None,
        instrument_code: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        is_non_deliverable: Optional[bool] = None,
        legs: Optional[List["_models.SwapLegDefinition"]] = None,
        settlement_ccy: Optional[str] = None,
        start_date: Optional[datetime.datetime] = None,
        start_tenor: Optional[str] = None,
        template: Optional[str] = None,
        tenor: Optional[str] = None,
        trade_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwapLegDefinition(_model_base.Model):
    """Swap leg definition.

    Attributes
    ----------
    accrued_calculation_method : str or ~analyticsapi.models.AccruedCalculationMethodEnum
        The day count basis method used to calculate the accrued interest
        payments (e.g. Dcb_30_360, Dcb_30_Actual). If instrumentCode is
        defined, the value comes from the instrument reference data. In case of
        a user-defined instrument, interestCalculationMethod is used. Known
        values are: "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German",
        "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
        "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual",
        "Dcb_30_Actual_ISDA", "Dcb_30E_360_ISMA", "Dcb_Actual_360",
        "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
        "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB",
        "Dcb_WorkingDays_252", "Dcb_Actual_365L", "Dcb_Actual_365P",
        "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525",
        "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
    adjust_interest_to_payment_date : str or ~analyticsapi.models.AdjustInterestToPaymentDateEnum
        An indication if the coupon dates are adjusted to the payment dates.
        The possible values are: Adjusted, Unadjusted. If instrumentCode is
        defined, the value comes from the instrument reference data.

        * For Swap: In case of a user-defined instrument, the default value is 'Adjusted'.
        * For Bond and Loan: In case of a user-defined instrument, the default value is 'Unadjusted'.
        Known values are: "Unadjusted" and "Adjusted".
    amortization_schedule : list[~analyticsapi.models.AmortizationItemDefinition]
        The amortization schedule of the instrument. It contains the following
        information: startDate, endDate, remainingNotional,
        amortizationFrequency, amount, amortizationType. Optional. No default
        value applies.  The default value is None, needs to be assigned before
        using.
    cap_strike_percent : float
        The contractual strike rate of the cap. The value is expressed in
        percentages. If this parameter is set, the cap will apply to the leg
        with the same parameters set in the swapLegDefinition (e.g.maturity,
        frequency, index, discounting rule). No default value applies.

        * For Bond and Loan: Not applicable.
    cms_template : str
        A reference to a common swap contract that represents the underlying
        swap in case of a Constant Maturity Swap contract (CMS). Example:
        EUR_AB6E. No default value applies.
    custom_interest_periods : list[~analyticsapi.models.InterestRateScheduleItem]
        The default value is None, needs to be assigned before using.
    direction : str or ~analyticsapi.models.IPADirectionEnum
        The indication whether the cash flows of the instrument's leg are paid
        or received. Mandatory if instrumentCode or template is not defined. If
        instrumentCode or template is defined, the value comes from the
        instrument reference data. The possible values are:

        * For Swap:
          Paid: the cash flows are paid to the counterparty,
          Received: the cash flows are received from the counterparty.
        * For CDS:
          Paid: the fixed payments are paid by the counterparty (applied to the CDS buyer),
          Received: the fixed payments are received from the counterparty (applied to the CDS seller).
        * For Bond and Loan: Not applicable. Known values are: "Paid" and "Received".
    end_stub : ~analyticsapi.models.StubRateCalculationParameters
    first_regular_payment_date : ~datetime.datetime
        The first regular interest payment date used for the odd first interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).

        * For Swap: No default value applies.
        * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
        stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
        instrument reference data.
        * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency.
    fixed_rate_percent : float
        The interest rate used to derive future fixed interest payments of the
        instrument. The value is expressed in percentages. Either
        fixedRatePercent or fixedRatePercentSchedule is used. In Swap, applies
        to fixed leg only. If instrumentCode is defined, the value comes from
        the instrument reference data. In case of a user-defined instrument,
        the default value is '0' for Bond, par rate for Swap and '1' for CDS.
        For Loan: Mandatory for a fixed rate loan. No default value applies.
    floor_strike_percent : float
        The contractual strike rate of the floor. The value is expressed in
        percentages. If this parameter is set, the floor will apply to the leg
        with the same parameters set in the swapLegDefinition (e.g.maturity,
        frequency, index, discounting rule). No default value applies.

        * For Bond and Loan: Not applicable.
    has_cap : bool
        A boolean to determine whether one should use a default cap strike on a
        given floating leg. The value of the default strike is the par swap
        rate.
    has_floor : bool
        A boolean to determine whether one should use a default floor strike on
        a given floating leg. The value of the default strike is the par swap
        rate.
    index_average_method : str or ~analyticsapi.models.IndexAverageMethodEnum
        The method of calculating the average index value. The possible values
        are: CompoundedActual, DailyCompoundedAverage, CompoundedAverageRate,
        ArithmeticAverage The default value depends on the index default
        convention.

        * For Bond and Loan: Not applicable. Known values are: "CompoundedActual",
        "DailyCompoundedAverage", "CompoundedAverageRate", and "ArithmeticAverage".
    index_compounding_method : str or ~analyticsapi.models.IndexCompoundingMethodEnum
        The method how the interest rate is calculated from the reset floating
        rates when the reset frequency is higher than the interest payment
        frequency (e.g. daily index reset with quarterly interest payments).
        The possible values are: Compounded, Average, Constant,
        AdjustedCompounded, MexicanCompounded. Optional.

        * For Bond and Loan: If instrumentCode is defined, the value comes from the instrument
        reference data. In case of a user-defined instrument, the default value is 'Constant'.
        * For Swap: The default value is defined by the market conventions of the index defined for the
        floating leg. Known values are: "Compounded", "AdjustedCompounded", "MexicanCompounded",
        "Average", and "Constant".
    index_fixing_lag : int
        The number of working days between the fixing date of the index and the
        start of the interest accrual period ('InAdvance') or the end of the
        interest accrual period ('InArrears').

        * For Swap: The InAdvance/InArrears mode is set in the indexResetType parameter. The default
        value is the fixing lag associated to the index defined/determined by default on the floating
        leg.
        * For Bond and Loan: In case of a user-defined instrument, the default value is 0. If
        instrumentCode is defined, the value comes from the instrument reference data.
    index_fixing_ric : str
        The RIC that carries the fixing value if the instrument has a floating
        interest.

        * For Swap: Optional. The default value depends on the notional currency.
        * For Bond and Loan: Mandatory for floating rate instruments if no instrumentCode is defined.
        If instrumentCode is defined, the value comes from the instrument reference data.
    index_lockout_period : int
        The period from the start date (inclusive) of the index lockout to the
        end date of the interest calculation period for which the reference
        rate is no longer updated. During this period the index of the day
        preceding the start date of the lockout period is applied to the
        remaining days of the interest period. The value is expressed in
        working days. Please note, that by (ISDA) definition the lockout method
        is applied only to payment periods (with Fixing) and not to future
        periods (with ZcCurve). Optional. The default value is 0.
    index_name : str
        The name of the floating rate index (e.g. 'EURIBOR'). No default value
        applies.
    index_observation_method : str or ~analyticsapi.models.IPAIndexObservationMethodEnum
        (RFR) Method for determining the accrual observation period. The lag is
        defined using the indexFixingLag property. The possible values are:
        Lookback: use the interest period for both rate accrual and interest
        payment. PeriodShift: use the observation period for both rate accrual
        and interest payment. Mixed: use the observation period for rate
        accrual and the interest period for interest payment. Optional. No
        default value applies.

        * For Bond and Loan: Not applicable. Known values are: "Lookback", "PeriodShift", and "Mixed".
    index_price_side : str or ~analyticsapi.models.IndexPriceSideEnum
        The quoted price side of the floating rate index that applies to legs
        or the instrument. The possible values are: Bid, Ask, Mid. This
        property applies only if an index is quoted with a 'Bid'/'Ask' price
        side. The default value is 'Mid'. Known values are: "Mid", "Bid",
        "Ask", and "Last".
    index_reset_frequency : str or ~analyticsapi.models.IndexResetFrequencyEnum
        The reset frequency for the floating instrument (e.g. Annual,
        SemiAnnual).

        * For Swap: The default value is interestPaymentFrequency. For RFR index, the default value is
        EveryWorkingDay.
        * For Bond: If instrumentCode is defined, the value comes from the instrument reference data.
        In case of a user-defined instrument, the default value is derived from the index tenor.
        * For Loan: The default value is interestPaymentFrequency. Known values are: "Annual",
        "SemiAnnual", "Quarterly", "Monthly", "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every91Days", "Every182Days", "Every364Days",
        "Every365Days", "Every90Days", "Every92Days", "Every93Days", "Every180Days", "Every183Days",
        "Every184Days", "Every4Months", "R2", "R4", "Zero", and "Scheduled".
    index_reset_type : str or ~analyticsapi.models.IndexResetTypeEnum
        A type indicating if the floating rate index is reset before the coupon
        period starts or at the end of the coupon period. The possible values
        are: InAdvance: resets the index before the start of the interest
        period, InArrears: resets the index at the end of the interest period.
        The default value is 'InAdvance'. For RFR index, the default value is
        'InArrears'. Known values are: "InAdvance" and "InArrears".
    index_source : str
        The source of the floating rate index (e.g. 'RFTB' or 'IBAL'). The
        default value depends on the notional currency. In case of multiple
        sources for an index 'RFTB' (Refinitiv) is selected.
    index_spread_compounding_method : str or ~analyticsapi.models.IndexSpreadCompoundingMethodEnum
        The method defining how the computed float leg spread is applied to
        compounded rate. It applies only when indexCompoundingMethod=
        Compounded. The possible values are: IsdaCompounding, NoCompounding,
        IsdaFlatCompounding. The default value is 'IsdaCompounding'. Known
        values are: "IsdaCompounding", "NoCompounding", and
        "IsdaFlatCompounding".
    index_tenor : str
        The period code indicating the tenor of the underlying floating rate
        index (e.g., '1M','1Y'). The requested tenor must exist in the
        multicurve environment which is used. The default value is the tenor
        equivalent to indexResetFrequency or interestPaymentFrequency.
    interest_calculation_convention : str or ~analyticsapi.models.InterestCalculationConventionEnum
        The convention applied to calculate the interest payments. The possible
        values are:

        * None,
        * MoneyMarket: money market methods calculate all cash flow based on the actual number of days
        in the payment period,
        * BondBasis: bond methods calculate interest payments proportionally to the payment frequency
        and adjust them if the number of days in the payment period is larger or smaller.

        Optional. If instrumentCode is defined, the value comes from the instrument reference data. In
        case of a user-defined instrument, the default value is 'MoneyMarket'. Known values are:
        "None", "MoneyMarket", and "BondBasis".
    interest_calculation_method : str or ~analyticsapi.models.InterestCalculationMethodEnum
        The day count basis method used to calculate the interest payments(e.g.
        Dcb_30_360, Dcb_30_Actual).

        * For Swap: The default value is selected based on notionalCcy.
        * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
        comes from the instrument reference data.
        * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
        Otherwise, the default value is 'Dcb_Actual_360'.
        * For Loan: Mandatory. No default value applies. Known values are: "Dcb_30_360",
        "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA", "Dcb_30_365_ISDA",
        "Dcb_30_365_German", "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual",
        "Dcb_30_Actual_ISDA", "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364", "Dcb_Actual_365",
        "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252",
        "Dcb_Actual_365L", "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
    interest_payment_delay : int
        The number of working days between the end of the interest accrual
        period and the interest payment date. If instrumentCode is defined, the
        value comes from the instrument reference data. In case of a user-
        defined instrument, the default value is '0'.
    interest_payment_frequency : str or ~analyticsapi.models.InterestPaymentFrequencyEnum
        The interest payment frequency.

        * For Swap: Either indexResetFrequency or InterestPaymentFrequency must be provided (e.g.
        Annual, SemiAnnual). The default value is indexResetFrequency.
        * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
        comes from the instrument reference data.
        * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
        Otherwise, the default value is 'Quaterly'.
        * For Loan: Mandatory. No default value applies. Known values are: "Annual", "SemiAnnual",
        "Quarterly", "Monthly", "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every91Days", "Every182Days", "Every364Days",
        "Every365Days", "Every90Days", "Every92Days", "Every93Days", "Every180Days", "Every183Days",
        "Every184Days", "Every4Months", "R2", "R4", "Zero", and "Scheduled".
    interest_type : str or ~analyticsapi.models.InterestTypeEnum
        An indicator whether the instrument pays a fixed or floating interest.
        The possible values are:

        * Fixed,
        * Float.

        For Swap: No default value applies. Mandatory for SwapLegDefinition.
        For Bond: Optional. If instrumentCode is defined, the value comes from the instrument reference
        data. Otherwise, the default value is 'Fixed'.
        For Loan: Mandatory. No default value applies. Known values are: "Fixed", "Float", and
        "Stepped".
    last_regular_payment_date : ~datetime.datetime
        The last regular interest payment date used for the odd last interest
        period. The value is expressed in ISO 8601 format: YYYY-MM-
        DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).

        * For Swap: No default value applies.
        * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
        stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
        instrument reference data.
        * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency.
    leg_tag : str
        A user-defined string to identify the leg. By default, the value
        specified in the 'direction' property is returned.
    notional_amount : float
        The notional amount of the instrument. Optional. The default value is
        '1,000,000'. For CDS: the amounts for the premium and protection legs
        must be equal.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g. 'USD'). If
        instrumentCode is defined, the value comes from the instrument
        reference data.

        * For Swap: Mandatory for SwapLegDefinition if instrumentCode is not defined.
        * For CDS: Mandatory for protectionLeg definition if instrumentCode is not defined. For
        premiumLeg definition, it is derived from pretctionLeg definition.
        * For Bond and Loan: Mandatory if no instrumentCode is defined.
    notional_exchange : str or ~analyticsapi.models.NotionalExchangeEnum
        An indicator if the notional amount is exchanged and when it is
        exchanged. The possible values are: None, Start, End, Both,
        EndAdjustment. The default value is 'None'. Known values are: "None",
        "Start", "End", "Both", and "EndAdjustment".
    payment_business_day_convention : str or ~analyticsapi.models.PaymentBusinessDayConventionEnum
        The method to adjust dates to working days. The possible values are:
        PreviousBusinessDay, NextBusinessDay, Modified following, NoMoving,
        BBSWModifiedFollowing. If instrumentCode is defined, the value comes
        from the instrument reference data. In case of a user-defined
        instrument, the default value is 'ModifiedFollowing'. Known values are:
        "ModifiedFollowing", "NextBusinessDay", "PreviousBusinessDay",
        "NoMoving", "EveryThirdWednesday", and "BbswModifiedFollowing".
    payment_business_days : str
        A list of comma-separated calendar codes to adjust dates (e.g. 'EMU' or
        'USA').

        * For Swap: The default value is the calendar associated to the market conventions of the
        InterestPaymentCcy for the corresponding leg.
        * For Bond and Loan: The default value is the calendar associated to NotionalCcy.
    payment_roll_convention : str or ~analyticsapi.models.PaymentRollConventionEnum
        The method to adjust payment dates when they fall at the end of the
        month (e.g. 28th of February, 30th, 31st). The possible values are:
        Last, Same, Last28, Same28. If instrumentCode is defined, the value
        comes from the instrument reference data. In case of a user-defined
        instrument, the default value is 'Same'. Known values are: "Last",
        "Same", "Same1", "Last28", and "Same28".
    spread_bp : float
        The spread applied to the floating interest rate of the instrument. The
        value is expressed in basis points. Optional. If instrumentCode is
        defined, the value comes from the instrument reference data. In case of
        a user-defined instrument, the default value is '0'.
    start_stub : ~analyticsapi.models.StubRateCalculationParameters
    stub_rule : str or ~analyticsapi.models.FinancialContractStubRuleEnum
        The rule that defines whether coupon roll dates are aligned to the
        maturity or issue date. The possible values are: Issue, Maturity,
        ShortFirstProRata, ShortFirstFull, LongFirstFull, ShortLastProRata. If
        instrumentCode is defined, the value comes from the instrument
        reference data. In case of a user-defined instrument, the default value
        is 'Maturity'. Known values are: "Issue", "Maturity",
        "ShortFirstProRata", "ShortFirstFull", "LongFirstFull", and
        "ShortLastProRata".
    upfront_amount : float
        The amount which represents the net present value of the swap. It is
        computed as [(100  DirtyPricePercent / 100) x NotionalAmount]. The
        value is expressed in upfrontAmountCcy. By default, no payment (0)
        applies.
    """

    accrued_calculation_method: Optional[Union[str, "_models.AccruedCalculationMethodEnum"]] = rest_field(
        name="accruedCalculationMethod"
    )
    """The day count basis method used to calculate the accrued interest payments (e.g. Dcb_30_360,
     Dcb_30_Actual).
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, interestCalculationMethod is used. Known values are: \"Dcb_30_360\",
     \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\",
     \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\",
     \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\",
     \"Dcb_Actual_365_CanadianConvention\", and \"Dcb_Constant\"."""
    adjust_interest_to_payment_date: Optional[Union[str, "_models.AdjustInterestToPaymentDateEnum"]] = rest_field(
        name="adjustInterestToPaymentDate"
    )
    """An indication if the coupon dates are adjusted to the payment dates. The possible values are:
     Adjusted,
     Unadjusted.
     If instrumentCode is defined, the value comes from the instrument reference data.
     
     
     * For Swap: In case of a user-defined instrument, the default value is 'Adjusted'.
     * For Bond and Loan: In case of a user-defined instrument, the default value is 'Unadjusted'.
     Known values are: \"Unadjusted\" and \"Adjusted\"."""
    amortization_schedule: Optional[List["_models.AmortizationItemDefinition"]] = rest_field(
        name="amortizationSchedule"
    )
    """The amortization schedule of the instrument. It contains the following information:
     startDate,
     endDate,
     remainingNotional,
     amortizationFrequency,
     amount,
     amortizationType.
     Optional. No default value applies."""
    cap_strike_percent: Optional[float] = rest_field(name="capStrikePercent")
    """The contractual strike rate of the cap. The value is expressed in percentages.
     If this parameter is set, the cap will apply to the leg with the same parameters set in the
     swapLegDefinition (e.g.maturity, frequency, index, discounting rule).
     No default value applies.
     
     
     * For Bond and Loan: Not applicable."""
    cms_template: Optional[str] = rest_field(name="cmsTemplate")
    """A reference to a common swap contract that represents the underlying swap in case of a Constant
     Maturity Swap contract (CMS). Example: EUR_AB6E.
     No default value applies."""
    custom_interest_periods: Optional[List["_models.InterestRateScheduleItem"]] = rest_field(
        name="customInterestPeriods"
    )
    direction: Optional[Union[str, "_models.IPADirectionEnum"]] = rest_field()
    """The indication whether the cash flows of the instrument's leg are paid or received.
     Mandatory if instrumentCode or template is not defined. If instrumentCode or template is
     defined, the value comes from the instrument reference data.
     The possible values are:
     
     
     * For Swap:
       Paid: the cash flows are paid to the counterparty,
       Received: the cash flows are received from the counterparty.
     * For CDS:
       Paid: the fixed payments are paid by the counterparty (applied to the CDS buyer),
       Received: the fixed payments are received from the counterparty (applied to the CDS seller).
     * For Bond and Loan: Not applicable. Known values are: \"Paid\" and \"Received\"."""
    end_stub: Optional["_models.StubRateCalculationParameters"] = rest_field(name="endStub")
    first_regular_payment_date: Optional[datetime.datetime] = rest_field(
        name="firstRegularPaymentDate", format="rfc3339"
    )
    """The first regular interest payment date used for the odd first interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
     
     
     * For Swap: No default value applies.
     * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
     stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
     instrument reference data.
     * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency."""
    fixed_rate_percent: Optional[float] = rest_field(name="fixedRatePercent")
    """The interest rate used to derive future fixed interest payments of the instrument. The value is
     expressed in percentages. Either fixedRatePercent or fixedRatePercentSchedule is used.
     In Swap, applies to fixed leg only.
     If instrumentCode is defined, the value comes from the instrument reference data.
     In case of a user-defined instrument, the default value is '0' for Bond, par rate for Swap and
     '1' for CDS.
     For Loan: Mandatory for a fixed rate loan. No default value applies."""
    floor_strike_percent: Optional[float] = rest_field(name="floorStrikePercent")
    """The contractual strike rate of the floor. The value is expressed in percentages.
     If this parameter is set, the floor will apply to the leg with the same parameters set in the
     swapLegDefinition (e.g.maturity, frequency, index, discounting rule).
     No default value applies.
     
     
     * For Bond and Loan: Not applicable."""
    has_cap: Optional[bool] = rest_field(name="hasCap")
    """A boolean to determine whether one should use a default cap strike on a given floating leg.
     The value of the default strike is the par swap rate."""
    has_floor: Optional[bool] = rest_field(name="hasFloor")
    """A boolean to determine whether one should use a default floor strike on a given floating leg.
     The value of the default strike is the par swap rate."""
    index_average_method: Optional[Union[str, "_models.IndexAverageMethodEnum"]] = rest_field(name="indexAverageMethod")
    """The method of calculating the average index value. The possible values are:
     CompoundedActual,
     DailyCompoundedAverage,
     CompoundedAverageRate,
     ArithmeticAverage
     The default value depends on the index default convention.
     
     
     * For Bond and Loan: Not applicable. Known values are: \"CompoundedActual\",
     \"DailyCompoundedAverage\", \"CompoundedAverageRate\", and \"ArithmeticAverage\"."""
    index_compounding_method: Optional[Union[str, "_models.IndexCompoundingMethodEnum"]] = rest_field(
        name="indexCompoundingMethod"
    )
    """The method how the interest rate is calculated from the reset floating rates when the reset
     frequency is higher than the interest payment frequency (e.g. daily index reset with quarterly
     interest payments). The possible values are:
     Compounded,
     Average,
     Constant,
     AdjustedCompounded,
     MexicanCompounded.
     Optional.
     
     
     * For Bond and Loan: If instrumentCode is defined, the value comes from the instrument
     reference data. In case of a user-defined instrument, the default value is 'Constant'.
     * For Swap: The default value is defined by the market conventions of the index defined for the
     floating leg. Known values are: \"Compounded\", \"AdjustedCompounded\", \"MexicanCompounded\",
     \"Average\", and \"Constant\"."""
    index_fixing_lag: Optional[int] = rest_field(name="indexFixingLag")
    """The number of working days between the fixing date of the index and the start of the interest
     accrual period ('InAdvance') or the end of the interest accrual period ('InArrears').
     
     
     * For Swap: The InAdvance/InArrears mode is set in the indexResetType parameter. The default
     value is the fixing lag associated to the index defined/determined by default on the floating
     leg.
     * For Bond and Loan: In case of a user-defined instrument, the default value is 0. If
     instrumentCode is defined, the value comes from the instrument reference data."""
    index_fixing_ric: Optional[str] = rest_field(name="indexFixingRic")
    """The RIC that carries the fixing value if the instrument has a floating interest.
     
     
     * For Swap: Optional. The default value depends on the notional currency.
     * For Bond and Loan: Mandatory for floating rate instruments if no instrumentCode is defined.
     If instrumentCode is defined, the value comes from the instrument reference data."""
    index_lockout_period: Optional[int] = rest_field(name="indexLockoutPeriod")
    """The period from the start date (inclusive) of the index lockout to the end date of the interest
     calculation period for which the reference rate is no longer updated.
     During this period the index of the day preceding the start date of the lockout period is
     applied to the remaining days of the interest period. The value is expressed in working days.
     Please note, that by (ISDA) definition the lockout method is applied only to payment periods
     (with Fixing) and not to future periods (with ZcCurve).
     Optional. The default value is 0."""
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g. 'EURIBOR').
     No default value applies."""
    index_observation_method: Optional[Union[str, "_models.IPAIndexObservationMethodEnum"]] = rest_field(
        name="indexObservationMethod"
    )
    """(RFR) Method for determining the accrual observation period. The lag is defined using the
     indexFixingLag property. The possible values are:
     Lookback: use the interest period for both rate accrual and interest payment.
     PeriodShift: use the observation period for both rate accrual and interest payment.
     Mixed: use the observation period for rate accrual and the interest period for interest
     payment.
     Optional. No default value applies.
     
     
     * For Bond and Loan: Not applicable. Known values are: \"Lookback\", \"PeriodShift\", and
     \"Mixed\"."""
    index_price_side: Optional[Union[str, "_models.IndexPriceSideEnum"]] = rest_field(name="indexPriceSide")
    """The quoted price side of the floating rate index that applies to legs or the instrument.
     The possible values are: Bid, Ask, Mid.
     This property applies only if an index is quoted with a 'Bid'/'Ask' price side.
     The default value is 'Mid'. Known values are: \"Mid\", \"Bid\", \"Ask\", and \"Last\"."""
    index_reset_frequency: Optional[Union[str, "_models.IndexResetFrequencyEnum"]] = rest_field(
        name="indexResetFrequency"
    )
    """The reset frequency for the floating instrument (e.g. Annual, SemiAnnual).
     
     
     * For Swap: The default value is interestPaymentFrequency. For RFR index, the default value is
     EveryWorkingDay.
     * For Bond: If instrumentCode is defined, the value comes from the instrument reference data.
     In case of a user-defined instrument, the default value is derived from the index tenor.
     * For Loan: The default value is interestPaymentFrequency. Known values are: \"Annual\",
     \"SemiAnnual\", \"Quarterly\", \"Monthly\", \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\",
     \"Every7Days\", \"Every14Days\", \"Every28Days\", \"Every30Days\", \"Every91Days\",
     \"Every182Days\", \"Every364Days\", \"Every365Days\", \"Every90Days\", \"Every92Days\",
     \"Every93Days\", \"Every180Days\", \"Every183Days\", \"Every184Days\", \"Every4Months\",
     \"R2\", \"R4\", \"Zero\", and \"Scheduled\"."""
    index_reset_type: Optional[Union[str, "_models.IndexResetTypeEnum"]] = rest_field(name="indexResetType")
    """A type indicating if the floating rate index is reset before the coupon period starts or at the
     end of the coupon period. The possible values are:
     InAdvance: resets the index before the start of the interest period,
     InArrears: resets the index at the end of the interest period.
     The default value is 'InAdvance'. For RFR index, the default value is 'InArrears'. Known values
     are: \"InAdvance\" and \"InArrears\"."""
    index_source: Optional[str] = rest_field(name="indexSource")
    """The source of the floating rate index (e.g. 'RFTB' or 'IBAL').
     The default value depends on the notional currency. In case of multiple sources for an index
     'RFTB' (Refinitiv) is selected."""
    index_spread_compounding_method: Optional[Union[str, "_models.IndexSpreadCompoundingMethodEnum"]] = rest_field(
        name="indexSpreadCompoundingMethod"
    )
    """The method defining how the computed float leg spread is applied to compounded rate.
     It applies only when indexCompoundingMethod= Compounded.
     The possible values are:
     IsdaCompounding,
     NoCompounding,
     IsdaFlatCompounding.
     The default value is 'IsdaCompounding'. Known values are: \"IsdaCompounding\",
     \"NoCompounding\", and \"IsdaFlatCompounding\"."""
    index_tenor: Optional[str] = rest_field(name="indexTenor")
    """The period code indicating the tenor of the underlying floating rate index (e.g., '1M','1Y').
     The requested tenor must exist in the multicurve environment which is used.
     The default value is the tenor equivalent to indexResetFrequency or interestPaymentFrequency."""
    interest_calculation_convention: Optional[Union[str, "_models.InterestCalculationConventionEnum"]] = rest_field(
        name="interestCalculationConvention"
    )
    """The convention applied to calculate the interest payments. The possible values are:
     
     
     * None,
     * MoneyMarket: money market methods calculate all cash flow based on the actual number of days
     in the payment period,
     * BondBasis: bond methods calculate interest payments proportionally to the payment frequency
     and adjust them if the number of days in the payment period is larger or smaller.
     
     Optional. If instrumentCode is defined, the value comes from the instrument reference data. In
     case of a user-defined instrument, the default value is 'MoneyMarket'. Known values are:
     \"None\", \"MoneyMarket\", and \"BondBasis\"."""
    interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = rest_field(
        name="interestCalculationMethod"
    )
    """The day count basis method used to calculate the interest payments(e.g. Dcb_30_360,
     Dcb_30_Actual).
     
     
     * For Swap: The default value is selected based on notionalCcy.
     * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
     comes from the instrument reference data.
     * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
     Otherwise, the default value is 'Dcb_Actual_360'.
     * For Loan: Mandatory. No default value applies. Known values are: \"Dcb_30_360\",
     \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\",
     \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\",
     \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\",
     \"Dcb_Actual_365_CanadianConvention\", and \"Dcb_Constant\"."""
    interest_payment_delay: Optional[int] = rest_field(name="interestPaymentDelay")
    """The number of working days between the end of the interest accrual period and the interest
     payment date.
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, the default value is '0'."""
    interest_payment_frequency: Optional[Union[str, "_models.InterestPaymentFrequencyEnum"]] = rest_field(
        name="interestPaymentFrequency"
    )
    """The interest payment frequency.
     
     
     * For Swap: Either indexResetFrequency or InterestPaymentFrequency must be provided (e.g.
     Annual, SemiAnnual). The default value is indexResetFrequency.
     * For Bond: Mandatory if no instrumentCode is defined. If instrumentCode is defined, the value
     comes from the instrument reference data.
     * For CDS: If instrumentCode is defined, the value comes from the instrument reference data.
     Otherwise, the default value is 'Quaterly'.
     * For Loan: Mandatory. No default value applies. Known values are: \"Annual\", \"SemiAnnual\",
     \"Quarterly\", \"Monthly\", \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\", \"Every7Days\",
     \"Every14Days\", \"Every28Days\", \"Every30Days\", \"Every91Days\", \"Every182Days\",
     \"Every364Days\", \"Every365Days\", \"Every90Days\", \"Every92Days\", \"Every93Days\",
     \"Every180Days\", \"Every183Days\", \"Every184Days\", \"Every4Months\", \"R2\", \"R4\",
     \"Zero\", and \"Scheduled\"."""
    interest_type: Optional[Union[str, "_models.InterestTypeEnum"]] = rest_field(name="interestType")
    """An indicator whether the instrument pays a fixed or floating interest. The possible values are:
     
     
     * Fixed,
     * Float.
     
     For Swap: No default value applies. Mandatory for SwapLegDefinition.
     For Bond: Optional. If instrumentCode is defined, the value comes from the instrument reference
     data. Otherwise, the default value is 'Fixed'.
     For Loan: Mandatory. No default value applies. Known values are: \"Fixed\", \"Float\", and
     \"Stepped\"."""
    last_regular_payment_date: Optional[datetime.datetime] = rest_field(name="lastRegularPaymentDate", format="rfc3339")
    """The last regular interest payment date used for the odd last interest period. The value is
     expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
     
     
     * For Swap: No default value applies.
     * For Bond and Loan: In case of a user-defined instrument, the default value is computed from
     stubRule and interestPaymentFrequency. If instrumentCode is defined, the value comes from the
     instrument reference data.
     * For CDS:  By default, it is computed from FirstAccrualDate and InterestPaymentFrequency."""
    leg_tag: Optional[str] = rest_field(name="legTag")
    """A user-defined string to identify the leg.
     By default, the value specified in the 'direction' property is returned."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument.
     Optional. The default value is '1,000,000'.
     For CDS: the amounts for the premium and protection legs must be equal."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g. 'USD').
     If instrumentCode is defined, the value comes from the instrument reference data.
     
     
     * For Swap: Mandatory for SwapLegDefinition if instrumentCode is not defined.
     * For CDS: Mandatory for protectionLeg definition if instrumentCode is not defined. For
     premiumLeg definition, it is derived from pretctionLeg definition.
     * For Bond and Loan: Mandatory if no instrumentCode is defined."""
    notional_exchange: Optional[Union[str, "_models.NotionalExchangeEnum"]] = rest_field(name="notionalExchange")
    """An indicator if the notional amount is exchanged and when it is exchanged. The possible values
     are:
     None,
     Start,
     End,
     Both,
     EndAdjustment.
     The default value is 'None'. Known values are: \"None\", \"Start\", \"End\", \"Both\", and
     \"EndAdjustment\"."""
    payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = rest_field(
        name="paymentBusinessDayConvention"
    )
    """The method to adjust dates to working days. The possible values are:
     PreviousBusinessDay,
     NextBusinessDay,
     Modified following,
     NoMoving,
     BBSWModifiedFollowing.
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, the default value is 'ModifiedFollowing'. Known values are:
     \"ModifiedFollowing\", \"NextBusinessDay\", \"PreviousBusinessDay\", \"NoMoving\",
     \"EveryThirdWednesday\", and \"BbswModifiedFollowing\"."""
    payment_business_days: Optional[str] = rest_field(name="paymentBusinessDays")
    """A list of comma-separated calendar codes to adjust dates (e.g. 'EMU' or 'USA').
     
     
     * For Swap: The default value is the calendar associated to the market conventions of the
     InterestPaymentCcy for the corresponding leg.
     * For Bond and Loan: The default value is the calendar associated to NotionalCcy."""
    payment_roll_convention: Optional[Union[str, "_models.PaymentRollConventionEnum"]] = rest_field(
        name="paymentRollConvention"
    )
    """The method to adjust payment dates when they fall at the end of the month (e.g. 28th of
     February, 30th, 31st). The possible values are:
     Last,
     Same,
     Last28,
     Same28.
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, the default value is 'Same'. Known values are: \"Last\", \"Same\",
     \"Same1\", \"Last28\", and \"Same28\"."""
    spread_bp: Optional[float] = rest_field(name="spreadBp")
    """The spread applied to the floating interest rate of the instrument. The value is expressed in
     basis points.
     Optional. If instrumentCode is defined, the value comes from the instrument reference data. In
     case of a user-defined instrument, the default value is '0'."""
    start_stub: Optional["_models.StubRateCalculationParameters"] = rest_field(name="startStub")
    stub_rule: Optional[Union[str, "_models.FinancialContractStubRuleEnum"]] = rest_field(name="stubRule")
    """The rule that defines whether coupon roll dates are aligned to the maturity or issue date. The
     possible values are:
     Issue,
     Maturity,
     ShortFirstProRata,
     ShortFirstFull,
     LongFirstFull,
     ShortLastProRata.
     If instrumentCode is defined, the value comes from the instrument reference data. In case of a
     user-defined instrument, the default value is 'Maturity'. Known values are: \"Issue\",
     \"Maturity\", \"ShortFirstProRata\", \"ShortFirstFull\", \"LongFirstFull\", and
     \"ShortLastProRata\"."""
    upfront_amount: Optional[float] = rest_field(name="upfrontAmount")
    """The amount which represents the net present value of the swap. It is computed as [(100 
     DirtyPricePercent / 100) x NotionalAmount]. The value is expressed in upfrontAmountCcy.
     By default, no payment (0) applies."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        accrued_calculation_method: Optional[Union[str, "_models.AccruedCalculationMethodEnum"]] = None,
        adjust_interest_to_payment_date: Optional[Union[str, "_models.AdjustInterestToPaymentDateEnum"]] = None,
        amortization_schedule: Optional[List["_models.AmortizationItemDefinition"]] = None,
        cap_strike_percent: Optional[float] = None,
        cms_template: Optional[str] = None,
        custom_interest_periods: Optional[List["_models.InterestRateScheduleItem"]] = None,
        direction: Optional[Union[str, "_models.IPADirectionEnum"]] = None,
        end_stub: Optional["_models.StubRateCalculationParameters"] = None,
        first_regular_payment_date: Optional[datetime.datetime] = None,
        fixed_rate_percent: Optional[float] = None,
        floor_strike_percent: Optional[float] = None,
        has_cap: Optional[bool] = None,
        has_floor: Optional[bool] = None,
        index_average_method: Optional[Union[str, "_models.IndexAverageMethodEnum"]] = None,
        index_compounding_method: Optional[Union[str, "_models.IndexCompoundingMethodEnum"]] = None,
        index_fixing_lag: Optional[int] = None,
        index_fixing_ric: Optional[str] = None,
        index_lockout_period: Optional[int] = None,
        index_name: Optional[str] = None,
        index_observation_method: Optional[Union[str, "_models.IPAIndexObservationMethodEnum"]] = None,
        index_price_side: Optional[Union[str, "_models.IndexPriceSideEnum"]] = None,
        index_reset_frequency: Optional[Union[str, "_models.IndexResetFrequencyEnum"]] = None,
        index_reset_type: Optional[Union[str, "_models.IndexResetTypeEnum"]] = None,
        index_source: Optional[str] = None,
        index_spread_compounding_method: Optional[Union[str, "_models.IndexSpreadCompoundingMethodEnum"]] = None,
        index_tenor: Optional[str] = None,
        interest_calculation_convention: Optional[Union[str, "_models.InterestCalculationConventionEnum"]] = None,
        interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = None,
        interest_payment_delay: Optional[int] = None,
        interest_payment_frequency: Optional[Union[str, "_models.InterestPaymentFrequencyEnum"]] = None,
        interest_type: Optional[Union[str, "_models.InterestTypeEnum"]] = None,
        last_regular_payment_date: Optional[datetime.datetime] = None,
        leg_tag: Optional[str] = None,
        notional_amount: Optional[float] = None,
        notional_ccy: Optional[str] = None,
        notional_exchange: Optional[Union[str, "_models.NotionalExchangeEnum"]] = None,
        payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = None,
        payment_business_days: Optional[str] = None,
        payment_roll_convention: Optional[Union[str, "_models.PaymentRollConventionEnum"]] = None,
        spread_bp: Optional[float] = None,
        start_stub: Optional["_models.StubRateCalculationParameters"] = None,
        stub_rule: Optional[Union[str, "_models.FinancialContractStubRuleEnum"]] = None,
        upfront_amount: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionAnalyticsResponseData(_model_base.Model):
    """SwaptionAnalyticsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.SwaptionDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.SwaptionPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.SwaptionAnalyticsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketDataQps
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.SwaptionDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.SwaptionPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.SwaptionAnalyticsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketDataQps"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.SwaptionDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.SwaptionPricingParameters"] = None,
        analytics: Optional[List["_models.SwaptionAnalyticsResponseWithError"]] = None,
        market_data: Optional["_models.MarketDataQps"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionAnalyticsResponseWithError(_model_base.Model):
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    tabular_data : ~analyticsapi.models.FinancialContractResponse
        Standard Financial Contract Analytics in tabular format.
    cashflows : ~analyticsapi.models.SwaptionCashflows
        Response categorized under Cashflows.
    description : ~analyticsapi.models.SwaptionDescription
        Response categorized under Description.
    greeks : ~analyticsapi.models.SwaptionGreeks
        Response categorized under Greeks.
    pricing_analysis : ~analyticsapi.models.SwaptionPricingAnalysis
        Response categorized under Pricing analysis.
    valuation : ~analyticsapi.models.SwaptionValuation
        Response categorized under Valuation.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    tabular_data: Optional["_models.FinancialContractResponse"] = rest_field(name="tabularData")
    """Standard Financial Contract Analytics in tabular format."""
    cashflows: Optional["_models.SwaptionCashflows"] = rest_field()
    """Response categorized under Cashflows."""
    description: Optional["_models.SwaptionDescription"] = rest_field()
    """Response categorized under Description."""
    greeks: Optional["_models.SwaptionGreeks"] = rest_field()
    """Response categorized under Greeks."""
    pricing_analysis: Optional["_models.SwaptionPricingAnalysis"] = rest_field(name="pricingAnalysis")
    """Response categorized under Pricing analysis."""
    valuation: Optional["_models.SwaptionValuation"] = rest_field()
    """Response categorized under Valuation."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        tabular_data: Optional["_models.FinancialContractResponse"] = None,
        cashflows: Optional["_models.SwaptionCashflows"] = None,
        description: Optional["_models.SwaptionDescription"] = None,
        greeks: Optional["_models.SwaptionGreeks"] = None,
        pricing_analysis: Optional["_models.SwaptionPricingAnalysis"] = None,
        valuation: Optional["_models.SwaptionValuation"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionCalculationResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.SwaptionAnalyticsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.SwaptionAnalyticsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.SwaptionAnalyticsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class SwaptionCashflows(_model_base.Model):
    """Cashflows Object.

    Attributes
    ----------
    cash_flows : list[any]
        The information on the contract's cash flows during its lifetime. It
        consists of the following properties:

        * instrumentType: the instrument type for which cash flows are computed,
        * payments: the array of properties which define all instruments cash flows (paid and
        received) during its lifetime.

        For more details, please refer here.  The default value is None, needs to be assigned before
        using.
    cash_flow_residual_amounts_in_deal_ccy_array : list[float]
        The residual amounts of the instrument for each cash flow date. The
        values are expressed in the deal currency.  The default value is None,
        needs to be assigned before using.
    """

    cash_flows: Optional[List[Any]] = rest_field(name="cashFlows")
    """The information on the contract's cash flows during its lifetime. It consists of the following
     properties:
     
     
     * instrumentType: the instrument type for which cash flows are computed,
     * payments: the array of properties which define all instruments cash flows (paid and
     received) during its lifetime.
     
     For more details, please refer here."""
    cash_flow_residual_amounts_in_deal_ccy_array: Optional[List[float]] = rest_field(
        name="cashFlowResidualAmountsInDealCcyArray"
    )
    """The residual amounts of the instrument for each cash flow date. The values are expressed in the
     deal currency."""

    @overload
    def __init__(
        self,
        *,
        cash_flows: Optional[List[Any]] = None,
        cash_flow_residual_amounts_in_deal_ccy_array: Optional[List[float]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionDefinition(_model_base.Model):
    """SwaptionDefinition.

    Attributes
    ----------
    bermudan_swaption_definition : ~analyticsapi.models.BermudanSwaptionDefinition
    buy_sell : str or ~analyticsapi.models.IPABuySellEnum
        The indicator of the deal side. The possible values are: Buy: buying
        the option, Sell: selling/writing the option. No default value applies.
        Known values are: "Buy" and "Sell".
    delivery_date : ~datetime.datetime
        The date on which the option is settled. The value is expressed in ISO
        8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. '2021-01-01T00:00:00Z').
        Optional. By default, it is equal to EndDate.
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.
        2021-01-01T00:00:00Z). Either tenor or endDate must be provided.
        Optional. No default value applies.
    exercise_style : str or ~analyticsapi.models.IPAExerciseStyleEnum
        The option style based on its exercise restrictions. The possible
        values are: AMER, EURO, BERM. Note: all exercise styles may not apply
        to certain option No default value applies. Known values are: "EURO",
        "AMER", and "BERM".
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported. Optional. No default value applies.
    notional_amount : float
        The notional amount of the instrument. The default value is
        '1,000,000'.
    payments : list[~analyticsapi.models.InputFlow]
        The array of properties which can be used to define instruments
        premium for cash flow analysis. Optional. By default, the properties
        are computed using the specific contract terms.  The default value is
        None, needs to be assigned before using.
    premium_settlement_type : str or ~analyticsapi.models.PremiumSettlementTypeEnum
        The settlement type of the option premium. The possible values are:

        * Spot,
        * Forward.

        Optional. The default value is 'Spot'. Known values are: "Spot", "Forward", and "Schedule".
    settlement_type : str or ~analyticsapi.models.SettlementTypeEnum
        The settlement method for options when exercised. The possible values
        are: Physical: delivering the underlying asset, or for a swaption,
        physically entering into the underlying swap. Cash: paying out in cash.
        The default value is 'Physical'. Known values are: "Physical", "Cash",
        and "CCP".
    spread_vs_atm_in_bp : float
        The spread added to the strike rate of the equivalent at-the-money
        swaption. To be used for a pre-trade use case. The value is expressed
        in basis points. Optional. No default value applies.
    start_date : ~datetime.datetime
        The start date of the instrument. The value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z).
        Optional. By default, valuationDate is used.
    strike_percent : float
        The set price at which the owner of the option can buy or sell the
        underlying asset. For a swaption, it is the fixed rate of the
        underlying swap at which the owner of the swaption can enter the swap.
        The value is expressed in percentages. By default, FixedRatePercent of
        the underlying swap is used.
    swaption_type : str or ~analyticsapi.models.SwaptionTypeEnum
        The indicator if the swaption is a payer or a receiver. The possible
        values are: Receiver: a right to receive a fixed rate of the underlying
        swap, Payer: a right to pay a fixed rate of the underlying swap. No
        default value applies. Known values are: "Payer" and "Receiver".
    tenor : str
        The code indicating the period between StartDate and EndDate of the
        instrument (e.g. '6M', '1Y'). Either tenor or endDate must be provided.
        Optional. No default value applies.
    underlying_definition : ~analyticsapi.models.SwapDefinition
    """

    bermudan_swaption_definition: Optional["_models.BermudanSwaptionDefinition"] = rest_field(
        name="bermudanSwaptionDefinition"
    )
    buy_sell: Optional[Union[str, "_models.IPABuySellEnum"]] = rest_field(name="buySell")
    """The indicator of the deal side. The possible values are:
     Buy: buying the option,
     Sell: selling/writing the option.
     No default value applies. Known values are: \"Buy\" and \"Sell\"."""
    delivery_date: Optional[datetime.datetime] = rest_field(name="deliveryDate", format="rfc3339")
    """The date on which the option is settled. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. '2021-01-01T00:00:00Z').
     Optional. By default, it is equal to EndDate."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z).
     Either tenor or endDate must be provided.
     Optional. No default value applies."""
    exercise_style: Optional[Union[str, "_models.IPAExerciseStyleEnum"]] = rest_field(name="exerciseStyle")
    """The option style based on its exercise restrictions. The possible values are:
     AMER,
     EURO,
     BERM.
     Note: all exercise styles may not apply to certain option
     No default value applies. Known values are: \"EURO\", \"AMER\", and \"BERM\"."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported.
     Optional. No default value applies."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument.
     The default value is '1,000,000'."""
    payments: Optional[List["_models.InputFlow"]] = rest_field()
    """The array of properties which can be used to define instruments premium for cash flow
     analysis.
     Optional. By default, the properties are computed using the specific contract terms."""
    premium_settlement_type: Optional[Union[str, "_models.PremiumSettlementTypeEnum"]] = rest_field(
        name="premiumSettlementType"
    )
    """The settlement type of the option premium. The possible values are:
     
     
     * Spot,
     * Forward.
     
     Optional. The default value is 'Spot'. Known values are: \"Spot\", \"Forward\", and
     \"Schedule\"."""
    settlement_type: Optional[Union[str, "_models.SettlementTypeEnum"]] = rest_field(name="settlementType")
    """The settlement method for options when exercised. The possible values are:
     Physical: delivering the underlying asset, or for a swaption, physically entering into the
     underlying swap.
     Cash: paying out in cash.
     The default value is 'Physical'. Known values are: \"Physical\", \"Cash\", and \"CCP\"."""
    spread_vs_atm_in_bp: Optional[float] = rest_field(name="spreadVsAtmInBp")
    """The spread added to the strike rate of the equivalent at-the-money swaption. To be used for a
     pre-trade use case. The value is expressed in basis points.
     Optional. No default value applies."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z).
     Optional. By default, valuationDate is used."""
    strike_percent: Optional[float] = rest_field(name="strikePercent")
    """The set price at which the owner of the option can buy or sell the underlying asset. For a
     swaption, it is the fixed rate of the underlying swap at which the owner of the swaption can
     enter the swap. The value is expressed in percentages.
     By default, FixedRatePercent of the underlying swap is used."""
    swaption_type: Optional[Union[str, "_models.SwaptionTypeEnum"]] = rest_field(name="swaptionType")
    """The indicator if the swaption is a payer or a receiver. The possible values are:
     Receiver: a right to receive a fixed rate of the underlying swap,
     Payer: a right to pay a fixed rate of the underlying swap.
     No default value applies. Known values are: \"Payer\" and \"Receiver\"."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between StartDate and EndDate of the instrument (e.g. '6M',
     '1Y'). Either tenor or endDate must be provided.
     Optional. No default value applies."""
    underlying_definition: Optional["_models.SwapDefinition"] = rest_field(name="underlyingDefinition")

    @overload
    def __init__(
        self,
        *,
        bermudan_swaption_definition: Optional["_models.BermudanSwaptionDefinition"] = None,
        buy_sell: Optional[Union[str, "_models.IPABuySellEnum"]] = None,
        delivery_date: Optional[datetime.datetime] = None,
        end_date: Optional[datetime.datetime] = None,
        exercise_style: Optional[Union[str, "_models.IPAExerciseStyleEnum"]] = None,
        instrument_tag: Optional[str] = None,
        notional_amount: Optional[float] = None,
        payments: Optional[List["_models.InputFlow"]] = None,
        premium_settlement_type: Optional[Union[str, "_models.PremiumSettlementTypeEnum"]] = None,
        settlement_type: Optional[Union[str, "_models.SettlementTypeEnum"]] = None,
        spread_vs_atm_in_bp: Optional[float] = None,
        start_date: Optional[datetime.datetime] = None,
        strike_percent: Optional[float] = None,
        swaption_type: Optional[Union[str, "_models.SwaptionTypeEnum"]] = None,
        tenor: Optional[str] = None,
        underlying_definition: Optional["_models.SwapDefinition"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.SwaptionDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.SwaptionDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.SwaptionDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionDescription(_model_base.Model):
    """Description Object.

    Attributes
    ----------
    instrument_type : str
        The type of instrument defined in the request. The possible values are
        listed  here  .
    instrument_tag : str
        A user defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    instrument_code : str
        The code used to define the instrument. The possible values for each
        asset type are listed  here  .
    instrument_description : str
        The label that describes the instrument.
    swaption_type : str
        The indicator if the swaption is a payer or a receiver. The possible
        values are:  -  Receiver:  a right to receive a fixed rate of the
        underlying swap.  -  Payer: a right to pay a fixed rate of the
        underlying swap.
    buy_sell : str
        The indicator of the deal side. The possible values are:- Buy: buying
        the option.- Sell: selling/writing the option. The output amounts
        calculated with taking buySell into consideration are returned with a
        reversed sign when the value 'Sell' is used.
    exercise_style : str
        The option style based on its exercise restrictions. The possible
        values are:  -  AMER:  the owner has the right to exercise on any date
        before the option expires.  - EURO:  the owner has the right to
        exercise only on  EndDate.  - BERM:  the owner has the right to
        exercise on any of several specified dates before the option  expires.
        Note:  all exercise styles may not apply to certain option types.
    notional_amount : float
        The notional amount of the instrument.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g.,  'USD').
    settlement_type : str
        The settlement method for options when exercised. The possible values
        are:  -  Physical:  delivering the underlying asset, or for a swaption,
        physically entering into the underlying swap.  -  Cash:  paying out in
        cash.
    settlement_ccy : str
        The code of the currency, in which the deal is settled. The value is
        expressed in ISO 4217 alphabetical format (e.g., 'USD').
    underlying_ccy : str
        The currency of the underlying asset. The value is expressed in ISO
        4217 alphabetical format (e.g., 'USD').
    report_ccy : str
        The currency code set for the fields ending with '  xxxInReportCcy  '.
        The value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
    start_date : ~datetime.datetime
        The start date of the instrument. The value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z).
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        2021-01-01T00:00:00Z).
    tenor : str
        The code indicating the period between  StartDate  and  EndDate  of the
        instrument (e.g., '6M', '1Y').
    underlying_tenor : str
        The code indicating the period between the start date and the end date
        of the underlying asset (e.g., '6M', '1Y').
    strike_percent : float
        The set price at which the owner of the option can buy or sell the
        underlying asset. For a swaption, it is the fixed rate of the
        underlying swap at which the owner of the swaption can enter the swap.
        The value is expressed in percentages.
    exercise_schedule_type : str
        The source of the exercise dates of Bermudan options. The possible
        values are:  -  FixedLeg:  coupon dates of the fixed leg of the
        underlying swap are used as the swaption exercise schedule.  -
        FloatLeg:  coupon dates of the floating leg of the underlying swap are
        used as the swaption exercise schedule.  -  UserDefined:  the exercise
        schedule to be defined by the user.
    discount_curve_id : str
        The identifier of the zero-coupon curve used to discount the
        instrument's future payments.
    discount_curve_name : str
        The name of the zero-coupon curve used to discount the instrument cash
        flows.  Specifying data for this curve can be set using the market data
        section. By default, the discount curve is found from the instrument's
        currency and frequency.
    forward_curve_id : str
        The identifier of the zero-coupon curve used to derive forward index
        values for the instrument.
    forward_curve_name : str
        The name of the zero-coupon curve used to derive forward index values
        for the instrument. Examples could be as follows:  - EUR EURIBOR 6M: a
        zero-coupon curve bootstrapped from EURIBOR 6M swaps.  - USD LIBOR OIS
        disc. COP COIBR OIS: a cross-currency curve COP COIBR OIS discounted by
        USD LIBOR OIS.
    error_code : str
        The code of  ErrorMessage.
    error_message : str
        The error message in case of a blocking error in calculation.
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    instrument_type: Optional[str] = rest_field(name="instrumentType")
    """The type of instrument defined in the request. The possible values are listed  here  ."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument. The possible values for each asset type are listed
     here  ."""
    instrument_description: Optional[str] = rest_field(name="instrumentDescription")
    """The label that describes the instrument."""
    swaption_type: Optional[str] = rest_field(name="swaptionType")
    """The indicator if the swaption is a payer or a receiver. The possible values are:  -  Receiver:
     a right to receive a fixed rate of the underlying swap.  -  Payer:  a right to pay a fixed rate
     of the underlying swap."""
    buy_sell: Optional[str] = rest_field(name="buySell")
    """The indicator of the deal side. The possible values are:- Buy: buying the option.- Sell:
     selling/writing the option.
     The output amounts calculated with taking buySell into consideration are returned with a
     reversed sign when the value 'Sell' is used."""
    exercise_style: Optional[str] = rest_field(name="exerciseStyle")
    """The option style based on its exercise restrictions. The possible values are:  -  AMER:  the
     owner has the right to exercise on any date before the option expires.  -  EURO:  the owner has
     the right to exercise only on  EndDate.  - BERM:  the owner has the right to exercise on any of
     several specified dates before the option  expires.  Note:  all exercise styles may not apply
     to certain option types."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g.,  'USD')."""
    settlement_type: Optional[str] = rest_field(name="settlementType")
    """The settlement method for options when exercised. The possible values are:  -  Physical:
     delivering the underlying asset, or for a swaption, physically entering into the underlying
     swap.  -  Cash:  paying out in cash."""
    settlement_ccy: Optional[str] = rest_field(name="settlementCcy")
    """The code of the currency, in which the deal is settled. The value is expressed in ISO 4217
     alphabetical format (e.g., 'USD')."""
    underlying_ccy: Optional[str] = rest_field(name="underlyingCcy")
    """The currency of the underlying asset. The value is expressed in ISO 4217 alphabetical format
     (e.g., 'USD')."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with '  xxxInReportCcy  '. The value is expressed
     in ISO 4217 alphabetical format (e.g., 'USD')."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z)."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z)."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between  StartDate  and  EndDate  of the instrument (e.g., '6M',
     '1Y')."""
    underlying_tenor: Optional[str] = rest_field(name="underlyingTenor")
    """The code indicating the period between the start date and the end date of the underlying asset
     (e.g., '6M', '1Y')."""
    strike_percent: Optional[float] = rest_field(name="strikePercent")
    """The set price at which the owner of the option can buy or sell the underlying asset. For a
     swaption, it is the fixed rate of the underlying swap at which the owner of the swaption can
     enter the swap. The value is expressed in percentages."""
    exercise_schedule_type: Optional[str] = rest_field(name="exerciseScheduleType")
    """The source of the exercise dates of Bermudan options. The possible values are:  -  FixedLeg:
     coupon dates of the fixed leg of the underlying swap are used as the swaption exercise
     schedule.  -  FloatLeg:  coupon dates of the floating leg of the underlying swap are used as
     the swaption exercise schedule.  -  UserDefined:  the exercise schedule to be defined by the
     user."""
    discount_curve_id: Optional[str] = rest_field(name="discountCurveId")
    """The identifier of the zero-coupon curve used to discount the instrument's future payments."""
    discount_curve_name: Optional[str] = rest_field(name="discountCurveName")
    """The name of the zero-coupon curve used to discount the instrument cash flows.  Specifying data
     for this curve can be set using the market data section. By default, the discount curve is
     found from the instrument's currency and frequency."""
    forward_curve_id: Optional[str] = rest_field(name="forwardCurveId")
    """The identifier of the zero-coupon curve used to derive forward index values for the instrument."""
    forward_curve_name: Optional[str] = rest_field(name="forwardCurveName")
    """The name of the zero-coupon curve used to derive forward index values for the instrument.
     Examples could be as follows:  - EUR EURIBOR 6M: a zero-coupon curve bootstrapped from EURIBOR
     6M swaps.  - USD LIBOR OIS disc. COP COIBR OIS: a cross-currency curve COP COIBR OIS discounted
     by USD LIBOR OIS."""
    error_code: Optional[str] = rest_field(name="errorCode")
    """The code of  ErrorMessage."""
    error_message: Optional[str] = rest_field(name="errorMessage")
    """The error message in case of a blocking error in calculation."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        instrument_type: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        instrument_code: Optional[str] = None,
        instrument_description: Optional[str] = None,
        swaption_type: Optional[str] = None,
        buy_sell: Optional[str] = None,
        exercise_style: Optional[str] = None,
        notional_amount: Optional[float] = None,
        notional_ccy: Optional[str] = None,
        settlement_type: Optional[str] = None,
        settlement_ccy: Optional[str] = None,
        underlying_ccy: Optional[str] = None,
        report_ccy: Optional[str] = None,
        start_date: Optional[datetime.datetime] = None,
        end_date: Optional[datetime.datetime] = None,
        tenor: Optional[str] = None,
        underlying_tenor: Optional[str] = None,
        strike_percent: Optional[float] = None,
        exercise_schedule_type: Optional[str] = None,
        discount_curve_id: Optional[str] = None,
        discount_curve_name: Optional[str] = None,
        forward_curve_id: Optional[str] = None,
        forward_curve_name: Optional[str] = None,
        error_code: Optional[str] = None,
        error_message: Optional[str] = None,
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionGreeks(_model_base.Model):
    """Greeks Object.

    Attributes
    ----------
    delta_amount_in_deal_ccy : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in the deal currency  .
    delta_amount_in_report_ccy : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in the reporting currency.
    delta_percent : float
        The change in the instrument's price or market value caused by a one-
        unit change in the price of the underlying asset, or by 1bp change in
        the swap rate for a swaption, or by 100bp change in the outright for FX
        instruments. The value is expressed in percentages.
    gamma_amount_in_deal_ccy : float
        The change in the option's delta or DV01 per a one-unit change in the
        price of the underlying asset, or 1 unit parallel shift in the curve
        representing the instrument. The value is expressed in the deal
        currency.
    gamma_amount_in_report_ccy : float
        The change in the option's delta or DV01 per a one-unit change in the
        price of the underlying asset, or 1 unit parallel shift in the curve
        representing the instrument. The value is expressed in the reporting
        currency.
    gamma_percent : float
        The change in the option's delta or DV01 per a one-unit change in the
        price of the underlying asset, or 1 unit parallel shift in the curve
        representing the instrument. The value is expressed in percentages.
    theta_amount_in_deal_ccy : float
        The change in the instrument's price or market value caused by a one-
        day decrease in its time to expiration. The value is expressed in the
        deal currency.
    theta_amount_in_report_ccy : float
        The change in the instrument's price or market value caused by a one-
        day decrease in its time to expiration. The value is expressed in the
        reporting currency.
    theta_percent : float
        The change in the instrument's price or market value caused by a one-
        day decrease in its time to expiration. The value is expressed in
        percentages.
    vega_amount_in_deal_ccy : float
        The change in the price of an option per  1bp  change in the normal
        volatility  (1%  in the lognormal volatility) of the underlying asset.
        The value is expressed in the deal currency.
    vega_amount_in_report_ccy : float
        The change in the price of an option per  1bp  change in the normal
        volatility  (1%  in the lognormal volatility) of the underlying asset.
        The value is expressed in the reporting currency.
    vega_percent : float
        The change in the price of an option per  1bp  change in the normal
        volatility  (1%  in the lognormal volatility) of the underlying asset.
        The value is expressed in percentages.
    hedge_notional_amount_in_deal_ccy : float
        The notional amount of the underlying swap that allows to hedge the
        swaption. The value is expressed in the deal currency.
    hedge_notional_amount_in_report_ccy : float
        The notional amount of the underlying swap that allows to hedge the
        swaption. The value is expressed in the reporting currency.
    """

    delta_amount_in_deal_ccy: Optional[float] = rest_field(name="deltaAmountInDealCcy")
    """The change in the instrument's price or market value caused by a one-unit change in the price
     of the underlying asset, or by 1bp change in the swap rate for a swaption, or by 100bp change
     in the outright for FX instruments. The value is expressed in the deal currency  ."""
    delta_amount_in_report_ccy: Optional[float] = rest_field(name="deltaAmountInReportCcy")
    """The change in the instrument's price or market value caused by a one-unit change in the price
     of the underlying asset, or by 1bp change in the swap rate for a swaption, or by 100bp change
     in the outright for FX instruments. The value is expressed in the reporting currency."""
    delta_percent: Optional[float] = rest_field(name="deltaPercent")
    """The change in the instrument's price or market value caused by a one-unit change in the price
     of the underlying asset, or by 1bp change in the swap rate for a swaption, or by 100bp change
     in the outright for FX instruments. The value is expressed in percentages."""
    gamma_amount_in_deal_ccy: Optional[float] = rest_field(name="gammaAmountInDealCcy")
    """The change in the option's delta or DV01 per a one-unit change in the price of the underlying
     asset, or 1 unit parallel shift in the curve representing the instrument. The value is
     expressed in the deal currency."""
    gamma_amount_in_report_ccy: Optional[float] = rest_field(name="gammaAmountInReportCcy")
    """The change in the option's delta or DV01 per a one-unit change in the price of the underlying
     asset, or 1 unit parallel shift in the curve representing the instrument. The value is
     expressed in the reporting currency."""
    gamma_percent: Optional[float] = rest_field(name="gammaPercent")
    """The change in the option's delta or DV01 per a one-unit change in the price of the underlying
     asset, or 1 unit parallel shift in the curve representing the instrument. The value is
     expressed in percentages."""
    theta_amount_in_deal_ccy: Optional[float] = rest_field(name="thetaAmountInDealCcy")
    """The change in the instrument's price or market value caused by a one-day decrease in its time
     to expiration. The value is expressed in the deal currency."""
    theta_amount_in_report_ccy: Optional[float] = rest_field(name="thetaAmountInReportCcy")
    """The change in the instrument's price or market value caused by a one-day decrease in its time
     to expiration. The value is expressed in the reporting currency."""
    theta_percent: Optional[float] = rest_field(name="thetaPercent")
    """The change in the instrument's price or market value caused by a one-day decrease in its time
     to expiration. The value is expressed in percentages."""
    vega_amount_in_deal_ccy: Optional[float] = rest_field(name="vegaAmountInDealCcy")
    """The change in the price of an option per  1bp  change in the normal volatility  (1%  in the
     lognormal volatility) of the underlying asset. The value is expressed in the deal currency."""
    vega_amount_in_report_ccy: Optional[float] = rest_field(name="vegaAmountInReportCcy")
    """The change in the price of an option per  1bp  change in the normal volatility  (1%  in the
     lognormal volatility) of the underlying asset. The value is expressed in the reporting
     currency."""
    vega_percent: Optional[float] = rest_field(name="vegaPercent")
    """The change in the price of an option per  1bp  change in the normal volatility  (1%  in the
     lognormal volatility) of the underlying asset. The value is expressed in percentages."""
    hedge_notional_amount_in_deal_ccy: Optional[float] = rest_field(name="hedgeNotionalAmountInDealCcy")
    """The notional amount of the underlying swap that allows to hedge the swaption. The value is
     expressed in the deal currency."""
    hedge_notional_amount_in_report_ccy: Optional[float] = rest_field(name="hedgeNotionalAmountInReportCcy")
    """The notional amount of the underlying swap that allows to hedge the swaption. The value is
     expressed in the reporting currency."""

    @overload
    def __init__(
        self,
        *,
        delta_amount_in_deal_ccy: Optional[float] = None,
        delta_amount_in_report_ccy: Optional[float] = None,
        delta_percent: Optional[float] = None,
        gamma_amount_in_deal_ccy: Optional[float] = None,
        gamma_amount_in_report_ccy: Optional[float] = None,
        gamma_percent: Optional[float] = None,
        theta_amount_in_deal_ccy: Optional[float] = None,
        theta_amount_in_report_ccy: Optional[float] = None,
        theta_percent: Optional[float] = None,
        vega_amount_in_deal_ccy: Optional[float] = None,
        vega_amount_in_report_ccy: Optional[float] = None,
        vega_percent: Optional[float] = None,
        hedge_notional_amount_in_deal_ccy: Optional[float] = None,
        hedge_notional_amount_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionPricingAnalysis(_model_base.Model):
    """Pricing analysis Object.

    Attributes
    ----------
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.
        2021-01-01T00:00:00Z).
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        2021-01-01T00:00:00Z).
    implied_volatility_percent : float
        The implied volatility of the option at the expiration of the option
        extracted from Black-Scholes Model. The value is expressed in
        percentages.
    implied_volatility_bp : float
        The implied volatility of the option extracted from the Normal
        Bachelier Model. The value is expressed in basis points.
    implied_strike_percent : float
        The strike rate implied in the market value and used to compute
        ImpliedVolatilityBp  and  ImpliedVolatilityPercent  . The value is
        expressed in percentages.
    underlying_swap_data_object : any
        The object with the underlying swap properties. For a detailed
        breakdown, please refer here.
    """

    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z)."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., 2021-01-01T00:00:00Z)."""
    implied_volatility_percent: Optional[float] = rest_field(name="impliedVolatilityPercent")
    """The implied volatility of the option at the expiration of the option extracted from
     Black-Scholes Model. The value is expressed in percentages."""
    implied_volatility_bp: Optional[float] = rest_field(name="impliedVolatilityBp")
    """The implied volatility of the option extracted from the Normal Bachelier Model. The value is
     expressed in basis points."""
    implied_strike_percent: Optional[float] = rest_field(name="impliedStrikePercent")
    """The strike rate implied in the market value and used to compute  ImpliedVolatilityBp  and
     ImpliedVolatilityPercent  . The value is expressed in percentages."""
    underlying_swap_data_object: Optional[Any] = rest_field(name="underlyingSwapDataObject")
    """The object with the underlying swap properties.
     For a detailed breakdown, please refer here."""

    @overload
    def __init__(
        self,
        *,
        market_data_date: Optional[datetime.datetime] = None,
        valuation_date: Optional[datetime.datetime] = None,
        implied_volatility_percent: Optional[float] = None,
        implied_volatility_bp: Optional[float] = None,
        implied_strike_percent: Optional[float] = None,
        underlying_swap_data_object: Optional[Any] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionPricingParameters(_model_base.Model):
    """SwaptionPricingParameters.

    Attributes
    ----------
    calibrate_on_matching_expiries : bool
        A flag indicating if a filter should be applied to volatility surface.
        Possible values are:

        * True: maturiry filter will be applied in order to use only a sub set of the volatility
        surface.
        * False: no filter applied. will use the full cube to price the contract.
    exercise_date : ~datetime.datetime
        The date when the option can be exercised. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.
        2021-01-01T00:00:00Z). Available for Bermudan swaptions.
    implied_volatility_bp : float
        User defined implied normal volatility, expressed in basis points.
    implied_volatility_percent : float
        User defined implied lognormal volatility, expressed in percent.
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).
        Optional. By default, marketDataDate is valuationDate or today.
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency. Optional. No default value applies. Note that Premium takes
        priority over Volatility input.
    nb_iterations : int
        The number of steps for the Bermudan swaption pricing via the Hull-
        White One-Factor (HW1F) tree. The default value is '80'.
    price_side : str or ~analyticsapi.models.PriceSideEnum
        The quoted price side of the instrument. The way to select a price side
        of the curves used to value the contract. Optional. Default value is
        'Mid'. Known values are: "Mid", "Bid", "Ask", and "Last".
    report_ccy : str
        The currency code set for the fields ending with 'xxxInReportCcy'. The
        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
        Optional. No default value applies.
    simulate_exercise : bool
        An indicator if the option should be assumed to be exercised or not.
        The possible values:

        * True: the option is exercised,
        * False: the option is not exercised.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    """

    calibrate_on_matching_expiries: Optional[bool] = rest_field(name="calibrateOnMatchingExpiries")
    """A flag indicating if a filter should be applied to volatility surface. Possible values are:
     
     
     * True: maturiry filter will be applied in order to use only a sub set of the volatility
     surface.
     * False: no filter applied. will use the full cube to price the contract."""
    exercise_date: Optional[datetime.datetime] = rest_field(name="exerciseDate", format="rfc3339")
    """The date when the option can be exercised. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z). Available for Bermudan swaptions."""
    implied_volatility_bp: Optional[float] = rest_field(name="impliedVolatilityBp")
    """User defined implied normal volatility, expressed in basis points."""
    implied_volatility_percent: Optional[float] = rest_field(name="impliedVolatilityPercent")
    """User defined implied lognormal volatility, expressed in percent."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It should be less or equal to
     valuationDate).
     Optional. By default, marketDataDate is valuationDate or today."""
    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency.
     Optional. No default value applies. Note that Premium takes priority over Volatility input."""
    nb_iterations: Optional[int] = rest_field(name="nbIterations")
    """The number of steps for the Bermudan swaption pricing via the Hull-White One-Factor (HW1F)
     tree.
     The default value is '80'."""
    price_side: Optional[Union[str, "_models.PriceSideEnum"]] = rest_field(name="priceSide")
    """The quoted price side of the instrument.
     The way to select a price side of the curves used to value the contract.
     Optional. Default value is 'Mid'. Known values are: \"Mid\", \"Bid\", \"Ask\", and \"Last\"."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with 'xxxInReportCcy'. The value is expressed in
     ISO 4217 alphabetical format (e.g., 'USD').
     Optional. No default value applies."""
    simulate_exercise: Optional[bool] = rest_field(name="simulateExercise")
    """An indicator if the option should be assumed to be exercised or not. The possible values:
     
     
     * True: the option is exercised,
     * False: the option is not exercised."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""

    @overload
    def __init__(
        self,
        *,
        calibrate_on_matching_expiries: Optional[bool] = None,
        exercise_date: Optional[datetime.datetime] = None,
        implied_volatility_bp: Optional[float] = None,
        implied_volatility_percent: Optional[float] = None,
        market_data_date: Optional[datetime.datetime] = None,
        market_value_in_deal_ccy: Optional[float] = None,
        nb_iterations: Optional[int] = None,
        price_side: Optional[Union[str, "_models.PriceSideEnum"]] = None,
        report_ccy: Optional[str] = None,
        simulate_exercise: Optional[bool] = None,
        valuation_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionValuation(_model_base.Model):
    """Valuation Object.

    Attributes
    ----------
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency.
    market_value_in_report_ccy : float
        The market value of the instrument. The value is expressed in the
        reporting currency.
    premium_percent : float
        The premium paid by the option buyer to the option seller. The value is
        expressed in percentages.
    premium_bp : float
        The price of an option computed as  [PremiumPercent  * 100]. The value
        is expressed in basis points.
    forward_premium_in_deal_ccy : float
        The forward price of an option expressed in the deal currency.
    forward_premium_percent : float
        The forward price of an option computed as [ForwardPremiumInDealCcy  /
        NotionalAmount].  The value is expressed in percentages.
    forward_premium_bp : float
        The forward price of an option computed as  [ForwardPremiumPercent  *
        100]. The value is expressed in basis points.
    """

    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value of the instrument. The value is expressed in the reporting currency."""
    premium_percent: Optional[float] = rest_field(name="premiumPercent")
    """The premium paid by the option buyer to the option seller. The value is expressed in
     percentages."""
    premium_bp: Optional[float] = rest_field(name="premiumBp")
    """The price of an option computed as  [PremiumPercent  * 100]. The value is expressed in basis
     points."""
    forward_premium_in_deal_ccy: Optional[float] = rest_field(name="forwardPremiumInDealCcy")
    """The forward price of an option expressed in the deal currency."""
    forward_premium_percent: Optional[float] = rest_field(name="forwardPremiumPercent")
    """The forward price of an option computed as  [ForwardPremiumInDealCcy  /  NotionalAmount].  The
     value is expressed in percentages."""
    forward_premium_bp: Optional[float] = rest_field(name="forwardPremiumBp")
    """The forward price of an option computed as  [ForwardPremiumPercent  * 100]. The value is
     expressed in basis points."""

    @overload
    def __init__(
        self,
        *,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
        premium_percent: Optional[float] = None,
        premium_bp: Optional[float] = None,
        forward_premium_in_deal_ccy: Optional[float] = None,
        forward_premium_percent: Optional[float] = None,
        forward_premium_bp: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionVolatility(_model_base.Model):
    """SwaptionVolatility.

    Attributes
    ----------
    value_type : str
        Is either a Literal["ABS"] type or a Literal["REL"] type.
    values_property : list[~analyticsapi.models.SwaptionVolItem]
        The default value is None, needs to be assigned before using.
    """

    value_type: Optional[Literal["ABS", "REL"]] = rest_field(name="valueType")
    """Is either a Literal[\"ABS\"] type or a Literal[\"REL\"] type."""
    values_property: Optional[List["_models.SwaptionVolItem"]] = rest_field(name="values")

    @overload
    def __init__(
        self,
        *,
        value_type: Optional[Literal["ABS", "REL"]] = None,
        values_property: Optional[List["_models.SwaptionVolItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SwaptionVolItem(_model_base.Model):
    """SwaptionVolItem.

    Attributes
    ----------
    expiration : ~decimal.Decimal
    value : ~decimal.Decimal
    term : ~decimal.Decimal
    """

    expiration: Optional[decimal.Decimal] = rest_field()
    value: Optional[decimal.Decimal] = rest_field()
    term: Optional[decimal.Decimal] = rest_field()

    @overload
    def __init__(
        self,
        *,
        expiration: Optional[decimal.Decimal] = None,
        value: Optional[decimal.Decimal] = None,
        term: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SyntheticInstrumentDefinition(_model_base.Model):
    """SyntheticInstrumentDefinition.

    Attributes
    ----------
    instrument_code : str
        The code used to define the instrument.
    synthetic_instrument_code : str
        The code used to define the formula.
    template : str
        A reference to a style used to define the instrument.
    tenor : str
        The code indicating the instrument tenor (e.g., '6M', '1Y').
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument."""
    synthetic_instrument_code: Optional[str] = rest_field(name="syntheticInstrumentCode")
    """The code used to define the formula."""
    template: Optional[str] = rest_field()
    """A reference to a style used to define the instrument."""
    tenor: Optional[str] = rest_field()
    """The code indicating the instrument tenor (e.g., '6M', '1Y')."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        synthetic_instrument_code: Optional[str] = None,
        template: Optional[str] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class SystemScenario(_model_base.Model):
    """SystemScenario.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    name : str
        Required. Is one of the following types: Literal["BEARSTEEP50"],
        Literal["BEARFLAT50"], Literal["BULLFLAT50"], Literal["BULLSTEEP50"],
        Literal["BEARSTEEP100"], Literal["BEARFLAT100"],
        Literal["BULLFLAT100"], Literal["BULLSTEEP100"],
        Literal["SHORTEND1PLUS25"], Literal["SHORTEND1MINUS25"],
        Literal["SHORTEND2PLUS25"], Literal["SHORTEND2MINUS25"],
        Literal["SHORTEND3PLUS25"], Literal["SHORTEND3MINUS25"],
        Literal["LONGEND5PLUS25"], Literal["LONGEND5MINUS25"],
        Literal["LONGEND10PLUS25"], Literal["LONGEND10MINUS25"],
        Literal["LONGEND30PLUS25"], Literal["LONGEND30MINUS25"],
        Literal["YR20PLUS25"], Literal["YR20MINUS25"], Literal["PC1MOCOMP1UP"],
        Literal["PC1MOCOMP2UP"], Literal["PC1MOCOMP3UP"],
        Literal["PC1MOCOMP1DOWN"], Literal["PC1MOCOMP2DOWN"],
        Literal["PC1MOCOMP3DOWN"], Literal["PC3MOCOMP1UP"],
        Literal["PC3MOCOMP2UP"], Literal["PC3MOCOMP3UP"],
        Literal["PC3MOCOMP1DOWN"], Literal["PC3MOCOMP2DOWN"],
        Literal["PC3MOCOMP3DOWN"], Literal["PC6MOCOMP1UP"],
        Literal["PC6MOCOMP2UP"], Literal["PC6MOCOMP3UP"],
        Literal["PC6MOCOMP1DOWN"], Literal["PC6MOCOMP2DOWN"],
        Literal["PC6MOCOMP3DOWN"], Literal["PC1YRCOMP1UP"],
        Literal["PC1YRCOMP2UP"], Literal["PC1YRCOMP3UP"],
        Literal["PC1YRCOMP1DOWN"], Literal["PC1YRCOMP2DOWN"],
        Literal["PC1YRCOMP3DOWN"], Literal["IRRBBFLAT"],
        Literal["IRRBBPARDOWN"], Literal["IRRBBPARUP"],
        Literal["IRRBBSHORTDOWN"], Literal["IRRBBSHORTUP"],
        Literal["IRRBBSTEEP"], Literal["IRRBB26FLAT"],
        Literal["IRRBB26PARDOWN"], Literal["IRRBB26PARUP"],
        Literal["IRRBB26SHORTDOWN"], Literal["IRRBB26SHORTUP"],
        Literal["IRRBB26STEEP"]
    """

    name: Literal[
        "BEARSTEEP50",
        "BEARFLAT50",
        "BULLFLAT50",
        "BULLSTEEP50",
        "BEARSTEEP100",
        "BEARFLAT100",
        "BULLFLAT100",
        "BULLSTEEP100",
        "SHORTEND1PLUS25",
        "SHORTEND1MINUS25",
        "SHORTEND2PLUS25",
        "SHORTEND2MINUS25",
        "SHORTEND3PLUS25",
        "SHORTEND3MINUS25",
        "LONGEND5PLUS25",
        "LONGEND5MINUS25",
        "LONGEND10PLUS25",
        "LONGEND10MINUS25",
        "LONGEND30PLUS25",
        "LONGEND30MINUS25",
        "YR20PLUS25",
        "YR20MINUS25",
        "PC1MOCOMP1UP",
        "PC1MOCOMP2UP",
        "PC1MOCOMP3UP",
        "PC1MOCOMP1DOWN",
        "PC1MOCOMP2DOWN",
        "PC1MOCOMP3DOWN",
        "PC3MOCOMP1UP",
        "PC3MOCOMP2UP",
        "PC3MOCOMP3UP",
        "PC3MOCOMP1DOWN",
        "PC3MOCOMP2DOWN",
        "PC3MOCOMP3DOWN",
        "PC6MOCOMP1UP",
        "PC6MOCOMP2UP",
        "PC6MOCOMP3UP",
        "PC6MOCOMP1DOWN",
        "PC6MOCOMP2DOWN",
        "PC6MOCOMP3DOWN",
        "PC1YRCOMP1UP",
        "PC1YRCOMP2UP",
        "PC1YRCOMP3UP",
        "PC1YRCOMP1DOWN",
        "PC1YRCOMP2DOWN",
        "PC1YRCOMP3DOWN",
        "IRRBBFLAT",
        "IRRBBPARDOWN",
        "IRRBBPARUP",
        "IRRBBSHORTDOWN",
        "IRRBBSHORTUP",
        "IRRBBSTEEP",
        "IRRBB26FLAT",
        "IRRBB26PARDOWN",
        "IRRBB26PARUP",
        "IRRBB26SHORTDOWN",
        "IRRBB26SHORTUP",
        "IRRBB26STEEP",
    ] = rest_field()
    """Required. Is one of the following types: Literal[\"BEARSTEEP50\"], Literal[\"BEARFLAT50\"],
     Literal[\"BULLFLAT50\"], Literal[\"BULLSTEEP50\"], Literal[\"BEARSTEEP100\"],
     Literal[\"BEARFLAT100\"], Literal[\"BULLFLAT100\"], Literal[\"BULLSTEEP100\"],
     Literal[\"SHORTEND1PLUS25\"], Literal[\"SHORTEND1MINUS25\"], Literal[\"SHORTEND2PLUS25\"],
     Literal[\"SHORTEND2MINUS25\"], Literal[\"SHORTEND3PLUS25\"], Literal[\"SHORTEND3MINUS25\"],
     Literal[\"LONGEND5PLUS25\"], Literal[\"LONGEND5MINUS25\"], Literal[\"LONGEND10PLUS25\"],
     Literal[\"LONGEND10MINUS25\"], Literal[\"LONGEND30PLUS25\"], Literal[\"LONGEND30MINUS25\"],
     Literal[\"YR20PLUS25\"], Literal[\"YR20MINUS25\"], Literal[\"PC1MOCOMP1UP\"],
     Literal[\"PC1MOCOMP2UP\"], Literal[\"PC1MOCOMP3UP\"], Literal[\"PC1MOCOMP1DOWN\"],
     Literal[\"PC1MOCOMP2DOWN\"], Literal[\"PC1MOCOMP3DOWN\"], Literal[\"PC3MOCOMP1UP\"],
     Literal[\"PC3MOCOMP2UP\"], Literal[\"PC3MOCOMP3UP\"], Literal[\"PC3MOCOMP1DOWN\"],
     Literal[\"PC3MOCOMP2DOWN\"], Literal[\"PC3MOCOMP3DOWN\"], Literal[\"PC6MOCOMP1UP\"],
     Literal[\"PC6MOCOMP2UP\"], Literal[\"PC6MOCOMP3UP\"], Literal[\"PC6MOCOMP1DOWN\"],
     Literal[\"PC6MOCOMP2DOWN\"], Literal[\"PC6MOCOMP3DOWN\"], Literal[\"PC1YRCOMP1UP\"],
     Literal[\"PC1YRCOMP2UP\"], Literal[\"PC1YRCOMP3UP\"], Literal[\"PC1YRCOMP1DOWN\"],
     Literal[\"PC1YRCOMP2DOWN\"], Literal[\"PC1YRCOMP3DOWN\"], Literal[\"IRRBBFLAT\"],
     Literal[\"IRRBBPARDOWN\"], Literal[\"IRRBBPARUP\"], Literal[\"IRRBBSHORTDOWN\"],
     Literal[\"IRRBBSHORTUP\"], Literal[\"IRRBBSTEEP\"], Literal[\"IRRBB26FLAT\"],
     Literal[\"IRRBB26PARDOWN\"], Literal[\"IRRBB26PARUP\"], Literal[\"IRRBB26SHORTDOWN\"],
     Literal[\"IRRBB26SHORTUP\"], Literal[\"IRRBB26STEEP\"]"""

    @overload
    def __init__(
        self,
        name: Literal[
            "BEARSTEEP50",
            "BEARFLAT50",
            "BULLFLAT50",
            "BULLSTEEP50",
            "BEARSTEEP100",
            "BEARFLAT100",
            "BULLFLAT100",
            "BULLSTEEP100",
            "SHORTEND1PLUS25",
            "SHORTEND1MINUS25",
            "SHORTEND2PLUS25",
            "SHORTEND2MINUS25",
            "SHORTEND3PLUS25",
            "SHORTEND3MINUS25",
            "LONGEND5PLUS25",
            "LONGEND5MINUS25",
            "LONGEND10PLUS25",
            "LONGEND10MINUS25",
            "LONGEND30PLUS25",
            "LONGEND30MINUS25",
            "YR20PLUS25",
            "YR20MINUS25",
            "PC1MOCOMP1UP",
            "PC1MOCOMP2UP",
            "PC1MOCOMP3UP",
            "PC1MOCOMP1DOWN",
            "PC1MOCOMP2DOWN",
            "PC1MOCOMP3DOWN",
            "PC3MOCOMP1UP",
            "PC3MOCOMP2UP",
            "PC3MOCOMP3UP",
            "PC3MOCOMP1DOWN",
            "PC3MOCOMP2DOWN",
            "PC3MOCOMP3DOWN",
            "PC6MOCOMP1UP",
            "PC6MOCOMP2UP",
            "PC6MOCOMP3UP",
            "PC6MOCOMP1DOWN",
            "PC6MOCOMP2DOWN",
            "PC6MOCOMP3DOWN",
            "PC1YRCOMP1UP",
            "PC1YRCOMP2UP",
            "PC1YRCOMP3UP",
            "PC1YRCOMP1DOWN",
            "PC1YRCOMP2DOWN",
            "PC1YRCOMP3DOWN",
            "IRRBBFLAT",
            "IRRBBPARDOWN",
            "IRRBBPARUP",
            "IRRBBSHORTDOWN",
            "IRRBBSHORTUP",
            "IRRBBSTEEP",
            "IRRBB26FLAT",
            "IRRBB26PARDOWN",
            "IRRBB26PARUP",
            "IRRBB26SHORTDOWN",
            "IRRBB26SHORTUP",
            "IRRBB26STEEP",
        ],
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["name"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class TenorBasisSwapConstituent(IrConstituent, discriminator="TenorBasisSwap"):
    """An object defining a tenor basis swap constituent of an interest rate curve.

    Readonly variables are only populated by the server, and will be ignored when sending a request.

    Attributes
    ----------
    index : str
        This is the reference Index of the curve that the constituent
        contributes to. For instance (e.g. LIBOR 3M). Required.
    quote : ~analyticsapi.models.Quote
        An object to define the quote of the instrument used as a constituent.
        Required.
    status : list[str]
        A message is returned if the constituent cannot be identified, or
        access for a user to the instrument used as a constituent is denied.
    type : str or ~analyticsapi.models.TENOR_BASIS_SWAP
        The type of constituent. TenorBasisSwap is the only valid value.
        Required.
    definition : ~analyticsapi.models.TenorBasisSwapConstituentDefinition
        An object to define the tenor basis swap used as a constituent.
        Required.
    """

    type: Literal[IrConstituentEnum.TENOR_BASIS_SWAP] = rest_discriminator(name="type")  # type: ignore
    """The type of constituent. TenorBasisSwap is the only valid value. Required."""
    definition: "_models.TenorBasisSwapConstituentDefinition" = rest_field()
    """An object to define the tenor basis swap used as a constituent. Required."""

    @overload
    def __init__(
        self,
        *,
        index: str,
        quote: "_models.Quote",
        definition: "_models.TenorBasisSwapConstituentDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, type=IrConstituentEnum.TENOR_BASIS_SWAP, **kwargs)


class TenorBasisSwapConstituentDefinition(_model_base.Model):
    """The definition of a tenor basis swap instrument used as a constituent of an interest rate
    curve.

    Attributes
    ----------
    tenor : str
        The code indicating the tenor of the instrument used as a constituent
        (e.g., '1M', '1Y'). Required.
    template : str
        A pre-defined template can be used as an input by the user. It is the
        currency code of the constituent. Required.
    """

    tenor: str = rest_field()
    """The code indicating the tenor of the instrument used as a constituent (e.g., '1M', '1Y').
     Required."""
    template: str = rest_field()
    """A pre-defined template can be used as an input by the user. It is the currency code of the
     constituent. Required."""

    @overload
    def __init__(
        self,
        *,
        tenor: str,
        template: str,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TenorBasisSwapOverride(_model_base.Model):
    """An object that contains the tenor basis swap properties that can be overridden.

    Attributes
    ----------
    start_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the tenor basis
        swap start date.
    end_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the tenor basis
        swap end date.
    amount : float
        The principal amount of the tenor basis swap.
    first_spread : ~analyticsapi.models.Rate
    second_spread : ~analyticsapi.models.Rate
    paid_leg : str or ~analyticsapi.models.PaidLegEnum
        A flag that defines whether the first leg or the second leg of the
        tenor basis swap is paid. Known values are: "FirstLeg" and "SecondLeg".
    """

    start_date: Optional["_models.Date"] = rest_field(name="startDate")
    """An object that contains properties to define and adjust the tenor basis swap start date."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """An object that contains properties to define and adjust the tenor basis swap end date."""
    amount: Optional[float] = rest_field()
    """The principal amount of the tenor basis swap."""
    first_spread: Optional["_models.Rate"] = rest_field(name="firstSpread")
    second_spread: Optional["_models.Rate"] = rest_field(name="secondSpread")
    paid_leg: Optional[Union[str, "_models.PaidLegEnum"]] = rest_field(name="paidLeg")
    """A flag that defines whether the first leg or the second leg of the tenor basis swap is paid.
     Known values are: \"FirstLeg\" and \"SecondLeg\"."""

    @overload
    def __init__(
        self,
        *,
        start_date: Optional["_models.Date"] = None,
        end_date: Optional["_models.Date"] = None,
        amount: Optional[float] = None,
        first_spread: Optional["_models.Rate"] = None,
        second_spread: Optional["_models.Rate"] = None,
        paid_leg: Optional[Union[str, "_models.PaidLegEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TenorBasisSwapTemplateDefinition(InstrumentTemplateDefinition, discriminator="TenorBasisSwap"):
    """TenorBasisSwapTemplateDefinition.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.TENOR_BASIS_SWAP
        Required. A tenor basis swap contract.
    template : ~analyticsapi.models.IrSwapDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.TENOR_BASIS_SWAP] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. A tenor basis swap contract."""
    template: "_models.IrSwapDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.IrSwapDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.TENOR_BASIS_SWAP, **kwargs)


class TermAndValue(_model_base.Model):
    """TermAndValue.

    Attributes
    ----------
    term : int
    value : ~decimal.Decimal
    """

    term: Optional[int] = rest_field()
    value: Optional[decimal.Decimal] = rest_field()

    @overload
    def __init__(
        self,
        *,
        term: Optional[int] = None,
        value: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermDepositAnalyticsResponseData(_model_base.Model):
    """TermDepositAnalyticsResponseData.

    Attributes
    ----------
    definitions : list[~analyticsapi.models.TermDepositDefinitionInstrument]
        An array of objects describing a curve or an instrument. Please provide
        either a full definition (for a user-defined curve/instrument), or
        reference to a curve/instrument definition saved in the platform, or
        the code identifying the existing curve/instrument.  The default value
        is None, needs to be assigned before using.
    pricing_preferences : ~analyticsapi.models.TermDepositPricingParameters
        The parameters that control the computation of the analytics.
    analytics : list[~analyticsapi.models.TermDepositAnalyticsResponseWithError]
        The result of the calculation request.  The default value is None,
        needs to be assigned before using.
    market_data : ~analyticsapi.models.MarketDataQps
        The market data used to compute the analytics.
    """

    definitions: Optional[List["_models.TermDepositDefinitionInstrument"]] = rest_field()
    """An array of objects describing a curve or an instrument.
     Please provide either a full definition (for a user-defined curve/instrument), or reference to
     a curve/instrument definition saved in the platform, or the code identifying the existing
     curve/instrument."""
    pricing_preferences: Optional["_models.TermDepositPricingParameters"] = rest_field(name="pricingPreferences")
    """The parameters that control the computation of the analytics."""
    analytics: Optional[List["_models.TermDepositAnalyticsResponseWithError"]] = rest_field()
    """The result of the calculation request."""
    market_data: Optional["_models.MarketDataQps"] = rest_field(name="marketData")
    """The market data used to compute the analytics."""

    @overload
    def __init__(
        self,
        *,
        definitions: Optional[List["_models.TermDepositDefinitionInstrument"]] = None,
        pricing_preferences: Optional["_models.TermDepositPricingParameters"] = None,
        analytics: Optional[List["_models.TermDepositAnalyticsResponseWithError"]] = None,
        market_data: Optional["_models.MarketDataQps"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermDepositAnalyticsResponseWithError(_model_base.Model):
    """A model template describing a response with an error for a given object.

    Attributes
    ----------
    tabular_data : ~analyticsapi.models.FinancialContractResponse
        Standard Financial Contract Analytics in tabular format.
    cashflows : ~analyticsapi.models.TermDepositCashflows
        Response categorized under Cashflows.
    description : ~analyticsapi.models.TermDepositDescription
        Response categorized under Description.
    nominal_measures : ~analyticsapi.models.TermDepositNominalMeasures
        Response categorized under Nominal measures.
    pricing_analysis : ~analyticsapi.models.TermDepositPricingAnalysis
        Response categorized under Pricing analysis.
    valuation : ~analyticsapi.models.TermDepositValuation
        Response categorized under Valuation.
    error : ~analyticsapi.models.ServiceError
        The error message for the calculation in case of a non-blocking error.
    """

    tabular_data: Optional["_models.FinancialContractResponse"] = rest_field(name="tabularData")
    """Standard Financial Contract Analytics in tabular format."""
    cashflows: Optional["_models.TermDepositCashflows"] = rest_field()
    """Response categorized under Cashflows."""
    description: Optional["_models.TermDepositDescription"] = rest_field()
    """Response categorized under Description."""
    nominal_measures: Optional["_models.TermDepositNominalMeasures"] = rest_field(name="nominalMeasures")
    """Response categorized under Nominal measures."""
    pricing_analysis: Optional["_models.TermDepositPricingAnalysis"] = rest_field(name="pricingAnalysis")
    """Response categorized under Pricing analysis."""
    valuation: Optional["_models.TermDepositValuation"] = rest_field()
    """Response categorized under Valuation."""
    error: Optional["_models.ServiceError"] = rest_field()
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        tabular_data: Optional["_models.FinancialContractResponse"] = None,
        cashflows: Optional["_models.TermDepositCashflows"] = None,
        description: Optional["_models.TermDepositDescription"] = None,
        nominal_measures: Optional["_models.TermDepositNominalMeasures"] = None,
        pricing_analysis: Optional["_models.TermDepositPricingAnalysis"] = None,
        valuation: Optional["_models.TermDepositValuation"] = None,
        error: Optional["_models.ServiceError"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermDepositCalculationResponse(_model_base.Model):
    """A model template describing the analytics response returned for an instrument provided as part
    of the request.

    Attributes
    ----------
    data : ~analyticsapi.models.TermDepositAnalyticsResponseData
        An object that contains calculated analytics, requested, and other data
        used for calculation. Required.
    """

    data: "_models.TermDepositAnalyticsResponseData" = rest_field()
    """An object that contains calculated analytics, requested, and other data used for calculation.
     Required."""

    @overload
    def __init__(
        self,
        data: "_models.TermDepositAnalyticsResponseData",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class TermDepositCashflows(_model_base.Model):
    """Cashflows Object.

    Attributes
    ----------
    interest_amount_in_deal_ccy : float
        The amount of interest payments. The value is expressed in the deal
        currency. For more details on the field calculation, please refer here.
    interest_amount_in_report_ccy : float
        The amount of interest payments. The value is expressed in the
        reporting currency.
    repayment_amount_in_deal_ccy : float
        The total amount settled at maturity. The value is expressed in the
        deal currency. For more details on the field calculation, please refer
        here.
    repayment_amount_in_report_ccy : float
        The total amount settled at maturity. The value is expressed in the
        reporting currency.
    cash_flows : list[any]
        The information on the contract's cash flows during its lifetime. It
        consists of the following properties:

        * instrumentType: the instrument type for which cash flows are computed,
        * payments: the array of properties which define all instruments cash flows (paid and received)
        during its lifetime.

        For more details, please refer here.
        For more details on the field calculation, please refer here.  The default value is None, needs
        to be assigned before using.
    """

    interest_amount_in_deal_ccy: Optional[float] = rest_field(name="interestAmountInDealCcy")
    """The amount of interest payments. The value is expressed in the deal currency.
     For more details on the field calculation, please refer here."""
    interest_amount_in_report_ccy: Optional[float] = rest_field(name="interestAmountInReportCcy")
    """The amount of interest payments. The value is expressed in the reporting currency."""
    repayment_amount_in_deal_ccy: Optional[float] = rest_field(name="repaymentAmountInDealCcy")
    """The total amount settled at maturity. The value is expressed in the deal currency.
     For more details on the field calculation, please refer here."""
    repayment_amount_in_report_ccy: Optional[float] = rest_field(name="repaymentAmountInReportCcy")
    """The total amount settled at maturity. The value is expressed in the reporting currency."""
    cash_flows: Optional[List[Any]] = rest_field(name="cashFlows")
    """The information on the contract's cash flows during its lifetime. It consists of the following
     properties:
     
     
     * instrumentType: the instrument type for which cash flows are computed,
     * payments: the array of properties which define all instruments cash flows (paid and received)
     during its lifetime.
     
     For more details, please refer here.
     For more details on the field calculation, please refer here."""

    @overload
    def __init__(
        self,
        *,
        interest_amount_in_deal_ccy: Optional[float] = None,
        interest_amount_in_report_ccy: Optional[float] = None,
        repayment_amount_in_deal_ccy: Optional[float] = None,
        repayment_amount_in_report_ccy: Optional[float] = None,
        cash_flows: Optional[List[Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermDepositDefinition(_model_base.Model):
    """TermDepositDefinition.

    Attributes
    ----------
    calendar : str
        Deprecated, please use 'paymentBusinessDays'.
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). If no instrumentCode is defined, either tenor
        or endDate must be provided. If instrumentCode is defined, the value
        comes from the instrument reference data.
    fixed_rate_percent : float
        The interest rate of the instrument. The value is expressed in
        percentages. Mandatory if no instrumentCode is defined. If
        instrumentCode is defined, the value comes from the instrument
        reference data.
    instrument_code : str
        The code used to define the instrument. The possible values for each
        asset type are listed here. Mandatory if no user-defined instrument
        data is provided.
    instrument_tag : str
        A user-defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    interest_calculation_method : str or ~analyticsapi.models.InterestCalculationMethodEnum
        The day count basis method used to calculate the interest payments.
        Mandatory if no instrumentCode is defined. If instrumentCode is
        defined, the value comes from the instrument reference data. Known
        values are: "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German",
        "Dcb_30_360_ISDA", "Dcb_30_365_ISDA", "Dcb_30_365_German",
        "Dcb_30_365_Brazil", "Dcb_30_Actual_German", "Dcb_30_Actual",
        "Dcb_30_Actual_ISDA", "Dcb_30E_360_ISMA", "Dcb_Actual_360",
        "Dcb_Actual_364", "Dcb_Actual_365", "Dcb_Actual_Actual",
        "Dcb_Actual_Actual_ISDA", "Dcb_Actual_Actual_AFB",
        "Dcb_WorkingDays_252", "Dcb_Actual_365L", "Dcb_Actual_365P",
        "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360", "Dcb_Actual_36525",
        "Dcb_Actual_365_CanadianConvention", and "Dcb_Constant".
    interest_payment_frequency : str or ~analyticsapi.models.InterestPaymentFrequencyEnum
        The frequency of the interest payment. The default value is zero. Known
        values are: "Annual", "SemiAnnual", "Quarterly", "Monthly",
        "BiMonthly", "Everyday", "EveryWorkingDay", "Every7Days",
        "Every14Days", "Every28Days", "Every30Days", "Every91Days",
        "Every182Days", "Every364Days", "Every365Days", "Every90Days",
        "Every92Days", "Every93Days", "Every180Days", "Every183Days",
        "Every184Days", "Every4Months", "R2", "R4", "Zero", and "Scheduled".
    notional_amount : float
        The notional amount of the instrument. The default value is
        '1,000,000'.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g. 'USD'). Mandatory if no
        instrumentCode is defined. If instrumentCode is defined, the value
        comes from the instrument reference data.
    payment_business_day_convention : str or ~analyticsapi.models.PaymentBusinessDayConventionEnum
        The method to adjust dates to a working day. Optional. By Default
        'ModifiedFollowing'. Known values are: "ModifiedFollowing",
        "NextBusinessDay", "PreviousBusinessDay", "NoMoving",
        "EveryThirdWednesday", and "BbswModifiedFollowing".
    payment_business_days : str
        A comma-separated calendar code used to adjust dates(e.g., 'EMU' or
        'USA'). The default value is the calendar associated to the market
        conventions of NotionalCcy.
    payment_roll_convention : str or ~analyticsapi.models.PaymentRollConventionEnum
        Method to adjust payment dates when they fall at the end of the month
        (28th of February, 30th, 31st). Optional. By Default 'Last'. Known
        values are: "Last", "Same", "Same1", "Last28", and "Same28".
    start_date : ~datetime.datetime
        The start date of the instrument. The value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g. 2021-01-01T00:00:00Z). The
        default value is valuationDate shifted forward by a spot lag using
        money market conventions.
    start_tenor : str
        The code indicating the period from a spot date to startDate of the
        instrument (e.g., '1M'). Either startDate or startTenor can be
        specified, but not both.
    tenor : str
        The code indicating the period between StartDate and EndDate of the
        instrument (e.g. '6M', '1Y'). If no instrumentCode is defined, either
        tenor or endDate must be provided. If instrumentCode is defined, the
        value comes from the instrument reference data.
    year_basis : str or ~analyticsapi.models.FinancialContractYearBasisEnum
        Deprecated, please use 'interestCalculationMethod'. Known values are:
        "Dcb_30_360", "Dcb_30_360_US", "Dcb_30_360_German", "Dcb_30_360_ISDA",
        "Dcb_30_365_ISDA", "Dcb_30_365_German", "Dcb_30_365_Brazil",
        "Dcb_30_Actual_German", "Dcb_30_Actual", "Dcb_30_Actual_ISDA",
        "Dcb_30E_360_ISMA", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_Actual", "Dcb_Actual_Actual_ISDA",
        "Dcb_Actual_Actual_AFB", "Dcb_WorkingDays_252", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_ActualLeapDay_365", "Dcb_ActualLeapDay_360",
        "Dcb_Actual_36525", "Dcb_Actual_365_CanadianConvention", and
        "Dcb_Constant".
    """

    calendar: Optional[str] = rest_field()
    """Deprecated, please use 'paymentBusinessDays'."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument.
     The value is expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
     '2021-01-01T00:00:00Z').
     If no instrumentCode is defined, either tenor or endDate must be provided.
     If instrumentCode is defined, the value comes from the instrument reference data."""
    fixed_rate_percent: Optional[float] = rest_field(name="fixedRatePercent")
    """The interest rate of the instrument.
     The value is expressed in percentages.
     Mandatory if no instrumentCode is defined.
     If instrumentCode is defined, the value comes from the instrument reference data."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument. The possible values for each asset type are listed
     here.
     Mandatory if no user-defined instrument data is provided."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user-defined string to identify the instrument.
     It can be used to link output results to the instrument definition. Limited to 40 characters.
     Only alphabetic, numeric and '- _.#=@' characters are supported."""
    interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = rest_field(
        name="interestCalculationMethod"
    )
    """The day count basis method used to calculate the interest payments.
     Mandatory if no instrumentCode is defined.
     If instrumentCode is defined, the value comes from the instrument reference data. Known values
     are: \"Dcb_30_360\", \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\",
     \"Dcb_30_365_ISDA\", \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\",
     \"Dcb_30_Actual\", \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\",
     \"Dcb_Actual_364\", \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\",
     \"Dcb_Actual_365_CanadianConvention\", and \"Dcb_Constant\"."""
    interest_payment_frequency: Optional[Union[str, "_models.InterestPaymentFrequencyEnum"]] = rest_field(
        name="interestPaymentFrequency"
    )
    """The frequency of the interest payment.
     The default value is zero. Known values are: \"Annual\", \"SemiAnnual\", \"Quarterly\",
     \"Monthly\", \"BiMonthly\", \"Everyday\", \"EveryWorkingDay\", \"Every7Days\", \"Every14Days\",
     \"Every28Days\", \"Every30Days\", \"Every91Days\", \"Every182Days\", \"Every364Days\",
     \"Every365Days\", \"Every90Days\", \"Every92Days\", \"Every93Days\", \"Every180Days\",
     \"Every183Days\", \"Every184Days\", \"Every4Months\", \"R2\", \"R4\", \"Zero\", and
     \"Scheduled\"."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument.
     The default value is '1,000,000'."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount.
     The value is expressed in ISO 4217 alphabetical format (e.g. 'USD').
     Mandatory if no instrumentCode is defined.
     If instrumentCode is defined, the value comes from the instrument reference data."""
    payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = rest_field(
        name="paymentBusinessDayConvention"
    )
    """The method to adjust dates to a working day.
     Optional. By Default 'ModifiedFollowing'. Known values are: \"ModifiedFollowing\",
     \"NextBusinessDay\", \"PreviousBusinessDay\", \"NoMoving\", \"EveryThirdWednesday\", and
     \"BbswModifiedFollowing\"."""
    payment_business_days: Optional[str] = rest_field(name="paymentBusinessDays")
    """A comma-separated calendar code used to adjust dates(e.g., 'EMU' or 'USA').
     The default value is the calendar associated to the market conventions of NotionalCcy."""
    payment_roll_convention: Optional[Union[str, "_models.PaymentRollConventionEnum"]] = rest_field(
        name="paymentRollConvention"
    )
    """Method to adjust payment dates when they fall at the end of the month (28th of February, 30th,
     31st).
     Optional. By Default 'Last'. Known values are: \"Last\", \"Same\", \"Same1\", \"Last28\", and
     \"Same28\"."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument.
     The value is expressed in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.
     2021-01-01T00:00:00Z).
     The default value is valuationDate shifted forward by a spot lag using money market
     conventions."""
    start_tenor: Optional[str] = rest_field(name="startTenor")
    """The code indicating the period from a spot date to startDate of the instrument (e.g., '1M').
     Either startDate or startTenor can be specified, but not both."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between StartDate and EndDate of the instrument (e.g. '6M',
     '1Y').
     If no instrumentCode is defined, either tenor or endDate must be provided.
     If instrumentCode is defined, the value comes from the instrument reference data."""
    year_basis: Optional[Union[str, "_models.FinancialContractYearBasisEnum"]] = rest_field(name="yearBasis")
    """Deprecated, please use 'interestCalculationMethod'. Known values are: \"Dcb_30_360\",
     \"Dcb_30_360_US\", \"Dcb_30_360_German\", \"Dcb_30_360_ISDA\", \"Dcb_30_365_ISDA\",
     \"Dcb_30_365_German\", \"Dcb_30_365_Brazil\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual\",
     \"Dcb_30_Actual_ISDA\", \"Dcb_30E_360_ISMA\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_ISDA\",
     \"Dcb_Actual_Actual_AFB\", \"Dcb_WorkingDays_252\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_ActualLeapDay_365\", \"Dcb_ActualLeapDay_360\", \"Dcb_Actual_36525\",
     \"Dcb_Actual_365_CanadianConvention\", and \"Dcb_Constant\"."""

    @overload
    def __init__(
        self,
        *,
        calendar: Optional[str] = None,
        end_date: Optional[datetime.datetime] = None,
        fixed_rate_percent: Optional[float] = None,
        instrument_code: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        interest_calculation_method: Optional[Union[str, "_models.InterestCalculationMethodEnum"]] = None,
        interest_payment_frequency: Optional[Union[str, "_models.InterestPaymentFrequencyEnum"]] = None,
        notional_amount: Optional[float] = None,
        notional_ccy: Optional[str] = None,
        payment_business_day_convention: Optional[Union[str, "_models.PaymentBusinessDayConventionEnum"]] = None,
        payment_business_days: Optional[str] = None,
        payment_roll_convention: Optional[Union[str, "_models.PaymentRollConventionEnum"]] = None,
        start_date: Optional[datetime.datetime] = None,
        start_tenor: Optional[str] = None,
        tenor: Optional[str] = None,
        year_basis: Optional[Union[str, "_models.FinancialContractYearBasisEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermDepositDefinitionInstrument(_model_base.Model):
    """An array of objects describing a curve or an instrument.
    Please provide either a full definition (for a user-defined curve/instrument), or reference to
    a curve/instrument definition saved in the platform, or the code identifying the existing
    curve/instrument.

    Attributes
    ----------
    definition : ~analyticsapi.models.TermDepositDefinition
        The object that describes the definition of the instrument.
    reference : str
        The identifier of a resource (instrument definition, curve definition)
        that is already in the platform.
    code : str
        The unique public code used to identify an instrument that exists on
        the market (ISIN, RIC, etc.).
    """

    definition: Optional["_models.TermDepositDefinition"] = rest_field()
    """The object that describes the definition of the instrument."""
    reference: Optional[str] = rest_field()
    """The identifier of a resource (instrument definition, curve definition) that is already in the
     platform."""
    code: Optional[str] = rest_field()
    """The unique public code used to identify an instrument that exists on the market (ISIN, RIC,
     etc.)."""

    @overload
    def __init__(
        self,
        *,
        definition: Optional["_models.TermDepositDefinition"] = None,
        reference: Optional[str] = None,
        code: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermDepositDescription(_model_base.Model):
    """Description Object.

    Attributes
    ----------
    instrument_type : str
        The type of instrument defined in the request. The possible values are
        listed  here  .
    instrument_code : str
        The code used to define the instrument. The possible values for each
        asset type are listed  here  .
    instrument_tag : str
        A user-defined string to identify the instrument. It can be used to
        link output results to the instrument definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    instrument_description : str
        The label that describes the instrument.
    notional_ccy : str
        The currency of the instrument's notional amount. The value is
        expressed in ISO 4217 alphabetical format (e.g.,  'USD  ').
    notional_amount : float
        The notional amount of the instrument.
    report_ccy : str
        The currency code set for the fields ending with '  xxxInReportCcy  '.
        The value is expressed in ISO 4217 alphabetical format (e.g., '  USD
        ').
    start_date : ~datetime.datetime
        The start date of the instrument. The value is expressed in ISO 8601
        format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ').
    end_date : ~datetime.datetime
        The maturity or expiry date of the instrument. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    tenor : str
        The code indicating the period between  StartDate  and  EndDate  of the
        instrument (e.g. '  6M  ',  '  1Y  ').
    interest_calculation_method : str
        The day count basis method used to calculate the interest payments. The
        possible values are listed  here  .
    error_code : str
        The code of  ErrorMessage  .
    error_message : str
        The error message in case of a blocking error in calculation.
    processing_information : str
        The error message for the calculation in case of a non-blocking error.
    """

    instrument_type: Optional[str] = rest_field(name="instrumentType")
    """The type of instrument defined in the request. The possible values are listed  here  ."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument. The possible values for each asset type are listed
     here  ."""
    instrument_tag: Optional[str] = rest_field(name="instrumentTag")
    """A user-defined string to identify the instrument. It can be used to link output results to the
     instrument definition. Limited to 40 characters. Only alphabetic, numeric and '- _.#=@'
     characters are supported."""
    instrument_description: Optional[str] = rest_field(name="instrumentDescription")
    """The label that describes the instrument."""
    notional_ccy: Optional[str] = rest_field(name="notionalCcy")
    """The currency of the instrument's notional amount. The value is expressed in ISO 4217
     alphabetical format (e.g.,  'USD  ')."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of the instrument."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code set for the fields ending with '  xxxInReportCcy  '. The value is expressed
     in ISO 4217 alphabetical format (e.g., '  USD  ')."""
    start_date: Optional[datetime.datetime] = rest_field(name="startDate", format="rfc3339")
    """The start date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    end_date: Optional[datetime.datetime] = rest_field(name="endDate", format="rfc3339")
    """The maturity or expiry date of the instrument. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between  StartDate  and  EndDate  of the instrument (e.g. '  6M
     ',  '  1Y  ')."""
    interest_calculation_method: Optional[str] = rest_field(name="interestCalculationMethod")
    """The day count basis method used to calculate the interest payments. The possible values are
     listed  here  ."""
    error_code: Optional[str] = rest_field(name="errorCode")
    """The code of  ErrorMessage  ."""
    error_message: Optional[str] = rest_field(name="errorMessage")
    """The error message in case of a blocking error in calculation."""
    processing_information: Optional[str] = rest_field(name="processingInformation")
    """The error message for the calculation in case of a non-blocking error."""

    @overload
    def __init__(
        self,
        *,
        instrument_type: Optional[str] = None,
        instrument_code: Optional[str] = None,
        instrument_tag: Optional[str] = None,
        instrument_description: Optional[str] = None,
        notional_ccy: Optional[str] = None,
        notional_amount: Optional[float] = None,
        report_ccy: Optional[str] = None,
        start_date: Optional[datetime.datetime] = None,
        end_date: Optional[datetime.datetime] = None,
        tenor: Optional[str] = None,
        interest_calculation_method: Optional[str] = None,
        error_code: Optional[str] = None,
        error_message: Optional[str] = None,
        processing_information: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermDepositNominalMeasures(_model_base.Model):
    """Nominal measures Object.

    Attributes
    ----------
    average_life : float
        The average remaining time to all principal instrument payments,
        weighted by the repayment amounts. It doesn't take into account
        interest payments. The value is expressed in years. For more details on
        the field calculation, please refer here.
    duration : float
        The weighted average maturity of all cash flows. The final cash flow
        includes the principal, which has a much greater weight than the
        intermediate cash flows. For more details on the field calculation,
        please refer here.
    modified_duration : float
        The measure of price sensitivity to a 100 basis points change in the
        instrument's yield, or 1% parallel shift in the underlying zero-coupon
        curve in case of interest rate swap instruments. For a floating rate
        instrument, it is computed as time to next payment. For more details on
        the field calculation, please refer here.
    convexity : float
        The measure of the curvature in the relationship between the
        instrument's price and yield. For more details on the field
        calculation, please refer here.
    dv01_bp : float
        The sensitivity of the market value to a 1bp parallel shift in the
        yield curve. The value is expressed in basis points. For more details
        on the field calculation, please refer here.
    """

    average_life: Optional[float] = rest_field(name="averageLife")
    """The average remaining time to all principal instrument payments, weighted by the repayment
     amounts. It doesn't take into account interest payments. The value is expressed in years.
     For more details on the field calculation, please refer here."""
    duration: Optional[float] = rest_field()
    """The weighted average maturity of all cash flows. The final cash flow includes the principal,
     which has a much greater weight than the intermediate cash flows.
     For more details on the field calculation, please refer here."""
    modified_duration: Optional[float] = rest_field(name="modifiedDuration")
    """The measure of price sensitivity to a 100 basis points change in the instrument's yield, or 1%
     parallel shift in the underlying zero-coupon curve in case of interest rate swap instruments.
     For a floating rate instrument, it is computed as time to next payment.
     For more details on the field calculation, please refer here."""
    convexity: Optional[float] = rest_field()
    """The measure of the curvature in the relationship between the instrument's price and yield.
     For more details on the field calculation, please refer here."""
    dv01_bp: Optional[float] = rest_field(name="dv01Bp")
    """The sensitivity of the market value to a 1bp parallel shift in the yield curve. The value is
     expressed in basis points.
     For more details on the field calculation, please refer here."""

    @overload
    def __init__(
        self,
        *,
        average_life: Optional[float] = None,
        duration: Optional[float] = None,
        modified_duration: Optional[float] = None,
        convexity: Optional[float] = None,
        dv01_bp: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermDepositPricingAnalysis(_model_base.Model):
    """Pricing analysis Object.

    Attributes
    ----------
    fixed_rate_percent : float
        The interest rate used to derive future fixed interest payments of the
        instrument. The value is expressed in percentages.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '
        2021-01-01T00:00:00Z  ').
    """

    fixed_rate_percent: Optional[float] = rest_field(name="fixedRatePercent")
    """The interest rate used to derive future fixed interest payments of the instrument. The value is
     expressed in percentages."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""
    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '  2021-01-01T00:00:00Z  ')."""

    @overload
    def __init__(
        self,
        *,
        fixed_rate_percent: Optional[float] = None,
        valuation_date: Optional[datetime.datetime] = None,
        market_data_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermDepositPricingParameters(_model_base.Model):
    """TermDepositPricingParameters.

    Attributes
    ----------
    market_data_date : ~datetime.datetime
        The date at which the market data is retrieved. The value is expressed
        in ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). It should be less or equal to valuationDate).
        Optional. By default, marketDataDate is valuationDate or today.
    price_side : str or ~analyticsapi.models.PriceSideEnum
        The price side of the instrument which comes from the instrument's
        quote or from the curve (derived from quotes) used to value the
        instrument. The possible values are:

        * Bid,
        * Ask,
        * Mid.

        The default value is 'Mid'. Known values are: "Mid", "Bid", "Ask", and "Last".
    report_ccy : str
        The currency code for the fields ending with 'xxxInReportCcy'. The
        value is expressed in ISO 4217 alphabetical format (e.g., 'USD').
        Optional. No default value applies.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    """

    market_data_date: Optional[datetime.datetime] = rest_field(name="marketDataDate", format="rfc3339")
    """The date at which the market data is retrieved. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z'). It should be less or equal to
     valuationDate).
     Optional. By default, marketDataDate is valuationDate or today."""
    price_side: Optional[Union[str, "_models.PriceSideEnum"]] = rest_field(name="priceSide")
    """The price side of the instrument which comes from the instrument's quote or from the curve
     (derived from quotes) used to value the instrument.
     The possible values are:
     
     
     * Bid,
     * Ask,
     * Mid.
     
     The default value is 'Mid'. Known values are: \"Mid\", \"Bid\", \"Ask\", and \"Last\"."""
    report_ccy: Optional[str] = rest_field(name="reportCcy")
    """The currency code for the fields ending with 'xxxInReportCcy'. The value is expressed in ISO
     4217 alphabetical format (e.g., 'USD').
     Optional. No default value applies."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""

    @overload
    def __init__(
        self,
        *,
        market_data_date: Optional[datetime.datetime] = None,
        price_side: Optional[Union[str, "_models.PriceSideEnum"]] = None,
        report_ccy: Optional[str] = None,
        valuation_date: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermDepositValuation(_model_base.Model):
    """Valuation Object.

    Attributes
    ----------
    accrued_days : int
        The number of days since the last interest payment date or since the
        dated date of the instrument.
    accrued_amount_in_deal_ccy : float
        The accrued interest amount. It is computed from the accrued percent
        and the notional amount. The value is expressed in the deal currency.
        For more details on the field calculation, please refer here.
    accrued_amount_in_report_ccy : float
        The accrued interest amount. It is computed from the accrued percent
        and the notional amount. The value is expressed in the reporting
        currency.
    market_value_in_deal_ccy : float
        The market value of the instrument. The value is expressed in the deal
        currency. For more details on the field calculation, please refer here.
    market_value_in_report_ccy : float
        The market value of the instrument. The value is expressed in the
        reporting currency.
    clean_market_value_in_deal_ccy : float
        The market value of the instrument less any accrued interest. The value
        is expressed in the deal currency. For more details on the field
        calculation, please refer here.
    clean_market_value_in_report_ccy : float
        The market value of the instrument less any accrued interest. The value
        is expressed in the reporting currency.
    """

    accrued_days: Optional[int] = rest_field(name="accruedDays")
    """The number of days since the last interest payment date or since the dated date of the
     instrument."""
    accrued_amount_in_deal_ccy: Optional[float] = rest_field(name="accruedAmountInDealCcy")
    """The accrued interest amount. It is computed from the accrued percent and the notional amount.
     The value is expressed in the deal currency.
     For more details on the field calculation, please refer here."""
    accrued_amount_in_report_ccy: Optional[float] = rest_field(name="accruedAmountInReportCcy")
    """The accrued interest amount. It is computed from the accrued percent and the notional amount.
     The value is expressed in the reporting currency."""
    market_value_in_deal_ccy: Optional[float] = rest_field(name="marketValueInDealCcy")
    """The market value of the instrument. The value is expressed in the deal currency.
     For more details on the field calculation, please refer here."""
    market_value_in_report_ccy: Optional[float] = rest_field(name="marketValueInReportCcy")
    """The market value of the instrument. The value is expressed in the reporting currency."""
    clean_market_value_in_deal_ccy: Optional[float] = rest_field(name="cleanMarketValueInDealCcy")
    """The market value of the instrument less any accrued interest. The value is expressed in the
     deal currency.
     For more details on the field calculation, please refer here."""
    clean_market_value_in_report_ccy: Optional[float] = rest_field(name="cleanMarketValueInReportCcy")
    """The market value of the instrument less any accrued interest. The value is expressed in the
     reporting currency."""

    @overload
    def __init__(
        self,
        *,
        accrued_days: Optional[int] = None,
        accrued_amount_in_deal_ccy: Optional[float] = None,
        accrued_amount_in_report_ccy: Optional[float] = None,
        market_value_in_deal_ccy: Optional[float] = None,
        market_value_in_report_ccy: Optional[float] = None,
        clean_market_value_in_deal_ccy: Optional[float] = None,
        clean_market_value_in_report_ccy: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TermRatePair(_model_base.Model):
    """TermRatePair.

    Attributes
    ----------
    term : int
    rate : float
    """

    term: Optional[int] = rest_field()
    rate: Optional[float] = rest_field()

    @overload
    def __init__(
        self,
        *,
        term: Optional[int] = None,
        rate: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Time(_model_base.Model):
    """An object to determine a certain time.

    Attributes
    ----------
    local_time : ~datetime.time
        The local time of the time zone used to determine a certain time. It is
        expressed in hh:mm:ss format (e.g., '17:00:00'). Required.
    time_zone_id : str or ~analyticsapi.models.TimezoneEnum
        The time zone used to determine a certain time. Known values are:
        "Africa/Abidjan", "Africa/Accra", "Africa/Addis_Ababa",
        "Africa/Algiers", "Africa/Asmara", "Africa/Asmera", "Africa/Bamako",
        "Africa/Bangui", "Africa/Banjul", "Africa/Bissau", "Africa/Blantyre",
        "Africa/Brazzaville", "Africa/Bujumbura", "Africa/Cairo",
        "Africa/Casablanca", "Africa/Ceuta", "Africa/Conakry", "Africa/Dakar",
        "Africa/Dar_es_Salaam", "Africa/Djibouti", "Africa/Douala",
        "Africa/El_Aaiun", "Africa/Freetown", "Africa/Gaborone",
        "Africa/Harare", "Africa/Johannesburg", "Africa/Juba",
        "Africa/Kampala", "Africa/Khartoum", "Africa/Kigali",
        "Africa/Kinshasa", "Africa/Lagos", "Africa/Libreville", "Africa/Lome",
        "Africa/Luanda", "Africa/Lubumbashi", "Africa/Lusaka", "Africa/Malabo",
        "Africa/Maputo", "Africa/Maseru", "Africa/Mbabane", "Africa/Mogadishu",
        "Africa/Monrovia", "Africa/Nairobi", "Africa/Ndjamena",
        "Africa/Niamey", "Africa/Nouakchott", "Africa/Ouagadougou",
        "Africa/Porto-Novo", "Africa/Sao_Tome", "Africa/Timbuktu",
        "Africa/Tripoli", "Africa/Tunis", "Africa/Windhoek", "America/Adak",
        "America/Anchorage", "America/Anguilla", "America/Antigua",
        "America/Araguaina", "America/Argentina/Buenos_Aires",
        "America/Argentina/Catamarca", "America/Argentina/ComodRivadavia",
        "America/Argentina/Cordoba", "America/Argentina/Jujuy",
        "America/Argentina/La_Rioja", "America/Argentina/Mendoza",
        "America/Argentina/Rio_Gallegos", "America/Argentina/Salta",
        "America/Argentina/San_Juan", "America/Argentina/San_Luis",
        "America/Argentina/Tucuman", "America/Argentina/Ushuaia",
        "America/Aruba", "America/Asuncion", "America/Atikokan",
        "America/Atka", "America/Bahia", "America/Bahia_Banderas",
        "America/Barbados", "America/Belem", "America/Belize", "America/Blanc-
        Sablon", "America/Boa_Vista", "America/Bogota", "America/Boise",
        "America/Buenos_Aires", "America/Cambridge_Bay",
        "America/Campo_Grande", "America/Cancun", "America/Caracas",
        "America/Catamarca", "America/Cayenne", "America/Cayman",
        "America/Chicago", "America/Chihuahua", "America/Ciudad_Juarez",
        "America/Coral_Harbour", "America/Cordoba", "America/Costa_Rica",
        "America/Creston", "America/Cuiaba", "America/Curacao",
        "America/Danmarkshavn", "America/Dawson", "America/Dawson_Creek",
        "America/Denver", "America/Detroit", "America/Dominica",
        "America/Edmonton", "America/Eirunepe", "America/El_Salvador",
        "America/Ensenada", "America/Fort_Nelson", "America/Fort_Wayne",
        "America/Fortaleza", "America/Glace_Bay", "America/Godthab",
        "America/Goose_Bay", "America/Grand_Turk", "America/Grenada",
        "America/Guadeloupe", "America/Guatemala", "America/Guayaquil",
        "America/Guyana", "America/Halifax", "America/Havana",
        "America/Hermosillo", "America/Indiana/Indianapolis",
        "America/Indiana/Knox", "America/Indiana/Marengo",
        "America/Indiana/Petersburg", "America/Indiana/Tell_City",
        "America/Indiana/Vevay", "America/Indiana/Vincennes",
        "America/Indiana/Winamac", "America/Indianapolis", "America/Inuvik",
        "America/Iqaluit", "America/Jamaica", "America/Jujuy",
        "America/Juneau", "America/Kentucky/Louisville",
        "America/Kentucky/Monticello", "America/Knox_IN", "America/Kralendijk",
        "America/La_Paz", "America/Lima", "America/Los_Angeles",
        "America/Louisville", "America/Lower_Princes", "America/Maceio",
        "America/Managua", "America/Manaus", "America/Marigot",
        "America/Martinique", "America/Matamoros", "America/Mazatlan",
        "America/Mendoza", "America/Menominee", "America/Merida",
        "America/Metlakatla", "America/Mexico_City", "America/Miquelon",
        "America/Moncton", "America/Monterrey", "America/Montevideo",
        "America/Montreal", "America/Montserrat", "America/Nassau",
        "America/New_York", "America/Nipigon", "America/Nome",
        "America/Noronha", "America/North_Dakota/Beulah",
        "America/North_Dakota/Center", "America/North_Dakota/New_Salem",
        "America/Nuuk", "America/Ojinaga", "America/Panama",
        "America/Pangnirtung", "America/Paramaribo", "America/Phoenix",
        "America/Port-au-Prince", "America/Port_of_Spain",
        "America/Porto_Acre", "America/Porto_Velho", "America/Puerto_Rico",
        "America/Punta_Arenas", "America/Rainy_River", "America/Rankin_Inlet",
        "America/Recife", "America/Regina", "America/Resolute",
        "America/Rio_Branco", "America/Rosario", "America/Santa_Isabel",
        "America/Santarem", "America/Santiago", "America/Santo_Domingo",
        "America/Sao_Paulo", "America/Scoresbysund", "America/Shiprock",
        "America/Sitka", "America/St_Barthelemy", "America/St_Johns",
        "America/St_Kitts", "America/St_Lucia", "America/St_Thomas",
        "America/St_Vincent", "America/Swift_Current", "America/Tegucigalpa",
        "America/Thule", "America/Thunder_Bay", "America/Tijuana",
        "America/Toronto", "America/Tortola", "America/Vancouver",
        "America/Virgin", "America/Whitehorse", "America/Winnipeg",
        "America/Yakutat", "America/Yellowknife", "Antarctica/Casey",
        "Antarctica/Davis", "Antarctica/DumontDUrville",
        "Antarctica/Macquarie", "Antarctica/Mawson", "Antarctica/McMurdo",
        "Antarctica/Palmer", "Antarctica/Rothera", "Antarctica/South_Pole",
        "Antarctica/Syowa", "Antarctica/Troll", "Antarctica/Vostok",
        "Arctic/Longyearbyen", "Asia/Aden", "Asia/Almaty", "Asia/Amman",
        "Asia/Anadyr", "Asia/Aqtau", "Asia/Aqtobe", "Asia/Ashgabat",
        "Asia/Ashkhabad", "Asia/Atyrau", "Asia/Baghdad", "Asia/Bahrain",
        "Asia/Baku", "Asia/Bangkok", "Asia/Barnaul", "Asia/Beirut",
        "Asia/Bishkek", "Asia/Brunei", "Asia/Calcutta", "Asia/Chita",
        "Asia/Choibalsan", "Asia/Chongqing", "Asia/Chungking", "Asia/Colombo",
        "Asia/Dacca", "Asia/Damascus", "Asia/Dhaka", "Asia/Dili", "Asia/Dubai",
        "Asia/Dushanbe", "Asia/Famagusta", "Asia/Gaza", "Asia/Harbin",
        "Asia/Hebron", "Asia/Ho_Chi_Minh", "Asia/Hong_Kong", "Asia/Hovd",
        "Asia/Irkutsk", "Asia/Istanbul", "Asia/Jakarta", "Asia/Jayapura",
        "Asia/Jerusalem", "Asia/Kabul", "Asia/Kamchatka", "Asia/Karachi",
        "Asia/Kashgar", "Asia/Kathmandu", "Asia/Katmandu", "Asia/Khandyga",
        "Asia/Kolkata", "Asia/Krasnoyarsk", "Asia/Kuala_Lumpur",
        "Asia/Kuching", "Asia/Kuwait", "Asia/Macao", "Asia/Macau",
        "Asia/Magadan", "Asia/Makassar", "Asia/Manila", "Asia/Muscat",
        "Asia/Nicosia", "Asia/Novokuznetsk", "Asia/Novosibirsk", "Asia/Omsk",
        "Asia/Oral", "Asia/Phnom_Penh", "Asia/Pontianak", "Asia/Pyongyang",
        "Asia/Qatar", "Asia/Qostanay", "Asia/Qyzylorda", "Asia/Rangoon",
        "Asia/Riyadh", "Asia/Saigon", "Asia/Sakhalin", "Asia/Samarkand",
        "Asia/Seoul", "Asia/Shanghai", "Asia/Singapore", "Asia/Srednekolymsk",
        "Asia/Taipei", "Asia/Tashkent", "Asia/Tbilisi", "Asia/Tehran",
        "Asia/Tel_Aviv", "Asia/Thimbu", "Asia/Thimphu", "Asia/Tokyo",
        "Asia/Tomsk", "Asia/Ujung_Pandang", "Asia/Ulaanbaatar",
        "Asia/Ulan_Bator", "Asia/Urumqi", "Asia/Ust-Nera", "Asia/Vientiane",
        "Asia/Vladivostok", "Asia/Yakutsk", "Asia/Yangon",
        "Asia/Yekaterinburg", "Asia/Yerevan", "Atlantic/Azores",
        "Atlantic/Bermuda", "Atlantic/Canary", "Atlantic/Cape_Verde",
        "Atlantic/Faeroe", "Atlantic/Faroe", "Atlantic/Jan_Mayen",
        "Atlantic/Madeira", "Atlantic/Reykjavik", "Atlantic/South_Georgia",
        "Atlantic/St_Helena", "Atlantic/Stanley", "Australia/ACT",
        "Australia/Adelaide", "Australia/Brisbane", "Australia/Broken_Hill",
        "Australia/Canberra", "Australia/Currie", "Australia/Darwin",
        "Australia/Eucla", "Australia/Hobart", "Australia/LHI",
        "Australia/Lindeman", "Australia/Lord_Howe", "Australia/Melbourne",
        "Australia/NSW", "Australia/North", "Australia/Perth",
        "Australia/Queensland", "Australia/South", "Australia/Sydney",
        "Australia/Tasmania", "Australia/Victoria", "Australia/West",
        "Australia/Yancowinna", "Brazil/Acre", "Brazil/DeNoronha",
        "Brazil/East", "Brazil/West", "CET", "CST6CDT", "Canada/Atlantic",
        "Canada/Central", "Canada/Eastern", "Canada/Mountain",
        "Canada/Newfoundland", "Canada/Pacific", "Canada/Saskatchewan",
        "Canada/Yukon", "Chile/Continental", "Chile/EasterIsland", "Cuba",
        "EET", "EST", "EST5EDT", "Egypt", "Eire", "Etc/GMT", "Etc/GMT+0",
        "Etc/GMT+1", "Etc/GMT+10", "Etc/GMT+11", "Etc/GMT+12", "Etc/GMT+2",
        "Etc/GMT+3", "Etc/GMT+4", "Etc/GMT+5", "Etc/GMT+6", "Etc/GMT+7",
        "Etc/GMT+8", "Etc/GMT+9", "Etc/GMT-0", "Etc/GMT-1", "Etc/GMT-10",
        "Etc/GMT-11", "Etc/GMT-12", "Etc/GMT-13", "Etc/GMT-14", "Etc/GMT-2",
        "Etc/GMT-3", "Etc/GMT-4", "Etc/GMT-5", "Etc/GMT-6", "Etc/GMT-7",
        "Etc/GMT-8", "Etc/GMT-9", "Etc/GMT0", "Etc/Greenwich", "Etc/UCT",
        "Etc/UTC", "Etc/Universal", "Etc/Zulu", "Europe/Amsterdam",
        "Europe/Andorra", "Europe/Astrakhan", "Europe/Athens",
        "Europe/Belfast", "Europe/Belgrade", "Europe/Berlin",
        "Europe/Bratislava", "Europe/Brussels", "Europe/Bucharest",
        "Europe/Budapest", "Europe/Busingen", "Europe/Chisinau",
        "Europe/Copenhagen", "Europe/Dublin", "Europe/Gibraltar",
        "Europe/Guernsey", "Europe/Helsinki", "Europe/Isle_of_Man",
        "Europe/Istanbul", "Europe/Jersey", "Europe/Kaliningrad",
        "Europe/Kiev", "Europe/Kirov", "Europe/Kyiv", "Europe/Lisbon",
        "Europe/Ljubljana", "Europe/London", "Europe/Luxembourg",
        "Europe/Madrid", "Europe/Malta", "Europe/Mariehamn", "Europe/Minsk",
        "Europe/Monaco", "Europe/Moscow", "Europe/Nicosia", "Europe/Oslo",
        "Europe/Paris", "Europe/Podgorica", "Europe/Prague", "Europe/Riga",
        "Europe/Rome", "Europe/Samara", "Europe/San_Marino", "Europe/Sarajevo",
        "Europe/Saratov", "Europe/Simferopol", "Europe/Skopje", "Europe/Sofia",
        "Europe/Stockholm", "Europe/Tallinn", "Europe/Tirane",
        "Europe/Tiraspol", "Europe/Ulyanovsk", "Europe/Uzhgorod",
        "Europe/Vaduz", "Europe/Vatican", "Europe/Vienna", "Europe/Vilnius",
        "Europe/Volgograd", "Europe/Warsaw", "Europe/Zagreb",
        "Europe/Zaporozhye", "Europe/Zurich", "GB", "GB-Eire", "GMT", "GMT+0",
        "GMT-0", "GMT0", "Greenwich", "HST", "Hongkong", "Iceland",
        "Indian/Antananarivo", "Indian/Chagos", "Indian/Christmas",
        "Indian/Cocos", "Indian/Comoro", "Indian/Kerguelen", "Indian/Mahe",
        "Indian/Maldives", "Indian/Mauritius", "Indian/Mayotte",
        "Indian/Reunion", "Iran", "Israel", "Jamaica", "Japan", "Kwajalein",
        "Libya", "MET", "MST", "MST7MDT", "Mexico/BajaNorte", "Mexico/BajaSur",
        "Mexico/General", "NZ", "NZ-CHAT", "Navajo", "PRC", "PST8PDT",
        "Pacific/Apia", "Pacific/Auckland", "Pacific/Bougainville",
        "Pacific/Chatham", "Pacific/Chuuk", "Pacific/Easter", "Pacific/Efate",
        "Pacific/Enderbury", "Pacific/Fakaofo", "Pacific/Fiji",
        "Pacific/Funafuti", "Pacific/Galapagos", "Pacific/Gambier",
        "Pacific/Guadalcanal", "Pacific/Guam", "Pacific/Honolulu",
        "Pacific/Johnston", "Pacific/Kanton", "Pacific/Kiritimati",
        "Pacific/Kosrae", "Pacific/Kwajalein", "Pacific/Majuro",
        "Pacific/Marquesas", "Pacific/Midway", "Pacific/Nauru", "Pacific/Niue",
        "Pacific/Norfolk", "Pacific/Noumea", "Pacific/Pago_Pago",
        "Pacific/Palau", "Pacific/Pitcairn", "Pacific/Pohnpei",
        "Pacific/Ponape", "Pacific/Port_Moresby", "Pacific/Rarotonga",
        "Pacific/Saipan", "Pacific/Samoa", "Pacific/Tahiti", "Pacific/Tarawa",
        "Pacific/Tongatapu", "Pacific/Truk", "Pacific/Wake", "Pacific/Wallis",
        "Pacific/Yap", "Poland", "Portugal", "ROC", "ROK", "Singapore",
        "Turkey", "UCT", "US/Alaska", "US/Aleutian", "US/Arizona",
        "US/Central", "US/East-Indiana", "US/Eastern", "US/Hawaii",
        "US/Indiana-Starke", "US/Michigan", "US/Mountain", "US/Pacific",
        "US/Samoa", "UTC", "Universal", "W-SU", "WET", and "Zulu".
    """

    local_time: datetime.time = rest_field(name="localTime")
    """The local time of the time zone used to determine a certain time. It is expressed in hh:mm:ss
     format (e.g., '17:00:00'). Required."""
    time_zone_id: Optional[Union[str, "_models.TimezoneEnum"]] = rest_field(name="timeZoneId")
    """The time zone used to determine a certain time. Known values are: \"Africa/Abidjan\",
     \"Africa/Accra\", \"Africa/Addis_Ababa\", \"Africa/Algiers\", \"Africa/Asmara\",
     \"Africa/Asmera\", \"Africa/Bamako\", \"Africa/Bangui\", \"Africa/Banjul\", \"Africa/Bissau\",
     \"Africa/Blantyre\", \"Africa/Brazzaville\", \"Africa/Bujumbura\", \"Africa/Cairo\",
     \"Africa/Casablanca\", \"Africa/Ceuta\", \"Africa/Conakry\", \"Africa/Dakar\",
     \"Africa/Dar_es_Salaam\", \"Africa/Djibouti\", \"Africa/Douala\", \"Africa/El_Aaiun\",
     \"Africa/Freetown\", \"Africa/Gaborone\", \"Africa/Harare\", \"Africa/Johannesburg\",
     \"Africa/Juba\", \"Africa/Kampala\", \"Africa/Khartoum\", \"Africa/Kigali\",
     \"Africa/Kinshasa\", \"Africa/Lagos\", \"Africa/Libreville\", \"Africa/Lome\",
     \"Africa/Luanda\", \"Africa/Lubumbashi\", \"Africa/Lusaka\", \"Africa/Malabo\",
     \"Africa/Maputo\", \"Africa/Maseru\", \"Africa/Mbabane\", \"Africa/Mogadishu\",
     \"Africa/Monrovia\", \"Africa/Nairobi\", \"Africa/Ndjamena\", \"Africa/Niamey\",
     \"Africa/Nouakchott\", \"Africa/Ouagadougou\", \"Africa/Porto-Novo\", \"Africa/Sao_Tome\",
     \"Africa/Timbuktu\", \"Africa/Tripoli\", \"Africa/Tunis\", \"Africa/Windhoek\",
     \"America/Adak\", \"America/Anchorage\", \"America/Anguilla\", \"America/Antigua\",
     \"America/Araguaina\", \"America/Argentina/Buenos_Aires\", \"America/Argentina/Catamarca\",
     \"America/Argentina/ComodRivadavia\", \"America/Argentina/Cordoba\",
     \"America/Argentina/Jujuy\", \"America/Argentina/La_Rioja\", \"America/Argentina/Mendoza\",
     \"America/Argentina/Rio_Gallegos\", \"America/Argentina/Salta\",
     \"America/Argentina/San_Juan\", \"America/Argentina/San_Luis\", \"America/Argentina/Tucuman\",
     \"America/Argentina/Ushuaia\", \"America/Aruba\", \"America/Asuncion\", \"America/Atikokan\",
     \"America/Atka\", \"America/Bahia\", \"America/Bahia_Banderas\", \"America/Barbados\",
     \"America/Belem\", \"America/Belize\", \"America/Blanc-Sablon\", \"America/Boa_Vista\",
     \"America/Bogota\", \"America/Boise\", \"America/Buenos_Aires\", \"America/Cambridge_Bay\",
     \"America/Campo_Grande\", \"America/Cancun\", \"America/Caracas\", \"America/Catamarca\",
     \"America/Cayenne\", \"America/Cayman\", \"America/Chicago\", \"America/Chihuahua\",
     \"America/Ciudad_Juarez\", \"America/Coral_Harbour\", \"America/Cordoba\",
     \"America/Costa_Rica\", \"America/Creston\", \"America/Cuiaba\", \"America/Curacao\",
     \"America/Danmarkshavn\", \"America/Dawson\", \"America/Dawson_Creek\", \"America/Denver\",
     \"America/Detroit\", \"America/Dominica\", \"America/Edmonton\", \"America/Eirunepe\",
     \"America/El_Salvador\", \"America/Ensenada\", \"America/Fort_Nelson\", \"America/Fort_Wayne\",
     \"America/Fortaleza\", \"America/Glace_Bay\", \"America/Godthab\", \"America/Goose_Bay\",
     \"America/Grand_Turk\", \"America/Grenada\", \"America/Guadeloupe\", \"America/Guatemala\",
     \"America/Guayaquil\", \"America/Guyana\", \"America/Halifax\", \"America/Havana\",
     \"America/Hermosillo\", \"America/Indiana/Indianapolis\", \"America/Indiana/Knox\",
     \"America/Indiana/Marengo\", \"America/Indiana/Petersburg\", \"America/Indiana/Tell_City\",
     \"America/Indiana/Vevay\", \"America/Indiana/Vincennes\", \"America/Indiana/Winamac\",
     \"America/Indianapolis\", \"America/Inuvik\", \"America/Iqaluit\", \"America/Jamaica\",
     \"America/Jujuy\", \"America/Juneau\", \"America/Kentucky/Louisville\",
     \"America/Kentucky/Monticello\", \"America/Knox_IN\", \"America/Kralendijk\",
     \"America/La_Paz\", \"America/Lima\", \"America/Los_Angeles\", \"America/Louisville\",
     \"America/Lower_Princes\", \"America/Maceio\", \"America/Managua\", \"America/Manaus\",
     \"America/Marigot\", \"America/Martinique\", \"America/Matamoros\", \"America/Mazatlan\",
     \"America/Mendoza\", \"America/Menominee\", \"America/Merida\", \"America/Metlakatla\",
     \"America/Mexico_City\", \"America/Miquelon\", \"America/Moncton\", \"America/Monterrey\",
     \"America/Montevideo\", \"America/Montreal\", \"America/Montserrat\", \"America/Nassau\",
     \"America/New_York\", \"America/Nipigon\", \"America/Nome\", \"America/Noronha\",
     \"America/North_Dakota/Beulah\", \"America/North_Dakota/Center\",
     \"America/North_Dakota/New_Salem\", \"America/Nuuk\", \"America/Ojinaga\", \"America/Panama\",
     \"America/Pangnirtung\", \"America/Paramaribo\", \"America/Phoenix\",
     \"America/Port-au-Prince\", \"America/Port_of_Spain\", \"America/Porto_Acre\",
     \"America/Porto_Velho\", \"America/Puerto_Rico\", \"America/Punta_Arenas\",
     \"America/Rainy_River\", \"America/Rankin_Inlet\", \"America/Recife\", \"America/Regina\",
     \"America/Resolute\", \"America/Rio_Branco\", \"America/Rosario\", \"America/Santa_Isabel\",
     \"America/Santarem\", \"America/Santiago\", \"America/Santo_Domingo\", \"America/Sao_Paulo\",
     \"America/Scoresbysund\", \"America/Shiprock\", \"America/Sitka\", \"America/St_Barthelemy\",
     \"America/St_Johns\", \"America/St_Kitts\", \"America/St_Lucia\", \"America/St_Thomas\",
     \"America/St_Vincent\", \"America/Swift_Current\", \"America/Tegucigalpa\", \"America/Thule\",
     \"America/Thunder_Bay\", \"America/Tijuana\", \"America/Toronto\", \"America/Tortola\",
     \"America/Vancouver\", \"America/Virgin\", \"America/Whitehorse\", \"America/Winnipeg\",
     \"America/Yakutat\", \"America/Yellowknife\", \"Antarctica/Casey\", \"Antarctica/Davis\",
     \"Antarctica/DumontDUrville\", \"Antarctica/Macquarie\", \"Antarctica/Mawson\",
     \"Antarctica/McMurdo\", \"Antarctica/Palmer\", \"Antarctica/Rothera\",
     \"Antarctica/South_Pole\", \"Antarctica/Syowa\", \"Antarctica/Troll\", \"Antarctica/Vostok\",
     \"Arctic/Longyearbyen\", \"Asia/Aden\", \"Asia/Almaty\", \"Asia/Amman\", \"Asia/Anadyr\",
     \"Asia/Aqtau\", \"Asia/Aqtobe\", \"Asia/Ashgabat\", \"Asia/Ashkhabad\", \"Asia/Atyrau\",
     \"Asia/Baghdad\", \"Asia/Bahrain\", \"Asia/Baku\", \"Asia/Bangkok\", \"Asia/Barnaul\",
     \"Asia/Beirut\", \"Asia/Bishkek\", \"Asia/Brunei\", \"Asia/Calcutta\", \"Asia/Chita\",
     \"Asia/Choibalsan\", \"Asia/Chongqing\", \"Asia/Chungking\", \"Asia/Colombo\", \"Asia/Dacca\",
     \"Asia/Damascus\", \"Asia/Dhaka\", \"Asia/Dili\", \"Asia/Dubai\", \"Asia/Dushanbe\",
     \"Asia/Famagusta\", \"Asia/Gaza\", \"Asia/Harbin\", \"Asia/Hebron\", \"Asia/Ho_Chi_Minh\",
     \"Asia/Hong_Kong\", \"Asia/Hovd\", \"Asia/Irkutsk\", \"Asia/Istanbul\", \"Asia/Jakarta\",
     \"Asia/Jayapura\", \"Asia/Jerusalem\", \"Asia/Kabul\", \"Asia/Kamchatka\", \"Asia/Karachi\",
     \"Asia/Kashgar\", \"Asia/Kathmandu\", \"Asia/Katmandu\", \"Asia/Khandyga\", \"Asia/Kolkata\",
     \"Asia/Krasnoyarsk\", \"Asia/Kuala_Lumpur\", \"Asia/Kuching\", \"Asia/Kuwait\", \"Asia/Macao\",
     \"Asia/Macau\", \"Asia/Magadan\", \"Asia/Makassar\", \"Asia/Manila\", \"Asia/Muscat\",
     \"Asia/Nicosia\", \"Asia/Novokuznetsk\", \"Asia/Novosibirsk\", \"Asia/Omsk\", \"Asia/Oral\",
     \"Asia/Phnom_Penh\", \"Asia/Pontianak\", \"Asia/Pyongyang\", \"Asia/Qatar\", \"Asia/Qostanay\",
     \"Asia/Qyzylorda\", \"Asia/Rangoon\", \"Asia/Riyadh\", \"Asia/Saigon\", \"Asia/Sakhalin\",
     \"Asia/Samarkand\", \"Asia/Seoul\", \"Asia/Shanghai\", \"Asia/Singapore\",
     \"Asia/Srednekolymsk\", \"Asia/Taipei\", \"Asia/Tashkent\", \"Asia/Tbilisi\", \"Asia/Tehran\",
     \"Asia/Tel_Aviv\", \"Asia/Thimbu\", \"Asia/Thimphu\", \"Asia/Tokyo\", \"Asia/Tomsk\",
     \"Asia/Ujung_Pandang\", \"Asia/Ulaanbaatar\", \"Asia/Ulan_Bator\", \"Asia/Urumqi\",
     \"Asia/Ust-Nera\", \"Asia/Vientiane\", \"Asia/Vladivostok\", \"Asia/Yakutsk\", \"Asia/Yangon\",
     \"Asia/Yekaterinburg\", \"Asia/Yerevan\", \"Atlantic/Azores\", \"Atlantic/Bermuda\",
     \"Atlantic/Canary\", \"Atlantic/Cape_Verde\", \"Atlantic/Faeroe\", \"Atlantic/Faroe\",
     \"Atlantic/Jan_Mayen\", \"Atlantic/Madeira\", \"Atlantic/Reykjavik\",
     \"Atlantic/South_Georgia\", \"Atlantic/St_Helena\", \"Atlantic/Stanley\", \"Australia/ACT\",
     \"Australia/Adelaide\", \"Australia/Brisbane\", \"Australia/Broken_Hill\",
     \"Australia/Canberra\", \"Australia/Currie\", \"Australia/Darwin\", \"Australia/Eucla\",
     \"Australia/Hobart\", \"Australia/LHI\", \"Australia/Lindeman\", \"Australia/Lord_Howe\",
     \"Australia/Melbourne\", \"Australia/NSW\", \"Australia/North\", \"Australia/Perth\",
     \"Australia/Queensland\", \"Australia/South\", \"Australia/Sydney\", \"Australia/Tasmania\",
     \"Australia/Victoria\", \"Australia/West\", \"Australia/Yancowinna\", \"Brazil/Acre\",
     \"Brazil/DeNoronha\", \"Brazil/East\", \"Brazil/West\", \"CET\", \"CST6CDT\",
     \"Canada/Atlantic\", \"Canada/Central\", \"Canada/Eastern\", \"Canada/Mountain\",
     \"Canada/Newfoundland\", \"Canada/Pacific\", \"Canada/Saskatchewan\", \"Canada/Yukon\",
     \"Chile/Continental\", \"Chile/EasterIsland\", \"Cuba\", \"EET\", \"EST\", \"EST5EDT\",
     \"Egypt\", \"Eire\", \"Etc/GMT\", \"Etc/GMT+0\", \"Etc/GMT+1\", \"Etc/GMT+10\", \"Etc/GMT+11\",
     \"Etc/GMT+12\", \"Etc/GMT+2\", \"Etc/GMT+3\", \"Etc/GMT+4\", \"Etc/GMT+5\", \"Etc/GMT+6\",
     \"Etc/GMT+7\", \"Etc/GMT+8\", \"Etc/GMT+9\", \"Etc/GMT-0\", \"Etc/GMT-1\", \"Etc/GMT-10\",
     \"Etc/GMT-11\", \"Etc/GMT-12\", \"Etc/GMT-13\", \"Etc/GMT-14\", \"Etc/GMT-2\", \"Etc/GMT-3\",
     \"Etc/GMT-4\", \"Etc/GMT-5\", \"Etc/GMT-6\", \"Etc/GMT-7\", \"Etc/GMT-8\", \"Etc/GMT-9\",
     \"Etc/GMT0\", \"Etc/Greenwich\", \"Etc/UCT\", \"Etc/UTC\", \"Etc/Universal\", \"Etc/Zulu\",
     \"Europe/Amsterdam\", \"Europe/Andorra\", \"Europe/Astrakhan\", \"Europe/Athens\",
     \"Europe/Belfast\", \"Europe/Belgrade\", \"Europe/Berlin\", \"Europe/Bratislava\",
     \"Europe/Brussels\", \"Europe/Bucharest\", \"Europe/Budapest\", \"Europe/Busingen\",
     \"Europe/Chisinau\", \"Europe/Copenhagen\", \"Europe/Dublin\", \"Europe/Gibraltar\",
     \"Europe/Guernsey\", \"Europe/Helsinki\", \"Europe/Isle_of_Man\", \"Europe/Istanbul\",
     \"Europe/Jersey\", \"Europe/Kaliningrad\", \"Europe/Kiev\", \"Europe/Kirov\", \"Europe/Kyiv\",
     \"Europe/Lisbon\", \"Europe/Ljubljana\", \"Europe/London\", \"Europe/Luxembourg\",
     \"Europe/Madrid\", \"Europe/Malta\", \"Europe/Mariehamn\", \"Europe/Minsk\", \"Europe/Monaco\",
     \"Europe/Moscow\", \"Europe/Nicosia\", \"Europe/Oslo\", \"Europe/Paris\", \"Europe/Podgorica\",
     \"Europe/Prague\", \"Europe/Riga\", \"Europe/Rome\", \"Europe/Samara\", \"Europe/San_Marino\",
     \"Europe/Sarajevo\", \"Europe/Saratov\", \"Europe/Simferopol\", \"Europe/Skopje\",
     \"Europe/Sofia\", \"Europe/Stockholm\", \"Europe/Tallinn\", \"Europe/Tirane\",
     \"Europe/Tiraspol\", \"Europe/Ulyanovsk\", \"Europe/Uzhgorod\", \"Europe/Vaduz\",
     \"Europe/Vatican\", \"Europe/Vienna\", \"Europe/Vilnius\", \"Europe/Volgograd\",
     \"Europe/Warsaw\", \"Europe/Zagreb\", \"Europe/Zaporozhye\", \"Europe/Zurich\", \"GB\",
     \"GB-Eire\", \"GMT\", \"GMT+0\", \"GMT-0\", \"GMT0\", \"Greenwich\", \"HST\", \"Hongkong\",
     \"Iceland\", \"Indian/Antananarivo\", \"Indian/Chagos\", \"Indian/Christmas\",
     \"Indian/Cocos\", \"Indian/Comoro\", \"Indian/Kerguelen\", \"Indian/Mahe\",
     \"Indian/Maldives\", \"Indian/Mauritius\", \"Indian/Mayotte\", \"Indian/Reunion\", \"Iran\",
     \"Israel\", \"Jamaica\", \"Japan\", \"Kwajalein\", \"Libya\", \"MET\", \"MST\", \"MST7MDT\",
     \"Mexico/BajaNorte\", \"Mexico/BajaSur\", \"Mexico/General\", \"NZ\", \"NZ-CHAT\", \"Navajo\",
     \"PRC\", \"PST8PDT\", \"Pacific/Apia\", \"Pacific/Auckland\", \"Pacific/Bougainville\",
     \"Pacific/Chatham\", \"Pacific/Chuuk\", \"Pacific/Easter\", \"Pacific/Efate\",
     \"Pacific/Enderbury\", \"Pacific/Fakaofo\", \"Pacific/Fiji\", \"Pacific/Funafuti\",
     \"Pacific/Galapagos\", \"Pacific/Gambier\", \"Pacific/Guadalcanal\", \"Pacific/Guam\",
     \"Pacific/Honolulu\", \"Pacific/Johnston\", \"Pacific/Kanton\", \"Pacific/Kiritimati\",
     \"Pacific/Kosrae\", \"Pacific/Kwajalein\", \"Pacific/Majuro\", \"Pacific/Marquesas\",
     \"Pacific/Midway\", \"Pacific/Nauru\", \"Pacific/Niue\", \"Pacific/Norfolk\",
     \"Pacific/Noumea\", \"Pacific/Pago_Pago\", \"Pacific/Palau\", \"Pacific/Pitcairn\",
     \"Pacific/Pohnpei\", \"Pacific/Ponape\", \"Pacific/Port_Moresby\", \"Pacific/Rarotonga\",
     \"Pacific/Saipan\", \"Pacific/Samoa\", \"Pacific/Tahiti\", \"Pacific/Tarawa\",
     \"Pacific/Tongatapu\", \"Pacific/Truk\", \"Pacific/Wake\", \"Pacific/Wallis\", \"Pacific/Yap\",
     \"Poland\", \"Portugal\", \"ROC\", \"ROK\", \"Singapore\", \"Turkey\", \"UCT\", \"US/Alaska\",
     \"US/Aleutian\", \"US/Arizona\", \"US/Central\", \"US/East-Indiana\", \"US/Eastern\",
     \"US/Hawaii\", \"US/Indiana-Starke\", \"US/Michigan\", \"US/Mountain\", \"US/Pacific\",
     \"US/Samoa\", \"UTC\", \"Universal\", \"W-SU\", \"WET\", and \"Zulu\"."""

    @overload
    def __init__(
        self,
        *,
        local_time: datetime.time,
        time_zone_id: Optional[Union[str, "_models.TimezoneEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TimeBucketShift(_model_base.Model):
    """From start to end tenor parallel shift applies.

    Attributes
    ----------
    amount : float
        Amount of shifting, applied to points depending on shift method
        selected. Can be measured in basis points/percents/future price based
        points. Also can be expressed as multiplier for relative shift type.
    end_tenor : str
        The code indicating the end tenor from which the combined shifts
        scenario is applied to curve points. When startTenor equals endTenor:
        * shift equals 0 for tenor less than startTenor,   * shift equals
        amount for tenor is equal and greater than endTenor. When startTenor
        less than endTenor:   * shift equals 0 for tenor which is less or equal
        startTenor, * shift rises from 0 to amount in period from startTenor to
        endTenor. Shift equals amount for tenor greater than endTenor.
    ignore_quotation_scale : bool
    shift_type : str or ~analyticsapi.models.ShiftTypeEnum
        The type of shifting. The possible values are:   * Additive: the amount
        of shifting is added to the corresponding curve point,   * Relative:
        the curve point is multiplied by the amount of shifting (e.g., if
        amount = 1, the curve point value will be doubled),   * Scaled: the
        curve point is scaled by the value of the shifting amount (e.g., if
        amount = 1.1, the curve point value will multiplied by this value).
        Known values are: "Additive", "Relative", and "Scaled".
    shift_unit : str or ~analyticsapi.models.ShiftUnitEnum
        The unit that describes the amount of shifting. The possible values
        are:   * Absolute: the amount of shifting is expressed in absolute
        value.   * Bp: the amount of shifting is expressed in basis points,   *
        Percent: the amount of shifting is expressed in percentages,. Known
        values are: "Absolute", "Bp", and "Percent".
    start_tenor : str
        The code indicating the start tenor from which the combined shifts
        scenario is applied to curve points. When startTenor equals endTenor:
        * shift equals 0 for tenor less than startTenor,   * shift equals
        amount for tenor is equal and greater than endTenor. When startTenor
        less than endTenor:   * shift equals 0 for tenor which is less or equal
        startTenor, * shift rises from 0 to amount in period from startTenor to
        endTenor. Shift equals amount for tenor greater than endTenor.
    """

    amount: Optional[float] = rest_field()
    """Amount of shifting, applied to points depending on shift method selected. Can be measured in
     basis points/percents/future price based points. Also can be expressed as multiplier for
     relative shift type."""
    end_tenor: Optional[str] = rest_field(name="endTenor")
    """The code indicating the end tenor from which the combined shifts scenario is applied to curve
     points. When startTenor equals endTenor:   * shift equals 0 for tenor less than startTenor,   *
     shift equals amount for tenor is equal and greater than endTenor. When startTenor less than
     endTenor:   * shift equals 0 for tenor which is less or equal startTenor,   * shift rises from
     0 to amount in period from startTenor to endTenor. Shift equals amount for tenor greater than
     endTenor."""
    ignore_quotation_scale: Optional[bool] = rest_field(name="ignoreQuotationScale")
    shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = rest_field(name="shiftType")
    """The type of shifting. The possible values are:   * Additive: the amount of shifting is added to
     the corresponding curve point,   * Relative: the curve point is multiplied by the amount of
     shifting (e.g., if amount = 1, the curve point value will be doubled),   * Scaled: the curve
     point is scaled by the value of the shifting amount (e.g., if amount = 1.1, the curve point
     value will multiplied by this value). Known values are: \"Additive\", \"Relative\", and
     \"Scaled\"."""
    shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = rest_field(name="shiftUnit")
    """The unit that describes the amount of shifting. The possible values are:   * Absolute: the
     amount of shifting is expressed in absolute value.   * Bp: the amount of shifting is expressed
     in basis points,   * Percent: the amount of shifting is expressed in percentages,. Known values
     are: \"Absolute\", \"Bp\", and \"Percent\"."""
    start_tenor: Optional[str] = rest_field(name="startTenor")
    """The code indicating the start tenor from which the combined shifts scenario is applied to curve
     points. When startTenor equals endTenor:   * shift equals 0 for tenor less than startTenor,   *
     shift equals amount for tenor is equal and greater than endTenor. When startTenor less than
     endTenor:   * shift equals 0 for tenor which is less or equal startTenor,   * shift rises from
     0 to amount in period from startTenor to endTenor. Shift equals amount for tenor greater than
     endTenor."""

    @overload
    def __init__(
        self,
        *,
        amount: Optional[float] = None,
        end_tenor: Optional[str] = None,
        ignore_quotation_scale: Optional[bool] = None,
        shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = None,
        shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = None,
        start_tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Turn(_model_base.Model):
    """All these attributes must be provided, otherwise turns will be ignored.

    Attributes
    ----------
    month : int
        The month of the turn period.
    rate_percent : float
        The mid turn rate expressed in percentages.
    year : int
        The year of the turn period.
    """

    month: Optional[int] = rest_field()
    """The month of the turn period."""
    rate_percent: Optional[float] = rest_field(name="ratePercent")
    """The mid turn rate expressed in percentages."""
    year: Optional[int] = rest_field()
    """The year of the turn period."""

    @overload
    def __init__(
        self,
        *,
        month: Optional[int] = None,
        rate_percent: Optional[float] = None,
        year: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class TwistShift(_model_base.Model):
    """TwistShift.

    Attributes
    ----------
    amount : float
        Amount of shifting, applied to points depending on shift method
        selected. Can be measured in basis points/percents/future price based
        points. Also can be expressed as multiplier for relative shift type.
    ignore_quotation_scale : bool
    pivot_tenor : str
        The code indicating the curve point which is not shifted (e.g., '1M',
        '6M', '4Y').
    shift_type : str or ~analyticsapi.models.ShiftTypeEnum
        The type of shifting. The possible values are:   * Additive: the amount
        of shifting is added to the corresponding curve point,   * Relative:
        the curve point is multiplied by the amount of shifting (e.g., if
        amount = 1, the curve point value will be doubled),   * Scaled: the
        curve point is scaled by the value of the shifting amount (e.g., if
        amount = 1.1, the curve point value will multiplied by this value).
        Known values are: "Additive", "Relative", and "Scaled".
    shift_unit : str or ~analyticsapi.models.ShiftUnitEnum
        The unit that describes the amount of shifting. The possible values
        are:   * Absolute: the amount of shifting is expressed in absolute
        value.   * Bp: the amount of shifting is expressed in basis points,   *
        Percent: the amount of shifting is expressed in percentages,. Known
        values are: "Absolute", "Bp", and "Percent".
    """

    amount: Optional[float] = rest_field()
    """Amount of shifting, applied to points depending on shift method selected. Can be measured in
     basis points/percents/future price based points. Also can be expressed as multiplier for
     relative shift type."""
    ignore_quotation_scale: Optional[bool] = rest_field(name="ignoreQuotationScale")
    pivot_tenor: Optional[str] = rest_field(name="pivotTenor")
    """The code indicating the curve point which is not shifted (e.g., '1M', '6M', '4Y')."""
    shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = rest_field(name="shiftType")
    """The type of shifting. The possible values are:   * Additive: the amount of shifting is added to
     the corresponding curve point,   * Relative: the curve point is multiplied by the amount of
     shifting (e.g., if amount = 1, the curve point value will be doubled),   * Scaled: the curve
     point is scaled by the value of the shifting amount (e.g., if amount = 1.1, the curve point
     value will multiplied by this value). Known values are: \"Additive\", \"Relative\", and
     \"Scaled\"."""
    shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = rest_field(name="shiftUnit")
    """The unit that describes the amount of shifting. The possible values are:   * Absolute: the
     amount of shifting is expressed in absolute value.   * Bp: the amount of shifting is expressed
     in basis points,   * Percent: the amount of shifting is expressed in percentages,. Known values
     are: \"Absolute\", \"Bp\", and \"Percent\"."""

    @overload
    def __init__(
        self,
        *,
        amount: Optional[float] = None,
        ignore_quotation_scale: Optional[bool] = None,
        pivot_tenor: Optional[str] = None,
        shift_type: Optional[Union[str, "_models.ShiftTypeEnum"]] = None,
        shift_unit: Optional[Union[str, "_models.ShiftUnitEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UDIExtension(_model_base.Model):
    """UDIExtension.

    Attributes
    ----------
    identifier : str
    """

    identifier: Optional[str] = rest_field()

    @overload
    def __init__(
        self,
        identifier: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["identifier"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class UnderlyingDefinition(ABC, _model_base.Model):
    """An object that defines the underlying asset.

    You probably want to use the sub-classes and not this class directly. Known sub-classes are:
    UnderlyingBond, UnderlyingBondFuture, UnderlyingCommodity, UnderlyingEquity, UnderlyingFx,
    UnderlyingIrs

    Attributes
    ----------
    underlying_type : str or ~analyticsapi.models.UnderlyingTypeEnum
        The type of the underlying asset. Required. Known values are: "Fx",
        "Bond", "Irs", "Commodity", "Equity", and "BondFuture".
    code : str
        The code (a RIC) used to define the underlying asset.
    definition : str
        The identifier of the underlying definition resource (GUID or URI).
        Note that a URI must be at least 2 and at most 102 characters long,
        start with an alphanumeric character, and contain only alphanumeric
        characters, slashes and underscores.
    """

    __mapping__: Dict[str, _model_base.Model] = {}
    underlying_type: str = rest_discriminator(name="underlyingType")
    """The type of the underlying asset. Required. Known values are: \"Fx\", \"Bond\", \"Irs\",
     \"Commodity\", \"Equity\", and \"BondFuture\"."""
    code: Optional[str] = rest_field()
    """The code (a RIC) used to define the underlying asset."""
    definition: Optional[str] = rest_field()
    """The identifier of the underlying definition resource (GUID or URI).
     Note that a URI must be at least 2 and at most 102 characters long, start with an alphanumeric
     character, and contain only alphanumeric characters, slashes and underscores."""

    @overload
    def __init__(
        self,
        *,
        underlying_type: str,
        code: Optional[str] = None,
        definition: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UnderlyingBond(UnderlyingDefinition, discriminator="Bond"):
    """An object that defines the underlying bond instrument.

    Attributes
    ----------
    code : str
        The code (a RIC) used to define the underlying asset.
    definition : str
        The identifier of the underlying definition resource (GUID or URI).
        Note that a URI must be at least 2 and at most 102 characters long,
        start with an alphanumeric character, and contain only alphanumeric
        characters, slashes and underscores.
    underlying_type : str or ~analyticsapi.models.BOND
        The type of the underlying asset. Restricted to 'Bond'. Required.
    """

    underlying_type: Literal[UnderlyingTypeEnum.BOND] = rest_discriminator(name="underlyingType")  # type: ignore
    """The type of the underlying asset. Restricted to 'Bond'. Required."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        definition: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["underlying_type"] = args[0]
            args = tuple()
        super().__init__(*args, underlying_type=UnderlyingTypeEnum.BOND, **kwargs)


class UnderlyingBondFuture(UnderlyingDefinition, discriminator="BondFuture"):
    """An object that defines the underlying bond future instrument.

    Attributes
    ----------
    code : str
        The code (a RIC) used to define the underlying asset.
    definition : str
        The identifier of the underlying definition resource (GUID or URI).
        Note that a URI must be at least 2 and at most 102 characters long,
        start with an alphanumeric character, and contain only alphanumeric
        characters, slashes and underscores.
    underlying_type : str or ~analyticsapi.models.BOND_FUTURE
        The type of the underlying asset. Restricted to 'BondFuture'. Required.
    """

    underlying_type: Literal[UnderlyingTypeEnum.BOND_FUTURE] = rest_discriminator(name="underlyingType")  # type: ignore
    """The type of the underlying asset. Restricted to 'BondFuture'. Required."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        definition: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["underlying_type"] = args[0]
            args = tuple()
        super().__init__(*args, underlying_type=UnderlyingTypeEnum.BOND_FUTURE, **kwargs)


class UnderlyingCommodity(UnderlyingDefinition, discriminator="Commodity"):
    """An object that defines the underlying commodity instrument.

    Attributes
    ----------
    code : str
        The code (a RIC) used to define the underlying asset.
    definition : str
        The identifier of the underlying definition resource (GUID or URI).
        Note that a URI must be at least 2 and at most 102 characters long,
        start with an alphanumeric character, and contain only alphanumeric
        characters, slashes and underscores.
    underlying_type : str or ~analyticsapi.models.COMMODITY
        The type of the underlying asset. Restricted to 'Commodity'. Required.
    """

    underlying_type: Literal[UnderlyingTypeEnum.COMMODITY] = rest_discriminator(name="underlyingType")  # type: ignore
    """The type of the underlying asset. Restricted to 'Commodity'. Required."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        definition: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["underlying_type"] = args[0]
            args = tuple()
        super().__init__(*args, underlying_type=UnderlyingTypeEnum.COMMODITY, **kwargs)


class UnderlyingCurves(_model_base.Model):
    """UnderlyingCurves.

    Attributes
    ----------
    interest_rate_curves : dict[str, ~analyticsapi.models.UnderlyingZcCurves]
        The list of attributes for the underlying curves surface.
    """

    interest_rate_curves: Optional[Dict[str, "_models.UnderlyingZcCurves"]] = rest_field(name="interestRateCurves")
    """The list of attributes for the underlying curves surface."""

    @overload
    def __init__(
        self,
        interest_rate_curves: Optional[Dict[str, "_models.UnderlyingZcCurves"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["interest_rate_curves"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class UnderlyingEquity(UnderlyingDefinition, discriminator="Equity"):
    """An object that defines the underlying equity instrument.

    Attributes
    ----------
    code : str
        The code (a RIC) used to define the underlying asset.
    definition : str
        The identifier of the underlying definition resource (GUID or URI).
        Note that a URI must be at least 2 and at most 102 characters long,
        start with an alphanumeric character, and contain only alphanumeric
        characters, slashes and underscores.
    underlying_type : str or ~analyticsapi.models.EQUITY
        The type of the underlying asset. Restricted to 'Equity'. Required.
    """

    underlying_type: Literal[UnderlyingTypeEnum.EQUITY] = rest_discriminator(name="underlyingType")  # type: ignore
    """The type of the underlying asset. Restricted to 'Equity'. Required."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        definition: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["underlying_type"] = args[0]
            args = tuple()
        super().__init__(*args, underlying_type=UnderlyingTypeEnum.EQUITY, **kwargs)


class UnderlyingFx(UnderlyingDefinition, discriminator="Fx"):
    """An object that defines the underlying FX instrument.

    Attributes
    ----------
    code : str
        The code (a RIC) used to define the underlying asset.
    definition : str
        The identifier of the underlying definition resource (GUID or URI).
        Note that a URI must be at least 2 and at most 102 characters long,
        start with an alphanumeric character, and contain only alphanumeric
        characters, slashes and underscores.
    underlying_type : str or ~analyticsapi.models.FX
        The type of the underlying asset. Restricted to 'Fx'. Required.
    """

    underlying_type: Literal[UnderlyingTypeEnum.FX] = rest_discriminator(name="underlyingType")  # type: ignore
    """The type of the underlying asset. Restricted to 'Fx'. Required."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        definition: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["underlying_type"] = args[0]
            args = tuple()
        super().__init__(*args, underlying_type=UnderlyingTypeEnum.FX, **kwargs)


class UnderlyingIrs(UnderlyingDefinition, discriminator="Irs"):
    """An object that defines the underlying interest rate swap instrument.

    Attributes
    ----------
    code : str
        The code (a RIC) used to define the underlying asset.
    definition : str
        The identifier of the underlying definition resource (GUID or URI).
        Note that a URI must be at least 2 and at most 102 characters long,
        start with an alphanumeric character, and contain only alphanumeric
        characters, slashes and underscores.
    underlying_type : str or ~analyticsapi.models.IRS
        The type of the underlying asset. Restricted to 'Irs'. Required.
    """

    underlying_type: Literal[UnderlyingTypeEnum.IRS] = rest_discriminator(name="underlyingType")  # type: ignore
    """The type of the underlying asset. Restricted to 'Irs'. Required."""

    @overload
    def __init__(
        self,
        *,
        code: Optional[str] = None,
        definition: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["underlying_type"] = args[0]
            args = tuple()
        super().__init__(*args, underlying_type=UnderlyingTypeEnum.IRS, **kwargs)


class UnderlyingZcCurves(_model_base.Model):
    """UnderlyingZcCurves.

    Attributes
    ----------
    underlying_zc_curves : ~analyticsapi.models.ZcCurve
    """

    underlying_zc_curves: Optional["_models.ZcCurve"] = rest_field(name="underlyingZcCurves")

    @overload
    def __init__(
        self,
        underlying_zc_curves: Optional["_models.ZcCurve"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["underlying_zc_curves"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class UserCurve(_model_base.Model):
    """UserCurve.

    Attributes
    ----------
    curve_type : str
        Is one of the following types: Literal["GVT"], Literal["GVT_TSYM"],
        Literal["GVT_TSYM_MUNI"], Literal["GVT_AGN"], Literal["GVT_MUNI"],
        Literal["GVT_BUND"], Literal["SWAP"], Literal["SWAP_RFR"],
        Literal["SWAP_MUNI"]
    currency : str
    points : list[~analyticsapi.models.CurvePoint]
        The default value is None, needs to be assigned before using.
    rate_type : str
        Is one of the following types: Literal["Spot"], Literal["Par"],
        Literal["Forward"], Literal["DiscountFactor"]
    source : str
    asof : str
    compounding_freq : int
    relative : bool
    validate : bool
    swap_index : str
    swap_fixed_day_type : str
    swap_float_day_type : str
    swap_reset_convention : str
    """

    curve_type: Optional[
        Literal["GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN", "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI"]
    ] = rest_field(name="curveType")
    """Is one of the following types: Literal[\"GVT\"], Literal[\"GVT_TSYM\"],
     Literal[\"GVT_TSYM_MUNI\"], Literal[\"GVT_AGN\"], Literal[\"GVT_MUNI\"], Literal[\"GVT_BUND\"],
     Literal[\"SWAP\"], Literal[\"SWAP_RFR\"], Literal[\"SWAP_MUNI\"]"""
    currency: Optional[str] = rest_field()
    points: Optional[List["_models.CurvePoint"]] = rest_field()
    rate_type: Optional[Literal["Spot", "Par", "Forward", "DiscountFactor"]] = rest_field(name="rateType")
    """Is one of the following types: Literal[\"Spot\"], Literal[\"Par\"], Literal[\"Forward\"],
     Literal[\"DiscountFactor\"]"""
    source: Optional[str] = rest_field()
    asof: Optional[str] = rest_field()
    compounding_freq: Optional[int] = rest_field(name="compoundingFreq")
    relative: Optional[bool] = rest_field()
    validate: Optional[bool] = rest_field()
    swap_index: Optional[str] = rest_field(name="swapIndex")
    swap_fixed_day_type: Optional[str] = rest_field(name="swapFixedDayType")
    swap_float_day_type: Optional[str] = rest_field(name="swapFloatDayType")
    swap_reset_convention: Optional[str] = rest_field(name="swapResetConvention")

    @overload
    def __init__(
        self,
        *,
        curve_type: Optional[
            Literal[
                "GVT", "GVT_TSYM", "GVT_TSYM_MUNI", "GVT_AGN", "GVT_MUNI", "GVT_BUND", "SWAP", "SWAP_RFR", "SWAP_MUNI"
            ]
        ] = None,
        currency: Optional[str] = None,
        points: Optional[List["_models.CurvePoint"]] = None,
        rate_type: Optional[Literal["Spot", "Par", "Forward", "DiscountFactor"]] = None,
        source: Optional[str] = None,
        asof: Optional[str] = None,
        compounding_freq: Optional[int] = None,
        relative: Optional[bool] = None,
        validate: Optional[bool] = None,
        swap_index: Optional[str] = None,
        swap_fixed_day_type: Optional[str] = None,
        swap_float_day_type: Optional[str] = None,
        swap_reset_convention: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UserLoan(_model_base.Model):
    """User Loan.

    Attributes
    ----------
    deal : ~analyticsapi.models.UserLoanDeal
    collateral : ~analyticsapi.models.UserLoanCollateral
    """

    deal: Optional["_models.UserLoanDeal"] = rest_field()
    collateral: Optional["_models.UserLoanCollateral"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        deal: Optional["_models.UserLoanDeal"] = None,
        collateral: Optional["_models.UserLoanCollateral"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UserLoanCollateral(_model_base.Model):
    """UserLoanCollateral.

    Attributes
    ----------
    columns : list[str]
        The default value is None, needs to be assigned before using.
    data : list[list[dict[str, any]]]
        The default value is None, needs to be assigned before using.
    records : list[dict[str, any]]
        The default value is None, needs to be assigned before using.
    defaults : dict[str, any]
    """

    columns: Optional[List[str]] = rest_field()
    data: Optional[List[List[Dict[str, Any]]]] = rest_field()
    records: Optional[List[Dict[str, Any]]] = rest_field()
    defaults: Optional[Dict[str, Any]] = rest_field()

    @overload
    def __init__(
        self,
        *,
        columns: Optional[List[str]] = None,
        data: Optional[List[List[Dict[str, Any]]]] = None,
        records: Optional[List[Dict[str, Any]]] = None,
        defaults: Optional[Dict[str, Any]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UserLoanDeal(_model_base.Model):
    """UserLoanDeal.

    Attributes
    ----------
    deal_template : str
        Is either a Literal["PT"] type or a Literal["IOPO"] type.
    dated_date : ~datetime.date
    amount : ~decimal.Decimal
    delay : int
    finance_rate : ~decimal.Decimal
    freq : int
    settle_date : ~datetime.date
    asset_purchase_date : ~datetime.date
    int_date_count : str
    issue_type : str
    country : str
    coupon : ~decimal.Decimal
    first_pay_date : ~datetime.date
    """

    deal_template: Optional[Literal["PT", "IOPO"]] = rest_field(name="dealTemplate")
    """Is either a Literal[\"PT\"] type or a Literal[\"IOPO\"] type."""
    dated_date: Optional[datetime.date] = rest_field(name="datedDate")
    amount: Optional[decimal.Decimal] = rest_field()
    delay: Optional[int] = rest_field()
    finance_rate: Optional[decimal.Decimal] = rest_field(name="financeRate")
    freq: Optional[int] = rest_field()
    settle_date: Optional[datetime.date] = rest_field(name="settleDate")
    asset_purchase_date: Optional[datetime.date] = rest_field(name="assetPurchaseDate")
    int_date_count: Optional[str] = rest_field(name="intDateCount")
    issue_type: Optional[str] = rest_field(name="issueType")
    country: Optional[str] = rest_field()
    coupon: Optional[decimal.Decimal] = rest_field()
    first_pay_date: Optional[datetime.date] = rest_field(name="firstPayDate")

    @overload
    def __init__(
        self,
        *,
        deal_template: Optional[Literal["PT", "IOPO"]] = None,
        dated_date: Optional[datetime.date] = None,
        amount: Optional[decimal.Decimal] = None,
        delay: Optional[int] = None,
        finance_rate: Optional[decimal.Decimal] = None,
        freq: Optional[int] = None,
        settle_date: Optional[datetime.date] = None,
        asset_purchase_date: Optional[datetime.date] = None,
        int_date_count: Optional[str] = None,
        issue_type: Optional[str] = None,
        country: Optional[str] = None,
        coupon: Optional[decimal.Decimal] = None,
        first_pay_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UserScenario(_model_base.Model):
    """UserScenario.

    Attributes
    ----------
    shift_type : str
        Is one of the following types: Literal["Forward"],
        Literal["ImpliedForward"], Literal["Par"], Literal["Spot"]
    interpolation_type : str
        Is one of the following types: Literal["Years"], Literal["Yields"],
        Literal["PrincipalComponents"]
    swap_spread_const : bool
        Optional, if true, the spread between the treasury curve and swap curve
        is held constant.
    curve_shifts : list[~analyticsapi.models.ApimCurveShift]
        The default value is None, needs to be assigned before using.
    curve_multi_shifts : list[~analyticsapi.models.CurveMultiShift]
        The default value is None, needs to be assigned before using.
    curve_points : list[~analyticsapi.models.ScenAbsoluteCurvePoint]
        The default value is None, needs to be assigned before using.
    """

    shift_type: Optional[Literal["Forward", "ImpliedForward", "Par", "Spot"]] = rest_field(name="shiftType")
    """Is one of the following types: Literal[\"Forward\"], Literal[\"ImpliedForward\"],
     Literal[\"Par\"], Literal[\"Spot\"]"""
    interpolation_type: Optional[Literal["Years", "Yields", "PrincipalComponents"]] = rest_field(
        name="interpolationType"
    )
    """Is one of the following types: Literal[\"Years\"], Literal[\"Yields\"],
     Literal[\"PrincipalComponents\"]"""
    swap_spread_const: Optional[bool] = rest_field(name="swapSpreadConst")
    """Optional, if true, the spread between the treasury curve and swap curve is held constant."""
    curve_shifts: Optional[List["_models.ApimCurveShift"]] = rest_field(name="curveShifts")
    curve_multi_shifts: Optional[List["_models.CurveMultiShift"]] = rest_field(name="curveMultiShifts")
    curve_points: Optional[List["_models.ScenAbsoluteCurvePoint"]] = rest_field(name="curvePoints")

    @overload
    def __init__(
        self,
        *,
        shift_type: Optional[Literal["Forward", "ImpliedForward", "Par", "Spot"]] = None,
        interpolation_type: Optional[Literal["Years", "Yields", "PrincipalComponents"]] = None,
        swap_spread_const: Optional[bool] = None,
        curve_shifts: Optional[List["_models.ApimCurveShift"]] = None,
        curve_multi_shifts: Optional[List["_models.CurveMultiShift"]] = None,
        curve_points: Optional[List["_models.ScenAbsoluteCurvePoint"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UserScenarioCurve(_model_base.Model):
    """UserScenarioCurve.

    Attributes
    ----------
    timing : str
        Is one of the following types: Literal["Immediate"],
        Literal["Gradual"], Literal["AtHorizon"]
    reinvestment_rate : str
    definition : ~analyticsapi.models.UserScenCurveDefinition
    current_coupon_spread_change : ~decimal.Decimal
    """

    timing: Optional[Literal["Immediate", "Gradual", "AtHorizon"]] = rest_field()
    """Is one of the following types: Literal[\"Immediate\"], Literal[\"Gradual\"],
     Literal[\"AtHorizon\"]"""
    reinvestment_rate: Optional[str] = rest_field(name="reinvestmentRate")
    definition: Optional["_models.UserScenCurveDefinition"] = rest_field()
    current_coupon_spread_change: Optional[decimal.Decimal] = rest_field(name="currentCouponSpreadChange")

    @overload
    def __init__(
        self,
        *,
        timing: Optional[Literal["Immediate", "Gradual", "AtHorizon"]] = None,
        reinvestment_rate: Optional[str] = None,
        definition: Optional["_models.UserScenCurveDefinition"] = None,
        current_coupon_spread_change: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UserScenarioInput(_model_base.Model):
    """UserScenarioInput.

    Attributes
    ----------
    volatility : ~analyticsapi.models.ScenarioVolatility
    curve : ~analyticsapi.models.UserScenarioCurve
    """

    volatility: Optional["_models.ScenarioVolatility"] = rest_field()
    curve: Optional["_models.UserScenarioCurve"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        volatility: Optional["_models.ScenarioVolatility"] = None,
        curve: Optional["_models.UserScenarioCurve"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class UserScenCurveDefinition(_model_base.Model):
    """UserScenCurveDefinition.

    Attributes
    ----------
    user_scenario : ~analyticsapi.models.UserScenario
    """

    user_scenario: Optional["_models.UserScenario"] = rest_field(name="userScenario")

    @overload
    def __init__(
        self,
        user_scenario: Optional["_models.UserScenario"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["user_scenario"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class UserVol(_model_base.Model):
    """UserVol.

    Attributes
    ----------
    shift_type : str
    volatility_type : str
    currency : str
    asof : str
    term_unit : str
        Is either a Literal["MONTH"] type or a Literal["YEAR"] type.
    swaption_volatility : list[~analyticsapi.models.VolItem]
        The default value is None, needs to be assigned before using.
    cap_volatility : list[~analyticsapi.models.VolItem]
        The default value is None, needs to be assigned before using.
    """

    shift_type: Optional[str] = rest_field(name="shiftType")
    volatility_type: Optional[str] = rest_field(name="volatilityType")
    currency: Optional[str] = rest_field()
    asof: Optional[str] = rest_field()
    term_unit: Optional[Literal["MONTH", "YEAR"]] = rest_field(name="termUnit")
    """Is either a Literal[\"MONTH\"] type or a Literal[\"YEAR\"] type."""
    swaption_volatility: Optional[List["_models.VolItem"]] = rest_field(name="swaptionVolatility")
    cap_volatility: Optional[List["_models.VolItem"]] = rest_field(name="capVolatility")

    @overload
    def __init__(
        self,
        *,
        shift_type: Optional[str] = None,
        volatility_type: Optional[str] = None,
        currency: Optional[str] = None,
        asof: Optional[str] = None,
        term_unit: Optional[Literal["MONTH", "YEAR"]] = None,
        swaption_volatility: Optional[List["_models.VolItem"]] = None,
        cap_volatility: Optional[List["_models.VolItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ValidityPeriod(_model_base.Model):
    """An object to determine the validity period.

    Attributes
    ----------
    start_date : ~datetime.date
        The start date of the validity period. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., 2023-01-01). The default is
        "1950-01-01".
    end_date : ~datetime.date
        The end date of the validity period. The value is expressed in ISO 8601
        format: YYYY-MM-DD (e.g., 2024-01-01). The default is "2050-01-01".
    """

    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The start date of the validity period. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., 2023-01-01). The default is \"1950-01-01\"."""
    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The end date of the validity period. The value is expressed in ISO 8601 format: YYYY-MM-DD
     (e.g., 2024-01-01). The default is \"2050-01-01\"."""

    @overload
    def __init__(
        self,
        *,
        start_date: Optional[datetime.date] = None,
        end_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ValuationTime(_model_base.Model):
    """ValuationTime.

    Attributes
    ----------
    city_name : str or ~analyticsapi.models.CityNameEnum
        The city name according to Market Identifier Code (MIC) (e.g., 'NEW
        YORK') See ISO 10383 for reference. Known values are: "Aabenraa",
        "Aalborg", "Abidjan", "AbuDhabi", "Accra", "Ahmedabad", "Aichi",
        "Alberta", "Algiers", "Almaty", "Amman", "Amsterdam", "Ankara",
        "Antananarivo", "Antwerpen", "Astana", "Asti", "Asuncion", "Athens",
        "Atlanta", "Auckland", "Aylesbury", "Baghdad", "Baku", "Bangalore",
        "Bangkok", "BanjaLuka", "Barcelona", "Basseterre", "Bedminster",
        "Beijing", "Beirut", "Belgrade", "Bergamo", "Bergen", "Berlin",
        "Bermuda", "Berne", "Biella", "Bilbao", "Bishkek", "Blantyre",
        "BocaRaton", "Bogota", "Bologna", "Boston", "Bradford", "Bratislava",
        "Bremen", "Bridgetown", "Brussels", "BryanstonSandton", "Bucharest",
        "Budaors", "Budapest", "BuenosAires", "Cairo", "Calcutta", "Calgary",
        "Caracas", "Casablanca", "Charlotte", "Chatham", "Chicago", "Chisinau",
        "Chittagong", "ChiyodaKu", "ClujNapoca", "Colombo", "Copenhagen",
        "Cordoba", "Corrientes", "Curitiba", "CybercityEbene", "Dalian",
        "Dallas", "Damascus", "DarEsSalaam", "Delhi", "Dhaka",
        "Dnipropetrovsk", "Doha", "Douala", "Dubai", "Dublin", "Duesseldorf",
        "Ebene", "EbeneCity", "EdenIsland", "Edinburgh", "Ekaterinburg",
        "ElSalvador", "Eschborn", "EschSurAlzette", "EspiritoSanto", "Espoo",
        "Fiac", "Firenze", "Florence", "Frankfurt", "FrankfurtAmMain",
        "Fukuoka", "Gaborone", "Gandhinagar", "Geneva", "Genova", "Georgetown",
        "Gibraltar", "GiftCityGandhinagar", "Glenview", "GreatNeck",
        "Greenwich", "Grindsted", "Guatemala", "Guayaquil", "Guaynabo",
        "Guildford", "Hamburg", "Hamilton", "Hannover", "Hanoi", "Harare",
        "Helsinki", "Hiroshima", "HoChiMinhCity", "HongKong", "Horsens",
        "Hove", "HradecKralove", "Illinois", "IndoreMadhyaPradesh",
        "Islamabad", "Istanbul", "Izmir", "Jaen", "Jakarta", "JerseyCity",
        "Johannesburg", "Kampala", "KansasCity", "Karachi", "Kathmandu",
        "Kharkov", "Khartoum", "Kiel", "Kiev", "Kigali", "Kingston",
        "Kingstown", "KlagenfurtAmWoerthersee", "Kobe", "Kongsvinger",
        "Krakow", "KualaLumpur", "Kuwait", "Kyoto", "LaPaz", "Labuan", "Lagos",
        "Lahore", "LaneCove", "Lao", "Larnaca", "Leipzig", "Lenexa", "Leuven",
        "Lima", "Limassol", "Linz", "Lisbon", "Ljubljana", "London",
        "LosAngeles", "Luanda", "Lusaka", "Luxembourg", "Luzern", "Madras",
        "Madrid", "MakatiCity", "Male", "Managua", "Manama", "Manila",
        "Maputo", "Maringa", "Mbabane", "Melbourne", "Mendoza", "Mexico",
        "Miami", "Milan", "MiltonKeynes", "Minneapolis", "Minsk", "Montevideo",
        "Montreal", "Moorpark", "Moscow", "MountPleasant", "Muenchen",
        "Mumbai", "Munich", "Muscat", "Nablus", "Nacka", "Nagoya", "Nairobi",
        "Narberth", "Nasau", "NewYorkCity", "Newcastle", "Nicosia", "Nigita",
        "NizhniyNovgorod", "NorthBergen", "Novosibirsk", "Nyon", "Odessa",
        "Oldenburg", "Osaka", "Oslo", "Oststeinbek", "Padova",
        "PalmaDeMallorca", "Panama", "Paris", "PasigCity", "Philadelphia",
        "PhnomPenh", "Phoenix", "Podgorica", "Polokwane", "PortLouis",
        "PortMoresby", "PortOfSpain", "PortVila", "Porto", "Prague", "Praia",
        "Princeton", "Purchase", "Quito", "Randers", "RedBank", "Regensburg",
        "Reykjavik", "Riga", "RioDeJaneiro", "Riyadh", "RoadTown", "Rodgau",
        "Rome", "Rosario", "Rostov", "Sabadell", "SaintPetersburg", "Salzburg",
        "Samara", "SanCarlos", "SanFrancisco", "SanJose", "SanPedroSula",
        "SantaFe", "Santander", "Santiago", "SantoDomingo", "SaoPaulo",
        "Sapporo", "Sarajevo", "Schwerin", "SeaGirt", "Seoul", "Shanghai",
        "Shenzhen", "Shertogenbosch", "Shimonoseki", "Sibiu", "Silkeborg",
        "Singapore", "Skopje", "Sliema", "Sofia", "Split", "StAlbans",
        "StJohn", "StPeterPort", "Stamford", "Stockholm", "Stuttgart",
        "Surabaya", "Suva", "Sydney", "Taipei", "Taiwan", "Tallinn",
        "Tashkent", "Tbilisi", "Tegucigalpa", "Tehran", "TelAviv", "TheHague",
        "TheWoodlands", "Tirana", "Tokyo", "Torino", "Toronto", "Torshavn",
        "Tortola", "Tripoli", "Tromso", "Trondheim", "Tucuman", "Tunis",
        "UlaanBaatar", "Unterschleisshem", "Utrecht", "Vaduz", "Valencia",
        "Valletta", "Valparaiso", "Vancouver", "Varazdin", "Victoria",
        "VictoriaFalls", "Vienna", "Vila", "Vilnius", "Vladivostok", "Warsaw",
        "Washington", "Willemstad", "Wilmington", "Windhoek", "Winnipeg",
        "WinterPark", "Wroclaw", "Wuxi", "Yerevan", "Zagreb", "Zaragoza",
        "Zhengzhou", "Zilina", "Zug", and "Zurich".
    local_time : ~datetime.time
        Local time or other words time in offset timezone. The value is
        expressed in ISO 8601 format: [hh]:[mm]:[ss] (e.g., '14:00:00').
    market_identifier_code : str
        The Market Identifier Code (MIC) used to identify securities trading
        exchanges, regulated and non-regulated trading markets. The MIC is a
        four alphanumeric character code, and is defined in ISO 10383 (e.g.,
        'XNAS' for NASDAQ).   See ISO 10383 for reference.
    time_zone_offset : ~datetime.datetime
        Time offsets from UTC. The value is expressed in ISO 8601 format:
        [hh]:[mm] (e.g., '+05:00').
    """

    city_name: Optional[Union[str, "_models.CityNameEnum"]] = rest_field(name="cityName")
    """The city name according to Market Identifier Code (MIC) (e.g., 'NEW YORK')  See ISO 10383 for
     reference. Known values are: \"Aabenraa\", \"Aalborg\", \"Abidjan\", \"AbuDhabi\", \"Accra\",
     \"Ahmedabad\", \"Aichi\", \"Alberta\", \"Algiers\", \"Almaty\", \"Amman\", \"Amsterdam\",
     \"Ankara\", \"Antananarivo\", \"Antwerpen\", \"Astana\", \"Asti\", \"Asuncion\", \"Athens\",
     \"Atlanta\", \"Auckland\", \"Aylesbury\", \"Baghdad\", \"Baku\", \"Bangalore\", \"Bangkok\",
     \"BanjaLuka\", \"Barcelona\", \"Basseterre\", \"Bedminster\", \"Beijing\", \"Beirut\",
     \"Belgrade\", \"Bergamo\", \"Bergen\", \"Berlin\", \"Bermuda\", \"Berne\", \"Biella\",
     \"Bilbao\", \"Bishkek\", \"Blantyre\", \"BocaRaton\", \"Bogota\", \"Bologna\", \"Boston\",
     \"Bradford\", \"Bratislava\", \"Bremen\", \"Bridgetown\", \"Brussels\", \"BryanstonSandton\",
     \"Bucharest\", \"Budaors\", \"Budapest\", \"BuenosAires\", \"Cairo\", \"Calcutta\",
     \"Calgary\", \"Caracas\", \"Casablanca\", \"Charlotte\", \"Chatham\", \"Chicago\",
     \"Chisinau\", \"Chittagong\", \"ChiyodaKu\", \"ClujNapoca\", \"Colombo\", \"Copenhagen\",
     \"Cordoba\", \"Corrientes\", \"Curitiba\", \"CybercityEbene\", \"Dalian\", \"Dallas\",
     \"Damascus\", \"DarEsSalaam\", \"Delhi\", \"Dhaka\", \"Dnipropetrovsk\", \"Doha\", \"Douala\",
     \"Dubai\", \"Dublin\", \"Duesseldorf\", \"Ebene\", \"EbeneCity\", \"EdenIsland\",
     \"Edinburgh\", \"Ekaterinburg\", \"ElSalvador\", \"Eschborn\", \"EschSurAlzette\",
     \"EspiritoSanto\", \"Espoo\", \"Fiac\", \"Firenze\", \"Florence\", \"Frankfurt\",
     \"FrankfurtAmMain\", \"Fukuoka\", \"Gaborone\", \"Gandhinagar\", \"Geneva\", \"Genova\",
     \"Georgetown\", \"Gibraltar\", \"GiftCityGandhinagar\", \"Glenview\", \"GreatNeck\",
     \"Greenwich\", \"Grindsted\", \"Guatemala\", \"Guayaquil\", \"Guaynabo\", \"Guildford\",
     \"Hamburg\", \"Hamilton\", \"Hannover\", \"Hanoi\", \"Harare\", \"Helsinki\", \"Hiroshima\",
     \"HoChiMinhCity\", \"HongKong\", \"Horsens\", \"Hove\", \"HradecKralove\", \"Illinois\",
     \"IndoreMadhyaPradesh\", \"Islamabad\", \"Istanbul\", \"Izmir\", \"Jaen\", \"Jakarta\",
     \"JerseyCity\", \"Johannesburg\", \"Kampala\", \"KansasCity\", \"Karachi\", \"Kathmandu\",
     \"Kharkov\", \"Khartoum\", \"Kiel\", \"Kiev\", \"Kigali\", \"Kingston\", \"Kingstown\",
     \"KlagenfurtAmWoerthersee\", \"Kobe\", \"Kongsvinger\", \"Krakow\", \"KualaLumpur\",
     \"Kuwait\", \"Kyoto\", \"LaPaz\", \"Labuan\", \"Lagos\", \"Lahore\", \"LaneCove\", \"Lao\",
     \"Larnaca\", \"Leipzig\", \"Lenexa\", \"Leuven\", \"Lima\", \"Limassol\", \"Linz\", \"Lisbon\",
     \"Ljubljana\", \"London\", \"LosAngeles\", \"Luanda\", \"Lusaka\", \"Luxembourg\", \"Luzern\",
     \"Madras\", \"Madrid\", \"MakatiCity\", \"Male\", \"Managua\", \"Manama\", \"Manila\",
     \"Maputo\", \"Maringa\", \"Mbabane\", \"Melbourne\", \"Mendoza\", \"Mexico\", \"Miami\",
     \"Milan\", \"MiltonKeynes\", \"Minneapolis\", \"Minsk\", \"Montevideo\", \"Montreal\",
     \"Moorpark\", \"Moscow\", \"MountPleasant\", \"Muenchen\", \"Mumbai\", \"Munich\", \"Muscat\",
     \"Nablus\", \"Nacka\", \"Nagoya\", \"Nairobi\", \"Narberth\", \"Nasau\", \"NewYorkCity\",
     \"Newcastle\", \"Nicosia\", \"Nigita\", \"NizhniyNovgorod\", \"NorthBergen\", \"Novosibirsk\",
     \"Nyon\", \"Odessa\", \"Oldenburg\", \"Osaka\", \"Oslo\", \"Oststeinbek\", \"Padova\",
     \"PalmaDeMallorca\", \"Panama\", \"Paris\", \"PasigCity\", \"Philadelphia\", \"PhnomPenh\",
     \"Phoenix\", \"Podgorica\", \"Polokwane\", \"PortLouis\", \"PortMoresby\", \"PortOfSpain\",
     \"PortVila\", \"Porto\", \"Prague\", \"Praia\", \"Princeton\", \"Purchase\", \"Quito\",
     \"Randers\", \"RedBank\", \"Regensburg\", \"Reykjavik\", \"Riga\", \"RioDeJaneiro\",
     \"Riyadh\", \"RoadTown\", \"Rodgau\", \"Rome\", \"Rosario\", \"Rostov\", \"Sabadell\",
     \"SaintPetersburg\", \"Salzburg\", \"Samara\", \"SanCarlos\", \"SanFrancisco\", \"SanJose\",
     \"SanPedroSula\", \"SantaFe\", \"Santander\", \"Santiago\", \"SantoDomingo\", \"SaoPaulo\",
     \"Sapporo\", \"Sarajevo\", \"Schwerin\", \"SeaGirt\", \"Seoul\", \"Shanghai\", \"Shenzhen\",
     \"Shertogenbosch\", \"Shimonoseki\", \"Sibiu\", \"Silkeborg\", \"Singapore\", \"Skopje\",
     \"Sliema\", \"Sofia\", \"Split\", \"StAlbans\", \"StJohn\", \"StPeterPort\", \"Stamford\",
     \"Stockholm\", \"Stuttgart\", \"Surabaya\", \"Suva\", \"Sydney\", \"Taipei\", \"Taiwan\",
     \"Tallinn\", \"Tashkent\", \"Tbilisi\", \"Tegucigalpa\", \"Tehran\", \"TelAviv\", \"TheHague\",
     \"TheWoodlands\", \"Tirana\", \"Tokyo\", \"Torino\", \"Toronto\", \"Torshavn\", \"Tortola\",
     \"Tripoli\", \"Tromso\", \"Trondheim\", \"Tucuman\", \"Tunis\", \"UlaanBaatar\",
     \"Unterschleisshem\", \"Utrecht\", \"Vaduz\", \"Valencia\", \"Valletta\", \"Valparaiso\",
     \"Vancouver\", \"Varazdin\", \"Victoria\", \"VictoriaFalls\", \"Vienna\", \"Vila\",
     \"Vilnius\", \"Vladivostok\", \"Warsaw\", \"Washington\", \"Willemstad\", \"Wilmington\",
     \"Windhoek\", \"Winnipeg\", \"WinterPark\", \"Wroclaw\", \"Wuxi\", \"Yerevan\", \"Zagreb\",
     \"Zaragoza\", \"Zhengzhou\", \"Zilina\", \"Zug\", and \"Zurich\"."""
    local_time: Optional[datetime.time] = rest_field(name="localTime")
    """Local time or other words time in offset timezone. The value is expressed in ISO 8601 format:
     [hh]:[mm]:[ss] (e.g., '14:00:00')."""
    market_identifier_code: Optional[str] = rest_field(name="marketIdentifierCode")
    """The Market Identifier Code (MIC) used to identify securities trading exchanges, regulated and
     non-regulated trading markets. The MIC is a four alphanumeric character code, and is defined in
     ISO 10383 (e.g., 'XNAS' for NASDAQ).   See ISO 10383 for reference."""
    time_zone_offset: Optional[datetime.datetime] = rest_field(name="timeZoneOffset", format="rfc3339")
    """Time offsets from UTC. The value is expressed in ISO 8601 format: [hh]:[mm] (e.g., '+05:00')."""

    @overload
    def __init__(
        self,
        *,
        city_name: Optional[Union[str, "_models.CityNameEnum"]] = None,
        local_time: Optional[datetime.time] = None,
        market_identifier_code: Optional[str] = None,
        time_zone_offset: Optional[datetime.datetime] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Values(_model_base.Model):
    """An object that contains the bid and ask quotes for the instrument.

    Attributes
    ----------
    bid : ~analyticsapi.models.FieldValue
        An object that contains the bid quote for the instrument.
    ask : ~analyticsapi.models.FieldValue
        An object that contains the ask quote for the instrument.
    """

    bid: Optional["_models.FieldValue"] = rest_field()
    """An object that contains the bid quote for the instrument."""
    ask: Optional["_models.FieldValue"] = rest_field()
    """An object that contains the ask quote for the instrument."""

    @overload
    def __init__(
        self,
        *,
        bid: Optional["_models.FieldValue"] = None,
        ask: Optional["_models.FieldValue"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VanillaIrsOverride(_model_base.Model):
    """An object that contains interest rate swap properties that can be overridden.

    Attributes
    ----------
    start_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the interest
        rate swap start date.
    end_date : ~analyticsapi.models.Date
        An object that contains properties to define and adjust the interest
        rate swap end date.
    amount : float
        The principal amount of the interest rate swap.
    fixed_rate : ~analyticsapi.models.Rate
        An object that contains properties to override the fixed rate of the
        interest rate swap.
    spread : ~analyticsapi.models.Rate
        An object that contains properties to override the interet rate swap
        spread over the floating rate index.
    payer_receiver : str or ~analyticsapi.models.PayerReceiverEnum
        A flag that defines whether the interest rate swap is a fixed rate
        payer or receiver. Known values are: "Payer" and "Receiver".
    """

    start_date: Optional["_models.Date"] = rest_field(name="startDate")
    """An object that contains properties to define and adjust the interest rate swap start date."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """An object that contains properties to define and adjust the interest rate swap end date."""
    amount: Optional[float] = rest_field()
    """The principal amount of the interest rate swap."""
    fixed_rate: Optional["_models.Rate"] = rest_field(name="fixedRate")
    """An object that contains properties to override the fixed rate of the interest rate swap."""
    spread: Optional["_models.Rate"] = rest_field()
    """An object that contains properties to override the interet rate swap spread over the floating
     rate index."""
    payer_receiver: Optional[Union[str, "_models.PayerReceiverEnum"]] = rest_field(name="payerReceiver")
    """A flag that defines whether the interest rate swap is a fixed rate payer or receiver. Known
     values are: \"Payer\" and \"Receiver\"."""

    @overload
    def __init__(
        self,
        *,
        start_date: Optional["_models.Date"] = None,
        end_date: Optional["_models.Date"] = None,
        amount: Optional[float] = None,
        fixed_rate: Optional["_models.Rate"] = None,
        spread: Optional["_models.Rate"] = None,
        payer_receiver: Optional[Union[str, "_models.PayerReceiverEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VanillaOtcOptionOverride(_model_base.Model):
    """An object that contains the properties of an OTC vanilla option that can be overridden.

    Attributes
    ----------
    strike : float
        The set price at which the option holder can buy or sell the underlying
        asset. The value is expressed according to the market convention linked
        to the underlying asset.
    end_date : ~analyticsapi.models.Date
        An object that defines the maturity or expiry date of an option
        instrument.
    underlying_code : str
        The code (a RIC) used to define the underlying asset.
    option_type : str or ~analyticsapi.models.CallPutEnum
        An indicator of whether an option instrument is a call or a put. Known
        values are: "Call" and "Put".
    notional_amount : float
        The notional amount of an option instrument.
    """

    strike: Optional[float] = rest_field()
    """The set price at which the option holder can buy or sell the underlying asset. The value is
     expressed according to the market convention linked to the underlying asset."""
    end_date: Optional["_models.Date"] = rest_field(name="endDate")
    """An object that defines the maturity or expiry date of an option instrument."""
    underlying_code: Optional[str] = rest_field(name="underlyingCode")
    """The code (a RIC) used to define the underlying asset."""
    option_type: Optional[Union[str, "_models.CallPutEnum"]] = rest_field(name="optionType")
    """An indicator of whether an option instrument is a call or a put. Known values are: \"Call\" and
     \"Put\"."""
    notional_amount: Optional[float] = rest_field(name="notionalAmount")
    """The notional amount of an option instrument."""

    @overload
    def __init__(
        self,
        *,
        strike: Optional[float] = None,
        end_date: Optional["_models.Date"] = None,
        underlying_code: Optional[str] = None,
        option_type: Optional[Union[str, "_models.CallPutEnum"]] = None,
        notional_amount: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VanillaOtcOptionTemplate(InstrumentTemplateDefinition, discriminator="VanillaOtcOption"):
    """VanillaOtcOptionTemplate.

    Attributes
    ----------
    instrument_type : str or ~analyticsapi.models.VANILLA_OTC_OPTION
        Required. Vanilla OTC Option contract.
    template : ~analyticsapi.models.OptionDefinition
        Required.
    """

    instrument_type: Literal[InstrumentTemplateTypeEnum.VANILLA_OTC_OPTION] = rest_discriminator(name="instrumentType")  # type: ignore # pylint: disable=line-too-long
    """Required. Vanilla OTC Option contract."""
    template: "_models.OptionDefinition" = rest_field()
    """Required."""

    @overload
    def __init__(
        self,
        template: "_models.OptionDefinition",
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, instrument_type=InstrumentTemplateTypeEnum.VANILLA_OTC_OPTION, **kwargs)


class Vector(_model_base.Model):
    """Vector.

    Attributes
    ----------
    interpolation_type : str
        How the draw amount should be determined in between specified vector
        months. Is either a Literal["INTERPOLATED"] type or a Literal["LEVEL"]
        type.
    index : str
    values_property : list[~analyticsapi.models.MonthRatePair]
        The default value is None, needs to be assigned before using.
    """

    interpolation_type: Optional[Literal["INTERPOLATED", "LEVEL"]] = rest_field(name="interpolationType")
    """How the draw amount should be determined in between specified vector months. Is either a
     Literal[\"INTERPOLATED\"] type or a Literal[\"LEVEL\"] type."""
    index: Optional[str] = rest_field()
    values_property: Optional[List["_models.MonthRatePair"]] = rest_field(name="values")

    @overload
    def __init__(
        self,
        *,
        interpolation_type: Optional[Literal["INTERPOLATED", "LEVEL"]] = None,
        index: Optional[str] = None,
        values_property: Optional[List["_models.MonthRatePair"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class Volatility(_model_base.Model):
    """Volatility.

    Attributes
    ----------
    type : str
        Term structure model selection. Is one of the following types:
        Literal["Single"], Literal["Long"], Literal["Market"],
        Literal["Historical"], Literal["MarketWSkew"], Literal["MatrixWSkew"],
        Literal["Matrix"], Literal["1-Factor"], Literal["1FMeanReversion"],
        Literal["1FNormal"], Literal["LMMSkew"], Literal["LMMSkewOIS"],
        Literal["LMMSkewOld"], Literal["LMMDL"], Literal["LMMDLMOD"],
        Literal["LMMDD"], Literal["LMMCMI"], Literal["LMMCMI2"],
        Literal["LMMALTDD"], Literal["LMMSOFR"], Literal["LMMSOFR2"],
        Literal["LMMSOFRFLAT"], Literal["LMMSCMI2"], Literal["LMMTONAR"],
        Literal["Default"], Literal["1FMeanReversionLogNormal"],
        Literal["1FMeanReversionNormal"]
    rate : float
        Volatility rate input, only needed if type selection is SINGLE.
    structure_note : ~analyticsapi.models.StructureNote
    user_defined : ~analyticsapi.models.JsonRef
    """

    type: Optional[
        Literal[
            "Single",
            "Long",
            "Market",
            "Historical",
            "MarketWSkew",
            "MatrixWSkew",
            "Matrix",
            "1-Factor",
            "1FMeanReversion",
            "1FNormal",
            "LMMSkew",
            "LMMSkewOIS",
            "LMMSkewOld",
            "LMMDL",
            "LMMDLMOD",
            "LMMDD",
            "LMMCMI",
            "LMMCMI2",
            "LMMALTDD",
            "LMMSOFR",
            "LMMSOFR2",
            "LMMSOFRFLAT",
            "LMMSCMI2",
            "LMMTONAR",
            "Default",
            "1FMeanReversionLogNormal",
            "1FMeanReversionNormal",
        ]
    ] = rest_field(default=None)
    """Term structure model selection. Is one of the following types: Literal[\"Single\"],
     Literal[\"Long\"], Literal[\"Market\"], Literal[\"Historical\"], Literal[\"MarketWSkew\"],
     Literal[\"MatrixWSkew\"], Literal[\"Matrix\"], Literal[\"1-Factor\"],
     Literal[\"1FMeanReversion\"], Literal[\"1FNormal\"], Literal[\"LMMSkew\"],
     Literal[\"LMMSkewOIS\"], Literal[\"LMMSkewOld\"], Literal[\"LMMDL\"], Literal[\"LMMDLMOD\"],
     Literal[\"LMMDD\"], Literal[\"LMMCMI\"], Literal[\"LMMCMI2\"], Literal[\"LMMALTDD\"],
     Literal[\"LMMSOFR\"], Literal[\"LMMSOFR2\"], Literal[\"LMMSOFRFLAT\"], Literal[\"LMMSCMI2\"],
     Literal[\"LMMTONAR\"], Literal[\"Default\"], Literal[\"1FMeanReversionLogNormal\"],
     Literal[\"1FMeanReversionNormal\"]"""
    rate: Optional[float] = rest_field()
    """Volatility rate input, only needed if type selection is SINGLE."""
    structure_note: Optional["_models.StructureNote"] = rest_field(name="structureNote")
    user_defined: Optional["_models.JsonRef"] = rest_field(name="userDefined")

    @overload
    def __init__(
        self,
        *,
        type: Optional[
            Literal[
                "Single",
                "Long",
                "Market",
                "Historical",
                "MarketWSkew",
                "MatrixWSkew",
                "Matrix",
                "1-Factor",
                "1FMeanReversion",
                "1FNormal",
                "LMMSkew",
                "LMMSkewOIS",
                "LMMSkewOld",
                "LMMDL",
                "LMMDLMOD",
                "LMMDD",
                "LMMCMI",
                "LMMCMI2",
                "LMMALTDD",
                "LMMSOFR",
                "LMMSOFR2",
                "LMMSOFRFLAT",
                "LMMSCMI2",
                "LMMTONAR",
                "Default",
                "1FMeanReversionLogNormal",
                "1FMeanReversionNormal",
            ]
        ] = None,
        rate: Optional[float] = None,
        structure_note: Optional["_models.StructureNote"] = None,
        user_defined: Optional["_models.JsonRef"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VolatilityCubeDefinition(_model_base.Model):
    """VolatilityCubeDefinition.

    Attributes
    ----------
    discounting_type : str or ~analyticsapi.models.DiscountingTypeEnum
        The discounting type of the interest rate volatility model. The default
        value is selected based on 'instrumentCode'. Known values are:
        "LiborDiscounting" and "OisDiscounting".
    index_name : str
        Underlying index name (e.g. 'EURIBOR').
    index_tenor : str
        Index tenor of the projected zero curve used to calculate swap rates.
        The default value is the index tenor associated with the underlying
        swap structure (for EUR_AB6E, 6M).
    instrument_code : str
        The Currency of the interest rate volatility model.
    underlying_swap_structure : str
        Underlying swap structure, eg: EUR_AB6E.
    """

    discounting_type: Optional[Union[str, "_models.DiscountingTypeEnum"]] = rest_field(name="discountingType")
    """The discounting type of the interest rate volatility model.
     The default value is selected based on 'instrumentCode'. Known values are: \"LiborDiscounting\"
     and \"OisDiscounting\"."""
    index_name: Optional[str] = rest_field(name="indexName")
    """Underlying index name (e.g. 'EURIBOR')."""
    index_tenor: Optional[str] = rest_field(name="indexTenor")
    """Index tenor of the projected zero curve used to calculate swap rates.
     The default value is the index tenor associated with the underlying swap structure (for
     EUR_AB6E, 6M)."""
    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The Currency of the interest rate volatility model."""
    underlying_swap_structure: Optional[str] = rest_field(name="underlyingSwapStructure")
    """Underlying swap structure, eg: EUR_AB6E."""

    @overload
    def __init__(
        self,
        *,
        discounting_type: Optional[Union[str, "_models.DiscountingTypeEnum"]] = None,
        index_name: Optional[str] = None,
        index_tenor: Optional[str] = None,
        instrument_code: Optional[str] = None,
        underlying_swap_structure: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VolatilityCubeSurfaceParameters(_model_base.Model):
    """VolatilityCubeSurfaceParameters.

    Attributes
    ----------
    beta : float
        SABR Beta parameter. The possible values: a number between 0 and 1. The
        default value is '0.45'.
    calculation_date : ~datetime.datetime
        The date the volatility surface is generated.
    calibration_type : str or ~analyticsapi.models.CurvesAndSurfacesCalibrationTypeEnum
        The Calibration type defines the solver used during calibration (i.e.
        Sabr Model Calibration Optimization Method). The default value is
        selected based on instrumentCode. Known values are:
        "AlternateConjugateGradient", "ConjugateGradient", "Powell", and
        "SimplexNelderMead".
    cap_source : str
    include_caplets_volatility : bool
        Determines whether the volatility cube is computed from interpolations
        on volatility skews, or via Atm swaption volatility and caplets
        volatility. The default value is True.
    input_volatility_type : str or ~analyticsapi.models.InputVolatilityTypeEnum
        user can specify whether calibration is based on Normal or Lognorma
        vol. However it would be preferrable to let the service determine the
        most appropriate one. Known values are: "Implied",
        "LogNormalVolatility", "NormalVolatility", "Quoted", and "Settle".
    output_volatility_type : str or ~analyticsapi.models.OutputVolatilityTypeEnum
        The SABR volatility can be expressed as lognormal volatility (%) or
        normal volatility (bp). By default the output volatility type follows
        the InputVolatilityType parameter. Known values are:
        "LogNormalVolatility" and "NormalVolatility".
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        Specifies whether bid, ask, mid or settle is used to build the surface.
        If not precised, default to mid. Known values are: "Ask", "Bid",
        "Last", and "Mid".
    shift_percent : float
        Shift applied to calibrated strikes allowing negative rates. The value
        is expressed in percentages. The default value is selected based on
        instrumentCode.
    source : str
        Requested volatility data contributor.
    strike_type : str or ~analyticsapi.models.CurvesAndSurfacesStrikeTypeEnum
        The strike axis type of the volatility cube surface. The default value
        is 'RelativePercent'. Known values are: "AbsolutePercent" and
        "RelativePercent".
    stripping_shift_percent : float
        Shift value applied to strikes allowing the stripped caplets surface to
        include volatility even when some strikes are negative. The value is
        expressed in percentages. The default value is '0.0'.
    swaption_source : str
    time_stamp : str or ~analyticsapi.models.CurvesAndSurfacesTimeStampEnum
        Define how the timestamp is selected:

        * Open: the opening value of the valuationDate or if not available the close of the previous
        day is used.
        * Default: the latest snapshot is used when valuationDate is today, the close price when
        valuationDate is in the past. Known values are: "Close", "Default", "Open", and "Settle".
    use_smart_params : bool
        An indicator if a first SABR calibration is used to estimate the model
        initial parameters (correlation and volatility of volatility). The
        possible values are: True: will use a Precalibration to estimate
        initial parameters, False: will use an arbitrary initial parameters.
        The default value is 'False'.
    valuation_date : ~datetime.datetime
        The date at which the instrument is valued. The value is expressed in
        ISO 8601 format: YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g.,
        '2021-01-01T00:00:00Z'). By default, MarketDataDate is used. If
        MarketDataDate is not specified, the default value is today.
    volatility_adjustment_type : str or ~analyticsapi.models.VolatilityAdjustmentTypeEnum
        Volatility adjustment method applied to caplets surface before
        stripping. The default value is 'ConstantCap'. Known values are:
        "ConstantCap", "ConstantCaplet", "NormalizedCap", "NormalizedCaplet",
        and "ShiftedCap".
    x_axis : str or ~analyticsapi.models.XAxisEnum
        The enumerate that specifies the unit for the x axis. Known values are:
        "Date", "Delta", "Expiry", "Moneyness", "Strike", and "Tenor".
    y_axis : str or ~analyticsapi.models.YAxisEnum
        The enumerate that specifies the unit for the y axis. Known values are:
        "Date", "Delta", "Expiry", "Moneyness", "Strike", and "Tenor".
    z_axis : str or ~analyticsapi.models.ZAxisEnum
        Specifies the unit for the z axis (e.g. Strike, Expiry, Tenor). This
        applies to swaption SABR cube. Known values are: "Date", "Delta",
        "Expiry", "Moneyness", "Strike", and "Tenor".
    """

    beta: Optional[float] = rest_field()
    """SABR Beta parameter. The possible values: a number between 0 and 1.
     The default value is '0.45'."""
    calculation_date: Optional[datetime.datetime] = rest_field(name="calculationDate", format="rfc3339")
    """The date the volatility surface is generated."""
    calibration_type: Optional[Union[str, "_models.CurvesAndSurfacesCalibrationTypeEnum"]] = rest_field(
        name="calibrationType"
    )
    """The Calibration type defines the solver used during calibration (i.e. Sabr Model Calibration
     Optimization Method).
     The default value is selected based on instrumentCode. Known values are:
     \"AlternateConjugateGradient\", \"ConjugateGradient\", \"Powell\", and \"SimplexNelderMead\"."""
    cap_source: Optional[str] = rest_field(name="capSource")
    include_caplets_volatility: Optional[bool] = rest_field(name="includeCapletsVolatility")
    """Determines whether the volatility cube is computed from interpolations on volatility skews, or
     via Atm swaption volatility and caplets volatility.
     The default value is True."""
    input_volatility_type: Optional[Union[str, "_models.InputVolatilityTypeEnum"]] = rest_field(
        name="inputVolatilityType"
    )
    """user can specify whether calibration is based on Normal or Lognorma vol. However it would be
     preferrable to let the service determine the most appropriate one. Known values are:
     \"Implied\", \"LogNormalVolatility\", \"NormalVolatility\", \"Quoted\", and \"Settle\"."""
    output_volatility_type: Optional[Union[str, "_models.OutputVolatilityTypeEnum"]] = rest_field(
        name="outputVolatilityType"
    )
    """The SABR volatility can be expressed as lognormal volatility (%) or normal volatility (bp).
     By default the output volatility type follows the InputVolatilityType parameter. Known values
     are: \"LogNormalVolatility\" and \"NormalVolatility\"."""
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """Specifies whether bid, ask, mid or settle is used to build the surface. If not precised,
     default to mid. Known values are: \"Ask\", \"Bid\", \"Last\", and \"Mid\"."""
    shift_percent: Optional[float] = rest_field(name="shiftPercent")
    """Shift applied to calibrated strikes allowing negative rates. The value is expressed in
     percentages.
     The default value is selected based on instrumentCode."""
    source: Optional[str] = rest_field()
    """Requested volatility data contributor."""
    strike_type: Optional[Union[str, "_models.CurvesAndSurfacesStrikeTypeEnum"]] = rest_field(name="strikeType")
    """The strike axis type of the volatility cube surface.
     The default value is 'RelativePercent'. Known values are: \"AbsolutePercent\" and
     \"RelativePercent\"."""
    stripping_shift_percent: Optional[float] = rest_field(name="strippingShiftPercent")
    """Shift value applied to strikes allowing the stripped caplets surface to include volatility even
     when some strikes are negative. The value is expressed in percentages.
     The default value is '0.0'."""
    swaption_source: Optional[str] = rest_field(name="swaptionSource")
    time_stamp: Optional[Union[str, "_models.CurvesAndSurfacesTimeStampEnum"]] = rest_field(name="timeStamp")
    """Define how the timestamp is selected:
     
     
     * Open: the opening value of the valuationDate or if not available the close of the previous
     day is used.
     * Default: the latest snapshot is used when valuationDate is today, the close price when
     valuationDate is in the past. Known values are: \"Close\", \"Default\", \"Open\", and
     \"Settle\"."""
    use_smart_params: Optional[bool] = rest_field(name="useSmartParams")
    """An indicator if a first SABR calibration is used to estimate the model initial parameters
     (correlation and volatility of volatility). The possible values are:
     True: will use a Precalibration to estimate initial parameters,
     False: will use an arbitrary initial parameters.
     The default value is 'False'."""
    valuation_date: Optional[datetime.datetime] = rest_field(name="valuationDate", format="rfc3339")
    """The date at which the instrument is valued. The value is expressed in ISO 8601 format:
     YYYY-MM-DDT[hh]:[mm]:[ss]Z (e.g., '2021-01-01T00:00:00Z').
     By default, MarketDataDate is used. If MarketDataDate is not specified, the default value is
     today."""
    volatility_adjustment_type: Optional[Union[str, "_models.VolatilityAdjustmentTypeEnum"]] = rest_field(
        name="volatilityAdjustmentType"
    )
    """Volatility adjustment method applied to caplets surface before stripping.
     The default value is 'ConstantCap'. Known values are: \"ConstantCap\", \"ConstantCaplet\",
     \"NormalizedCap\", \"NormalizedCaplet\", and \"ShiftedCap\"."""
    x_axis: Optional[Union[str, "_models.XAxisEnum"]] = rest_field(name="xAxis")
    """The enumerate that specifies the unit for the x axis. Known values are: \"Date\", \"Delta\",
     \"Expiry\", \"Moneyness\", \"Strike\", and \"Tenor\"."""
    y_axis: Optional[Union[str, "_models.YAxisEnum"]] = rest_field(name="yAxis")
    """The enumerate that specifies the unit for the y axis. Known values are: \"Date\", \"Delta\",
     \"Expiry\", \"Moneyness\", \"Strike\", and \"Tenor\"."""
    z_axis: Optional[Union[str, "_models.ZAxisEnum"]] = rest_field(name="zAxis")
    """Specifies the unit for the z axis (e.g. Strike, Expiry, Tenor). This applies to swaption SABR
     cube. Known values are: \"Date\", \"Delta\", \"Expiry\", \"Moneyness\", \"Strike\", and
     \"Tenor\"."""

    @overload
    def __init__(
        self,
        *,
        beta: Optional[float] = None,
        calculation_date: Optional[datetime.datetime] = None,
        calibration_type: Optional[Union[str, "_models.CurvesAndSurfacesCalibrationTypeEnum"]] = None,
        cap_source: Optional[str] = None,
        include_caplets_volatility: Optional[bool] = None,
        input_volatility_type: Optional[Union[str, "_models.InputVolatilityTypeEnum"]] = None,
        output_volatility_type: Optional[Union[str, "_models.OutputVolatilityTypeEnum"]] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        shift_percent: Optional[float] = None,
        source: Optional[str] = None,
        strike_type: Optional[Union[str, "_models.CurvesAndSurfacesStrikeTypeEnum"]] = None,
        stripping_shift_percent: Optional[float] = None,
        swaption_source: Optional[str] = None,
        time_stamp: Optional[Union[str, "_models.CurvesAndSurfacesTimeStampEnum"]] = None,
        use_smart_params: Optional[bool] = None,
        valuation_date: Optional[datetime.datetime] = None,
        volatility_adjustment_type: Optional[Union[str, "_models.VolatilityAdjustmentTypeEnum"]] = None,
        x_axis: Optional[Union[str, "_models.XAxisEnum"]] = None,
        y_axis: Optional[Union[str, "_models.YAxisEnum"]] = None,
        z_axis: Optional[Union[str, "_models.ZAxisEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VolatilityCubeSurfaceRequestItem(_model_base.Model):
    """VolatilityCubeSurfaceRequestItem.

    Attributes
    ----------
    surface_layout : ~analyticsapi.models.SurfaceOutput
    surface_parameters : ~analyticsapi.models.VolatilityCubeSurfaceParameters
    surface_tag : str
    underlying_definition : ~analyticsapi.models.VolatilityCubeDefinition
    underlying_type : str or ~analyticsapi.models.CurvesAndSurfacesUnderlyingTypeEnum
        The type of the underlying used to generate the volatility surface.
        Known values are: "Cap", "Eti", "Fx", and "Swaption".
    """

    surface_layout: Optional["_models.SurfaceOutput"] = rest_field(name="surfaceLayout")
    surface_parameters: Optional["_models.VolatilityCubeSurfaceParameters"] = rest_field(name="surfaceParameters")
    surface_tag: Optional[str] = rest_field(name="surfaceTag")
    underlying_definition: Optional["_models.VolatilityCubeDefinition"] = rest_field(name="underlyingDefinition")
    underlying_type: Optional[Union[str, "_models.CurvesAndSurfacesUnderlyingTypeEnum"]] = rest_field(
        name="underlyingType"
    )
    """The type of the underlying used to generate the volatility surface. Known values are: \"Cap\",
     \"Eti\", \"Fx\", and \"Swaption\"."""

    @overload
    def __init__(
        self,
        *,
        surface_layout: Optional["_models.SurfaceOutput"] = None,
        surface_parameters: Optional["_models.VolatilityCubeSurfaceParameters"] = None,
        surface_tag: Optional[str] = None,
        underlying_definition: Optional["_models.VolatilityCubeDefinition"] = None,
        underlying_type: Optional[Union[str, "_models.CurvesAndSurfacesUnderlyingTypeEnum"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VolatilitySurfacePoint(_model_base.Model):
    """VolatilitySurfacePoint.

    Attributes
    ----------
    x : str
        The coordinate of the volatility data point on the x-axis.
    y : str
        The coordinate of the volatility data point on the y-axis.
    """

    x: Optional[str] = rest_field()
    """The coordinate of the volatility data point on the x-axis."""
    y: Optional[str] = rest_field()
    """The coordinate of the volatility data point on the y-axis."""

    @overload
    def __init__(
        self,
        *,
        x: Optional[str] = None,
        y: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VolatilitySurfaceResponse(_model_base.Model):
    """VolatilitySurfaceResponse.

    Attributes
    ----------
    data : list[~analyticsapi.models.VolatilitySurfaceResponseItem]
        The list of volatility surfaces that have been generated based on the
        request.  The default value is None, needs to be assigned before using.
    """

    data: Optional[List["_models.VolatilitySurfaceResponseItem"]] = rest_field()
    """The list of volatility surfaces that have been generated based on the request."""

    @overload
    def __init__(
        self,
        data: Optional[List["_models.VolatilitySurfaceResponseItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class VolatilitySurfaceResponseItem(_model_base.Model):
    """VolatilitySurfaceResponseItem.

    Attributes
    ----------
    discount_curve : any
        The discount curve.
    dividends : any
        The dividends.
    forward_curve : any
        The forward curve.
    goodness_of_fit : any
        The goodness of fit for VolSurface.
    headers : list[str]
        The list of column headers that describe the columns returned in the
        case of a "List" format.  The default value is None, needs to be
        assigned before using.
    interest_rate_curve : any
        The Interest rate curve.
    moneyness_strike : any
        The strike level associated to the moneyness level for VolSurface.
    surface : list[list[any]]
        The actual volatility surface.  The default value is None, needs to be
        assigned before using.
    surface_tag : str
        The user-defined tag provided in the request or a generated one if no
        tag were provided.
    underlying_spot : any
        The Underlying Spot.
    constituents : any
        The constituents of the volatility surface.
    description : any
        A description of the volatility surface.
    cross_currency_curves : any
        The cross currency curves.
    calibration_parameters : any
        The set of inputs and model-specific variables used to fit the
        volatility surface to observed option market data.
    theoritical_calls_premiums : any
        The model-based call prices derived from the calibrated volatility
        surface.
    theoritical_puts_premiums : any
        The model-based put prices derived from the calibrated volatility
        surface.
    theoritical_strikes : any
        Model-generated strike values.
    theoretical_strikes : any
        Model-generated strike values.
    expiry_dates : any
        A list of tenors, expiry dates, and settlement dates for each smile
        point in a volatility surface.
    surface_information : any
        This output provides further information about the surface, the
        underlying, and the constituents.
    statistics : any
        The parameters defining the computation of skewness and kurtosis across
        the smiles of the surface.
    deposit_curves : any
        The Deposit Curves (domestic and foreign).
    """

    discount_curve: Optional[Any] = rest_field(name="discountCurve")
    """The discount curve."""
    dividends: Optional[Any] = rest_field()
    """The dividends."""
    forward_curve: Optional[Any] = rest_field(name="forwardCurve")
    """The forward curve."""
    goodness_of_fit: Optional[Any] = rest_field(name="goodnessOfFit")
    """The goodness of fit for VolSurface."""
    headers: Optional[List[str]] = rest_field()
    """The list of column headers that describe the columns returned in the case of a \"List\" format."""
    interest_rate_curve: Optional[Any] = rest_field(name="interestRateCurve")
    """The Interest rate curve."""
    moneyness_strike: Optional[Any] = rest_field(name="moneynessStrike")
    """The strike level associated to the moneyness level for VolSurface."""
    surface: Optional[List[List[Any]]] = rest_field()
    """The actual volatility surface."""
    surface_tag: Optional[str] = rest_field(name="surfaceTag")
    """The user-defined tag provided in the request or a generated one if no tag were provided."""
    underlying_spot: Optional[Any] = rest_field(name="underlyingSpot")
    """The Underlying Spot."""
    constituents: Optional[Any] = rest_field()
    """The constituents of the volatility surface."""
    description: Optional[Any] = rest_field()
    """A description of the volatility surface."""
    cross_currency_curves: Optional[Any] = rest_field(name="crossCurrencyCurves")
    """The cross currency curves."""
    calibration_parameters: Optional[Any] = rest_field(name="calibrationParameters")
    """The set of inputs and model-specific variables used to fit the volatility surface to observed
     option market data."""
    theoritical_calls_premiums: Optional[Any] = rest_field(name="theoriticalCallsPremiums")
    """The model-based call prices derived from the calibrated volatility surface."""
    theoritical_puts_premiums: Optional[Any] = rest_field(name="theoriticalPutsPremiums")
    """The model-based put prices derived from the calibrated volatility surface."""
    theoritical_strikes: Optional[Any] = rest_field(name="theoriticalStrikes")
    """Model-generated strike values."""
    theoretical_strikes: Optional[Any] = rest_field(name="theoreticalStrikes")
    """Model-generated strike values."""
    expiry_dates: Optional[Any] = rest_field(name="expiryDates")
    """A list of tenors, expiry dates, and settlement dates for each smile point in a volatility
     surface."""
    surface_information: Optional[Any] = rest_field(name="surfaceInformation")
    """This output provides further information about the surface, the underlying, and the
     constituents."""
    statistics: Optional[Any] = rest_field()
    """The parameters defining the computation of skewness and kurtosis across the smiles of the
     surface."""
    deposit_curves: Optional[Any] = rest_field(name="depositCurves")
    """The Deposit Curves (domestic and foreign)."""

    @overload
    def __init__(
        self,
        *,
        discount_curve: Optional[Any] = None,
        dividends: Optional[Any] = None,
        forward_curve: Optional[Any] = None,
        goodness_of_fit: Optional[Any] = None,
        headers: Optional[List[str]] = None,
        interest_rate_curve: Optional[Any] = None,
        moneyness_strike: Optional[Any] = None,
        surface: Optional[List[List[Any]]] = None,
        surface_tag: Optional[str] = None,
        underlying_spot: Optional[Any] = None,
        constituents: Optional[Any] = None,
        description: Optional[Any] = None,
        cross_currency_curves: Optional[Any] = None,
        calibration_parameters: Optional[Any] = None,
        theoritical_calls_premiums: Optional[Any] = None,
        theoritical_puts_premiums: Optional[Any] = None,
        theoritical_strikes: Optional[Any] = None,
        theoretical_strikes: Optional[Any] = None,
        expiry_dates: Optional[Any] = None,
        surface_information: Optional[Any] = None,
        statistics: Optional[Any] = None,
        deposit_curves: Optional[Any] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VolCubePoint(_model_base.Model):
    """An object describing a point in the cube.

    Attributes
    ----------
    expiry_tenor : str
        The expiry tenor of the option related to the volatility. Required.
    underlying_expiry_tenor : str
        The expiry tenor of the underlying instrument of the option. Required.
    strike : float
        The strike value related to the volatility. Required.
    volatility : float
        The volatility expressed as a float. Required.
    """

    expiry_tenor: str = rest_field(name="expiryTenor")
    """The expiry tenor of the option related to the volatility. Required."""
    underlying_expiry_tenor: str = rest_field(name="underlyingExpiryTenor")
    """The expiry tenor of the underlying instrument of the option. Required."""
    strike: float = rest_field()
    """The strike value related to the volatility. Required."""
    volatility: float = rest_field()
    """The volatility expressed as a float. Required."""

    @overload
    def __init__(
        self,
        *,
        expiry_tenor: str,
        underlying_expiry_tenor: str,
        strike: float,
        volatility: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VolItem(_model_base.Model):
    """VolItem.

    Attributes
    ----------
    expiration : ~decimal.Decimal
    value : ~decimal.Decimal
    term : ~decimal.Decimal
    """

    expiration: Optional[decimal.Decimal] = rest_field()
    value: Optional[decimal.Decimal] = rest_field()
    term: Optional[decimal.Decimal] = rest_field()

    @overload
    def __init__(
        self,
        *,
        expiration: Optional[decimal.Decimal] = None,
        value: Optional[decimal.Decimal] = None,
        term: Optional[decimal.Decimal] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class VolSurfacePoint(_model_base.Model):
    """An object describing a point in the surface.

    Attributes
    ----------
    expiry_date : ~datetime.date
        The expiry date of the option related to the volatility. Required.
    strike : float
        The strike of the option related to the volatility. Required.
    volatility : float
        The volatility of the related option expressed as a float. Required.
    """

    expiry_date: datetime.date = rest_field(name="expiryDate")
    """The expiry date of the option related to the volatility. Required."""
    strike: float = rest_field()
    """The strike of the option related to the volatility. Required."""
    volatility: float = rest_field()
    """The volatility of the related option expressed as a float. Required."""

    @overload
    def __init__(
        self,
        *,
        expiry_date: datetime.date,
        strike: float,
        volatility: float,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WalSensitivityInput(_model_base.Model):
    """WalSensitivityInput.

    All required parameters must be populated in order to send to server.

    Attributes
    ----------
    identifier : str
        Required.
    id_type : str or ~analyticsapi.models.IdTypeEnum
        Known values are: "SecurityIDEntry", "SecurityID", "CUSIP", "ISIN",
        "REGSISIN", "SEDOL", "Identifier", "ChinaInterbankCode",
        "ShanghaiExchangeCode", "ShenzhenExchangeCode", and "MXTickerID".
    prepay_type : str
        Required. Is either a Literal["PSA"] type or a Literal["CPR"] type.
    prepay_rate_start : int
        Required.
    prepay_rate_end : int
        Required.
    prepay_rate_step : int
        Required.
    tolerance : float
        Required.
    horizon_date : ~datetime.date
    prepay_rate : int
    """

    identifier: str = rest_field()
    """Required."""
    id_type: Optional[Union[str, "_models.IdTypeEnum"]] = rest_field(name="idType")
    """Known values are: \"SecurityIDEntry\", \"SecurityID\", \"CUSIP\", \"ISIN\", \"REGSISIN\",
     \"SEDOL\", \"Identifier\", \"ChinaInterbankCode\", \"ShanghaiExchangeCode\",
     \"ShenzhenExchangeCode\", and \"MXTickerID\"."""
    prepay_type: Literal["PSA", "CPR"] = rest_field(name="prepayType")
    """Required. Is either a Literal[\"PSA\"] type or a Literal[\"CPR\"] type."""
    prepay_rate_start: int = rest_field(name="prepayRateStart")
    """Required."""
    prepay_rate_end: int = rest_field(name="prepayRateEnd")
    """Required."""
    prepay_rate_step: int = rest_field(name="prepayRateStep")
    """Required."""
    tolerance: float = rest_field()
    """Required."""
    horizon_date: Optional[datetime.date] = rest_field(name="horizonDate")
    prepay_rate: Optional[int] = rest_field(name="prepayRate")

    @overload
    def __init__(
        self,
        *,
        identifier: str,
        prepay_type: Literal["PSA", "CPR"],
        prepay_rate_start: int,
        prepay_rate_end: int,
        prepay_rate_step: int,
        tolerance: float,
        id_type: Optional[Union[str, "_models.IdTypeEnum"]] = None,
        horizon_date: Optional[datetime.date] = None,
        prepay_rate: Optional[int] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class WalSensitivityRequest(_model_base.Model):
    """WalSensitivityRequest.

    Attributes
    ----------
    input : ~analyticsapi.models.WalSensitivityInput
    """

    input: Optional["_models.WalSensitivityInput"] = rest_field()

    @overload
    def __init__(
        self,
        input: Optional["_models.WalSensitivityInput"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["input"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class YBPortUserBond(_model_base.Model):
    """YBPortUserBond.

    Attributes
    ----------
    id : str
    extends : ~analyticsapi.models.UDIExtension
    indic : dict[str, any]
    schedule : dict[str, list[~analyticsapi.models.ScheduleItem]]
    distribution : ~analyticsapi.models.Distribution
    """

    id: Optional[str] = rest_field()
    extends: Optional["_models.UDIExtension"] = rest_field()
    indic: Optional[Dict[str, Any]] = rest_field()
    schedule: Optional[Dict[str, List["_models.ScheduleItem"]]] = rest_field()
    distribution: Optional["_models.Distribution"] = rest_field()

    @overload
    def __init__(
        self,
        *,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        extends: Optional["_models.UDIExtension"] = None,
        indic: Optional[Dict[str, Any]] = None,
        schedule: Optional[Dict[str, List["_models.ScheduleItem"]]] = None,
        distribution: Optional["_models.Distribution"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurve(_model_base.Model):
    """ZcCurve.

    Attributes
    ----------
    curve_points : list[~analyticsapi.models.ZcCurvePoint]
        The list of the curve points attributes computed for the zero coupon
        curve. The default value is None, needs to be assigned before using.
    is_discount_curve : bool
    """

    curve_points: Optional[List["_models.ZcCurvePoint"]] = rest_field(name="curvePoints")
    """The list of the curve points attributes computed for the zero coupon curve."""
    is_discount_curve: Optional[bool] = rest_field(name="isDiscountCurve")

    @overload
    def __init__(
        self,
        *,
        curve_points: Optional[List["_models.ZcCurvePoint"]] = None,
        is_discount_curve: Optional[bool] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurveDefinition(_model_base.Model):
    """ZcCurveDefinition.

    Attributes
    ----------
    constituent_override_mode : str or ~analyticsapi.models.ConstituentOverrideModeEnum
        A method to use the default constituents. The possible values are:   *
        ReplaceDefinition: replace the default constituents by the user
        constituents from the input request,   * MergeWithDefinition: merge the
        default constituents and the user constituents from the input request,
        The default value is 'ReplaceDefinition'.  If the
        ignoreExistingDefinition is true, the constituentOverrideMode is set to
        ReplaceDefinition. Known values are: "MergeWithDefinition" and
        "ReplaceDefinition".
    currency : str
        The currency code of the interest rate curve (e.g., &#39;EUR&#39;).
    discounting_tenor : str
        The tenor which defines the interest rate curve to be used for
        discounting. It is one of the availableDiscountingTenors (e.g., '1M',
        '1Y'). By default, the first element of availableDiscountingTenors is
        used.
    id : str
        The identifier of the interest rate curve. Mandatory if currency or
        name is not specified.
    ignore_existing_definition : bool
    index_name : str
        The name of the floating rate index (e.g., &#39;ESTR&#39;).
    is_non_deliverable : bool
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        The asset class used to generate the interest rate curve. The possible
        values are:   * Deposit   * Futures   * Swap. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    market_data_location : str
        The identifier of the market place from which constituents come from.
        Currently the following values are supported: &#39;Onshore&#39; and
        &#39;EMEA&#39;. The list of values can be extended by a user when
        creating a curve.
    name : str
        The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC
        Curve&#39;).
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the generated interest rate curve is sensitive.
        The possible value is: InterestRate. Known values are: "Credit",
        "CrossCurrency", "Inflation", and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of a curve.
        Curves created by Refinitiv have the &#39;Refinitiv&#39; source.
    """

    constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = rest_field(
        name="constituentOverrideMode"
    )
    """A method to use the default constituents. The possible values are:   * ReplaceDefinition:
     replace the default constituents by the user constituents from the input request,   *
     MergeWithDefinition: merge the default constituents and the user constituents from the input
     request, The default value is 'ReplaceDefinition'.  If the ignoreExistingDefinition is true,
     the constituentOverrideMode is set to ReplaceDefinition. Known values are:
     \"MergeWithDefinition\" and \"ReplaceDefinition\"."""
    currency: Optional[str] = rest_field()
    """The currency code of the interest rate curve (e.g., &#39;EUR&#39;)."""
    discounting_tenor: Optional[str] = rest_field(name="discountingTenor")
    """The tenor which defines the interest rate curve to be used for discounting. It is one of the
     availableDiscountingTenors (e.g., '1M', '1Y'). By default, the first element of
     availableDiscountingTenors is used."""
    id: Optional[str] = rest_field()
    """The identifier of the interest rate curve. Mandatory if currency or name is not specified."""
    ignore_existing_definition: Optional[bool] = rest_field(name="ignoreExistingDefinition")
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., &#39;ESTR&#39;)."""
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """The asset class used to generate the interest rate curve. The possible values are:   * Deposit
     * Futures   * Swap. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    market_data_location: Optional[str] = rest_field(name="marketDataLocation")
    """The identifier of the market place from which constituents come from. Currently the following
     values are supported: &#39;Onshore&#39; and &#39;EMEA&#39;. The list of values can be extended
     by a user when creating a curve."""
    name: Optional[str] = rest_field()
    """The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC Curve&#39;)."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the generated interest rate curve is sensitive. The possible value is:
     InterestRate. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of a curve. Curves created by Refinitiv
     have the &#39;Refinitiv&#39; source."""

    @overload
    def __init__(
        self,
        *,
        constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = None,
        currency: Optional[str] = None,
        discounting_tenor: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        ignore_existing_definition: Optional[bool] = None,
        index_name: Optional[str] = None,
        is_non_deliverable: Optional[bool] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        market_data_location: Optional[str] = None,
        name: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurveDefinitionOutput(_model_base.Model):
    """ZcCurveDefinitionOutput.

    Attributes
    ----------
    available_discounting_tenors : list[str]
        The list of discounting tenors available when using a given interest
        rate curve. The values come from availableTenors list (e.g., '[OIS, 1M,
        3M, 6M, 1Y]'). The default value is None, needs to be assigned before
        using.
    available_tenors : list[str]
        The list of tenors which can be priced with curveDefinitions (e.g.,
        '[OIS, 1M, 3M, 6M, 1Y]').  The default value is None, needs to be
        assigned before using.
    constituent_override_mode : str or ~analyticsapi.models.ConstituentOverrideModeEnum
        A method to use the default constituents. The possible values are:   *
        ReplaceDefinition: replace the default constituents by the user
        constituents from the input request,   * MergeWithDefinition: merge the
        default constituents and the user constituents from the input request,
        The default value is 'ReplaceDefinition'.  If the
        ignoreExistingDefinition is true, the constituentOverrideMode is set to
        ReplaceDefinition. Known values are: "MergeWithDefinition" and
        "ReplaceDefinition".
    currency : str
        The currency code of the interest rate curve (e.g., &#39;EUR&#39;).
    discounting_tenor : str
        The tenor which defines the interest rate curve to be used for
        discounting. It is one of the availableDiscountingTenors (e.g., '1M',
        '1Y'). By default, the first element of availableDiscountingTenors is
        used.
    id : str
        The identifier of the interest rate curve. Mandatory if currency or
        name is not specified.
    ignore_existing_definition : bool
    index_name : str
        The name of the floating rate index (e.g., &#39;ESTR&#39;).
    is_non_deliverable : bool
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        The asset class used to generate the interest rate curve. The possible
        values are:   * Deposit   * Futures   * Swap. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    market_data_location : str
        The identifier of the market place from which constituents come from.
        Currently the following values are supported: &#39;Onshore&#39; and
        &#39;EMEA&#39;. The list of values can be extended by a user when
        creating a curve.
    name : str
        The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC
        Curve&#39;).
    owner : str
        UUID of the curve definition owner for none Refinitiv curve.
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the generated interest rate curve is sensitive.
        The possible value is: InterestRate. Known values are: "Credit",
        "CrossCurrency", "Inflation", and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of a curve.
        Curves created by Refinitiv have the &#39;Refinitiv&#39; source.
    """

    available_discounting_tenors: Optional[List[str]] = rest_field(name="availableDiscountingTenors")
    """The list of discounting tenors available when using a given interest rate curve. The values
     come from availableTenors list (e.g., '[OIS, 1M, 3M, 6M, 1Y]')."""
    available_tenors: Optional[List[str]] = rest_field(name="availableTenors")
    """The list of tenors which can be priced with curveDefinitions (e.g., '[OIS, 1M, 3M, 6M, 1Y]')."""
    constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = rest_field(
        name="constituentOverrideMode"
    )
    """A method to use the default constituents. The possible values are:   * ReplaceDefinition:
     replace the default constituents by the user constituents from the input request,   *
     MergeWithDefinition: merge the default constituents and the user constituents from the input
     request, The default value is 'ReplaceDefinition'.  If the ignoreExistingDefinition is true,
     the constituentOverrideMode is set to ReplaceDefinition. Known values are:
     \"MergeWithDefinition\" and \"ReplaceDefinition\"."""
    currency: Optional[str] = rest_field()
    """The currency code of the interest rate curve (e.g., &#39;EUR&#39;)."""
    discounting_tenor: Optional[str] = rest_field(name="discountingTenor")
    """The tenor which defines the interest rate curve to be used for discounting. It is one of the
     availableDiscountingTenors (e.g., '1M', '1Y'). By default, the first element of
     availableDiscountingTenors is used."""
    id: Optional[str] = rest_field()
    """The identifier of the interest rate curve. Mandatory if currency or name is not specified."""
    ignore_existing_definition: Optional[bool] = rest_field(name="ignoreExistingDefinition")
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., &#39;ESTR&#39;)."""
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """The asset class used to generate the interest rate curve. The possible values are:   * Deposit
     * Futures   * Swap. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    market_data_location: Optional[str] = rest_field(name="marketDataLocation")
    """The identifier of the market place from which constituents come from. Currently the following
     values are supported: &#39;Onshore&#39; and &#39;EMEA&#39;. The list of values can be extended
     by a user when creating a curve."""
    name: Optional[str] = rest_field()
    """The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC Curve&#39;)."""
    owner: Optional[str] = rest_field()
    """UUID of the curve definition owner for none Refinitiv curve."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the generated interest rate curve is sensitive. The possible value is:
     InterestRate. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of a curve. Curves created by Refinitiv
     have the &#39;Refinitiv&#39; source."""

    @overload
    def __init__(
        self,
        *,
        available_discounting_tenors: Optional[List[str]] = None,
        available_tenors: Optional[List[str]] = None,
        constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = None,
        currency: Optional[str] = None,
        discounting_tenor: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        ignore_existing_definition: Optional[bool] = None,
        index_name: Optional[str] = None,
        is_non_deliverable: Optional[bool] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        market_data_location: Optional[str] = None,
        name: Optional[str] = None,
        owner: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurveDefinitionRequest(_model_base.Model):
    """ZcCurveDefinitionRequest.

    Attributes
    ----------
    currency : str
        The currency code of the interest rate curve (e.g., &#39;EUR&#39;).
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    id : str
        The identifier of the interest rate curve. Mandatory if currency,
        indexName, or source cannot identify a unique curve.
    index_name : str
        The name of the floating rate index (e.g., &#39;ESTR&#39;).
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        The asset class used to generate the interest rate curve. The possible
        values are:   * Deposit   * Futures   * Swap. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    market_data_location : str
        The identifier of the market place from which constituents come from.
        Currently the following values are supported: &#39;Onshore&#39; and
        &#39;EMEA&#39;. The list of values can be extended by a user when
        creating a curve.
    name : str
        The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC
        Curve&#39;).
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the generated interest rate curve is sensitive.
        The possible value is: InterestRate. Known values are: "Credit",
        "CrossCurrency", "Inflation", and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of a curve.
        Curves created by Refinitiv have the &#39;Refinitiv&#39; source.
    valuation_date : ~datetime.date
        The date used to define a list of curves or a unique interest rate
        curve that can be priced at this date. The value is expressed in ISO
        8601 format: YYYY-MM-DD (e.g., '2021-01-01'). The default value is
        today.
    """

    currency: Optional[str] = rest_field()
    """The currency code of the interest rate curve (e.g., &#39;EUR&#39;)."""
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""
    id: Optional[str] = rest_field()
    """The identifier of the interest rate curve. Mandatory if currency, indexName, or source cannot
     identify a unique curve."""
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., &#39;ESTR&#39;)."""
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """The asset class used to generate the interest rate curve. The possible values are:   * Deposit
     * Futures   * Swap. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    market_data_location: Optional[str] = rest_field(name="marketDataLocation")
    """The identifier of the market place from which constituents come from. Currently the following
     values are supported: &#39;Onshore&#39; and &#39;EMEA&#39;. The list of values can be extended
     by a user when creating a curve."""
    name: Optional[str] = rest_field()
    """The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC Curve&#39;)."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the generated interest rate curve is sensitive. The possible value is:
     InterestRate. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of a curve. Curves created by Refinitiv
     have the &#39;Refinitiv&#39; source."""
    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """The date used to define a list of curves or a unique interest rate curve that can be priced at
     this date. The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). The
     default value is today."""

    @overload
    def __init__(
        self,
        *,
        currency: Optional[str] = None,
        curve_tag: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        index_name: Optional[str] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        market_data_location: Optional[str] = None,
        name: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
        valuation_date: Optional[datetime.date] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurveDefinitions(_model_base.Model):
    """ZcCurveDefinitions.

    Attributes
    ----------
    constituent_override_mode : str or ~analyticsapi.models.ConstituentOverrideModeEnum
        A method to use the default constituents. The possible values are:   *
        ReplaceDefinition: replace the default constituents by the user
        constituents from the input request,   * MergeWithDefinition: merge the
        default constituents and the user constituents from the input request,
        The default value is 'ReplaceDefinition'.  If the
        ignoreExistingDefinition is true, the constituentOverrideMode is set to
        ReplaceDefinition. Known values are: "MergeWithDefinition" and
        "ReplaceDefinition".
    cross_currency_definitions : list[~analyticsapi.models.CrossCurrencyCurveDefinitionPricing]
        The list of the cross currency definition attributes used for pricing
        the adjusted interest rate curve. If not set in the request the
        definition matching the currencies, index names and the
        isNonDeliverable flag are retrieved.  The default value is None, needs
        to be assigned before using.
    currency : str
        The currency code of the interest rate curve (e.g., &#39;EUR&#39;).
    curve_tenors : list[str]
        The list of user-defined tenors or dates for which curvePoints to be
        computed. The values are expressed in:   * time period code for tenors
        (e.g., '1M', '6M', '4Y'),   * ISO 8601 format 'YYYY-MM-DD' for dates
        (e.g., '2021-01-01').  The default value is None, needs to be assigned
        before using.
    discounting_tenor : str
        The tenor which defines the interest rate curve to be used for
        discounting. It is one of the availableDiscountingTenors (e.g., '1M',
        '1Y'). By default, the first element of availableDiscountingTenors is
        used.
    id : str
        The identifier of the interest rate curve. Mandatory if currency or
        name is not specified.
    ignore_existing_definition : bool
    index_name : str
        The name of the floating rate index (e.g., &#39;ESTR&#39;).
    index_tenors : list[str]
        The list of user-defined index tenors for which curvePoints to be
        computed. The values come from availableTenors list (e.g., '[OIS, 1M,
        3M, 6M, 1Y]'). It is ignored when adjusted curve is priced. In this
        case indexTenors of the curve that is built equals to discountingTenor
        of the reference curve.  The default value is None, needs to be
        assigned before using.
    is_non_deliverable : bool
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        The asset class used to generate the interest rate curve. The possible
        values are:   * Deposit   * Futures   * Swap. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    market_data_location : str
        The identifier of the market place from which constituents come from.
        Currently the following values are supported: &#39;Onshore&#39; and
        &#39;EMEA&#39;. The list of values can be extended by a user when
        creating a curve.
    name : str
        The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC
        Curve&#39;).
    pivot_curve_definition : ~analyticsapi.models.ZcCurveDefinition
    reference_curve_definition : ~analyticsapi.models.ZcCurveDefinition
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the generated interest rate curve is sensitive.
        The possible value is: InterestRate. Known values are: "Credit",
        "CrossCurrency", "Inflation", and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of a curve.
        Curves created by Refinitiv have the &#39;Refinitiv&#39; source.
    """

    constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = rest_field(
        name="constituentOverrideMode"
    )
    """A method to use the default constituents. The possible values are:   * ReplaceDefinition:
     replace the default constituents by the user constituents from the input request,   *
     MergeWithDefinition: merge the default constituents and the user constituents from the input
     request, The default value is 'ReplaceDefinition'.  If the ignoreExistingDefinition is true,
     the constituentOverrideMode is set to ReplaceDefinition. Known values are:
     \"MergeWithDefinition\" and \"ReplaceDefinition\"."""
    cross_currency_definitions: Optional[List["_models.CrossCurrencyCurveDefinitionPricing"]] = rest_field(
        name="crossCurrencyDefinitions"
    )
    """The list of the cross currency definition attributes used for pricing the adjusted interest
     rate curve. If not set in the request the definition matching the currencies, index names and
     the isNonDeliverable flag are retrieved."""
    currency: Optional[str] = rest_field()
    """The currency code of the interest rate curve (e.g., &#39;EUR&#39;)."""
    curve_tenors: Optional[List[str]] = rest_field(name="curveTenors")
    """The list of user-defined tenors or dates for which curvePoints to be computed. The values are
     expressed in:   * time period code for tenors (e.g., '1M', '6M', '4Y'),   * ISO 8601 format
     'YYYY-MM-DD' for dates (e.g., '2021-01-01')."""
    discounting_tenor: Optional[str] = rest_field(name="discountingTenor")
    """The tenor which defines the interest rate curve to be used for discounting. It is one of the
     availableDiscountingTenors (e.g., '1M', '1Y'). By default, the first element of
     availableDiscountingTenors is used."""
    id: Optional[str] = rest_field()
    """The identifier of the interest rate curve. Mandatory if currency or name is not specified."""
    ignore_existing_definition: Optional[bool] = rest_field(name="ignoreExistingDefinition")
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., &#39;ESTR&#39;)."""
    index_tenors: Optional[List[str]] = rest_field(name="indexTenors")
    """The list of user-defined index tenors for which curvePoints to be computed. The values come
     from availableTenors list (e.g., '[OIS, 1M, 3M, 6M, 1Y]'). It is ignored when adjusted curve is
     priced. In this case indexTenors of the curve that is built equals to discountingTenor of the
     reference curve."""
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """The asset class used to generate the interest rate curve. The possible values are:   * Deposit
     * Futures   * Swap. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    market_data_location: Optional[str] = rest_field(name="marketDataLocation")
    """The identifier of the market place from which constituents come from. Currently the following
     values are supported: &#39;Onshore&#39; and &#39;EMEA&#39;. The list of values can be extended
     by a user when creating a curve."""
    name: Optional[str] = rest_field()
    """The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC Curve&#39;)."""
    pivot_curve_definition: Optional["_models.ZcCurveDefinition"] = rest_field(name="pivotCurveDefinition")
    reference_curve_definition: Optional["_models.ZcCurveDefinition"] = rest_field(name="referenceCurveDefinition")
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the generated interest rate curve is sensitive. The possible value is:
     InterestRate. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of a curve. Curves created by Refinitiv
     have the &#39;Refinitiv&#39; source."""

    @overload
    def __init__(
        self,
        *,
        constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = None,
        cross_currency_definitions: Optional[List["_models.CrossCurrencyCurveDefinitionPricing"]] = None,
        currency: Optional[str] = None,
        curve_tenors: Optional[List[str]] = None,
        discounting_tenor: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        ignore_existing_definition: Optional[bool] = None,
        index_name: Optional[str] = None,
        index_tenors: Optional[List[str]] = None,
        is_non_deliverable: Optional[bool] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        market_data_location: Optional[str] = None,
        name: Optional[str] = None,
        pivot_curve_definition: Optional["_models.ZcCurveDefinition"] = None,
        reference_curve_definition: Optional["_models.ZcCurveDefinition"] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurveDefinitionsItem(_model_base.Model):
    """ZcCurveDefinitionsItem.

    Attributes
    ----------
    available_discounting_tenors : list[str]
        The list of discounting tenors available when using a given interest
        rate curve. The values come from availableTenors list (e.g., '[OIS, 1M,
        3M, 6M, 1Y]'). The default value is None, needs to be assigned before
        using.
    available_tenors : list[str]
        The list of tenors which can be priced with curveDefinitions (e.g.,
        '[OIS, 1M, 3M, 6M, 1Y]').  The default value is None, needs to be
        assigned before using.
    currency : str
        The currency code of the interest rate curve (e.g., &#39;EUR&#39;).
    definition_expiry_date : ~datetime.date
        The date after which curveDefinitions can not be used. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    first_historical_availability_date : ~datetime.date
        The date starting from which the definition of the curve can be used.
        The value is expressed in ISO 8601 format: YYYY-MM-DD (e.g.,
        '2021-01-01').
    id : str
        The identifier of the interest rate curve.
    index_name : str
        The name of the floating rate index (e.g., &#39;ESTR&#39;).
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        The asset class used to generate the interest rate curve. The possible
        values are:   * Deposit   * Futures   * Swap. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    market_data_location : str
        The identifier of the market place from which constituents come from.
        Currently the following values are supported: &#39;Onshore&#39; and
        &#39;EMEA&#39;. The list of values can be extended by a user when
        creating a curve.
    name : str
        The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC
        Curve&#39;).
    owner : str
        The owner of the interest rate curve definition (e.g., 'Refinitiv').
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the generated interest rate curve is sensitive.
        The possible value is: InterestRate. Known values are: "Credit",
        "CrossCurrency", "Inflation", and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of a curve.
        Curves created by Refinitiv have the &#39;Refinitiv&#39; source.
    """

    available_discounting_tenors: Optional[List[str]] = rest_field(name="availableDiscountingTenors")
    """The list of discounting tenors available when using a given interest rate curve. The values
     come from availableTenors list (e.g., '[OIS, 1M, 3M, 6M, 1Y]')."""
    available_tenors: Optional[List[str]] = rest_field(name="availableTenors")
    """The list of tenors which can be priced with curveDefinitions (e.g., '[OIS, 1M, 3M, 6M, 1Y]')."""
    currency: Optional[str] = rest_field()
    """The currency code of the interest rate curve (e.g., &#39;EUR&#39;)."""
    definition_expiry_date: Optional[datetime.date] = rest_field(name="definitionExpiryDate")
    """The date after which curveDefinitions can not be used. The value is expressed in ISO 8601
     format: YYYY-MM-DD (e.g., '2021-01-01')."""
    first_historical_availability_date: Optional[datetime.date] = rest_field(name="firstHistoricalAvailabilityDate")
    """The date starting from which the definition of the curve can be used.  The value is expressed
     in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    id: Optional[str] = rest_field()
    """The identifier of the interest rate curve."""
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., &#39;ESTR&#39;)."""
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """The asset class used to generate the interest rate curve. The possible values are:   * Deposit
     * Futures   * Swap. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    market_data_location: Optional[str] = rest_field(name="marketDataLocation")
    """The identifier of the market place from which constituents come from. Currently the following
     values are supported: &#39;Onshore&#39; and &#39;EMEA&#39;. The list of values can be extended
     by a user when creating a curve."""
    name: Optional[str] = rest_field()
    """The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC Curve&#39;)."""
    owner: Optional[str] = rest_field()
    """The owner of the interest rate curve definition (e.g., 'Refinitiv')."""
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the generated interest rate curve is sensitive. The possible value is:
     InterestRate. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of a curve. Curves created by Refinitiv
     have the &#39;Refinitiv&#39; source."""

    @overload
    def __init__(
        self,
        *,
        available_discounting_tenors: Optional[List[str]] = None,
        available_tenors: Optional[List[str]] = None,
        currency: Optional[str] = None,
        definition_expiry_date: Optional[datetime.date] = None,
        first_historical_availability_date: Optional[datetime.date] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        index_name: Optional[str] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        market_data_location: Optional[str] = None,
        name: Optional[str] = None,
        owner: Optional[str] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurveDefinitionsOutput(_model_base.Model):
    """ZcCurveDefinitionsOutput.

    Attributes
    ----------
    available_discounting_tenors : list[str]
        The list of discounting tenors available when using a given interest
        rate curve. The values come from availableTenors list (e.g., '[OIS, 1M,
        3M, 6M, 1Y]'). The default value is None, needs to be assigned before
        using.
    available_tenors : list[str]
        The list of tenors which can be priced with curveDefinitions (e.g.,
        '[OIS, 1M, 3M, 6M, 1Y]').  The default value is None, needs to be
        assigned before using.
    constituent_override_mode : str or ~analyticsapi.models.ConstituentOverrideModeEnum
        A method to use the default constituents. The possible values are:   *
        ReplaceDefinition: replace the default constituents by the user
        constituents from the input request,   * MergeWithDefinition: merge the
        default constituents and the user constituents from the input request,
        The default value is 'ReplaceDefinition'.  If the
        ignoreExistingDefinition is true, the constituentOverrideMode is set to
        ReplaceDefinition. Known values are: "MergeWithDefinition" and
        "ReplaceDefinition".
    cross_currency_definitions : list[~analyticsapi.models.CrossCurrencyCurveDefinitionPricing]
        Get crossCurrencyDefinitions.  The default value is None, needs to be
        assigned before using.
    currency : str
        The currency code of the interest rate curve (e.g., &#39;EUR&#39;).
    curve_tenors : list[str]
        List of user-defined curve tenors or dates to be computed.  The default
        value is None, needs to be assigned before using.
    discounting_tenor : str
        The tenor which defines the interest rate curve to be used for
        discounting. It is one of the availableDiscountingTenors (e.g., '1M',
        '1Y'). By default, the first element of availableDiscountingTenors is
        used.
    id : str
        The identifier of the interest rate curve. Mandatory if currency or
        name is not specified.
    ignore_existing_definition : bool
    index_name : str
        The name of the floating rate index (e.g., &#39;ESTR&#39;).
    index_tenors : list[str]
        Defines expected rate surface tenor/slices Defaults to the tenors
        available, based on provided market data.  The default value is None,
        needs to be assigned before using.
    is_non_deliverable : bool
    main_constituent_asset_class : str or ~analyticsapi.models.MainConstituentAssetClassEnum
        The asset class used to generate the interest rate curve. The possible
        values are:   * Deposit   * Futures   * Swap. Known values are: "Bond",
        "CreditDefaultSwap", "Deposit", "Futures", "FxForward", and "Swap".
    market_data_location : str
        The identifier of the market place from which constituents come from.
        Currently the following values are supported: &#39;Onshore&#39; and
        &#39;EMEA&#39;. The list of values can be extended by a user when
        creating a curve.
    name : str
        The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC
        Curve&#39;).
    owner : str
        UUID of the curve definition owner for none Refinitiv curve.
    pivot_curve_definition : ~analyticsapi.models.ZcCurveDefinitionOutput
    reference_curve_definition : ~analyticsapi.models.ZcCurveDefinitionOutput
    risk_type : str or ~analyticsapi.models.RiskTypeEnum
        The risk type to which the generated interest rate curve is sensitive.
        The possible value is: InterestRate. Known values are: "Credit",
        "CrossCurrency", "Inflation", and "InterestRate".
    source : str
        A user-defined string that is provided by the creator of a curve.
        Curves created by Refinitiv have the &#39;Refinitiv&#39; source.
    """

    available_discounting_tenors: Optional[List[str]] = rest_field(name="availableDiscountingTenors")
    """The list of discounting tenors available when using a given interest rate curve. The values
     come from availableTenors list (e.g., '[OIS, 1M, 3M, 6M, 1Y]')."""
    available_tenors: Optional[List[str]] = rest_field(name="availableTenors")
    """The list of tenors which can be priced with curveDefinitions (e.g., '[OIS, 1M, 3M, 6M, 1Y]')."""
    constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = rest_field(
        name="constituentOverrideMode"
    )
    """A method to use the default constituents. The possible values are:   * ReplaceDefinition:
     replace the default constituents by the user constituents from the input request,   *
     MergeWithDefinition: merge the default constituents and the user constituents from the input
     request, The default value is 'ReplaceDefinition'.  If the ignoreExistingDefinition is true,
     the constituentOverrideMode is set to ReplaceDefinition. Known values are:
     \"MergeWithDefinition\" and \"ReplaceDefinition\"."""
    cross_currency_definitions: Optional[List["_models.CrossCurrencyCurveDefinitionPricing"]] = rest_field(
        name="crossCurrencyDefinitions"
    )
    """Get crossCurrencyDefinitions."""
    currency: Optional[str] = rest_field()
    """The currency code of the interest rate curve (e.g., &#39;EUR&#39;)."""
    curve_tenors: Optional[List[str]] = rest_field(name="curveTenors")
    """List of user-defined curve tenors or dates to be computed."""
    discounting_tenor: Optional[str] = rest_field(name="discountingTenor")
    """The tenor which defines the interest rate curve to be used for discounting. It is one of the
     availableDiscountingTenors (e.g., '1M', '1Y'). By default, the first element of
     availableDiscountingTenors is used."""
    id: Optional[str] = rest_field()
    """The identifier of the interest rate curve. Mandatory if currency or name is not specified."""
    ignore_existing_definition: Optional[bool] = rest_field(name="ignoreExistingDefinition")
    index_name: Optional[str] = rest_field(name="indexName")
    """The name of the floating rate index (e.g., &#39;ESTR&#39;)."""
    index_tenors: Optional[List[str]] = rest_field(name="indexTenors")
    """Defines expected rate surface tenor/slices Defaults to the tenors available, based on provided
     market data."""
    is_non_deliverable: Optional[bool] = rest_field(name="isNonDeliverable")
    main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = rest_field(
        name="mainConstituentAssetClass"
    )
    """The asset class used to generate the interest rate curve. The possible values are:   * Deposit
     * Futures   * Swap. Known values are: \"Bond\", \"CreditDefaultSwap\", \"Deposit\",
     \"Futures\", \"FxForward\", and \"Swap\"."""
    market_data_location: Optional[str] = rest_field(name="marketDataLocation")
    """The identifier of the market place from which constituents come from. Currently the following
     values are supported: &#39;Onshore&#39; and &#39;EMEA&#39;. The list of values can be extended
     by a user when creating a curve."""
    name: Optional[str] = rest_field()
    """The name of the interest rate curve (e.g., &#39;EUR ESTR Swap ZC Curve&#39;)."""
    owner: Optional[str] = rest_field()
    """UUID of the curve definition owner for none Refinitiv curve."""
    pivot_curve_definition: Optional["_models.ZcCurveDefinitionOutput"] = rest_field(name="pivotCurveDefinition")
    reference_curve_definition: Optional["_models.ZcCurveDefinitionOutput"] = rest_field(
        name="referenceCurveDefinition"
    )
    risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = rest_field(name="riskType")
    """The risk type to which the generated interest rate curve is sensitive. The possible value is:
     InterestRate. Known values are: \"Credit\", \"CrossCurrency\", \"Inflation\", and
     \"InterestRate\"."""
    source: Optional[str] = rest_field()
    """A user-defined string that is provided by the creator of a curve. Curves created by Refinitiv
     have the &#39;Refinitiv&#39; source."""

    @overload
    def __init__(
        self,
        *,
        available_discounting_tenors: Optional[List[str]] = None,
        available_tenors: Optional[List[str]] = None,
        constituent_override_mode: Optional[Union[str, "_models.ConstituentOverrideModeEnum"]] = None,
        cross_currency_definitions: Optional[List["_models.CrossCurrencyCurveDefinitionPricing"]] = None,
        currency: Optional[str] = None,
        curve_tenors: Optional[List[str]] = None,
        discounting_tenor: Optional[str] = None,
        id: Optional[str] = None,  # pylint: disable=redefined-builtin
        ignore_existing_definition: Optional[bool] = None,
        index_name: Optional[str] = None,
        index_tenors: Optional[List[str]] = None,
        is_non_deliverable: Optional[bool] = None,
        main_constituent_asset_class: Optional[Union[str, "_models.MainConstituentAssetClassEnum"]] = None,
        market_data_location: Optional[str] = None,
        name: Optional[str] = None,
        owner: Optional[str] = None,
        pivot_curve_definition: Optional["_models.ZcCurveDefinitionOutput"] = None,
        reference_curve_definition: Optional["_models.ZcCurveDefinitionOutput"] = None,
        risk_type: Optional[Union[str, "_models.RiskTypeEnum"]] = None,
        source: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurveDefinitionsResponse(_model_base.Model):
    """ZcCurveDefinitionsResponse.

    Attributes
    ----------
    data : list[~analyticsapi.models.ZcCurveDefinitionsResponseItem]
        Get data.  The default value is None, needs to be assigned before
        using.
    """

    data: Optional[List["_models.ZcCurveDefinitionsResponseItem"]] = rest_field()
    """Get data."""

    @overload
    def __init__(
        self,
        data: Optional[List["_models.ZcCurveDefinitionsResponseItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class ZcCurveDefinitionsResponseItem(_model_base.Model):
    """ZcCurveDefinitionsResponseItem.

    Attributes
    ----------
    curve_definitions : list[~analyticsapi.models.ZcCurveDefinitionsItem]
        The definition of attributes for the interest rate curve.  The default
        value is None, needs to be assigned before using.
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    """

    curve_definitions: Optional[List["_models.ZcCurveDefinitionsItem"]] = rest_field(name="curveDefinitions")
    """The definition of attributes for the interest rate curve."""
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""

    @overload
    def __init__(
        self,
        *,
        curve_definitions: Optional[List["_models.ZcCurveDefinitionsItem"]] = None,
        curve_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurveInstrument(_model_base.Model):
    """ZcCurveInstrument.

    Attributes
    ----------
    instrument_code : str
        The code used to define the instrument which is used for the curve
        point computation.
    value : float
        The value of the instrument used for the curve point computation. It is
        returned if DetailedCurvePoint has been set in the request and if the
        user is permissioned to view the data.
    """

    instrument_code: Optional[str] = rest_field(name="instrumentCode")
    """The code used to define the instrument which is used for the curve point computation."""
    value: Optional[float] = rest_field()
    """The value of the instrument used for the curve point computation. It is returned if
     DetailedCurvePoint has been set in the request and if the user is permissioned to view the
     data."""

    @overload
    def __init__(
        self,
        *,
        instrument_code: Optional[str] = None,
        value: Optional[float] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurveParameters(_model_base.Model):
    """ZcCurveParameters.

    Attributes
    ----------
    calendar_adjustment : str or ~analyticsapi.models.CalendarAdjustmentEnum
        The cash flow adjustment according to a selected calendar. The possible
        values are:   * No   * Weekend: for the cash flow pricing using the
        calendar &#39;Weekend&#39;   * Calendar: for the cash flow pricing
        using the calendar defined by the parameter &#39;calendars&#39;. The
        default value is &#39;Calendar&#39;. Known values are: "Calendar",
        "No", and "Weekend".
    calendars : list[str]
        The list of comma-separated calendar codes used to define non-working
        days and to adjust interest rate curve coupon dates and values (e.g.,
        &#39;EMU_FI&#39;). By default, the calendar code is derived from the
        interest rate curve currency.  The default value is None, needs to be
        assigned before using.
    compounding_type : str or ~analyticsapi.models.CompoundingTypeEnum
        The yield type of the interest rate curve. The possible values are:   *
        Discounted   * Compounded   * Continuous   * MoneyMarket The default
        value is &#39;Compounded&#39;. Known values are: "Compounded",
        "Continuous", "Discounted", and "MoneyMarket".
    constant_forward_rate_parameters : ~analyticsapi.models.ConstantForwardRateParameters
    convexity_adjustment : ~analyticsapi.models.CurvesAndSurfacesConvexityAdjustment
    extrapolation_mode : str or ~analyticsapi.models.ExtrapolationModeEnum
        The extrapolation method used in the zero coupon curve bootstrapping.
        The possible values are:   * None: no extrapolation,   * Constant:
        constant extrapolation,   * Linear: linear extrapolation,   *
        ConstantRate: extrapolation with constant zero-coupon rate *
        ConstantForwardRate: extrapolation with constant forward rate   *
        UltimateForwardRate: extrapolation with ultimate forward rate The
        default value is 'None'. Known values are: "Constant",
        "ConstantForwardRate", "ConstantRate", "Linear", "None", and
        "UltimateForwardRate".
    ignore_invalid_instrument : bool
    interest_calculation_method : str or ~analyticsapi.models.CurvesAndSurfacesInterestCalculationMethodEnum
        The day count basis method used to compute the points of the zero
        coupon curve. The possible values are:   * Dcb_30_360     Actual number
        of days in the coupon period calculated on the basis of a year of 360
        days with twelve 30-day months unless: - the last day of the period is
        the 31st day of a month and the first day of the period is a day other
        than the 30th or 31st day of a month, in which case the month that
        includes the last day shall not be considered to be shortened to a
        30-day month,     - the last day of the period is the last day of the
        month of February, in which case the month of February shall not be
        considered to be lengthened to a 30-day month.   * Dcb_30_Actual
        The day count is identical to 30/360 (US) and the year basis is
        identical to Actual/Actual.   * Dcb_Actual_360     The day count is the
        actual number of days of the period. The year basis is 360.   *
        Dcb_Actual_365 The day count is the actual number of days of the
        period. The year basis is 365.   * Dcb_Actual_Actual     The DCB is
        calculated by Actual days / year basis where:     - Actual days are
        defined as the actual days between the starting date (D1.M1.Y1) and end
        date (D2.M2.Y2).     - Year basis is defined as the actual days between
        the start date (D1.M1.Y1) and the next relevant interest payment date
        (D3.M3.Y3) multiplied by the instrument coupon frequency.   *
        Dcb_Actual_Actual_ISDA     Similar to Actual/365, except for a period
        that includes days falling in a leap year. It is calculated by DCB
        &#x3D; number of days in a leap year/366 + number of days in a non-leap
        year/365.     A convention is also known as Actual/365 ISDA.
        *Dcb_30_360_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if
        D1 is 31, change it to 30,     - if D2 is 31 and D1 is 30, change D2 to
        30.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
        Dcb_30_365_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if
        D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31
        then D2&#x3D;30.     Then the date difference is
        (Y2-Y1)x365+(M2-M1)x30+(D2-D1)   * Dcb_30_360_US For two dates
        (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     -
        if D2&#x3D;31 and D1&#x3D;30 or 31 then D2&#x3D;30,     - if D1 is the
        last day of February then D1&#x3D;30,     - if D1 is the last day of
        February and D2 is the last day of February then D2&#x3D;30.     The
        last day of February is February 29 in leap years and February 28 in
        non leap years.     The 30/360 US rule is identical to 30/360 ISDA when
        the EOM (end-of-month) convention does not apply. This indicates
        whether all coupon payment dates fall on the last day of the month. If
        the investment is not EOM, it will always pay on the same day of the
        month (e.g., the 10th).     Then the date difference is
        (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_Actual_Actual_AFB     The DCB
        is calculated by Actual days / year basis where:     Actual days are
        defined as the actual days between the start date (D1.M1.Y1) and end
        date (D2.M2.Y2). Year basis is either 365 if the calculation period
        does not contain 29th Feb, or 366 if the calculation period includes
        29th Feb.   * Dcb_WorkingDays_252     The day count is the actual
        number of business days of the period according to the instrument
        calendars. The year basis is 252. Commonly used in the Brazilian
        market.   * Dcb_Actual_365L     The day count is the actual number of
        days of the period. The year basis is calculated in the following two
        rules:     - if the coupon frequency is annual, then year basis is 366
        if the 29 Feb. is included in the interest period, else 365,     - if
        the coupon frequency is not annual, then year basis is 366 for each
        interest period where ending date falls in a leap year, otherwise it is
        365.   * Dcb_ActualLeapDay_365     The day count ignores 29th February
        when counting days. The year basis is 365 days.   *
        Dcb_ActualLeapDay_360     The day count ignores 29th February when
        counting days. The year basis is 360 days.   * Dcb_Actual_36525     The
        day count is the actual number of days of the period. The year basis is
        365.25.   * Dcb_Actual_365_CanadianConvention Follows the Canadian
        domestic bond market convention. The day count basis is computed as
        follows:     - if the number of days of a period is less than the
        actual number of days in a regular coupon period the Dcb_Actual_365
        convention is used,     - otherwise: DCB &#x3D; 1 -
        DaysRemainingInPeriod x Frequency / 365.   * Dcb_30_360_German     For
        two dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then
        D1&#x3D;30,     - if D2&#x3D;31 then D2&#x3D;30,     - if D1 is the
        last day of February then D1&#x3D;30,     - if D2 is the last day of
        February then D2&#x3D;30.     The last day of February is February 29
        in leap years and February 28 in non leap years.     Then the date
        difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_30_365_German
        Similar to 30/360 (German), except that the year basis is treated as
        365 days.   * Dcb_30_Actual_German     The day count is identical to
        30/360 (German) and the year basis is similar to Actual/Actual. This
        method was formerly used in the Eurobond markets.   * Dcb_30E_360_ISMA
        Actual number of days in the coupon period calculated on the basis of a
        year of 360 days with twelve 30-day months (regardless of the date of
        the first day or last day of the period).   * Dcb_Actual_364     A
        special case of Actual/Actual (ISMA) when a coupon period contains 91
        or 182 days. Actual/364 applies for some short-term instruments.
        Day count basis &#x3D; 364.   * Dcb_30_Actual_ISDA   *
        Dcb_30_365_Brazil   * Dcb_Actual_365P   * Dcb_Constant. Known values
        are: "Dcb_30E_360_ISMA", "Dcb_30_360", "Dcb_30_360_German",
        "Dcb_30_360_ISDA", "Dcb_30_360_US", "Dcb_30_365_Brazil",
        "Dcb_30_365_German", "Dcb_30_365_ISDA", "Dcb_30_Actual",
        "Dcb_30_Actual_German", "Dcb_30_Actual_ISDA", "Dcb_ActualLeapDay_360",
        "Dcb_ActualLeapDay_365", "Dcb_Actual_360", "Dcb_Actual_364",
        "Dcb_Actual_365", "Dcb_Actual_36525", "Dcb_Actual_365L",
        "Dcb_Actual_365P", "Dcb_Actual_365_CanadianConvention",
        "Dcb_Actual_Actual", "Dcb_Actual_Actual_AFB", "Dcb_Actual_Actual_ISDA",
        "Dcb_Constant", and "Dcb_WorkingDays_252".
    interpolation_mode : str or ~analyticsapi.models.InterpolationModeEnum
        The interpolation method used in zero curve bootstrapping. The possible
        values are:   * CubicDiscount: local cubic interpolation of discount
        factors   * CubicRate: local cubic interpolation of rates   *
        CubicSpline: a natural cubic spline   * ForwardMonotoneConvex: forward
        Monotone Convexc interpolation   * Linear: linear interpolation * Log:
        log-linear interpolation   * Hermite: Hermite (Bessel) interpolation
        * AkimaMethod: the Akima method (a smoother variant of local cubic
        interpolation)   * FritschButlandMethod: the Fritsch-Butland method (a
        monotonic cubic variant)   * KrugerMethod: the Kruger method (a
        monotonic cubic variant)   * MonotonicCubicNaturalSpline: a monotonic
        natural cubic spline   * MonotonicHermiteCubic: monotonic Hermite
        (Bessel) cubic interpolation   * TensionSpline: a tension spline. Known
        values are: "AkimaMethod", "CubicDiscount", "CubicRate", "CubicSpline",
        "ForwardMonotoneConvex", "FritschButlandMethod", "Hermite",
        "KrugerMethod", "Linear", "Log", "MonotonicCubicNaturalSpline",
        "MonotonicHermiteCubic", "Step", and "TensionSpline".
    market_data_access_denied_fallback : str or ~analyticsapi.models.MarketDataAccessDeniedFallbackEnum
        If at least one constituent access is denied:   * ReturnError: dont
        price the surface and return an error (Default value)   *
        IgnoreConstituents: price the surface without the error market data   *
        UseDelayedData: use delayed Market Data if possible. Known values are:
        "IgnoreConstituents", "ReturnError", and "UseDelayedData".
    market_data_look_back : ~analyticsapi.models.MarketDataLookBack
    pivot_curve_parameters : ~analyticsapi.models.InterestRateCurveParameters
    price_side : str or ~analyticsapi.models.CurvesAndSurfacesPriceSideEnum
        The quoted price side of the instrument to be used for the zero coupon
        curve construction. The possible values are:   * Bid   * Ask   * Mid
        The default value is &#39;Mid&#39;. Known values are: "Ask", "Bid",
        "Last", and "Mid".
    reference_curve_parameters : ~analyticsapi.models.InterestRateCurveParameters
    reference_tenor : str
        The tenor of the index interest rate curve for which curvePoints are
        computed (e.g., '3M').
    steps : list[~analyticsapi.models.Step]
        The list of attributes used to calculate the swap rate surface discount
        curve, when OIS is selected as discount curve. The steps can specify
        overnight index stepped dates or/and rates. Currencies supporting steps
        are the following: USD, AUD, BRL, CAD, COP, CZK, EUR, GBP, JPY, NZD,
        PLN, HUF, SEK, CHF, RUB, INR, DKK.  The default value is None, needs to
        be assigned before using.
    turns : list[~analyticsapi.models.Turn]
        The list of attributes used to include end period when calculating swap
        rate surfaces.  The default value is None, needs to be assigned before
        using.
    use_convexity_adjustment : bool
    use_delayed_data_if_denied : bool
    use_multi_dimensional_solver : bool
    use_stub : bool
    valuation_date : ~datetime.date
        The date at which the zero coupon curve is generated. The value is
        expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01'). Only one
        parameter of valuationDate and valuationDateTime must be specified. The
        default value is today.
    valuation_date_time : ~datetime.datetime
        The date and time at which the zero coupon curve is generated. The
        value is expressed in ISO 8601 format: YYYY-MM-DDT00:00:00Z (e.g.,
        '2021-01-01T14:00:00Z' or '2021-01-01T14:00:00+02:00'). Only one
        parameter of valuationDate and valuationDateTime must be specified.
    valuation_time : ~analyticsapi.models.CurvesAndSurfacesValuationTime
    """

    calendar_adjustment: Optional[Union[str, "_models.CalendarAdjustmentEnum"]] = rest_field(name="calendarAdjustment")
    """The cash flow adjustment according to a selected calendar. The possible values are:   * No   *
     Weekend: for the cash flow pricing using the calendar &#39;Weekend&#39;   * Calendar: for the
     cash flow pricing using the calendar defined by the parameter &#39;calendars&#39;. The default
     value is &#39;Calendar&#39;. Known values are: \"Calendar\", \"No\", and \"Weekend\"."""
    calendars: Optional[List[str]] = rest_field()
    """The list of comma-separated calendar codes used to define non-working days and to adjust
     interest rate curve coupon dates and values (e.g., &#39;EMU_FI&#39;). By default, the calendar
     code is derived from the interest rate curve currency."""
    compounding_type: Optional[Union[str, "_models.CompoundingTypeEnum"]] = rest_field(name="compoundingType")
    """The yield type of the interest rate curve. The possible values are:   * Discounted   *
     Compounded   * Continuous   * MoneyMarket The default value is &#39;Compounded&#39;. Known
     values are: \"Compounded\", \"Continuous\", \"Discounted\", and \"MoneyMarket\"."""
    constant_forward_rate_parameters: Optional["_models.ConstantForwardRateParameters"] = rest_field(
        name="constantForwardRateParameters"
    )
    convexity_adjustment: Optional["_models.CurvesAndSurfacesConvexityAdjustment"] = rest_field(
        name="convexityAdjustment"
    )
    extrapolation_mode: Optional[Union[str, "_models.ExtrapolationModeEnum"]] = rest_field(name="extrapolationMode")
    """The extrapolation method used in the zero coupon curve bootstrapping. The possible values are:
     * None: no extrapolation,   * Constant: constant extrapolation,   * Linear: linear
     extrapolation,   * ConstantRate: extrapolation with constant zero-coupon rate   *
     ConstantForwardRate: extrapolation with constant forward rate   * UltimateForwardRate:
     extrapolation with ultimate forward rate The default value is 'None'. Known values are:
     \"Constant\", \"ConstantForwardRate\", \"ConstantRate\", \"Linear\", \"None\", and
     \"UltimateForwardRate\"."""
    ignore_invalid_instrument: Optional[bool] = rest_field(name="ignoreInvalidInstrument")
    interest_calculation_method: Optional[Union[str, "_models.CurvesAndSurfacesInterestCalculationMethodEnum"]] = (
        rest_field(name="interestCalculationMethod")
    )
    """The day count basis method used to compute the points of the zero coupon curve. The possible
     values are:   * Dcb_30_360     Actual number of days in the coupon period calculated on the
     basis of a year of 360 days with twelve 30-day months unless:     - the last day of the period
     is the 31st day of a month and the first day of the period is a day other than the 30th or 31st
     day of a month, in which case the month that includes the last day shall not be considered to
     be shortened to a 30-day month,     - the last day of the period is the last day of the month
     of February, in which case the month of February shall not be considered to be lengthened to a
     30-day month.   * Dcb_30_Actual     The day count is identical to 30/360 (US) and the year
     basis is identical to Actual/Actual.   * Dcb_Actual_360     The day count is the actual number
     of days of the period. The year basis is 360.   * Dcb_Actual_365     The day count is the
     actual number of days of the period. The year basis is 365.   * Dcb_Actual_Actual     The DCB
     is calculated by Actual days / year basis where:     - Actual days are defined as the actual
     days between the starting date (D1.M1.Y1) and end date (D2.M2.Y2).     - Year basis is defined
     as the actual days between the start date (D1.M1.Y1) and the next relevant interest payment
     date (D3.M3.Y3) multiplied by the instrument coupon frequency.   * Dcb_Actual_Actual_ISDA
     Similar to Actual/365, except for a period that includes days falling in a leap year. It is
     calculated by DCB &#x3D; number of days in a leap year/366 + number of days in a non-leap
     year/365.     A convention is also known as Actual/365 ISDA.   *Dcb_30_360_ISDA     For two
     dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1 is 31, change it to 30,     - if D2 is 31 and D1
     is 30, change D2 to 30.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
     Dcb_30_365_ISDA     For two dates (Y1,M1,D1) and (Y2,M2,D2):     - if D1&#x3D;31 then
     D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31 then D2&#x3D;30.     Then the date
     difference is (Y2-Y1)x365+(M2-M1)x30+(D2-D1)   * Dcb_30_360_US     For two dates (Y1,M1,D1) and
     (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 and D1&#x3D;30 or 31 then
     D2&#x3D;30,     - if D1 is the last day of February then D1&#x3D;30,     - if D1 is the last
     day of February and D2 is the last day of February then D2&#x3D;30.     The last day of
     February is February 29 in leap years and February 28 in non leap years.     The 30/360 US rule
     is identical to 30/360 ISDA when the EOM (end-of-month) convention does not apply. This
     indicates whether all coupon payment dates fall on the last day of the month. If the investment
     is not EOM, it will always pay on the same day of the month (e.g., the 10th).     Then the date
     difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   * Dcb_Actual_Actual_AFB     The DCB is
     calculated by Actual days / year basis where:     Actual days are defined as the actual days
     between the start date (D1.M1.Y1) and end date (D2.M2.Y2).     Year basis is either 365 if the
     calculation period does not contain 29th Feb, or 366 if the calculation period includes 29th
     Feb.   * Dcb_WorkingDays_252     The day count is the actual number of business days of the
     period according to the instrument calendars. The year basis is 252. Commonly used in the
     Brazilian market.   * Dcb_Actual_365L     The day count is the actual number of days of the
     period. The year basis is calculated in the following two rules:     - if the coupon frequency
     is annual, then year basis is 366 if the 29 Feb. is included in the interest period, else 365,
     - if the coupon frequency is not annual, then year basis is 366 for each interest period where
     ending date falls in a leap year, otherwise it is 365.   * Dcb_ActualLeapDay_365     The day
     count ignores 29th February when counting days. The year basis is 365 days.   *
     Dcb_ActualLeapDay_360     The day count ignores 29th February when counting days. The year
     basis is 360 days.   * Dcb_Actual_36525     The day count is the actual number of days of the
     period. The year basis is 365.25.   * Dcb_Actual_365_CanadianConvention     Follows the
     Canadian domestic bond market convention. The day count basis is computed as follows:     - if
     the number of days of a period is less than the actual number of days in a regular coupon
     period the Dcb_Actual_365 convention is used,     - otherwise: DCB &#x3D; 1 -
     DaysRemainingInPeriod x Frequency / 365.   * Dcb_30_360_German     For two dates (Y1,M1,D1) and
     (Y2,M2,D2):     - if D1&#x3D;31 then D1&#x3D;30,     - if D2&#x3D;31 then D2&#x3D;30,     - if
     D1 is the last day of February then D1&#x3D;30,     - if D2 is the last day of February then
     D2&#x3D;30.     The last day of February is February 29 in leap years and February 28 in non
     leap years.     Then the date difference is (Y2-Y1)x360+(M2-M1)x30+(D2-D1).   *
     Dcb_30_365_German     Similar to 30/360 (German), except that the year basis is treated as 365
     days.   * Dcb_30_Actual_German     The day count is identical to 30/360 (German) and the year
     basis is similar to Actual/Actual. This method was formerly used in the Eurobond markets.   *
     Dcb_30E_360_ISMA     Actual number of days in the coupon period calculated on the basis of a
     year of 360 days with twelve 30-day months (regardless of the date of the first day or last day
     of the period).   * Dcb_Actual_364     A special case of Actual/Actual (ISMA) when a coupon
     period contains 91 or 182 days. Actual/364 applies for some short-term instruments.     Day
     count basis &#x3D; 364.   * Dcb_30_Actual_ISDA   * Dcb_30_365_Brazil   * Dcb_Actual_365P   *
     Dcb_Constant. Known values are: \"Dcb_30E_360_ISMA\", \"Dcb_30_360\", \"Dcb_30_360_German\",
     \"Dcb_30_360_ISDA\", \"Dcb_30_360_US\", \"Dcb_30_365_Brazil\", \"Dcb_30_365_German\",
     \"Dcb_30_365_ISDA\", \"Dcb_30_Actual\", \"Dcb_30_Actual_German\", \"Dcb_30_Actual_ISDA\",
     \"Dcb_ActualLeapDay_360\", \"Dcb_ActualLeapDay_365\", \"Dcb_Actual_360\", \"Dcb_Actual_364\",
     \"Dcb_Actual_365\", \"Dcb_Actual_36525\", \"Dcb_Actual_365L\", \"Dcb_Actual_365P\",
     \"Dcb_Actual_365_CanadianConvention\", \"Dcb_Actual_Actual\", \"Dcb_Actual_Actual_AFB\",
     \"Dcb_Actual_Actual_ISDA\", \"Dcb_Constant\", and \"Dcb_WorkingDays_252\"."""
    interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = rest_field(name="interpolationMode")
    """The interpolation method used in zero curve bootstrapping. The possible values are:   *
     CubicDiscount: local cubic interpolation of discount factors   * CubicRate: local cubic
     interpolation of rates   * CubicSpline: a natural cubic spline   * ForwardMonotoneConvex:
     forward Monotone Convexc interpolation   * Linear: linear interpolation   * Log: log-linear
     interpolation   * Hermite: Hermite (Bessel) interpolation   * AkimaMethod: the Akima method (a
     smoother variant of local cubic interpolation)   * FritschButlandMethod: the Fritsch-Butland
     method (a monotonic cubic variant)   * KrugerMethod: the Kruger method (a monotonic cubic
     variant)   * MonotonicCubicNaturalSpline: a monotonic natural cubic spline   *
     MonotonicHermiteCubic: monotonic Hermite (Bessel) cubic interpolation   * TensionSpline: a
     tension spline. Known values are: \"AkimaMethod\", \"CubicDiscount\", \"CubicRate\",
     \"CubicSpline\", \"ForwardMonotoneConvex\", \"FritschButlandMethod\", \"Hermite\",
     \"KrugerMethod\", \"Linear\", \"Log\", \"MonotonicCubicNaturalSpline\",
     \"MonotonicHermiteCubic\", \"Step\", and \"TensionSpline\"."""
    market_data_access_denied_fallback: Optional[Union[str, "_models.MarketDataAccessDeniedFallbackEnum"]] = rest_field(
        name="marketDataAccessDeniedFallback"
    )
    """If at least one constituent access is denied:   * ReturnError: dont price the surface and
     return an error (Default value)   * IgnoreConstituents: price the surface without the error
     market data   * UseDelayedData: use delayed Market Data if possible. Known values are:
     \"IgnoreConstituents\", \"ReturnError\", and \"UseDelayedData\"."""
    market_data_look_back: Optional["_models.MarketDataLookBack"] = rest_field(name="marketDataLookBack")
    pivot_curve_parameters: Optional["_models.InterestRateCurveParameters"] = rest_field(name="pivotCurveParameters")
    price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = rest_field(name="priceSide")
    """The quoted price side of the instrument to be used for the zero coupon curve construction. The
     possible values are:   * Bid   * Ask   * Mid The default value is &#39;Mid&#39;. Known values
     are: \"Ask\", \"Bid\", \"Last\", and \"Mid\"."""
    reference_curve_parameters: Optional["_models.InterestRateCurveParameters"] = rest_field(
        name="referenceCurveParameters"
    )
    reference_tenor: Optional[str] = rest_field(name="referenceTenor")
    """The tenor of the index interest rate curve for which curvePoints are computed (e.g., '3M')."""
    steps: Optional[List["_models.Step"]] = rest_field()
    """The list of attributes used to calculate the swap rate surface discount curve, when OIS is
     selected as discount curve. The steps can specify overnight index stepped dates or/and rates.
     Currencies supporting steps are the following: USD, AUD, BRL, CAD, COP, CZK, EUR, GBP, JPY,
     NZD, PLN, HUF, SEK, CHF, RUB, INR, DKK."""
    turns: Optional[List["_models.Turn"]] = rest_field()
    """The list of attributes used to include end period when calculating swap rate surfaces."""
    use_convexity_adjustment: Optional[bool] = rest_field(name="useConvexityAdjustment")
    use_delayed_data_if_denied: Optional[bool] = rest_field(name="useDelayedDataIfDenied")
    use_multi_dimensional_solver: Optional[bool] = rest_field(name="useMultiDimensionalSolver")
    use_stub: Optional[bool] = rest_field(name="useStub")
    valuation_date: Optional[datetime.date] = rest_field(name="valuationDate")
    """The date at which the zero coupon curve is generated. The value is expressed in ISO 8601
     format: YYYY-MM-DD (e.g., '2021-01-01'). Only one parameter of valuationDate and
     valuationDateTime must be specified. The default value is today."""
    valuation_date_time: Optional[datetime.datetime] = rest_field(name="valuationDateTime", format="rfc3339")
    """The date and time at which the zero coupon curve is generated. The value is expressed in ISO
     8601 format: YYYY-MM-DDT00:00:00Z (e.g., '2021-01-01T14:00:00Z' or
     '2021-01-01T14:00:00+02:00'). Only one parameter of valuationDate and valuationDateTime must be
     specified."""
    valuation_time: Optional["_models.CurvesAndSurfacesValuationTime"] = rest_field(name="valuationTime")

    @overload
    def __init__(  # pylint: disable=too-many-locals
        self,
        *,
        calendar_adjustment: Optional[Union[str, "_models.CalendarAdjustmentEnum"]] = None,
        calendars: Optional[List[str]] = None,
        compounding_type: Optional[Union[str, "_models.CompoundingTypeEnum"]] = None,
        constant_forward_rate_parameters: Optional["_models.ConstantForwardRateParameters"] = None,
        convexity_adjustment: Optional["_models.CurvesAndSurfacesConvexityAdjustment"] = None,
        extrapolation_mode: Optional[Union[str, "_models.ExtrapolationModeEnum"]] = None,
        ignore_invalid_instrument: Optional[bool] = None,
        interest_calculation_method: Optional[
            Union[str, "_models.CurvesAndSurfacesInterestCalculationMethodEnum"]
        ] = None,
        interpolation_mode: Optional[Union[str, "_models.InterpolationModeEnum"]] = None,
        market_data_access_denied_fallback: Optional[Union[str, "_models.MarketDataAccessDeniedFallbackEnum"]] = None,
        market_data_look_back: Optional["_models.MarketDataLookBack"] = None,
        pivot_curve_parameters: Optional["_models.InterestRateCurveParameters"] = None,
        price_side: Optional[Union[str, "_models.CurvesAndSurfacesPriceSideEnum"]] = None,
        reference_curve_parameters: Optional["_models.InterestRateCurveParameters"] = None,
        reference_tenor: Optional[str] = None,
        steps: Optional[List["_models.Step"]] = None,
        turns: Optional[List["_models.Turn"]] = None,
        use_convexity_adjustment: Optional[bool] = None,
        use_delayed_data_if_denied: Optional[bool] = None,
        use_multi_dimensional_solver: Optional[bool] = None,
        use_stub: Optional[bool] = None,
        valuation_date: Optional[datetime.date] = None,
        valuation_date_time: Optional[datetime.datetime] = None,
        valuation_time: Optional["_models.CurvesAndSurfacesValuationTime"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurvePoint(_model_base.Model):
    """ZcCurvePoint.

    Attributes
    ----------
    discount_factor : float
        The ratio used to calculate the present value of future cash flows at
        valuationDate. It is derived from ratePercent which corresponds to
        tenor of the point on the zero coupon curve.
    end_date : ~datetime.date
        The date used to define the end date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    instruments : list[~analyticsapi.models.ZcCurveInstrument]
        The instrument's codes and values used for the curve points
        computation. The default value is None, needs to be assigned before
        using.
    rate_percent : float
        The rate percent of the zero coupon curve computed for the given curve
        point.
    start_date : ~datetime.date
        The date used to define the start date of the curve point tenor. The
        value is expressed in ISO 8601 format: YYYY-MM-DD (e.g., '2021-01-01').
    tenor : str
        The code indicating the period between startDate and endDate of the
        zero coupon curve (e.g., '1M', '6M', '4Y').
    """

    discount_factor: Optional[float] = rest_field(name="discountFactor")
    """The ratio used to calculate the present value of future cash flows at valuationDate. It is
     derived from ratePercent which corresponds to tenor of the point on the zero coupon curve."""
    end_date: Optional[datetime.date] = rest_field(name="endDate")
    """The date used to define the end date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    instruments: Optional[List["_models.ZcCurveInstrument"]] = rest_field()
    """The instrument's codes and values used for the curve points computation."""
    rate_percent: Optional[float] = rest_field(name="ratePercent")
    """The rate percent of the zero coupon curve computed for the given curve point."""
    start_date: Optional[datetime.date] = rest_field(name="startDate")
    """The date used to define the start date of the curve point tenor. The value is expressed in ISO
     8601 format: YYYY-MM-DD (e.g., '2021-01-01')."""
    tenor: Optional[str] = rest_field()
    """The code indicating the period between startDate and endDate of the zero coupon curve (e.g.,
     '1M', '6M', '4Y')."""

    @overload
    def __init__(
        self,
        *,
        discount_factor: Optional[float] = None,
        end_date: Optional[datetime.date] = None,
        instruments: Optional[List["_models.ZcCurveInstrument"]] = None,
        rate_percent: Optional[float] = None,
        start_date: Optional[datetime.date] = None,
        tenor: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurveRequestItem(_model_base.Model):
    """ZcCurveRequestItem.

    Attributes
    ----------
    constituents : ~analyticsapi.models.Constituents
    curve_definition : ~analyticsapi.models.ZcCurveDefinitions
    curve_parameters : ~analyticsapi.models.ZcCurveParameters
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    shift_scenarios : list[~analyticsapi.models.ShiftScenario]
        The list of attributes applied to the curve shift scenarios.  The
        default value is None, needs to be assigned before using.
    """

    constituents: Optional["_models.Constituents"] = rest_field()
    curve_definition: Optional["_models.ZcCurveDefinitions"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.ZcCurveParameters"] = rest_field(name="curveParameters")
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""
    shift_scenarios: Optional[List["_models.ShiftScenario"]] = rest_field(name="shiftScenarios")
    """The list of attributes applied to the curve shift scenarios."""

    @overload
    def __init__(
        self,
        *,
        constituents: Optional["_models.Constituents"] = None,
        curve_definition: Optional["_models.ZcCurveDefinitions"] = None,
        curve_parameters: Optional["_models.ZcCurveParameters"] = None,
        curve_tag: Optional[str] = None,
        shift_scenarios: Optional[List["_models.ShiftScenario"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcCurvesResponse(_model_base.Model):
    """ZcCurvesResponse.

    Attributes
    ----------
    data : list[~analyticsapi.models.ZcCurvesResponseItem]
        Get data.  The default value is None, needs to be assigned before
        using.
    """

    data: Optional[List["_models.ZcCurvesResponseItem"]] = rest_field()
    """Get data."""

    @overload
    def __init__(
        self,
        data: Optional[List["_models.ZcCurvesResponseItem"]] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        if len(args) == 1 and not isinstance(args[0], dict):
            kwargs["data"] = args[0]
            args = tuple()
        super().__init__(*args, **kwargs)


class ZcCurvesResponseItem(_model_base.Model):
    """ZcCurvesResponseItem.

    Attributes
    ----------
    bootstrapped_curves : dict[str, ~analyticsapi.models.ZcCurve]
        The list of attributes for the bootstrapped zero coupon curve surface.
    constituents : ~analyticsapi.models.ConstituentsOutput
    curve_definition : ~analyticsapi.models.ZcCurveDefinitionsOutput
    curve_parameters : ~analyticsapi.models.ZcCurveParameters
    curve_tag : str
        A user-defined string to identify the interest rate curve. It can be
        used to link output results to the curve definition. Limited to 40
        characters. Only alphabetic, numeric and '- _.#=@' characters are
        supported.
    curves : dict[str, ~analyticsapi.models.ZcCurve]
        The list of attributes for the generated zero coupon curve surface.
    invalid_constituents : ~analyticsapi.models.ConstituentsOutput
    processing_information : list[~analyticsapi.models.ProcessingInformation]
        Get processingInformation.  The default value is None, needs to be
        assigned before using.
    shift_scenarios : list[~analyticsapi.models.ShiftScenario]
        The list of attributes applied to the curve shift scenarios.  The
        default value is None, needs to be assigned before using.
    shifted_curves : list[~analyticsapi.models.ZcShiftedCurve]
        The list of attributes of the shifted zero coupon curve for a given
        shift scenario.  The default value is None, needs to be assigned before
        using.
    shifted_underlying_curves : list[~analyticsapi.models.ShiftedUnderlyingCurves]
        The list of attributes of the shifted underlying curves used to
        generate and adjust the zero coupon curve.  The default value is None,
        needs to be assigned before using.
    step_curve_points : list[~analyticsapi.models.StepCurvePoint]
        The list of the curve points and related attributes of the curve.  The
        default value is None, needs to be assigned before using.
    underlying_curves : ~analyticsapi.models.UnderlyingCurves
    """

    bootstrapped_curves: Optional[Dict[str, "_models.ZcCurve"]] = rest_field(name="bootstrappedCurves")
    """The list of attributes for the bootstrapped zero coupon curve surface."""
    constituents: Optional["_models.ConstituentsOutput"] = rest_field()
    curve_definition: Optional["_models.ZcCurveDefinitionsOutput"] = rest_field(name="curveDefinition")
    curve_parameters: Optional["_models.ZcCurveParameters"] = rest_field(name="curveParameters")
    curve_tag: Optional[str] = rest_field(name="curveTag")
    """A user-defined string to identify the interest rate curve. It can be used to link output
     results to the curve definition. Limited to 40 characters. Only alphabetic, numeric and '-
     _.#=@' characters are supported."""
    curves: Optional[Dict[str, "_models.ZcCurve"]] = rest_field()
    """The list of attributes for the generated zero coupon curve surface."""
    invalid_constituents: Optional["_models.ConstituentsOutput"] = rest_field(name="invalidConstituents")
    processing_information: Optional[List["_models.ProcessingInformation"]] = rest_field(name="processingInformation")
    """Get processingInformation."""
    shift_scenarios: Optional[List["_models.ShiftScenario"]] = rest_field(name="shiftScenarios")
    """The list of attributes applied to the curve shift scenarios."""
    shifted_curves: Optional[List["_models.ZcShiftedCurve"]] = rest_field(name="shiftedCurves")
    """The list of attributes of the shifted zero coupon curve for a given shift scenario."""
    shifted_underlying_curves: Optional[List["_models.ShiftedUnderlyingCurves"]] = rest_field(
        name="shiftedUnderlyingCurves"
    )
    """The list of attributes of the shifted underlying curves used to generate and adjust the zero
     coupon curve."""
    step_curve_points: Optional[List["_models.StepCurvePoint"]] = rest_field(name="stepCurvePoints")
    """The list of the curve points and related attributes of the curve."""
    underlying_curves: Optional["_models.UnderlyingCurves"] = rest_field(name="underlyingCurves")

    @overload
    def __init__(
        self,
        *,
        bootstrapped_curves: Optional[Dict[str, "_models.ZcCurve"]] = None,
        constituents: Optional["_models.ConstituentsOutput"] = None,
        curve_definition: Optional["_models.ZcCurveDefinitionsOutput"] = None,
        curve_parameters: Optional["_models.ZcCurveParameters"] = None,
        curve_tag: Optional[str] = None,
        curves: Optional[Dict[str, "_models.ZcCurve"]] = None,
        invalid_constituents: Optional["_models.ConstituentsOutput"] = None,
        processing_information: Optional[List["_models.ProcessingInformation"]] = None,
        shift_scenarios: Optional[List["_models.ShiftScenario"]] = None,
        shifted_curves: Optional[List["_models.ZcShiftedCurve"]] = None,
        shifted_underlying_curves: Optional[List["_models.ShiftedUnderlyingCurves"]] = None,
        step_curve_points: Optional[List["_models.StepCurvePoint"]] = None,
        underlying_curves: Optional["_models.UnderlyingCurves"] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)


class ZcShiftedCurve(_model_base.Model):
    """Shifted curve.

    Attributes
    ----------
    curves : dict[str, ~analyticsapi.models.ZcCurve]
        The curve surface per tenor.
    shift_tag : str
        the shiftTag passed in the request.
    """

    curves: Optional[Dict[str, "_models.ZcCurve"]] = rest_field()
    """The curve surface per tenor."""
    shift_tag: Optional[str] = rest_field(name="shiftTag")
    """the shiftTag passed in the request."""

    @overload
    def __init__(
        self,
        *,
        curves: Optional[Dict[str, "_models.ZcCurve"]] = None,
        shift_tag: Optional[str] = None,
    ) -> None: ...

    @overload
    def __init__(self, mapping: Mapping[str, Any]) -> None:
        """
        Parameters
        ----------
        mapping : Mapping[str, Any]
            raw JSON to initialize the model.
        """

    def __init__(self, *args: Any, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
