"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from openrouter.components import (
    datacollection as components_datacollection,
    providername as components_providername,
    providersort as components_providersort,
    quantization as components_quantization,
)
from openrouter.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
    UnrecognizedStr,
)
from openrouter.utils import get_discriminator, validate_open_enum
from pydantic import Discriminator, Tag, model_serializer
from pydantic.functional_validators import PlainValidator
from typing import List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


TypeImageURL = Literal["image_url",]


class ImageURLTypedDict(TypedDict):
    url: str


class ImageURL(BaseModel):
    url: str


class ContentImageURLTypedDict(TypedDict):
    type: TypeImageURL
    image_url: ImageURLTypedDict


class ContentImageURL(BaseModel):
    type: TypeImageURL

    image_url: ImageURL


TypeText = Literal["text",]


class ContentTextTypedDict(TypedDict):
    type: TypeText
    text: str


class ContentText(BaseModel):
    type: TypeText

    text: str


ContentTypedDict = TypeAliasType(
    "ContentTypedDict", Union[ContentTextTypedDict, ContentImageURLTypedDict]
)


Content = Annotated[
    Union[
        Annotated[ContentText, Tag("text")],
        Annotated[ContentImageURL, Tag("image_url")],
    ],
    Discriminator(lambda m: get_discriminator(m, "type", "type")),
]


class InputTypedDict(TypedDict):
    content: List[ContentTypedDict]


class Input(BaseModel):
    content: List[Content]


InputUnionTypedDict = TypeAliasType(
    "InputUnionTypedDict",
    Union[str, List[str], List[float], List[List[float]], List[InputTypedDict]],
)


InputUnion = TypeAliasType(
    "InputUnion", Union[str, List[str], List[float], List[List[float]], List[Input]]
)


EncodingFormat = Union[
    Literal[
        "float",
        "base64",
    ],
    UnrecognizedStr,
]


OrderTypedDict = TypeAliasType(
    "OrderTypedDict", Union[components_providername.ProviderName, str]
)


Order = TypeAliasType(
    "Order",
    Union[
        Annotated[
            components_providername.ProviderName,
            PlainValidator(validate_open_enum(False)),
        ],
        str,
    ],
)


OnlyTypedDict = TypeAliasType(
    "OnlyTypedDict", Union[components_providername.ProviderName, str]
)


Only = TypeAliasType(
    "Only",
    Union[
        Annotated[
            components_providername.ProviderName,
            PlainValidator(validate_open_enum(False)),
        ],
        str,
    ],
)


IgnoreTypedDict = TypeAliasType(
    "IgnoreTypedDict", Union[components_providername.ProviderName, str]
)


Ignore = TypeAliasType(
    "Ignore",
    Union[
        Annotated[
            components_providername.ProviderName,
            PlainValidator(validate_open_enum(False)),
        ],
        str,
    ],
)


class MaxPriceTypedDict(TypedDict):
    r"""The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion."""

    prompt: NotRequired[str]
    r"""A value in string format that is a large number"""
    completion: NotRequired[str]
    r"""A value in string format that is a large number"""
    image: NotRequired[str]
    r"""A value in string format that is a large number"""
    audio: NotRequired[str]
    r"""A value in string format that is a large number"""
    request: NotRequired[str]
    r"""A value in string format that is a large number"""


class MaxPrice(BaseModel):
    r"""The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion."""

    prompt: Optional[str] = None
    r"""A value in string format that is a large number"""

    completion: Optional[str] = None
    r"""A value in string format that is a large number"""

    image: Optional[str] = None
    r"""A value in string format that is a large number"""

    audio: Optional[str] = None
    r"""A value in string format that is a large number"""

    request: Optional[str] = None
    r"""A value in string format that is a large number"""


class CreateEmbeddingsProviderTypedDict(TypedDict):
    allow_fallbacks: NotRequired[Nullable[bool]]
    r"""Whether to allow backup providers to serve requests
    - true: (default) when the primary provider (or your custom providers in \"order\") is unavailable, use the next best provider.
    - false: use only the primary/custom provider, and return the upstream error if it's unavailable.

    """
    require_parameters: NotRequired[Nullable[bool]]
    r"""Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest."""
    data_collection: NotRequired[Nullable[components_datacollection.DataCollection]]
    r"""Data collection setting. If no available model provider meets the requirement, your request will return an error.
    - allow: (default) allow providers which store user data non-transiently and may train on it

    - deny: use only providers which do not collect user data.
    """
    zdr: NotRequired[Nullable[bool]]
    r"""Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used."""
    enforce_distillable_text: NotRequired[Nullable[bool]]
    r"""Whether to restrict routing to only models that allow text distillation. When true, only models where the author has allowed distillation will be used."""
    order: NotRequired[Nullable[List[OrderTypedDict]]]
    r"""An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message."""
    only: NotRequired[Nullable[List[OnlyTypedDict]]]
    r"""List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request."""
    ignore: NotRequired[Nullable[List[IgnoreTypedDict]]]
    r"""List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request."""
    quantizations: NotRequired[Nullable[List[components_quantization.Quantization]]]
    r"""A list of quantization levels to filter the provider by."""
    sort: NotRequired[Nullable[components_providersort.ProviderSort]]
    r"""The sorting strategy to use for this request, if \"order\" is not specified. When set, no load balancing is performed."""
    max_price: NotRequired[MaxPriceTypedDict]
    r"""The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion."""
    min_throughput: NotRequired[Nullable[float]]
    r"""The minimum throughput (in tokens per second) required for this request. Only providers serving the model with at least this throughput will be used."""
    max_latency: NotRequired[Nullable[float]]
    r"""The maximum latency (in seconds) allowed for this request. Only providers serving the model with better than this latency will be used."""


class CreateEmbeddingsProvider(BaseModel):
    allow_fallbacks: OptionalNullable[bool] = UNSET
    r"""Whether to allow backup providers to serve requests
    - true: (default) when the primary provider (or your custom providers in \"order\") is unavailable, use the next best provider.
    - false: use only the primary/custom provider, and return the upstream error if it's unavailable.

    """

    require_parameters: OptionalNullable[bool] = UNSET
    r"""Whether to filter providers to only those that support the parameters you've provided. If this setting is omitted or set to false, then providers will receive only the parameters they support, and ignore the rest."""

    data_collection: Annotated[
        OptionalNullable[components_datacollection.DataCollection],
        PlainValidator(validate_open_enum(False)),
    ] = UNSET
    r"""Data collection setting. If no available model provider meets the requirement, your request will return an error.
    - allow: (default) allow providers which store user data non-transiently and may train on it

    - deny: use only providers which do not collect user data.
    """

    zdr: OptionalNullable[bool] = UNSET
    r"""Whether to restrict routing to only ZDR (Zero Data Retention) endpoints. When true, only endpoints that do not retain prompts will be used."""

    enforce_distillable_text: OptionalNullable[bool] = UNSET
    r"""Whether to restrict routing to only models that allow text distillation. When true, only models where the author has allowed distillation will be used."""

    order: OptionalNullable[List[Order]] = UNSET
    r"""An ordered list of provider slugs. The router will attempt to use the first provider in the subset of this list that supports your requested model, and fall back to the next if it is unavailable. If no providers are available, the request will fail with an error message."""

    only: OptionalNullable[List[Only]] = UNSET
    r"""List of provider slugs to allow. If provided, this list is merged with your account-wide allowed provider settings for this request."""

    ignore: OptionalNullable[List[Ignore]] = UNSET
    r"""List of provider slugs to ignore. If provided, this list is merged with your account-wide ignored provider settings for this request."""

    quantizations: OptionalNullable[
        List[
            Annotated[
                components_quantization.Quantization,
                PlainValidator(validate_open_enum(False)),
            ]
        ]
    ] = UNSET
    r"""A list of quantization levels to filter the provider by."""

    sort: Annotated[
        OptionalNullable[components_providersort.ProviderSort],
        PlainValidator(validate_open_enum(False)),
    ] = UNSET
    r"""The sorting strategy to use for this request, if \"order\" is not specified. When set, no load balancing is performed."""

    max_price: Optional[MaxPrice] = None
    r"""The object specifying the maximum price you want to pay for this request. USD price per million tokens, for prompt and completion."""

    min_throughput: OptionalNullable[float] = UNSET
    r"""The minimum throughput (in tokens per second) required for this request. Only providers serving the model with at least this throughput will be used."""

    max_latency: OptionalNullable[float] = UNSET
    r"""The maximum latency (in seconds) allowed for this request. Only providers serving the model with better than this latency will be used."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "allow_fallbacks",
            "require_parameters",
            "data_collection",
            "zdr",
            "enforce_distillable_text",
            "order",
            "only",
            "ignore",
            "quantizations",
            "sort",
            "max_price",
            "min_throughput",
            "max_latency",
        ]
        nullable_fields = [
            "allow_fallbacks",
            "require_parameters",
            "data_collection",
            "zdr",
            "enforce_distillable_text",
            "order",
            "only",
            "ignore",
            "quantizations",
            "sort",
            "min_throughput",
            "max_latency",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class CreateEmbeddingsRequestTypedDict(TypedDict):
    input: InputUnionTypedDict
    model: str
    encoding_format: NotRequired[EncodingFormat]
    dimensions: NotRequired[int]
    user: NotRequired[str]
    provider: NotRequired[CreateEmbeddingsProviderTypedDict]
    input_type: NotRequired[str]


class CreateEmbeddingsRequest(BaseModel):
    input: InputUnion

    model: str

    encoding_format: Annotated[
        Optional[EncodingFormat], PlainValidator(validate_open_enum(False))
    ] = None

    dimensions: Optional[int] = None

    user: Optional[str] = None

    provider: Optional[CreateEmbeddingsProvider] = None

    input_type: Optional[str] = None


Object = Literal["list",]


ObjectEmbedding = Literal["embedding",]


EmbeddingTypedDict = TypeAliasType("EmbeddingTypedDict", Union[List[float], str])


Embedding = TypeAliasType("Embedding", Union[List[float], str])


class CreateEmbeddingsDataTypedDict(TypedDict):
    object: ObjectEmbedding
    embedding: EmbeddingTypedDict
    index: NotRequired[float]


class CreateEmbeddingsData(BaseModel):
    object: ObjectEmbedding

    embedding: Embedding

    index: Optional[float] = None


class UsageTypedDict(TypedDict):
    prompt_tokens: float
    total_tokens: float
    cost: NotRequired[float]


class Usage(BaseModel):
    prompt_tokens: float

    total_tokens: float

    cost: Optional[float] = None


class CreateEmbeddingsResponseBodyTypedDict(TypedDict):
    r"""Embedding response"""

    object: Object
    data: List[CreateEmbeddingsDataTypedDict]
    model: str
    id: NotRequired[str]
    usage: NotRequired[UsageTypedDict]


class CreateEmbeddingsResponseBody(BaseModel):
    r"""Embedding response"""

    object: Object

    data: List[CreateEmbeddingsData]

    model: str

    id: Optional[str] = None

    usage: Optional[Usage] = None


CreateEmbeddingsResponseTypedDict = TypeAliasType(
    "CreateEmbeddingsResponseTypedDict",
    Union[CreateEmbeddingsResponseBodyTypedDict, str],
)


CreateEmbeddingsResponse = TypeAliasType(
    "CreateEmbeddingsResponse", Union[CreateEmbeddingsResponseBody, str]
)
