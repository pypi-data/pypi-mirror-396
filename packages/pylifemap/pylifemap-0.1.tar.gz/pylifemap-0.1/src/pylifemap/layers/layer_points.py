from typing import Literal

import pandas as pd
import polars as pl

from pylifemap.layers.base import LayersBase
from pylifemap.utils import MAX_HOVER_DATA_LEN, is_hex_color


class LayerPoints(LayersBase):
    def layer_points(
        self,
        data: pl.DataFrame | pd.DataFrame | None = None,
        *,
        taxid_col: str = "taxid",
        leaves: Literal["show", "only", "omit"] = "show",
        radius: int | float | str = 5,
        radius_range: tuple | list = (2, 30),
        fill: str | None = None,
        fill_cat: bool | None = None,
        categories: list | tuple | None = None,
        scheme: str | None = None,
        opacity: float = 0.8,
        popup: bool = True,
        popup_col: str | None = None,
        hover: bool | None = None,
        label: str | None = None,
        lazy: bool = False,
        lazy_zoom: int = 15,
        lazy_mode: Literal["self", "parent"] = "self",
    ) -> LayersBase:
        """
        Add a points layer.

        It can be used to display leaves values, or aggregated counts or values already
        computed or generated by [](`~pylifemap.aggregate_num`) or
        [](`~pylifemap.aggregate_count`).

        Parameters
        ----------
        data : pl.DataFrame | pd.DataFrame | None, optional
            Layer data. If not provided, use the base widget data.
        taxid_col : str, optional
            If `data` is provided, name of the `data` column with taxonomy ids, by default `"taxid"`
        leaves : Literal[&quot;show&quot;, &quot;only&quot;, &quot;omit&quot;], optional
            If `"only"`, only show tree leaves. If `"omit"`, only show nodes that are
            not leaves. If `"show"`, show all nodes, by default "show"
        radius : int | float | str, optional
            If numeric, the fixed radius of the points. If a string, the name of a numerical DataFrame column
            to compute radius width from.
        radius_range : tuple | list
            Range of values for points radius, only used if radius_col is not None, by default (2, 30)
        fill : str | None, optional
            Either the name of a numerical DataFrame column to determine points color, or a fixed CSS
            color for points.
        fill_cat : bool | None, optional
            If True, force color scheme to be categorical. If False, force it to be
            continuous. If None, let pylifemap decide. By default None.
        categories : list | tuple | None, optional
            Custom order of categories when a categorical variable is used for the fill argument.
            Defaults to None.
        scheme : str | None, optional
            Color scheme for points color. It is the name of
            an [Observable Plot color scale](https://observablehq.com/plot/features/scales#color-scales).
        opacity : float
            Points opacity as a floating number between 0 and 1, by default 0.8
        popup : bool
            If True, display informations in a popup when a point is clicked,
            by default True
        popup_col : str | None
            Name of a data column containing custom popup content. By default None.
        hover : bool | None, optional
            If True, highlight points on mouse hovering. By default True if less than 10_000 data points,
            False otherwise.
        label : str | None, optional
            Legend title for this layer if `fill` is defined. If `None`, the value
            of `fill` is used.
        lazy : bool
            If True, points are displayed depending on the widget view. If False, all points are displayed.
            Can be useful when displaying a great number of items. Defaults to False.
        lazy_zoom : int
            If lazy is True, only points with a zoom level less than (zoom + lazy_zoom) level will be
            displayed. Defaults to 15.
        lazy_mode : Literal["self", "parent"], optional
            If lazy is True, choose the zoom level to apply to each taxa. If "self", keep the taxa zoom
            level. If "parent", get the nearest ancestor zoom level. Defaults to "self".

        Returns
        -------
        Lifemap
            A Lifemap visualization object.

        Raises
        ------
        ValueError
            If leaves is not one of the allowed values.

        Examples
        --------
        >>> import polars as pl
        >>> from pylifemap import Lifemap
        >>> d = pl.DataFrame(
        ...     {
        ...         "taxid": [
        ...             9685,
        ...             9615,
        ...             9994,
        ...             2467430,
        ...             2514524,
        ...             2038938,
        ...             1021470,
        ...             1415565,
        ...             1928562,
        ...             1397240,
        ...             230741,
        ...         ],
        ...         "value": [7.4, 2.5, 8.3, 1.0, 1.4, 5.6, 4.6, 3.4, 2.3, 2.8, 3.1],
        ...     }
        ... )
        >>> Lifemap(d).layer_points(radius="value", fill="value", popup=True).show()


        See also
        --------
        [](`~pylifemap.aggregate_num`) : aggregation of a numeric variable.

        [](`~pylifemap.aggregate_count`) : aggregation of the number of observations.
        """
        options, df = self._process_options(locals())

        leaves_values = ["show", "only", "omit"]
        if options["leaves"] not in leaves_values:
            msg = f"leaves must be one of {leaves_values}"
            raise ValueError(msg)

        lazy_mode_values = ["self", "parent"]
        if options["lazy_mode"] not in lazy_mode_values:
            msg = f"lazy_mode must be one of {lazy_mode_values}"
            raise ValueError(msg)

        if (
            options["fill"] is not None
            and options["categories"] is None
            and options["fill"] in df._categories
        ):
            options["categories"] = df._categories[options["fill"]]

        if options["hover"] is None:
            options["hover"] = len(df) < MAX_HOVER_DATA_LEN

        layer = {"layer": "points", "options": options}
        self._layers.append(layer)

        data_columns = [
            options[k]
            for k in ("radius", "fill")
            if isinstance(options[k], str) and not is_hex_color(options[k])
        ]
        if popup_col is not None:
            data_columns.append(options["popup_col"])
        d = df.points_data(options, data_columns, lazy_mode=lazy_mode)
        self._layers_data[options["id"]] = d

        # Compute color range
        key = options["fill"]
        if key in data_columns:
            min_value = d.get_column(key).min()
            max_value = d.get_column(key).max()
            if key in self._color_ranges:
                self._color_ranges[key]["min"] = min(self._color_ranges[key]["min"], min_value)  # type: ignore
                self._color_ranges[key]["max"] = max(self._color_ranges[key]["max"], max_value)  # type: ignore
            else:
                self._color_ranges[key] = {"min": min_value, "max": max_value}

        return self
