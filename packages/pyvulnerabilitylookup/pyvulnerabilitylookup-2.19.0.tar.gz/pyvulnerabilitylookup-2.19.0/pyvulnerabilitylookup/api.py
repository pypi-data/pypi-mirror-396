#!/usr/bin/env python3

from __future__ import annotations

import logging

from datetime import date, datetime, timedelta
from importlib.metadata import version
from pathlib import PurePosixPath
from typing import Any, Generator, Literal, overload
from urllib.parse import urljoin, urlparse

import requests

from urllib3.util import Retry
from requests.adapters import HTTPAdapter


def enable_full_debug() -> None:
    import http.client as http_client
    http_client.HTTPConnection.debuglevel = 1
    logging.basicConfig()
    logging.getLogger().setLevel(logging.DEBUG)
    requests_log = logging.getLogger("requests.packages.urllib3")
    requests_log.setLevel(logging.DEBUG)
    requests_log.propagate = True


class PyVulnerabilityLookup():

    def __init__(self, root_url: str='https://vulnerability.circl.lu', useragent: str | None=None, token: str | None=None,
                 *, proxies: dict[str, str] | None=None) -> None:
        '''Query a specific instance.

        :param root_url: URL of the instance to query.
        :param useragent: The User Agent used by requests to run the HTTP requests against the vulnerability lookup instance
        :param proxies: The proxies to use to connect to the vulnerability lookup instance - More details: https://requests.readthedocs.io/en/latest/user/advanced/#proxies
        '''
        self.root_url = root_url

        if not urlparse(self.root_url).scheme:
            self.root_url = 'http://' + self.root_url
        if not self.root_url.endswith('/'):
            self.root_url += '/'
        self.session = requests.session()
        self.session.headers['user-agent'] = useragent if useragent else f'PyVulnerabilityLookup / {version("pyvulnerabilitylookup")}'
        self.session.headers['X-API-KEY'] = token if token else ''
        self.session.headers['Accept'] = 'application/json'
        self.session.headers['Content-Type'] = 'application/json'
        if proxies:
            self.session.proxies.update(proxies)
        retries = Retry(total=5, backoff_factor=1, status_forcelist=[500, 502, 503, 504])
        self.session.mount('https://', HTTPAdapter(max_retries=retries))

    def set_apikey(self, apikey: str) -> None:
        '''Set the API key to use for the requests'''
        self.session.headers['X-API-KEY'] = apikey

    @property
    def is_up(self) -> bool:
        '''Test if the given instance is accessible'''
        try:
            r = self.session.head(self.root_url)
        except requests.exceptions.ConnectionError:
            return False
        return r.status_code == 200

    # #### DB & system status ####

    def check_process(self) -> dict[str, Any]:
        '''[Authentication Required] Checks the hearbeats of the various processes.'''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('system', 'checkProcess'))))
        return r.json()

    def check_smtp(self) -> dict[str, Any]:
        '''[Authentication Required] Checks the SMTP connection.'''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('system', 'checkSMTP'))))
        return r.json()

    def get_config_info(self) -> dict[str, Any]:
        '''Returns non-sensitive information about the configuration of the system.'''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'system', 'configInfo'))))
        return r.json()

    def get_info(self) -> dict[str, Any]:
        '''Returns information about the current sources in the Kvrocks database in use and when it was updated.'''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'system', 'dbInfo'))))
        return r.json()

    def get_pg_info(self) -> dict[str, Any]:
        '''[Authentication Required] Returns information about the PostgreSQL database.'''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'system', 'pgInfo'))))
        return r.json()

    def redis_up(self) -> bool:
        '''[Deprecated] Check if redis/valkey is up and running'''
        return self.valkey_up()

    def valkey_up(self) -> bool:
        '''Check if valkey is up and running'''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'system', 'redis_up'))))
        return r.json()

    # #### Vulnerabilities ####

    def get_vulnerability(self, vulnerability_id: str) -> dict[str, Any]:
        '''Get a vulnerability

        :param vulnerability_id: The ID of the vulnerability to get (can be from any source, as long as it is a valid ID)
        '''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'vulnerability', vulnerability_id))))
        return r.json()

    def create_vulnerability(self, vulnerability: dict[str, Any]) -> dict[str, Any]:
        '''Create a vulnerability.

        :param vulnerability: The vulnerability
        '''
        r = self.session.post(urljoin(self.root_url, str(PurePosixPath('api', 'vulnerability'))),
                              json=vulnerability)
        return r.json()

    def delete_vulnerability(self, vulnerability_id: str) -> int:
        '''Delete a vulnerability.

        :param vulnerability_id: The vulnerability ID
        '''
        r = self.session.delete(urljoin(self.root_url, str(PurePosixPath('api', 'vulnerability', vulnerability_id))))
        return r.status_code

    def get_last(self, number: int | None=None, source: str | None = None) -> list[dict[str, Any]]:
        '''Get the last vulnerabilities

        :param number: The number of vulnerabilities to get
        :param source: The source of the vulnerabilities
        '''
        path = PurePosixPath('last')
        if source:
            path /= source
        if number is not None:
            path /= str(number)
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'vulnerability', path))))
        return r.json()

    def get_recent(self, date_from: date | datetime | None=None, source: str | None=None, number: int | None=None) -> list[dict[str, Any]]:
        '''Get the recent vulnerabilities

        :param date_from: The date from which to get the vulnerabilities
        :param source: The source of the vulnerabilities
        :param number: The number of vulnerabilities to get
        '''
        path = PurePosixPath('recent')
        if date_from:
            if isinstance(date_from, datetime):
                date_from = date_from.date()
            path /= date_from.isoformat()
        else:
            # Default to yesterday, required if we have either a source or a number
            path /= (date.today() - timedelta(days=1)).isoformat()
        if source:
            path /= source
        if number is not None:
            path /= str(number)
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'vulnerability', path))))
        return r.json()

    def get_vendors(self) -> list[str]:
        '''Get the  known vendors'''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'vulnerability', 'browse'))))
        return r.json()

    def get_vendor_products(self, vendor: str) -> list[str]:
        '''Get the known products for a vendor

        :params vendor: A vendor owning products (must be in the known vendor list)
        '''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'browse', vendor))))
        return r.json()

    def get_vendor_product_vulnerabilities(self, vendor: str, product: str,
                                           *, since: date | datetime | None=None, page: int | None=None,
                                           per_page: int | None=None) -> dict[str, Any]:
        '''Get the the vulnerabilities per vendor and a specific product

        :param vendor: A vendor owning products (must be in the known vendor list)
        :param product: A product owned by that vendor
        :param since: The date from which to get vulnerabilities
        :param page: The page to get (default: 1)
        :param per_page: The number of vulnerabilities to get per page (default: 10)
        '''

        params: dict[str, Any] = {}
        if since:
            if isinstance(since, datetime):
                since = since.date()
            params['since'] = since.isoformat()

        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page

        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'vulnerability', 'search', vendor, product))), params=params)
        return r.json()

    def get_vendor_product_vulnerabilities_iter(self, vendor: str, product: str,
                                                *, since: date | datetime | None=None,
                                                with_source: bool=False) -> Generator[dict[str, list[Any]]]:
        '''Iterate over the vulnerabilities per vendor and a specific product

        :param vendor: A vendor owning products (must be in the known vendor list)
        :param product: A product owned by that vendor
        :param since: The date from which to get vulnerabilities
        :param with_source: if true, the source is appended at the end of the list
        '''
        page = 1
        per_page = 10
        while True:
            r = self.get_vendor_product_vulnerabilities(vendor, product, since=since, page=page, per_page=per_page)
            # The format in the response is a dict with the source as key,
            # that contains a list [[ID, vulnerability], ...]
            # we yield that last part appended with the source as a third element (if with_origin is true)
            if not any(r.values()):
                break
            for origin, vulnerabilities in r.items():
                if with_source:
                    for vulnerability in vulnerabilities:
                        vulnerability.append(origin)
                yield from vulnerabilities
            page += 1

    def get_vulnerabilities_by_cpe(self, cpe: str) -> dict[str, Any]:
        '''Get the vulnerabilities by their CPE

        :param cpe: The CPE of the vulnerabilities
        '''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'vulnerability', 'cpesearch', cpe))))
        return r.json()

    # #### Stats ####

    @overload
    def most_commented_vulnerabilities(self, date_from: date | datetime | None=None,
                                       date_to: date | datetime | None=None,
                                       limit: int | None=None, output: Literal['json']='json') -> dict[str, Any]:
        pass

    @overload
    def most_commented_vulnerabilities(self, date_from: date | datetime | None=None,
                                       date_to: date | datetime | None=None,
                                       limit: int | None=None, output: Literal['markdown']='markdown') -> str:
        pass

    def most_commented_vulnerabilities(self, date_from: date | datetime | None=None,
                                       date_to: date | datetime | None=None,
                                       limit: int | None=None, output: Literal['json', 'markdown']='json') -> dict[str, Any] | str:
        '''Get the most commented vulnerabilities

        :param date_from: The date from which to get the most commented vulnerabilities
        :param date_to: The date to which to get the most commented vulnerabilities
        :param limit: The number of vulnerabilities to get (default: 10)
        :param output: The output format, either 'json' or 'markdown'
        '''
        params: dict[str, Any] = {}
        if date_from:
            if isinstance(date_from, datetime):
                date_from = date_from.date()
            params['date_from'] = date_from.isoformat()
        if date_to:
            if isinstance(date_to, datetime):
                date_to = date_to.date()
            params['date_to'] = date_to.isoformat()
        if limit is not None:
            params['limit'] = limit
        if output is not None:
            if output not in ('json', 'markdown'):
                raise ValueError("output must be either 'json' or 'markdown'")
            params['output'] = output
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'stats', 'vulnerability', 'most_commented'))),
                             params=params)
        if output == 'markdown':
            return r.text
        elif output == 'json':
            return r.json()

    @overload
    def most_sighted_vulnerabilities(self, date_from: date | datetime | None=None,
                                     date_to: date | datetime | None=None,
                                     sighting_type: str | None=None,
                                     limit: int | None=None, output: Literal['json']='json') -> dict[str, Any]:
        pass

    @overload
    def most_sighted_vulnerabilities(self, date_from: date | datetime | None=None,
                                     date_to: date | datetime | None=None,
                                     sighting_type: str | None=None,
                                     limit: int | None=None, output: Literal['markdown']='markdown') -> str:
        pass

    def most_sighted_vulnerabilities(self, date_from: date | datetime | None=None,
                                     date_to: date | datetime | None=None,
                                     sighting_type: str | None=None,
                                     limit: int | None=None, output: Literal['json', 'markdown']='json') -> dict[str, Any] | str:
        '''Get the most sighted vulnerabilities

        :param date_from: The date from which to get the most sighted vulnerabilities
        :param date_to: The date to which to get the most sighted vulnerabilities
        :param sighting_type: The type of sighting to filter by (can be one of: 'seen', 'exploided', 'not-exploited', 'confirmed', 'not-confirmed', 'patched', 'not-patched')
        :param limit: The number of vulnerabilities to get (default: 10)
        :param output: The output format, either 'json' or 'markdown'
        '''
        params: dict[str, Any] = {}
        if date_from:
            if isinstance(date_from, datetime):
                date_from = date_from.date()
            params['date_from'] = date_from.isoformat()
        if date_to:
            if isinstance(date_to, datetime):
                date_to = date_to.date()
            params['date_to'] = date_to.isoformat()
        if sighting_type:
            params['sighting_type'] = sighting_type
        if limit is not None:
            params['limit'] = limit
        if output is not None:
            if output not in ('json', 'markdown'):
                raise ValueError("output must be either 'json' or 'markdown'")
            params['output'] = output
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'stats', 'vulnerability', 'most_sighted'))),
                             params=params)
        if output == 'markdown':
            return r.text
        elif output == 'json':
            return r.json()

    # #### Comments ####

    def create_comment(self, /, *, comment: dict[str, Any] | None=None, description: str | None=None,
                       description_format: str | None = None, meta: dict[str, str] | None = None,
                       related_vulnerabilities: list[str] | None=None, title: str | None=None,
                       uuid: str | None=None, vulnerability: str | None = None) -> dict[str, Any]:
        '''Create a comment.

        :param comment: The comment
        :param description: The description of the comment
        :param description_format: Description format (markdown or text).
        :param meta: Zero or more meta-fields.
        :param related_vulnerabilities: Zero or more related vulnerabilities.
        :param title: The title of the comment
        :param uuid: The UUID of the comment
        :param vulnerability: The vulnerability ID of the comment
        '''

        if not comment:
            comment = {}
            if description:
                comment['description'] = description
            if description_format:
                comment['description_format'] = description_format
            if meta:
                comment['meta'] = meta
            if related_vulnerabilities:
                comment['related_vulnerabilities'] = related_vulnerabilities
            if title:
                comment['title'] = title
            if uuid:
                comment['uuid'] = uuid
            if vulnerability:
                comment['vulnerability'] = vulnerability

        r = self.session.post(urljoin(self.root_url, str(PurePosixPath('api', 'comment'))), json=comment)
        return r.json()

    def get_comments(self, uuid: str | None = None, vuln_id: str | None = None,
                     author: str | None = None,
                     *, page: int | None=None, per_page: int | None=None) -> dict[str, Any]:
        '''Get comment(s)

        :param uuid: The UUID of a specific comment
        :param vuln_id: The vulnerability ID to get comments of
        :param author: The author of the comment(s)
        '''
        params: dict[str, Any] = {}
        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page
        if uuid:
            params['uuid'] = uuid
        if vuln_id:
            params['vuln_id'] = vuln_id
        if author:
            params['author'] = author
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'comment'))),
                             params=params)
        return r.json()

    def get_comments_iter(self, uuid: str | None = None, vuln_id: str | None = None,
                          author: str | None = None) -> Generator[dict[str, Any]]:
        '''Iterate over comments

        :param uuid: The UUID of a specific comment
        :param vuln_id: The vulnerability ID to get comments of
        :param author: The author of the comment(s)
        '''
        page = 1
        per_page = 1000
        while True:
            r = self.get_comments(uuid=uuid, vuln_id=vuln_id, author=author, page=page, per_page=per_page)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    def get_comment(self, comment_uuid: str) -> dict[str, Any]:
        '''Get a comment

        :param comment_uuid: The UUID of the comment
        '''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'comment', comment_uuid)))
                             )
        return r.json()

    def delete_comment(self, comment_uuid: str) -> int:
        '''Delete a comment.

        :param comment_uuid: The comment UUID
        '''
        r = self.session.delete(urljoin(self.root_url, str(PurePosixPath('api', 'comment', comment_uuid))))
        return r.status_code

    # #### Bundles ####

    def create_bundle(self, /, *, bundle: dict[str, Any] | None=None, description: str | None=None,
                      meta: dict[str, str] | None=None, name: str | None=None, related_vulnerabilities: list[str] | None=None,
                      uuid: str | None=None) -> dict[str, Any]:
        '''Create a bundle.

        :param bundle: The bundle
        '''

        if not bundle:
            bundle = {}
            if description:
                bundle['description'] = description
            if meta:
                bundle['meta'] = meta
            if name:
                bundle['name'] = name
            if related_vulnerabilities:
                bundle['related_vulnerabilities'] = related_vulnerabilities
            if uuid:
                bundle['uuid'] = uuid

        r = self.session.post(urljoin(self.root_url, str(PurePosixPath('api', 'bundle'))),
                              json=bundle)
        return r.json()

    def get_bundles(self, uuid: str | None = None, vuln_id: str | None = None,
                    author: str | None = None,
                    meta: list[dict[str, str]] | None=None,
                    *, page: int | None=None, per_page: int | None=None) -> dict[str, Any]:
        '''Get bundle(s)

        :param uuid: The UUID a specific bundle
        :param vuln_id: The vulnerability ID to get bundles of
        :param author: The author of the bundle(s)
        :param per_page: The number of bundles to get per page
        :param meta: Query for the meta JSON field. Example: meta=[{‘tags’: [‘tcp’]}]
        '''
        params: dict[str, Any] = {}
        if meta:
            params['meta'] = meta
        if page is not None:
            params['page'] = page
        if uuid:
            params['uuid'] = uuid
        if vuln_id:
            params['vuln_id'] = vuln_id
        if author:
            params['author'] = author
        if per_page is not None:
            params['per_page'] = per_page

        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'bundle'))), params=params)
        return r.json()

    def get_bundles_iter(self, uuid: str | None = None, vuln_id: str | None = None,
                         author: str | None = None) -> Generator[dict[str, Any]]:
        '''Iterate over bundles

        :param uuid: The UUID a specific bundle
        :param vuln_id: The vulnerability ID to get bundles of
        :param author: The author of the bundle(s)
        '''
        page = 1
        per_page = 1000
        while True:
            r = self.get_bundles(uuid=uuid, vuln_id=vuln_id, author=author, page=page, per_page=per_page)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    def get_bundle(self, bundle_uuid: str) -> dict[str, Any]:
        '''Get a bundle

        :param bundle_uuid: The UUID of the bundle
        '''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'bundle', bundle_uuid))))
        return r.json()

    def delete_bundle(self, bundle_uuid: str) -> int:
        '''Delete a bundle.

        :param bundle_uuid: The bundle UUID
        '''
        r = self.session.delete(urljoin(self.root_url, str(PurePosixPath('api', 'bundle', bundle_uuid))))
        return r.status_code

    # #### Users ####

    def create_user(self, /, *, user: dict[str, Any] | None=None,
                    login: str | None=None, name: str | None=None,
                    organisation: str | None=None, email: str | None=None) -> dict[str, Any]:
        '''Create a user.

        :param login: The login of the user
        :param name: The name of the user
        :param organisation: The organisation of the user
        :param email: The email of the user
        '''

        if not user:
            user = {}
            if login:
                user['login'] = login
            if name:
                user['name'] = name
            if organisation:
                user['organisation'] = organisation
            if email:
                user['email'] = email

        r = self.session.post(urljoin(self.root_url, str(PurePosixPath('api', 'user'))), json=user)
        try:
            r.raise_for_status()
        except requests.exceptions.HTTPError as e:
            if r.status_code == 400:
                # If creating the user fails, the instance returns a 400 with a content explaining what happened.
                return r.json()
            raise e
        return r.json()

    def list_users(self) -> Generator[dict[str, Any]]:
        return self.get_users_iter()

    def get_users(self, *, page: int | None=None, per_page: int | None=None) -> dict[str, Any]:
        '''List users

        :param page: The page to get (default: 1)
        :param per_page: The number of users to get per page (default: 100)
        '''

        params: dict[str, Any] = {}
        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'user'))), params=params)
        try:
            r.raise_for_status()
        except requests.exceptions.HTTPError as e:
            if r.status_code == 400:
                # If creating the user fails, the instance returns a 400 with a content explaining what happened.
                return r.json()
            raise e
        return r.json()

    def get_users_iter(self) -> Generator[dict[str, Any]]:
        '''Iterate over users'''
        page = 1
        per_page = 20
        while True:
            r = self.get_users(page=page, per_page=per_page)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    def get_user_information(self) -> dict[str, Any]:
        '''Get user information'''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'user', 'me'))))
        try:
            r.raise_for_status()
        except requests.exceptions.HTTPError as e:
            if r.status_code == 400:
                # If creating the user fails, the instance returns a 400 with a content explaining what happened.
                return r.json()
            raise e
        return r.json()

    def reset_api_key(self) -> dict[str, Any]:
        '''Reset the API key'''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'user', 'api_key'))))
        try:
            r.raise_for_status()
        except requests.exceptions.HTTPError as e:
            if r.status_code == 400:
                # If creating the user fails, the instance returns a 400 with a content explaining what happened.
                return r.json()
            raise e
        return r.json()

    def delete_user(self, user_id: str) -> int:
        '''Delete a user.

        :param user_id: The user ID
        '''
        r = self.session.delete(urljoin(self.root_url, str(PurePosixPath('api', 'user', user_id))))
        try:
            r.raise_for_status()
        except requests.exceptions.HTTPError as e:
            if r.status_code == 400:
                # If creating the user fails, the instance returns a 400 with a content explaining what happened.
                return r.json()
            raise e
        return r.status_code

    # #### Sightings ####

    def get_sighting(self, sighting_uuid: str) -> dict[str, Any]:
        '''Get a sighting

        :param sighting_uuid: The UUID of the sighting
        '''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'sighting', sighting_uuid))))
        return r.json()

    def get_sightings(self, /, *, page: int | None = None, per_page: int | None = None,
                      sighting_uuid: str | None=None,
                      sighting_type: str | None=None, vuln_id: str | None = None,
                      author: str | None = None,
                      date_from: date | datetime | None=None,
                      date_to: date | datetime | None=None,
                      source: str | None=None) -> dict[str, Any]:
        '''Get sightings

        :param page: The page to get (default: 1)
        :param per_page: The number of sightings to get per page (default: 100)
        :param sighting_uuid: The UUID of a specific sighting
        :param sighting_type: The type of sighting, can be one of: 'seen', 'exploided', 'not-exploited', 'confirmed', 'not-confirmed', 'patched', 'not-patched'.
        :param vuln_id: The vulnerability ID to get sightings of
        :param author: The author of the sighting(s)
        :param date_from: The date from which to get sightings
        :param date_to: The date to which to get sightings
        :param source: The source of the sighting
        '''

        params: dict[str, Any] = {}
        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page
        if sighting_uuid:
            params['uuid'] = sighting_uuid
        if sighting_type:
            params['type'] = sighting_type
        if vuln_id:
            params['vuln_id'] = vuln_id
        if author:
            params['author'] = author
        if date_from:
            if isinstance(date_from, datetime):
                date_from = date_from.date()
            params['date_from'] = date_from.isoformat()
        if date_to:
            if isinstance(date_to, datetime):
                date_to = date_to.date()
            params['date_to'] = date_to.isoformat()
        if source:
            params['source'] = source

        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'sighting'))), params=params)
        return r.json()

    def get_sightings_iter(self, /, *, sighting_uuid: str | None=None,
                           sighting_type: str | None=None, vuln_id: str | None = None,
                           author: str | None = None,
                           date_from: date | datetime | None=None,
                           date_to: date | datetime | None=None,
                           source: str | None=None) -> Generator[dict[str, Any]]:

        '''Iterate over sightings

        :param sighting_uuid: The UUID of a specific sighting
        :param sighting_type: The type of sighting, can be one of: 'seen', 'exploided', 'not-exploited', 'confirmed', 'not-confirmed', 'patched', 'not-patched'.
        :param vuln_id: The vulnerability ID to get sightings of
        :param author: The author of the sighting(s)
        :param date_from: The date from which to get sightings
        :param date_to: The date to which to get sightings
        :param source: The source of the sighting
        '''
        page = 1
        per_page = 1000
        while True:
            r = self.get_sightings(page=page, per_page=per_page, sighting_uuid=sighting_uuid,
                                   sighting_type=sighting_type, vuln_id=vuln_id, author=author,
                                   date_from=date_from, date_to=date_to, source=source)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    def create_sighting(self, /, *, sighting: dict[str, Any] | None=None,
                        creation_timestamp: datetime | None=None,
                        source: str | None = None,
                        sighting_type: str | None=None,
                        vulnerability: str | None=None) -> dict[str, Any]:
        '''Create a sighting.

        :param sighting: The sighting, as an object.
        :param creation_timestamp: The timestamp of the sighting - set to now if not provided
        :param source: The source of the sighting
        :param sighting_type: The type of sighting, can be one of: 'seen', 'exploided', 'not-exploited', 'confirmed', 'not-confirmed', 'patched', 'not-patched'.
        :param vulnerability: The vulnerability ID of the sighting
        '''
        if not sighting:
            sighting = {}
            if creation_timestamp:
                # This calue may or may not have a TZ at this point
                sighting['creation_timestamp'] = creation_timestamp
            if source:
                sighting['source'] = source
            if sighting_type:
                sighting['type'] = sighting_type
            if vulnerability:
                sighting['vulnerability'] = vulnerability

        if 'creation_timestamp' in sighting:
            # check if the datetime object has a TZ, if it doesn't, set it to localtime, make it a string
            if sighting['creation_timestamp'].tzinfo is None:
                sighting['creation_timestamp'] = sighting['creation_timestamp'].astimezone()
            sighting['creation_timestamp'] = sighting['creation_timestamp'].isoformat()

        r = self.session.post(urljoin(self.root_url, str(PurePosixPath('api', 'sighting'))),
                              json=sighting)
        return r.json()

    # #### EPSS ####

    def get_epss(self, vulnerability: str) -> dict[str, Any]:
        '''Get the EPSS for a vulnerability

        :param vulnerability: The vulnerability ID
        '''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'epss', vulnerability))))
        return r.json()

    # #### CWE ####

    def get_cwes(self, *, page: int | None=None, per_page: int | None=None) -> dict[str, Any]:
        '''Get the list of CWEs

        :param page: The page to get (default: 1)
        :param per_page: The number of results per page (default: 100)
        '''
        params: dict[str, Any] = {}
        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'cwe'))), params=params)
        return r.json()

    def get_cwes_iter(self) -> Generator[dict[str, Any]]:
        '''Iterate over the CWEs'''
        page = 1
        per_page = 20
        while True:
            r = self.get_cwes(page=page, per_page=per_page)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    def get_cwe(self, cwe_id: str) -> dict[str, Any]:
        '''Get a CWE

        :param cwe_id: The CWE ID
        '''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'cwe', cwe_id))))
        return r.json()

    # #### CAPEC ####

    def get_capecs(self, *, page: int | None=None, per_page: int | None=None) -> dict[str, Any]:
        '''Get the list of CAPECs

        :param page: The page to get (default: 1)
        :param per_page: The number of results per page (default: 100)
        '''
        params: dict[str, Any] = {}
        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'capec'))), params=params)
        return r.json()

    def get_capecs_iter(self) -> Generator[dict[str, Any]]:
        '''Iterate over the CAPECs'''
        page = 1
        per_page = 20
        while True:
            r = self.get_capecs(page=page, per_page=per_page)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    def get_capec(self, capec_id: str) -> dict[str, Any]:
        '''Get a CAPEC

        :param capec_id: The CAPEC ID
        '''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'capec', capec_id))))
        return r.json()

    # #### Organization ####

    def get_organizations(self, organization_id: int | None=None,
                          uuid: str | None=None, name: str | None=None, gna_id: int | None=None,
                          *, page: int | None=None, per_page: int | None=None) -> dict[str, Any]:
        '''Get the list of organizations

        :param page: The page to get (default: 1)
        :param per_page: The number of results per page (default: 1000)
        :param organization_id: The ID of the organization to get (default: None)
        :param uuid: The UUID of the organization to get (default: None)
        :param name: The name of the organization to get (default: None)
        :param gna_id: The GNA ID of the organization to get (default: None)
        '''
        params: dict[str, Any] = {}
        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page
        if organization_id:
            params['organization_id'] = organization_id
        if uuid:
            params['uuid'] = uuid
        if name:
            params['name'] = name
        if gna_id:
            params['gna_id'] = gna_id
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'organization'))), params=params)
        return r.json()

    def get_organizations_iter(self, organization_id: int | None=None, uuid: str | None=None,
                               name: str | None=None, gna_id: int | None=None) -> Generator[dict[str, Any]]:
        '''Iterate over the organizations

        :param organization_id: The ID of the organization to get (default: None)
        :param uuid: The UUID of the organization to get (default: None)
        :param name: The name of the organization to get (default: None)
        :param gna_id: The GNA ID of the organization to get (default: None)
        '''
        page = 1
        per_page = 20
        while True:
            r = self.get_organizations(page=page, per_page=per_page, organization_id=organization_id,
                                       uuid=uuid, name=name, gna_id=gna_id)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    # #### Product ####

    def get_products(self, name: str | None=None, organization_name: str | None=None,
                     organization_id: str | None=None, organization_uuid: str | None=None,
                     *, page: int | None=None, per_page: int | None=None, uuid: str | None=None) -> dict[str, Any]:
        '''Get the list of products

        :param page: The page to get (default: 1)
        :param per_page: The number of results per page (default: 1000)
        :param uuid: The UUID of the product to get (default: None)
        :param name: The name of the product to get (default: None)
        :param organization_name: The name of the organization related to the product (default: None)
        :param organization_id: The ID of the organization related to the product (default: None)
        :param organization_uuid: The UUID of the organization related to the product (default: None)
        '''
        params: dict[str, Any] = {}
        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page
        if uuid:
            params['uuid'] = uuid
        if name:
            params['name'] = name
        if organization_name:
            params['organization_name'] = organization_name
        if organization_id:
            params['organization_id'] = organization_id
        if organization_uuid:
            params['organization_uuid'] = organization_uuid
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'product'))), params=params)
        return r.json()

    def get_products_iter(self, uuid: str | None=None, name: str | None=None,
                          organization_name: str | None=None,
                          organization_id: str | None=None, organization_uuid: str | None=None) -> Generator[dict[str, Any]]:
        '''Iterate over the products

        :param uuid: The UUID of the product to get (default: None)
        :param name: The name of the product to get (default: None)
        :param organization_name: The name of the organization related to the product (default: None)
        :param organization_id: The ID of the organization related to the product (default: None)
        :param organization_uuid: The UUID of the organization related to the product (default: None)
        '''
        page = 1
        per_page = 20
        while True:
            r = self.get_products(page=page, per_page=per_page, uuid=uuid, name=name,
                                  organization_name=organization_name,
                                  organization_id=organization_id,
                                  organization_uuid=organization_uuid)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    # #### emb3d ####

    def get_emb3ds(self, vuln_id: str | None=None, *, page: int | None=None, per_page: int | None=None) -> dict[str, Any]:
        '''Get the list of all emb3d vulnerabilities

        :param page: The page to get (default: 1)
        :param per_page: The number of results per page (default: 100)
        :param vuln_id: The vulnerability ID to filter by (default: None)
        '''
        params: dict[str, Any] = {}
        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page
        if vuln_id:
            params['vuln_id'] = vuln_id
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'emb3d'))), params=params)
        return r.json()

    def get_emb3ds_iter(self, vuln_id: str | None=None) -> Generator[dict[str, Any]]:
        '''Iterate over the emb3d vulnerabilities.

        :param vuln_id: The vulnerability ID to filter by (default: None)
        '''
        page = 1
        per_page = 20
        while True:
            r = self.get_emb3ds(page=page, per_page=per_page, vuln_id=vuln_id)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    def get_emb3d(self, emb3d_id: str) -> dict[str, Any]:
        '''Get an emb3d vulnerability

        :param emb3d_id: The emb3d ID
        '''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'emb3d', emb3d_id))))
        return r.json()

    # #### CISA KEV ####

    def get_cisa_kevs(self, *, page: int | None=None, per_page: int | None=None) -> dict[str, Any]:
        '''Get the list of all CISA KEV

        :param page: The page to get (default: 1)
        :param per_page: The number of results per page (default: 100)
        '''
        params: dict[str, Any] = {}
        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'cisa_kev'))), params=params)
        return r.json()

    def get_cisa_kevs_iter(self) -> Generator[dict[str, Any]]:
        '''Iterate over the CISA KEV list.
        '''
        page = 1
        per_page = 20
        while True:
            r = self.get_cisa_kevs(page=page, per_page=per_page)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    # #### GCVE ####

    def get_gcves(self, short_name: str | None=None, *, page: int | None=None, per_page: int | None=None) -> dict[str, Any]:
        '''List the GNAs from the GCVE registry of the Vulnerability-Lookup instance. The response is paginated.

        :param page: The page to get (default: 1)
        :param per_page: The number of results per page (default: 100)
        :param short_name: The short name of the GNA to filter by (default: None)
        '''

        params: dict[str, Any] = {}
        if page is not None:
            params['page'] = page
        if per_page is not None:
            params['per_page'] = per_page
        if short_name:
            params['short_name'] = short_name
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'gcve', 'registry'))), params=params)
        return r.json()

    def get_gcves_iter(self, short_name: str | None = None) -> Generator[dict[str, Any]]:
        '''Iterate over the GNAs from the GCVE registry of the Vulnerability-Lookup instance.

        :param short_name: The short name of the GNA to filter by (default: None)
        '''
        page = 1
        per_page = 20
        while True:
            r = self.get_gcves(page=page, per_page=per_page, short_name=short_name)
            if not r['data']:
                break
            yield from r['data']
            page += 1

    def get_gcve_registry_integrity(self) -> bool:
        '''Check the integrity of the GCVE registry'''
        r = self.session.get(urljoin(self.root_url, str(PurePosixPath('api', 'gcve', 'registry', 'integrity'))))
        return r.json()

    # #### VLAI ####

    def get_vlai_severity_classification(self, description: str) -> dict[str, Any]:
        '''Involves a classification model aimed to assist in classifying vulnerabilities by severity based on their descriptions.

        :param description: The description of the vulnerability to classify

        '''
        r = self.session.post(urljoin(self.root_url, str(PurePosixPath('api', 'vlai', 'severity-classification'))),
                              json={'description': description})
        return r.json()
