import matplotlib.pyplot as plt
import numpy as np


def visualize_protocol_workflow(sender_bases, receiver_bases, sender_bits, receiver_results):
    """
    Visualize the workflow of the BB84 protocol, including the bases and bit values.

    :param sender_bases: List of bases used by the sender ('X' or 'Z').
    :param receiver_bases: List of bases used by the receiver ('X' or 'Z').
    :param sender_bits: List of bits prepared by the sender (0 or 1).
    :param receiver_results: List of bits measured by the receiver (0 or 1).
    """
    fig, ax = plt.subplots(figsize=(10, 5))
    x = range(len(sender_bits))
    
    # Plot sender and receiver bits
    ax.plot(x, sender_bits, 'bo-', label='Sender Bits')
    ax.plot(x, receiver_results, 'ro-', label='Receiver Results')
    
    # Annotate bases comparison
    for i in range(len(sender_bases)):
        ax.text(i, 0.5, f"{sender_bases[i]}/{receiver_bases[i]}", 
                ha='center', va='bottom', fontsize=9, color='green' if sender_bases[i] == receiver_bases[i] else 'red')
    
    ax.set_title('BB84 Protocol Visualization')
    ax.set_xlabel('Bit Index')
    ax.set_ylabel('Bit Value (0 or 1)')
    ax.legend()
    plt.grid(alpha=0.5)
    plt.show()


def visualize_noise_impact(original_key, noisy_key):
    """
    Visualize the impact of noise by showing differences between the original and noisy keys.

    :param original_key: Original key generated by the sender.
    :param noisy_key: Key received by the receiver after noise is applied.
    """
    differences = [1 if o != n else 0 for o, n in zip(original_key, noisy_key)]
    fig, ax = plt.subplots(figsize=(10, 5))
    
    ax.bar(range(len(original_key)), differences, color='red', alpha=0.6, label='Errors')
    ax.set_title('Noise Impact on BB84 Key')
    ax.set_xlabel('Bit Index')
    ax.set_ylabel('Error (1 = Error)')
    ax.legend()
    plt.grid(alpha=0.5)
    plt.show()


def visualize_key_sifting(sender_bases, receiver_bases, sifted_indices):
    """
    Visualize the key sifting process, showing which bits were retained based on matching bases.

    :param sender_bases: List of bases used by the sender ('X' or 'Z').
    :param receiver_bases: List of bases used by the receiver ('X' or 'Z').
    :param sifted_indices: Indices of bits that were retained after sifting.
    """
    x = range(len(sender_bases))
    fig, ax = plt.subplots(figsize=(10, 5))
    
    # Plot bases
    ax.plot(x, sender_bases, 'bo-', label='Sender Bases')
    ax.plot(x, receiver_bases, 'ro-', label='Receiver Bases')
    
    # Highlight sifted bits
    ax.scatter(sifted_indices, [0] * len(sifted_indices), c='green', s=50, label='Sifted Bits')
    
    ax.set_title('Key Sifting Visualization')
    ax.set_xlabel('Bit Index')
    ax.set_ylabel('Basis (X or Z)')
    ax.legend()
    plt.grid(alpha=0.5)
    plt.show()


def plot_qber_variation(qber_values):
    """
    Plots the Quantum Bit Error Rate (QBER) over time.
    """
    plt.figure(figsize=(10, 5))
    plt.plot(qber_values, marker='o', linestyle='-', color='b', label="QBER")
    plt.xlabel("Key Exchange Iteration")
    plt.ylabel("QBER (%)")
    plt.title("Quantum Bit Error Rate Over Time")
    plt.legend()
    plt.grid()
    plt.show()
