{
  "title": "LString",
  "level": "Low",
  "elements": [
    {
      "pattern": "",
      "module": "LString",
      "name": "t",
      "type": "type",
      "signature": "type t = LChar.t list",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Creating an empty logic-mode string",
      "module": "LString",
      "name": "empty",
      "type": "value",
      "signature": "val empty : t",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Creating a logic-mode string from a list of 8-bit logic-mode characters",
      "module": "LString",
      "name": "of_list",
      "type": "function",
      "signature": "val of_list : LChar.t list -> t",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Converting a logic-mode string to a OCaml string",
      "module": "LString",
      "name": "to_string",
      "type": "function",
      "signature": "val to_string : t -> string",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Creating a logic-mode string from a OCaml string",
      "module": "LString",
      "name": "of_string",
      "type": "function",
      "signature": "val of_string : string -> LChar.t list",
      "description": "",
      "examples": []
    },

    {
      "pattern": "Getting the length of a logic-mode string",
      "module": "LString",
      "name": "length",
      "type": "function",
      "signature": "val length : t -> Z.t",
      "description": "",
      "examples": []
    },

    {
      "pattern": "Axiom: The length of a logic-mode string is always non-negative",
      "module": "LString",
      "name": "len_pos",
      "type": "function",
      "signature": "val len_pos : t -> bool",
      "description": "",
      "examples": [],
      "tags": ["theorem"]
    },
    {
      "pattern": "Axiom: The length of a logic-mode string is zero if and only if the string is empty",
      "module": "LString",
      "name": "len_zero_inversion",
      "type": "function",
      "signature": "val len_zero_inversion : t -> bool",
      "description": "",
      "examples": [],
      "tags": ["theorem"]
    },
    {
      "pattern": "Appending two logic-mode strings",
      "module": "LString",
      "name": "append",
      "type": "function",
      "signature": "val append : t -> t -> t",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Infix operator for appending two logic-mode strings",
      "module": "LString",
      "name": "( ^^ )",
      "type": "function",
      "signature": "val (^^) : t -> t -> t",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Checking if all characters in a logic-mode string satisfy a given predicate",
      "module": "LString",
      "name": "for_all",
      "type": "function",
      "signature": "val for_all : ( LChar.t -> bool ) -> t -> bool",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Checking if there exists a character in a logic-mode string that satisfies a given predicate",
      "module": "LString",
      "name": "exists",
      "type": "function",
      "signature": "val exists : ( LChar.t -> bool ) -> t -> bool",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Concatenating a list of logic-mode strings",
      "module": "LString",
      "name": "concat",
      "type": "function",
      "signature": "val concat : t -> LChar.t list list -> LChar.t list",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Checking if a logic-mode string is printable",
      "module": "LString",
      "name": "is_printable",
      "type": "function",
      "signature": "val is_printable : t -> bool",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Extracting a substring from a logic-mode string by specifying the start index and the length",
      "module": "LString",
      "name": "sub",
      "type": "function",
      "signature": "val sub : t -> int -> int -> t",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Checking if a logic-mode string is a prefix of another logic-mode string",
      "module": "LString",
      "name": "prefix",
      "type": "function",
      "signature": "val prefix : t -> t -> bool",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Checking if a logic-mode string is a suffix of another logic-mode string",
      "module": "LString",
      "name": "suffix",
      "type": "function",
      "signature": "val suffix : t -> t -> bool",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Checking if a logic-mode string contains another logic-mode string as a substring",
      "module": "LString",
      "name": "contains",
      "type": "function",
      "signature": "val contains : sub:t -> t -> bool",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Taking the first n characters from a logic-mode string",
      "module": "LString",
      "name": "take",
      "type": "function",
      "signature": "val take : int -> t -> t",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Dropping the first n characters from a logic-mode string",
      "module": "LString",
      "name": "drop",
      "type": "function",
      "signature": "val drop : int -> t -> t",
      "description": "",
      "examples": []
    }
  ],
  "metadata": {
    "signatures": [
      "type t = LChar.t list",
      "val empty : t",
      "val of_list : 'a -> 'a",
      "val to_string : t -> string",
      "val of_string : string -> LChar.t list",
      "val length : t -> Z.t",
      "val pp : Stdlib.Format.formatter -> LChar.t list -> unit",
      "val len_pos : t -> bool",
      "val len_zero_inversion : t -> bool",
      "val append : t -> t -> t",
      "val (^^) : t -> t -> t",
      "val for_all : ( LChar.t -> bool ) -> t -> bool",
      "val exists : ( LChar.t -> bool ) -> t -> bool",
      "val concat : t -> LChar.t list list -> LChar.t list",
      "val is_printable : t -> bool",
      "val sub : t -> int -> int -> t",
      "val prefix : t -> t -> bool",
      "val suffix : t -> t -> bool",
      "val contains : sub:t -> t -> bool",
      "val take : int -> t -> t",
      "val drop : int -> t -> t"
    ],
    "source": "https://docs.imandra.ai/imandra-docs/odoc/imandra-base/Imandra_prelude/LString/index.html",
    "description": "Logic-mode string. Strings purely in Imandra."
  }
}