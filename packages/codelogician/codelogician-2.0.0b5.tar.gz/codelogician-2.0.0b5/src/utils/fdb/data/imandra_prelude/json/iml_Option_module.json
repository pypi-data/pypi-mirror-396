{
  "title": "Option",
  "level": "Low",
  "elements": [
    {
      "pattern": "",
      "module": "Option",
      "name": "t",
      "type": "type",
      "signature": "type 'a t = 'a option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Wrap a value in an optional container (monad)",
      "module": "Option",
      "name": "return",
      "type": "val",
      "signature": "val return : 'a -> 'a option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Check if the optional contains a value",
      "module": "Option",
      "name": "is_some",
      "type": "val",
      "signature": "val is_some : 'a option -> bool",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Check if the optional does not contain a value",
      "module": "Option",
      "name": "is_none",
      "type": "val",
      "signature": "val is_none : 'a option -> bool",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Get the value from the optional",
      "module": "Option",
      "name": "get_or",
      "type": "val",
      "signature": "val get_or : default:'a -> 'a option -> 'a",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Applies a function within the context of the Option monad, preserving the possibility of absence (None).",
      "module": "Option",
      "name": "map",
      "type": "val",
      "signature": "val map : ( 'a -> 'b ) -> 'a option -> 'b option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Infix operator for applying a function within the context of the Option monad, preserving the possibility of absence (None).",
      "module": "Option",
      "name": "<$>",
      "type": "val",
      "signature": "val (<$>) : ( 'a -> 'b ) -> 'a option -> 'b option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Infix operator for applying a function within the context of the Option monad, preserving the possibility of absence (None).",
      "module": "Option",
      "name": ">|=",
      "type": "val",
      "signature": "val (>|=) : 'a option -> ( 'a -> 'b ) -> 'b option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Transforms an optional value or returns a default, providing a functional way to handle potential failures.",
      "module": "Option",
      "name": "map_or",
      "type": "val",
      "signature": "val map_or : default:'a -> ( 'b -> 'a ) -> 'b option -> 'a",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Monadic bind operation, allowing for composition of computations that may fail.",
      "module": "Option",
      "name": "flat_map",
      "type": "val",
      "signature": "val flat_map : ( 'a -> 'b option ) -> 'a option -> 'b option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Infix operator for monadic bind, enabling expressive chaining of failable computations.",
      "module": "Option",
      "name": ">>=",
      "type": "val",
      "signature": "val (>>=) : 'a option -> ( 'a -> 'b option ) -> 'b option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Provides an alternative optional if the first is empty, facilitating fallback mechanisms in error handling.",
      "module": "Option",
      "name": "or_",
      "type": "val",
      "signature": "val or_ : else_:'a option -> 'a option -> 'a option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Infix operator for combining two optional values, returning the first if both are present, otherwise the second.",
      "module": "Option",
      "name": "<+>",
      "type": "val",
      "signature": "val (<+>) : 'a option -> 'a option -> 'a option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Checks if a predicate holds for the optional value, providing a concise way to perform conditional checks.",
      "module": "Option",
      "name": "exists",
      "type": "val",
      "signature": "val exists : ( 'a -> bool ) -> 'a option -> bool",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Verifies a predicate for an optional value, treating None as vacuously true.",
      "module": "Option",
      "name": "for_all",
      "type": "val",
      "signature": "val for_all : ( 'a -> bool ) -> 'a option -> bool",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Applies a function to an accumulator and an optional value, allowing reduction operations that gracefully handle absence.",
      "module": "Option",
      "name": "fold",
      "type": "val",
      "signature": "val fold : ( 'a -> 'b -> 'a ) -> 'a -> 'b option -> 'a",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Combines two optionals into a paired optional, embodying the concept of synchronized success or failure.",
      "module": "Option",
      "name": "monoid_product",
      "type": "val",
      "signature": "val monoid_product : 'a option -> 'b option -> ('a * 'b) option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Syntactic sugar for monadic mapping, enabling more readable composition of optional computations.",
      "module": "Option",
      "name": "let+",
      "type": "val",
      "signature": "val let+ : 'a option -> ( 'a -> 'b ) -> 'b option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Combines two optionals into a paired optional, representing the applicative nature of the Option monad.",
      "module": "Option",
      "name": "and+",
      "type": "val",
      "signature": "val and+ : 'a option -> 'b option -> ('a * 'b) option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Syntactic sugar for monadic binding, enabling more readable composition of optional computations.",
      "module": "Option",
      "name": "let*",
      "type": "val",
      "signature": "val let* : 'a option -> ( 'a -> 'b option ) -> 'b option",
      "description": "",
      "examples": []
    },
    {
      "pattern": "Combines two optionals into a paired optional, used in monadic expressions to synchronize multiple failable computations.",
      "module": "Option",
      "name": "and*",
      "type": "val",
      "signature": "val and* : 'a option -> 'b option -> ('a * 'b) option",
      "description": "",
      "examples": []
    }
  ],
  "metadata": {
    "signatures": [
      "type 'a t = 'a option",
      "val return : 'a -> 'a option",
      "val is_some : 'a option -> bool",
      "val is_none : 'a option -> bool",
      "val get_or : default:'a -> 'a option -> 'a",
      "val map : ( 'a -> 'b ) -> 'a option -> 'b option",
      "val (<$>) : ( 'a -> 'b ) -> 'a option -> 'b option",
      "val (>|=) : 'a option -> ( 'a -> 'b ) -> 'b option",
      "val map_or : default:'a -> ( 'b -> 'a ) -> 'b option -> 'a",
      "val flat_map : ( 'a -> 'b option ) -> 'a option -> 'b option",
      "val (>>=) : 'a option -> ( 'a -> 'b option ) -> 'b option",
      "val or_ : else_:'a option -> 'a option -> 'a option",
      "val (<+>) : 'a option -> 'a option -> 'a option",
      "val exists : ( 'a -> bool ) -> 'a option -> bool",
      "val for_all : ( 'a -> bool ) -> 'a option -> bool",
      "val fold : ( 'a -> 'b -> 'a ) -> 'a -> 'b option -> 'a",
      "val monoid_product : 'a option -> 'b option -> ('a * 'b) option",
      "val let+ : 'a option -> ( 'a -> 'b ) -> 'b option",
      "val and+ : 'a option -> 'b option -> ('a * 'b) option",
      "val let* : 'a option -> ( 'a -> 'b option ) -> 'b option",
      "val and* : 'a option -> 'b option -> ('a * 'b) option"
    ],
    "source": "https://docs.imandra.ai/imandra-docs/odoc/imandra-base/Imandra_prelude/Set/index.html"
  }
}