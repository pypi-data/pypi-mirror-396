{"steps":[{"command":{"type":"init_state","src_code":"\"\"\"Advanced mathematical operations - Level 2 (depends on core.arithmetic)\"\"\"\n\nfrom .arithmetic import add, divide, multiply, subtract\nfrom .comparison import absolute_value\n\n\ndef square_root(x: float) -> float:\n    \"\"\"Calculate square root using Newton's method.\"\"\"\n    if x < 0:\n        raise ValueError(\"Square root not defined for negative numbers\")\n    if x == 0:\n        return 0.0\n\n    guess = divide(x, 2.0)\n\n    for _ in range(20):  # Simple iteration limit\n        new_guess = divide(add(guess, divide(x, guess)), 2.0)\n        if absolute_value(subtract(new_guess, guess)) < 1e-10:\n            break\n        guess = new_guess\n\n    return new_guess\n\n\ndef factorial(n: int) -> int:\n    \"\"\"Calculate factorial of n.\"\"\"\n    if n < 0:\n        raise ValueError(\"Factorial not defined for negative numbers\")\n    if n == 0 or n == 1:\n        return 1\n\n    result = 1\n    for i in range(2, n + 1):\n        result = int(multiply(result, i))\n    return result\n\n\ndef is_even(n: int) -> bool:\n    \"\"\"Check if number is even.\"\"\"\n    return n % 2 == 0\n\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if number is prime.\"\"\"\n    if n < 2:\n        return False\n    return all(n % i != 0 for i in range(2, int(square_root(n)) + 1))\n","src_lang":"Python"},"message":null,"task":null},{"command":{"type":"inject_formalization_context","context":"Do not use `[@@measure ...]` annotations on nested functions (closures). If a function needs a `[@@measure ...]` annotation, structure the code so that the nested function is moved to the top-level.\n\nWhen writing a recursive function where the recursion is controlled by an integer argument, put that integer argument as the first argument. Also try to arrange for the integer argument to count down to zero."},"message":null,"task":null},{"command":{"type":"edit_state_element","update":{"dependency":[{"src_module":{"name":"core/arithmetic.py","relative_path":"core/arithmetic.py","content":"\"\"\"Basic arithmetic operations - Level 1 (no dependencies)\"\"\"\n\n\ndef add(a: float, b: float) -> float:\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\n\ndef subtract(a: float, b: float) -> float:\n    \"\"\"Subtract b from a.\"\"\"\n    return a - b\n\n\ndef multiply(a: float, b: float) -> float:\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n\n\ndef divide(a: float, b: float) -> float:\n    \"\"\"Divide a by b.\"\"\"\n    if b == 0:\n        raise ValueError(\"Division by zero\")\n    return a / b\n\n\ndef power(base: float, exponent: float) -> float:\n    \"\"\"Raise base to the power of exponent.\"\"\"\n    return base**exponent\n","src_lang":"Python"},"iml_module":{"name":"Core_arithmetic","relative_path":"core/arithmetic.py","content":"(* Basic arithmetic operations - Level 1 (no dependencies) *)\n\nlet add (a : real) (b : real) : real =\n  (* Add two numbers. *)\n  a +. b\n\nlet subtract (a : real) (b : real) : real =\n  (* Subtract b from a. *)\n  a -. b\n\nlet multiply (a : real) (b : real) : real =\n  (* Multiply two numbers. *)\n  a *. b\n\nlet divide (a : real) (b : real) : real option =\n  (* Divide a by b. *)\n  if b = 0.0 then\n    None\n  else\n    Some (a /. b)\n\nlet power : real -> real -> real = () [@@opaque]\n(* Raise base to the power of exponent. *)","src_lang":"IML"}},{"src_module":{"name":"core/comparison.py","relative_path":"core/comparison.py","content":"\"\"\"Comparison and utility operations - Level 1 (no dependencies)\"\"\"\n\n\n# decompose the function maximum(a, b)\ndef maximum(a: float, b: float) -> float:\n    \"\"\"Return the maximum of two numbers.\"\"\"\n    return a if a > b else b\n\n\n# decompose the function minimum(a, b)\ndef minimum(a: float, b: float) -> float:\n    \"\"\"Return the minimum of two numbers.\"\"\"\n    return a if a < b else b\n\n\n# decompose the function absolute_value(x)\ndef absolute_value(x: float) -> float:\n    \"\"\"Return absolute value of x.\"\"\"\n    return x if x >= 0 else -x\n\n\n# decompose the function sign(x)\ndef sign(x: float) -> int:\n    \"\"\"Return sign of x (-1, 0, or 1).\"\"\"\n    if x > 0:\n        return 1\n    elif x < 0:\n        return -1\n    else:\n        return 0\n","src_lang":"Python"},"iml_module":{"name":"Core_comparison","relative_path":"core/comparison.py","content":"let maximum (a : real) (b : real) : real =\n  if a >. b then a else b\n[@@decomp top ~prune:true ~ctx_simp:true ()]\nlet minimum (a : real) (b : real) : real =\n  if a <. b then a else b\n[@@decomp top ~prune:true ~ctx_simp:true ()]\nlet absolute_value (x : real) : real =\n  if x >=. 0.0 then x else Real.(~-) x\n[@@decomp top ~prune:true ~ctx_simp:true ()]\nlet sign (x : real) : int =\n  if x >. 0.0 then\n    1\n  else if x <. 0.0 then\n    -1\n  else\n    0\n[@@decomp top ~prune:true ~ctx_simp:true ()]","src_lang":"IML"}}]}},"message":null,"task":null},{"command":{"type":"agent_formalizer","no_check_formalization_hitl":false,"no_refactor":false,"no_gen_model_hitl":true,"max_tries_wo_hitl":3,"max_tries":3},"message":null,"task":null},{"command":{"type":"gen_vgs","description":null},"message":null,"task":null},{"command":{"type":"gen_region_decomps","function_name":null},"message":null,"task":null}],"step_i":null,"info":{}}