#!/usr/bin/env Rscript
# Fit mgcv GAM using exact test data from Python

library(mgcv)

cat(strrep("=", 70), "\n")
cat("FITTING MGCV WITH EXACT TEST DATA\n")
cat(strrep("=", 70), "\n\n")

# Load data generated by Python
data <- read.csv("/tmp/test_data.csv")
x <- data$x
y <- data$y

cat("Data loaded:\n")
cat("  n =", length(x), "\n")
cat("  x range: [", min(x), ",", max(x), "]\n")
cat("  y mean:", mean(y), "\n")
cat("  y sd:", sd(y), "\n\n")

# Fit GAM with CR splines, k=10, REML
k <- 10
cat("Fitting GAM with k =", k, ", bs='cr', method='REML'\n\n")
gam_fit <- gam(y ~ s(x, k=k, bs="cr"), method="REML")

# Extract key results
lambda_mgcv <- gam_fit$sp
deviance_mgcv <- deviance(gam_fit)
edf_mgcv <- sum(gam_fit$edf)
reml_score <- gam_fit$gcv.ubre

cat("mgcv Results:\n")
cat("  Lambda (smoothing parameter):", lambda_mgcv, "\n")
cat("  Deviance:", deviance_mgcv, "\n")
cat("  EDF (effective degrees of freedom):", edf_mgcv, "\n")
cat("  REML score:", reml_score, "\n\n")

# Extract design matrix and penalty
sm <- gam_fit$smooth[[1]]
X <- model.matrix(gam_fit)
S <- sm$S[[1]]

# Extract coefficients and compute RSS
beta <- coef(gam_fit)
fitted_vals <- fitted(gam_fit)
residuals_vals <- residuals(gam_fit)
rss <- sum(residuals_vals^2)

cat("Model components:\n")
cat("  X shape:", dim(X), "\n")
cat("  S shape (smooth only):", dim(S), "\n")
cat("  Number of coefficients:", length(beta), "\n")
cat("  RSS:", rss, "\n")
cat("  RSS/n:", rss/length(x), "\n\n")

# Compute REML components manually
cat("REML Components (manual computation):\n")

# Embed S in full matrix
S_full <- matrix(0, nrow = ncol(X), ncol = ncol(X))
S_full[2:ncol(X), 2:ncol(X)] <- S

# Compute X'X + lambda*S
XtX <- t(X) %*% X
A <- XtX + lambda_mgcv * S_full

# Log determinant
log_det_A <- determinant(A, logarithm = TRUE)$modulus[1]
rank_S <- Matrix::rankMatrix(S)[1]

# REML formula components
log_rss_n <- log(rss / length(x))
log_lambda_term <- rank_S * log(lambda_mgcv)

cat("  RSS =", rss, "\n")
cat("  log(RSS/n) =", log_rss_n, "\n")
cat("  log|X'X + lambda*S| =", log_det_A, "\n")
cat("  rank(S) =", rank_S, "\n")
cat("  rank(S) * log(lambda) =", log_lambda_term, "\n")

# Full REML criterion
reml_manual <- length(x) * log_rss_n + log_det_A - log_lambda_term
cat("  REML (manual) = n*log(RSS/n) + log|A| - r*log(lambda) =", reml_manual, "\n\n")

# Save all key values
cat(strrep("=", 70), "\n")
cat("KEY VALUES FOR RUST COMPARISON\n")
cat(strrep("=", 70), "\n")
cat("Lambda:", lambda_mgcv, "\n")
cat("RSS:", rss, "\n")
cat("log|X'X + lambda*S|:", log_det_A, "\n")
cat("rank(S):", rank_S, "\n")
cat("n:", length(x), "\n")
cat("log(RSS/n):", log_rss_n, "\n")
cat("rank(S) * log(lambda):", log_lambda_term, "\n")
cat("REML (manual):", reml_manual, "\n")
cat("REML (mgcv internal):", reml_score, "\n")

# Save to CSV
write.csv(data.frame(
    lambda = lambda_mgcv,
    rss = rss,
    log_det_A = log_det_A,
    rank_S = rank_S,
    n = length(x),
    log_rss_n = log_rss_n,
    log_lambda_term = log_lambda_term,
    reml_manual = reml_manual,
    reml_mgcv = reml_score,
    deviance = deviance_mgcv,
    edf = edf_mgcv
), "/tmp/mgcv_reml_exact.csv", row.names = FALSE)

cat("\nSaved to /tmp/mgcv_reml_exact.csv\n")
